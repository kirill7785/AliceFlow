/* 19 08 2016 начало разработки АЛИС (пятница Monte Negro).
файл adaptive_local_refinement_mesh.cpp
АЛИС - Адаптивная Локально Измельченная Сетка.
или неструктурированная расчётная сетка локального дробления.
Adaptive Local Refinement Grid.
30.08.2016 - версия 0.01 полностью неработоспособная 17 454 строк кода.
для сравнения:
constr_struct.cpp 5775 строк кода.
my_agregat_amg.c 57054 строк кода.
31.08.2016 - версия 0.01 полностью неработоспособная 19 876 строк кода.
сделан первоначальный учёт возможности четырёх соседей по face грани.
С 31.08 по 2.09 2016 не мог понять в чём ошибка, оказалось нужно сделать  
// двухуровневость(двувариантность ) в count neighbour.
2.09.2016 - версия 0.02 сделан учёт многоуровневости (двухуровности ) в update_max_count_neighbour.
22 054 строки кода.
6.09.2016 работоспособная версия. Пред релиз. Приступаем к упаковке и тестированию. Версия 0.03. 34117 строк кода.
7.09.2016 Версия 0.03. Работоспособная версия. Пройдена проверка построения сетки для tgf2023_01 и
// радиатора водяного охлаждения модуля ВУМ.
Исправлена ошибка.
Пройдена проверка построения сетки для tgf2023_05 и tgf2023_20. Сеточный генератор содержит 34445 строк кода.
Поддерживаются призматические блоки и плоские прямоугольные источники и стенки в качестве геометрических объектов
меширования.
10.08.2019 Наконец правильное освобождение оперативной памяти из под octree дерева 42663 строк.
26.08.2020 Универсализация нумерации nvtx ячейки. Начало 14.04.
*/

#pragma once
#ifndef _ADAPTIVE_LOCAL_REFINEMENT_MESH_CPP_
#define _ADAPTIVE_LOCAL_REFINEMENT_MESH_CPP_ 1

#define DEBUG_ALICE_MESH false
#define B_QUICK_MESHING true

#include "inputlaplas.cpp"
#include <stdlib.h> // для функции exit(0)
#include <math.h> // для функции sqrt
#include <ctime> // Для инициализации функции rand();
//#include <Windows.h>

integer i0r = 0, i1r = 0, i2r = 0;

// Реализация содержится в uniformsimplemeshgen.
// добавляет несуществующую границу к массиву
void addboundary(doublereal* &rb, int &in, doublereal g, integer iDir, BLOCK* &b, int &lb,
	WALL* &w, int &lw, SOURCE* &s, int &ls);

// Реализация содержится в uniformsimplemeshgen.
bool in_polygon(TOCHKA p, integer nsizei, doublereal* &xi, doublereal* &yi, doublereal* &zi, 
	doublereal* &hi, integer iPlane_obj2, int &k, int ib);


// Если просто кубик по размеру кабинета и вообще никаких перегородок внутри.
bool bVerySimpleGeometryforALICE = true;

// стороны света.
const integer E_SIDE = 0; // (east)   восток
const integer N_SIDE = 1; // (north)  север
const integer T_SIDE = 2; // (top)    верх
const integer W_SIDE = 3; // (west)   запад
const integer S_SIDE = 4; // (south)  юг
const integer B_SIDE = 5; // (bottom) низ
const integer EE_SIDE = 6; // (double east) двойной сосед на востоке
const integer NN_SIDE = 7; // (double north)  двойной сосед на севере
const integer TT_SIDE = 8; // (double top)  двойной сосед сверху
const integer WW_SIDE = 9; // (double west)  двойной сосед с запада
const integer SS_SIDE = 10; // (double south)  двойной сосед с юга
const integer BB_SIDE = 11; // (double bottom) двойной сосед снизу

// Максимальное число соседей.
const char MAX_NEIGHBOUR_COUNT = 127;

// для хеш-таблицы.
typedef struct THASH_POLE {
	bool flag;
	int inum;

	THASH_POLE() {
		flag=false;
		inum=-1;
	}
} HASH_POLE;

// Узел octree дерева.
typedef struct Toctree {
	// 0-7 как вершины в nvtx
	Toctree* link0;
	Toctree* link1;
	Toctree* link2;
	Toctree* link3;
	Toctree* link4;
	Toctree* link5;
	Toctree* link6;
	Toctree* link7;
	TOCHKA p0;
	TOCHKA p1;
	TOCHKA p2;
	TOCHKA p3;
	TOCHKA p4;
	TOCHKA p5;
	TOCHKA p6;
	TOCHKA p7;
	bool dlist;// true если дробление закончилось.
	// если maxGneighbour больше 4 то дробление.
	char maxWneighbour;
	char maxEneighbour;
	char maxSneighbour;
	char maxNneighbour;
	char maxTneighbour;
	char maxBneighbour;
	// Линки на 6 соседей.
	// Истина если face ячейки имеет четырёх соседей и 
	// false если face ячейки имеет только одного соседа.
	bool b4W, b4E, b4S, b4N, b4B, b4T;
	// Если сосед лишь один.
	Toctree* linkW;
	Toctree* linkE;
	Toctree* linkS;
	Toctree* linkN;
	Toctree* linkB;
	Toctree* linkT;
    // Если соседа 4 штуки.
	// 3 2 B
	// 0 1
	//******
	// 7 3 W
	// 4 0
	//******
	// 2 6 E
	// 1 5
	//******
	// 4 5 S
	// 0 1
	//******
	// 7 6 N
	// 3 2
	//******
	// 4 5 T
	// 6 7
	Toctree* linkW0;
	Toctree* linkW3;
	Toctree* linkW4;
	Toctree* linkW7;
	Toctree* linkE1;
	Toctree* linkE2;
	Toctree* linkE5;
	Toctree* linkE6;
	Toctree* linkS0;
	Toctree* linkS1;
	Toctree* linkS4;
	Toctree* linkS5;
	Toctree* linkN2;
	Toctree* linkN3;
	Toctree* linkN6;
	Toctree* linkN7;
	Toctree* linkB0;
	Toctree* linkB1;
	Toctree* linkB2;
	Toctree* linkB3;
	Toctree* linkT4;
	Toctree* linkT5;
	Toctree* linkT6;
	Toctree* linkT7;
	// Целочисленные координаты октанта.
	int minx;
	int maxx;
	int miny;
	int maxy;
	int minz;
	int maxz;
	// root info
	// for update neighbor procedure.
	integer root; // (0,link0) (1,link1) ...(7,link7)
	bool brootSituationX, brootSituationY, brootSituationZ;
	bool brootSituationX_virtual, brootSituationY_virtual, brootSituationZ_virtual;
    char ilevel; // номер уровня в octree дереве.
	Toctree* parent; // ссылка на родителя.
	// обновлять ли ссылки сейчас
	bool b_the_geometric_fragmentation;
	bool bcrushing_when_balancing;
	bool disbalance_now;
	// Следующие структуры используются только в модуле constr_struct_alice и далее ниже по коду и НЕ
	// используются и заполняются в модуле adaptive_local_refinement_mesh.cpp.
	// Уникальный номер внутреннего КО температурной области и 0 если не принадлежит области.
	int inum_TD; // inumber Temperature Domain.
	int inum_FD; // inumber Fluid Domain.

	int whot_is_block; // Для ускорения работы программы.

	Toctree() {
		// 0-7 как вершины в nvtx
		link0 = nullptr;
		link1 = nullptr;
		link2 = nullptr;
		link3 = nullptr;
		link4 = nullptr;
		link5 = nullptr;
		link6 = nullptr;
		link7 = nullptr;
		//TOCHKA p0;
		//TOCHKA p1;
		//TOCHKA p2;
		//TOCHKA p3;
		//TOCHKA p4;
		//TOCHKA p5;
		//TOCHKA p6;
		//TOCHKA p7;
		dlist=false;// true если дробление закончилось.
		// если maxGneighbour больше 4 то дробление.
		maxWneighbour = MAX_NEIGHBOUR_COUNT;
		maxEneighbour = MAX_NEIGHBOUR_COUNT;
		maxSneighbour = MAX_NEIGHBOUR_COUNT;
		maxNneighbour = MAX_NEIGHBOUR_COUNT;
		maxTneighbour = MAX_NEIGHBOUR_COUNT;
		maxBneighbour = MAX_NEIGHBOUR_COUNT;
		// Линки на 6 соседей.
		// Истина если face ячейки имеет четырёх соседей и 
		// false если face ячейки имеет только одного соседа.
		 b4W=false; b4E = false; b4S = false; b4N = false; b4B = false; b4T = false;
		// Если сосед лишь один.
		linkW = nullptr;
		linkE = nullptr;
		linkS = nullptr;
		linkN = nullptr;
		linkB = nullptr;
		linkT = nullptr;
		// Если соседа 4 штуки.
		// 3 2 B
		// 0 1
		//******
		// 7 3 W
		// 4 0
		//******
		// 2 6 E
		// 1 5
		//******
		// 4 5 S
		// 0 1
		//******
		// 7 6 N
		// 3 2
		//******
		// 4 5 T
		// 6 7
		linkW0 = nullptr;
		linkW3 = nullptr;
		linkW4 = nullptr;
		linkW7 = nullptr;
		linkE1 = nullptr;
		linkE2 = nullptr;
		linkE5 = nullptr;
		linkE6 = nullptr;
		linkS0 = nullptr;
		linkS1 = nullptr;
		linkS4 = nullptr;
		linkS5 = nullptr;
		linkN2 = nullptr;
		linkN3 = nullptr;
		linkN6 = nullptr;
		linkN7 = nullptr;
		linkB0 = nullptr;
		linkB1 = nullptr;
		linkB2 = nullptr;
		linkB3 = nullptr;
		linkT4 = nullptr;
		linkT5 = nullptr;
		linkT6 = nullptr;
		linkT7 = nullptr;
		// Целочисленные координаты октанта.
		minx = -1;
		maxx = -2;
		miny = -1;
		maxy = -2;
		minz = -1;
		maxz = -2;
		// root info
		// for update neighbor procedure.
		root=-1; // (0,link0) (1,link1) ...(7,link7)
		brootSituationX = false; brootSituationY = false; brootSituationZ = false;
		brootSituationX_virtual = false; brootSituationY_virtual = false; brootSituationZ_virtual = false;
		ilevel=-1; // номер уровня в octree дереве.
		parent=nullptr; // ссылка на родителя.
		// обновлять ли ссылки сейчас
		b_the_geometric_fragmentation=false;
		bcrushing_when_balancing = false;
		disbalance_now = false;
		// Следующие структуры используются только в модуле constr_struct_alice и далее ниже по коду и НЕ
		// используются и заполняются в модуле adaptive_local_refinement_mesh.cpp.
		// Уникальный номер внутреннего КО температурной области и 0 если не принадлежит области.
		inum_TD=-1; // inumber Temperature Domain.
		inum_FD=-1; // inumber Fluid Domain.

		whot_is_block = -1; // неопределено.
	}

} octree;

// Ссылки на каждый узел octree дерева для его полной очистки.

typedef struct Toctree_list {

	octree* pnode;
	Toctree_list* next;

	Toctree_list() {

		pnode = nullptr;
		next = nullptr;

	}

} octree_list;

octree_list* rootClear_octree = nullptr;// Текущий элемент.
octree_list* head_rootClear_octree = nullptr; // голова списка.

typedef struct TSTACK_ALICE {

	// 29.10.2020
	// В сетке вдоль выбранного координатного направления 
	// не может быть более 32767 позиций. 32767 ^3 очень большое значение 
	// для 3D объекта оно заведомо не влезет в память одной машины.
	int minx;
	int maxx;
	int miny;
	int maxy;
	int minz;
	int maxz;
	octree* link;
	

	TSTACK_ALICE() {
		minx = -1;
		maxx = -2;
		miny = -1;
		maxy = -2;
		minz = -1;
		maxz = -2;
		link=nullptr;	
	}

} STACK_ALICE;

STACK_ALICE* my_ALICE_STACK=nullptr;
integer top_ALICE_STACK = 0;

octree* oc_global = nullptr;

// Для алгоритма сканирующих отрезков требуется дробить ячейку если отрезок внутри
// ячейки прошел чрез границу раздела двух блоков, т.е. номера блоков в соседних ячейках стали различны.
// Для детектирования данной особенности нужна хеш-таблица сопоставляющая номер ячейки сетки из (inx+1)*(iny+1)*(inz+1) с номерами блоков.
// Данный метод абсолютно универсален и подходит для любой формы блоков.
// Хранит номер блока достаточно типа int.2байта -32768 .. 32767
int*** hash_for_droblenie_xyz = nullptr;

#if _CUDA_IS_ACTIVE_ == 0
// Проект собран как стандартное консольное приложение windows.

// Возвращает минимум из двух целых чисел.

//integer min(integer ia, integer ib) {
	//if (ia < ib) return ia;
	//return ib;
//} // min

#endif

// Binary Search // Двоичный поиск.
// Стабильная версия. Быстрее 4.81% против 6.24%.
int binary_search_hash_key_alice33v0_experimental_not_stable(int istart, int iend, doublereal* &array,
	doublereal epsTol, doublereal dkey) {
	
	int istart1 = istart;
	int iend1 = iend;

	int i_vacant=-1;
	while (istart <= iend) {
		int middle = (istart + iend)/2;

		doublereal eps_loc = epsTol;
		// Нелокальный epsilon. 19.11.2020
		if (middle - 1 == istart1) {
			eps_loc = 0.98 * (array[istart1 + 1] - array[istart1]);
		}
		else if (middle - 1 == iend1) {
			eps_loc = 0.98 * (array[iend1] - array[iend1 - 1]);
		}
		else {
			//eps_loc = fmin(0.98 * (array[middle - 1] - array[middle - 2]), 0.98 * (array[middle] - array[middle - 1]));

			if (dkey >= array[middle - 1]) {
				eps_loc = 0.98 * (array[middle] - array[middle - 1]);
			}
			else {
				eps_loc = 0.98 * (array[middle - 1] - array[middle - 2]);
			}

		}



		if (fabs(array[middle - 1] - dkey) < eps_loc) {
			i_vacant = middle - 1;
			break;
		}
		else if (array[middle - 1] < dkey) {
			istart = middle + 1;
		}
		else {
			iend = middle - 1;
		}
	}
	return (i_vacant);

} // binary_search_hash_key_alice33v0


// Binary Search // Двоичный поиск.
// Стабильная версия. Быстрее 4.81% против 6.24%.
int binary_search_hash_key_alice33v0(int istart, int iend, doublereal*& array,
	doublereal epsTol, doublereal dkey) {

	int i_vacant = -1;
	while (istart <= iend) {
		int middle = (istart + iend) / 2;


		if (fabs(array[middle - 1] - dkey) < epsTol) {
			i_vacant = middle - 1;
			break;
		}
		else if (array[middle - 1] < dkey) {
			istart = middle + 1;
		}
		else {
			iend = middle - 1;
		}
	}
	return (i_vacant);

} // binary_search_hash_key_alice33v0

// Binary Search // Двоичный поиск.
// Стабильная версия. Быстрее 4.81% против 6.24%.
integer binary_search_hash_key_alice33v0Q(integer istart, integer iend, doublereal* &array,
	doublereal epsTol, doublereal dkey) {

	integer i_vacant = -1;
	while (istart <= iend) {
		integer middle = (istart + iend) / 2;
		if ((middle<iend) &&(array[middle - 1] <= dkey)&&(array[middle]>=dkey)) {
			i_vacant = middle - 1;
			break;
		}
		else if (array[middle-1] < dkey) {
			istart = middle + 1;
		}
		else {
			iend = middle;
		}
	}
	return (i_vacant);
} // binary_search_hash_key_alice33v0Q

// Совершенно не работает 
// Binary Search // Двоичный поиск.
// Альтернативная  версия.  Медленнее 6.24% против 4.81%.
integer binary_search_hash_key_alice33v1(integer istart, integer iend, doublereal* &array,
	doublereal epsTol, doublereal dkey) {

	integer i_vacant = -1;
	integer middle=istart;
	while (istart <= iend) {
		middle = (istart + iend)/2;
		 if (array[middle - 1] < dkey+ epsTol) {
			istart = middle + 1;
		}
		else if (array[middle - 1] > dkey- epsTol) {
			iend = middle - 1;
		}
		else if (fabs(array[middle - 1] - dkey) < epsTol) {
			 i_vacant = middle - 1;
			 break;
		 }
	}

	if (fabs(array[middle - 1] - dkey) < epsTol) {
		i_vacant = middle - 1;
	}
	else {
		if (istart <= iend) {
			if (fabs(array[istart - 1] - dkey) < epsTol) {
				i_vacant = istart - 1;
			}
		}
		else {
			if (fabs(array[iend - 1] - dkey) < epsTol) {
				i_vacant = iend - 1;
			}
		}
	}
	
	return (i_vacant);
} // binary_search_hash_key_alice33v1


// целочисленный ключ который используется в хеш-таблице для ускорения поиска при экспорте в программу tecplot.
// Сигнатура вызова:
// hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, p, epsTolx, epsToly, epsTolz);
integer hash_key_alice33(int inx7, int iny7, int inz7,
	doublereal* &xpos7, doublereal* &ypos7, doublereal* &zpos7,
	TOCHKA p, doublereal epsTolx, doublereal epsToly, doublereal epsTolz) {
	
	// Если скорость работы данной функции будет неприемлема, то можно воспользоваться 
	// двоичным поиском т.к. массивы упорядочены по возрастанию.

	//const bool blinear_search = false;
	//doublereal mult = 1.0;

	// Поиск.
	int i_vacant = -1;
	int j_vacant = -1;
	int k_vacant = -1;
	
	/*if (blinear_search) {

		// Линейный поиск.

		for (int i = 0; i <= inx7; ++i) {
			if (fabs(p.x - xpos7[i]) < mult*epsTolx) {
				i_vacant = i;
				break;
			}
		}

		for (int j = 0; j <= iny7; ++j) {
			if (fabs(p.y - ypos7[j]) < mult * epsToly) {
				j_vacant = j;
				break;
			}
		}

		for (int k = 0; k <= inz7; ++k) {
			if (fabs(p.z - zpos7[k]) < mult * epsTolz) {
				k_vacant = k;
				break;
			}
		}


	}
	else {*/


		// Binary Search // Двоичный поиск.
		
		int istart = 1;
		int iend = inx7 + 1;
		i_vacant = binary_search_hash_key_alice33v0(istart, iend, xpos7, epsTolx, p.x);

		istart = 1;
		iend = iny7 + 1;
		j_vacant = binary_search_hash_key_alice33v0(istart, iend, ypos7, epsToly, p.y);

		istart = 1;
		iend = inz7 + 1;
		k_vacant = binary_search_hash_key_alice33v0(istart, iend, zpos7, epsTolz, p.z);
		
	//}
	
	if ((i_vacant == -1) || (j_vacant == -1) || (k_vacant == -1)) {
		
		
		if (i_vacant == -1) {
			doublereal eps_memo = epsTolx;

			for (int i = 0; i <= inx7; ++i) {
				doublereal eps_loc = epsTolx;
				// Нелокальный epsilon. 19.11.2020
				if (i == 0) {
					eps_loc = 0.98 * (xpos7[1]-xpos7[0]);
				}
				else if (i == inx7) {
					eps_loc = 0.98 * (xpos7[inx7] - xpos7[inx7-1]);
				}
				else {
					//eps_loc = fmin(0.98 * (xpos7[i] - xpos7[i-1]), 0.98 * (xpos7[i+1] - xpos7[i]));

					if (p.x >= xpos7[i]) {
						eps_loc = 0.98 * (xpos7[i + 1] - xpos7[i]);
					}
					else {
						eps_loc = 0.98 * (xpos7[i] - xpos7[i - 1]);
					}

				}

				if (fabs(p.x - xpos7[i]) < eps_loc)
				{
					eps_memo = eps_loc;

					if (p.x >= xpos7[i]) {
						if (i != inx7) {
							if ((p.x - xpos7[i]) < (xpos7[i + 1] - p.x)) {
								i_vacant = i;
								break;
							}
							else {
								i_vacant = i + 1;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the right along the Ox axis\n";
							if ((p.x - xpos7[inx7-1]) < (xpos7[inx7] - p.x)) {
								i_vacant = inx7-1;
							}
							else {
								i_vacant = inx7;
							}
						}
					}
					else {
						if (i > 0) {
							if ((p.x - xpos7[i - 1]) < (xpos7[i] - p.x)) {
								i_vacant = i - 1;
								break;
							}
							else {
								i_vacant = i;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the left along the Ox axis\n";
							if ((p.x - xpos7[0]) < (xpos7[1] - p.x)) {
								i_vacant = 0;
							}
							else {
								i_vacant = 1;
							}
						}

					}

					
				}
			}

			if (0 && (i_vacant != -1)) {
				printf("i_vacant=%d epsTolx=%e\n", i_vacant, epsTolx);
				if (i_vacant > 0) {
					printf("xpos[i_vacant previos] =%e xpos[i_vacant] = %e epsTolx=%e eps_memo =%e\n", xpos7[i_vacant-1], xpos7[i_vacant], epsTolx, eps_memo);
				}
				if (i_vacant < inx7) {
					printf(" xpos[i_vacant] = %e xpos[i_vacant post] =%e epsTolx=%e eps_memo =%e\n", xpos7[i_vacant], xpos7[i_vacant+1], epsTolx, eps_memo);
				}

			}

		}

		if (j_vacant == -1) {

			doublereal eps_memo = epsToly;

			for (int i = 0; i <= iny7; ++i) {
				doublereal eps_loc = epsToly;
				// Нелокальный epsilon. 19.11.2020
				if (i == 0) {
					eps_loc = 0.98 * (ypos7[1] - ypos7[0]);
				}
				else if (i == iny7) {
					eps_loc = 0.98 * (ypos7[iny7] - ypos7[iny7 - 1]);
				}
				else {
					//eps_loc = fmin(0.98 * (ypos7[i] - ypos7[i-1]), 0.98 * (ypos7[i+1] - ypos7[i]));

					if (p.y >= ypos7[i]) {
						eps_loc = 0.98 * (ypos7[i + 1] - ypos7[i]);
					}
					else {
						eps_loc = 0.98 * (ypos7[i] - ypos7[i - 1]);
					}

				}

				if (fabs(p.y - ypos7[i]) < eps_loc)
				{
					eps_memo = eps_loc;

					if (p.y >= ypos7[i]) {
						if (i != iny7) {
							if ((p.y - ypos7[i]) < (ypos7[i + 1] - p.y)) {
								j_vacant = i;
								break;
							}
							else {
								j_vacant = i + 1;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the right along the Oy axis\n";
							if ((p.y - ypos7[iny7 - 1]) < (ypos7[iny7] - p.y)) {
								j_vacant = iny7 - 1;
							}
							else {
								j_vacant = iny7;
							}
						}
					}
					else {
						if (i > 0) {
							if ((p.y - ypos7[i - 1]) < (ypos7[i] - p.y)) {
								j_vacant = i - 1;
								break;
							}
							else {
								j_vacant = i;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the left along the Oy axis\n";
							if ((p.y - ypos7[0]) < (ypos7[1] - p.y)) {
								j_vacant = 0;
							}
							else {
								j_vacant = 1;
							}
						}

					}

					
				}
			}

			if (0 && (j_vacant != -1)) {
				printf("j_vacant=%d epsToly=%e\n", j_vacant, epsToly);
				if (j_vacant > 0) {
					printf("ypos[j_vacant previos] =%e ypos[j_vacant] = %e epsToly=%e  eps_memo =%e\n", ypos7[j_vacant - 1], ypos7[j_vacant], epsToly, eps_memo);
				}
				if (j_vacant < iny7) {
					printf(" ypos[j_vacant] = %e ypos[j_vacant post] =%e epsToly=%e  eps_memo =%e\n", ypos7[j_vacant], ypos7[j_vacant + 1], epsToly, eps_memo);
				}

			}

		}

		if (k_vacant == -1) {

			doublereal eps_memo = epsToly;

			for (int i = 0; i <= inz7; ++i) {

				doublereal eps_loc = epsTolz;
				// Нелокальный epsilon. 19.11.2020
				if (i == 0) {
					eps_loc = 0.98 * (zpos7[1] - zpos7[0]);
				}
				else if (i == inz7) {
					eps_loc = 0.98 * (zpos7[inz7] - zpos7[inz7 - 1]);
				}
				else {
					//eps_loc = fmin(0.98 * (zpos7[i] - zpos7[i-1]), 0.98 * (zpos7[i+1] - zpos7[i]));

					if (p.z >= zpos7[i]) {
						eps_loc = 0.98 * (zpos7[i + 1] - zpos7[i]);
					}
					else {
						eps_loc = 0.98 * (zpos7[i] - zpos7[i - 1]);
					}

				}

				if (fabs(p.z - zpos7[i]) < eps_loc) {
					eps_memo = eps_loc;

					if (p.z >= zpos7[i]) {
						if (i != inz7) {
							if ((p.z - zpos7[i]) < (zpos7[i + 1] - p.z)) {
								k_vacant = i;
								break;
							}
							else {
								k_vacant = i + 1;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the right along the Oz axis\n";
							if ((p.z - zpos7[inz7 - 1]) < (zpos7[inz7] - p.z)) {
								k_vacant = inz7 - 1;
							}
							else {
								k_vacant = inz7;
							}
						}
					}
					else {
						if (i > 0) {
							if ((p.z - zpos7[i - 1]) < (zpos7[i] - p.z)) {
								k_vacant = i - 1;
								break;
							}
							else {
								k_vacant = i;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the left along the Oz axis\n";
							if ((p.z - zpos7[0]) < (zpos7[1] - p.z)) {
								k_vacant = 0;
							}
							else {
								k_vacant = 1;
							}
						}

					}
				}
			}

			if (0&&(k_vacant != -1)) {
				printf("k_vacant=%d epsTolz=%e\n", k_vacant, epsTolz);
				if (k_vacant > 0) {
					printf("zpos[k_vacant previos] =%e zpos[k_vacant] = %e epsTolz=%e  eps_memo =%e\n", zpos7[k_vacant - 1], zpos7[k_vacant], epsTolz, eps_memo);
				}
				if (k_vacant < inz7) {
					printf(" zpos[k_vacant] = %e zpos[k_vacant post] =%e epsTolz=%e  eps_memo =%e\n", zpos7[k_vacant], zpos7[k_vacant + 1], epsTolz, eps_memo);
				}

			}

		}

		
		if ((i_vacant == -1) || (j_vacant == -1) || (k_vacant == -1)) {


			printf("x=%e y=%e z=%e\n", p.x, p.y, p.z);
			printf("inx=%d iny=%d inz=%d\n", inx7, iny7, inz7);
			printf("i=%d j=%d k=%d\n", i_vacant, j_vacant, k_vacant);
			printf("epsTolx=%e epsToly=%e epsTolz=%e\n", epsTolx, epsToly, epsTolz);
			printf("error in hash_key_alice33\n");

			system("PAUSE");
			exit(1);
		}
		else {

			integer i_vacant_long = i_vacant;
			integer j_vacant_long = j_vacant;
			integer k_vacant_long = k_vacant;
			integer inx7_long = inx7;
			integer iny7_long = iny7;

			return i_vacant_long + (inx7_long + 1) * j_vacant_long + (inx7_long + 1) * (iny7_long + 1) * k_vacant_long;
		}
	}
	else {
		integer i_vacant_long = i_vacant;
		integer j_vacant_long = j_vacant;
		integer k_vacant_long = k_vacant;
		integer inx7_long = inx7;
		integer iny7_long = iny7;

		return i_vacant_long + (inx7_long + 1) * j_vacant_long + (inx7_long + 1) * (iny7_long + 1) * k_vacant_long;
	}

} // hash_key_alice33

// целочисленный ключ который используется в хеш-таблице для ускорения поиска при экспорте в программу tecplot.
// Сигнатура вызова:
// hash_key_alice33Q(inx, iny, inz, xpos, ypos, zpos, p, epsTolx, epsToly, epsTolz);
integer hash_key_alice33Q(integer inx7, integer iny7, integer inz7,
	doublereal* &xpos7, doublereal* &ypos7, doublereal* &zpos7, TOCHKA p,
	doublereal epsTolx, doublereal epsToly, doublereal epsTolz) {

	// Если скорость работы данной функции будет неприемлема, то можно воспользоваться 
	// двоичным поиском т.к. массивы упорядочены по возрастанию.

	const bool blinear_search = true;// false;
	

	// Поиск.
	integer i_vacant = -1;
	integer j_vacant = -1;
	integer k_vacant = -1;

	if (blinear_search) {
		// до inx7 включительно.
		for (integer i = 0; i < inx7; ++i) {
			if ((p.x >= xpos7[i])&&(p.x <= xpos7[i+1])) {
				i_vacant = i;
				break;
			}
		}
	}
	else {
		// Binary Search // Двоичный поиск.

		integer istart = 1;
		integer iend = inx7 + 1;
		i_vacant = binary_search_hash_key_alice33v0Q(istart, iend, xpos7, epsTolx, p.x);
	}
	if (blinear_search) {
		// до iny7 включительно.
		for (integer j = 0; j < iny7; ++j) {
			if ((p.y >= ypos7[j])&&(p.y <= ypos7[j+1])) {
				j_vacant = j;
				break;
			}
		}
	}
	else {
		integer istart = 1;
		integer iend = iny7 + 1;
		j_vacant = binary_search_hash_key_alice33v0Q(istart, iend, ypos7, epsToly, p.y);
	}
	if (blinear_search) {
		// до inz7 включительно.
		for (integer k = 0; k < inz7; ++k) {
			if ((p.z >= zpos7[k])&&(p.z <= zpos7[k+1])) {
				k_vacant = k;
				break;
			}
		}
	}
	else {
		integer istart = 1;
		integer iend = inz7 + 1;
		k_vacant = binary_search_hash_key_alice33v0Q(istart, iend, zpos7, epsTolz, p.z);
	}

	if ((i_vacant == -1) || (j_vacant == -1) || (k_vacant == -1)) {
		
		

		if (i_vacant == -1) {
			doublereal eps_memo = epsTolx;

			for (int i = 0; i <= inx7; ++i) {
				doublereal eps_loc = epsTolx;
				// Нелокальный epsilon. 19.11.2020
				if (i == 0) {
					eps_loc = 0.98 * (xpos7[1] - xpos7[0]);
				}
				else if (i == inx7) {
					eps_loc = 0.98 * (xpos7[inx7] - xpos7[inx7 - 1]);
				}
				else {
					//eps_loc = fmin(0.98 * (xpos7[i] - xpos7[i-1]), 0.98 * (xpos7[i+1] - xpos7[i]));

					if (p.x >= xpos7[i]) {
						eps_loc = 0.98 * (xpos7[i + 1] - xpos7[i]);
					}
					else {
						eps_loc = 0.98 * (xpos7[i] - xpos7[i - 1]);
					}

				}

				if (fabs(p.x - xpos7[i]) < eps_loc)
				{
					eps_memo = eps_loc;

					if (p.x >= xpos7[i]) {
						if (i != inx7) {
							if ((p.x - xpos7[i]) < (xpos7[i + 1] - p.x)) {
								i_vacant = i;
								break;
							}
							else {
								i_vacant = i + 1;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the right along the Ox axis\n";
							if ((p.x - xpos7[inx7 - 1]) < (xpos7[inx7] - p.x)) {
								i_vacant = inx7 - 1;
							}
							else {
								i_vacant = inx7;
							}
						}
					}
					else {
						if (i > 0) {
							if ((p.x - xpos7[i - 1]) < (xpos7[i] - p.x)) {
								i_vacant = i - 1;
								break;
							}
							else {
								i_vacant = i;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the left along the Ox axis\n";
							if ((p.x - xpos7[0]) < (xpos7[1] - p.x)) {
								i_vacant = 0;
							}
							else {
								i_vacant = 1;
							}
						}

					}
				}
			}

			if (0&&(i_vacant != -1)) {
				printf("i_vacant=%lld epsTolx=%e\n", i_vacant, epsTolx);
				if (i_vacant > 0) {
					printf("xpos[i_vacant previos] =%e xpos[i_vacant] = %e epsTolx=%e eps_memo =%e\n", xpos7[i_vacant - 1], xpos7[i_vacant], epsTolx, eps_memo);
				}
				if (i_vacant < inx7) {
					printf(" xpos[i_vacant] = %e xpos[i_vacant post] =%e epsTolx=%e eps_memo =%e\n", xpos7[i_vacant], xpos7[i_vacant + 1], epsTolx, eps_memo);
				}

			}

		}

		if (j_vacant == -1) {

			doublereal eps_memo = epsToly;

			for (int i = 0; i <= iny7; ++i) {
				doublereal eps_loc = epsToly;
				// Нелокальный epsilon. 19.11.2020
				if (i == 0) {
					eps_loc = 0.98 * (ypos7[1] - ypos7[0]);
				}
				else if (i == iny7) {
					eps_loc = 0.98 * (ypos7[iny7] - ypos7[iny7 - 1]);
				}
				else {
					//eps_loc = fmin(0.98 * (ypos7[i] - ypos7[i-1]), 0.98 * (ypos7[i+1] - ypos7[i]));

					if (p.y >= ypos7[i]) {
						eps_loc = 0.98 * (ypos7[i + 1] - ypos7[i]);
					}
					else {
						eps_loc = 0.98 * (ypos7[i] - ypos7[i - 1]);
					}

				}

				if (fabs(p.y - ypos7[i]) < eps_loc)
				{
					eps_memo = eps_loc;
					
					if (p.y >= ypos7[i]) {
						if (i != iny7) {
							if ((p.y - ypos7[i]) < (ypos7[i + 1] - p.y)) {
								j_vacant = i;
								break;
							}
							else {
								j_vacant = i + 1;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the right along the Oy axis\n";
							if ((p.y - ypos7[iny7 - 1]) < (ypos7[iny7] - p.y)) {
								j_vacant = iny7 - 1;
							}
							else {
								j_vacant = iny7;
							}
						}
					}
					else {
						if (i > 0) {
							if ((p.y - ypos7[i - 1]) < (ypos7[i] - p.y)) {
								j_vacant = i - 1;
								break;
							}
							else {
								j_vacant = i;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the left along the Oy axis\n";
							if ((p.y - ypos7[0]) < (ypos7[1] - p.y)) {
								j_vacant = 0;
							}
							else {
								j_vacant = 1;
							}
						}

					}

				}
			}

			if (0&&(j_vacant != -1)) {
				printf("j_vacant=%lld epsToly=%e\n", j_vacant, epsToly);
				if (j_vacant > 0) {
					printf("ypos[j_vacant previos] =%e ypos[j_vacant] = %e epsToly=%e  eps_memo =%e\n", ypos7[j_vacant - 1], ypos7[j_vacant], epsToly, eps_memo);
				}
				if (j_vacant < iny7) {
					printf(" ypos[j_vacant] = %e ypos[j_vacant post] =%e epsToly=%e  eps_memo =%e\n", ypos7[j_vacant], ypos7[j_vacant + 1], epsToly, eps_memo);
				}

			}

		}

		if (k_vacant == -1) {

			doublereal eps_memo = epsToly;

			for (int i = 0; i <= inz7; ++i) {

				doublereal eps_loc = epsTolz;
				// Нелокальный epsilon. 19.11.2020
				if (i == 0) {
					eps_loc = 0.98 * (zpos7[1] - zpos7[0]);
				}
				else if (i == inz7) {
					eps_loc = 0.98 * (zpos7[inz7] - zpos7[inz7 - 1]);
				}
				else {
					//eps_loc = fmin(0.98 * (zpos7[i] - zpos7[i-1]), 0.98 * (zpos7[i+1] - zpos7[i]));

					if (p.z >= zpos7[i]) {
						eps_loc = 0.98 * (zpos7[i + 1] - zpos7[i]);
					}
					else {
						eps_loc = 0.98 * (zpos7[i] - zpos7[i - 1]);
					}

				}

				if (fabs(p.z - zpos7[i]) < eps_loc) {
					eps_memo = eps_loc;

					if (p.z >= zpos7[i]) {
						if (i != inz7) {
							if ((p.z - zpos7[i]) < (zpos7[i + 1] - p.z)) {
								k_vacant = i;
								break;
							}
							else {
								k_vacant = i + 1;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the right along the Oz axis\n";
							if ((p.z - zpos7[inz7 - 1]) < (zpos7[inz7] - p.z)) {
								k_vacant = inz7 - 1;
							}
							else {
								k_vacant = inz7;
							}
						}
					}
					else {
						if (i > 0) {
							if ((p.z - zpos7[i - 1]) < (zpos7[i] - p.z)) {
								k_vacant = i - 1;
								break;
							}
							else {
								k_vacant = i;
								break;
							}
						}
						else {
							//std::cout << "The point left the cabinet on the left along the Oz axis\n";
							if ((p.z - zpos7[0]) < (zpos7[1] - p.z)) {
								k_vacant = 0;
							}
							else {
								k_vacant = 1;
							}
						}

					}
				}
			}

			if (0&&(k_vacant != -1)) {
				printf("k_vacant=%lld epsTolz=%e\n", k_vacant, epsTolz);
				if (k_vacant > 0) {
					printf("zpos[k_vacant previos] =%e zpos[k_vacant] = %e epsTolz=%e  eps_memo =%e\n", zpos7[k_vacant - 1], zpos7[k_vacant], epsTolz, eps_memo);
				}
				if (k_vacant < inz7) {
					printf(" zpos[k_vacant] = %e zpos[k_vacant post] =%e epsTolz=%e  eps_memo =%e\n", zpos7[k_vacant], zpos7[k_vacant + 1], epsTolz, eps_memo);
				}

			}

		}


		if ((i_vacant == -1) || (j_vacant == -1) || (k_vacant == -1)) {

			printf("x=%e y=%e z=%e\n", p.x, p.y, p.z);
			printf("inx=%lld iny=%lld inz=%lld\n", inx7, iny7, inz7);
			printf("i=%lld j=%lld k=%lld\n", i_vacant, j_vacant, k_vacant);
			printf("epsTolx=%e epsToly=%e epsTolz=%e\n", epsTolx, epsToly, epsTolz);
			printf("error in hash_key_alice33Q\n");
			for (int i39 = 0; i39 <= iny7; i39++) {
				std::cout << ypos7[i39] << std::endl;
			}
			system("pause");

			system("PAUSE");
			exit(1);
		}
		else {
			return i_vacant + (inx7 + 1) * j_vacant + (inx7 + 1) * (iny7 + 1) * k_vacant;
		}

	}
	else {
		return i_vacant + (inx7+1)*j_vacant + (inx7+1)*(iny7+1)*k_vacant;
	}

} // hash_key_alice33Q

bool is_null(Toctree* &oc) {
	bool b1 = false;
	if (oc != nullptr) {
		if ((oc->link0 == nullptr) && (oc->link1 == nullptr) && (oc->link2 == nullptr) && (oc->link3 == nullptr) && (oc->link4 == nullptr) && (oc->link5 == nullptr) && (oc->link6 == nullptr) && (oc->link7 == nullptr)) {
			b1 = true;
		}
	}
	return b1;
} // is_null

// print_link
integer print_link(octree* &oc2) {
	if (oc2 == nullptr) {
		//printf("N");
		return 9; // nullptr
	}
	else {
#if doubleintprecision == 1
		//printf("%lld", oc2->root);
#else
		//printf("%d", oc2->root);
#endif
		
		return oc2->root;
	}
} // print_link

// 30.03.2019
bool CHECK_LINK_is_nullptr(Toctree* &oc, bool is_no_descendants)
{
	// соседи пусты ?
	if (oc != nullptr) {
		if (oc->link0 != nullptr) is_no_descendants = false;
		if (oc->link1 != nullptr) is_no_descendants = false;
		if (oc->link2 != nullptr) is_no_descendants = false;
		if (oc->link3 != nullptr) is_no_descendants = false;
		if (oc->link4 != nullptr) is_no_descendants = false;
		if (oc->link5 != nullptr) is_no_descendants = false;
		if (oc->link6 != nullptr) is_no_descendants = false;
		if (oc->link7 != nullptr) is_no_descendants = false;
	}

	return is_no_descendants;
} // CHECK_LINK_is_nullptr

// Правильная версия is_null1 6 сентября 2016. // 30.03.2019
// Ячейка делённая на наследников у неё потомков нет.
bool is_null1_new(Toctree* &oc) {
	// потомков нет ?
	bool is_no_descendants = false;
	if (oc != nullptr) {
		is_no_descendants = true;
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link0, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link1, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link2, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link3, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link4, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link5, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link6, is_no_descendants);
		is_no_descendants = CHECK_LINK_is_nullptr(oc->link7, is_no_descendants);
	}
	return is_no_descendants;
}// is_null1_new

// истина только в случае деления ячейки на 8 дочерних ячеек причем каждая дочерняя ячейка это лист.
bool is_null1(Toctree* &oc)
{
	// direct WSIDE, SSIDE, B:
	//integer dir = direct;
	//if (dir == ESIDE) dir = WSIDE;
	//if (dir == N) dir = S;
	//if (dir == T) dir = B;

	bool b1 = false;

	if (oc != nullptr) {
		/*
		switch (dir) {
		case WSIDE: // 0,3,4,7
		if ((oc->link0 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link7 != nullptr)) {
		if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
		if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
		if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
		if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
		b1 = true;

		}

		}


		}
		}
		}
		break;
		case S: // 0,1,4,5
		if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
		if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
		if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
		if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
		if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
		b1 = true;


		}
		}


		}
		}
		}
		break;
		case BSIDE: // 0,1,2,3
		// Т.к. может быть вырождение по Z.
		if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr)) {
		if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
		if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
		if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
		if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
		b1 = true;
		}
		}
		}
		}
		}
		break;
		default:
		printf("ERROR!!! is_null1 error in direct\n");
		system("PAUSE");
		exit(1);
		break;
		}
		*/

		//if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
			//if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
				//if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
					//if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
						//if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							//if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
								//if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
									//if ((oc->link6->link0 == nullptr) && (oc->link6->link1 == nullptr) && (oc->link6->link2 == nullptr) && (oc->link6->link3 == nullptr) && (oc->link6->link4 == nullptr) && (oc->link6->link5 == nullptr) && (oc->link6->link6 == nullptr) && (oc->link6->link7 == nullptr)) {
										//if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
											//b1 = true;
										//}
									//}
								//}
							//}
						//}
					//}
				//}
			//}
		//}

		// 30.03.2019
		b1 = is_null1_new(oc);


	}
	return b1;
} // is_null1

bool is_null1_(Toctree* &oc, integer direct)
{
	// direct WSIDE, SSIDE, B:
	integer dir = direct;
	if (dir == E_SIDE) dir = W_SIDE;
	if (dir == N_SIDE) dir = S_SIDE;
	if (dir == T_SIDE) dir = B_SIDE;

	bool b1 = false;

	if (oc != nullptr) {
		switch (dir) {
		case W_SIDE: // 0,3,4,7
			if ((oc->link0 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link7 != nullptr)) {
				if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
					if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
								b1 = true;

							}

						}


					}
				}
			}
			break;
		case S_SIDE: // 0,1,4,5 
			if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
				if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
								b1 = true;


							}
						}


					}
				}
			}
			break;
		case B_SIDE: // 0,1,2,3
			// Т.к. может быть вырождение по Z.
			if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr)) {
				if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
							if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
								b1 = true;
							}
						}
					}
				}
			}
			break;
		default:
			printf("ERROR!!! is_null1 error in direct\n");
			//system("PAUSE");
			system("PAUSE");
			exit(1);
			break;
		}

		/*
		if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
		if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
		if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
		if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
		if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
		if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
		if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
		if ((oc->link6->link0 == nullptr) && (oc->link6->link1 == nullptr) && (oc->link6->link2 == nullptr) && (oc->link6->link3 == nullptr) && (oc->link6->link4 == nullptr) && (oc->link6->link5 == nullptr) && (oc->link6->link6 == nullptr) && (oc->link6->link7 == nullptr)) {
		if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
		b1 = true;
		}
		}
		}
		}
		}
		}
		}
		}
		}
		*/
	}
	return b1;
} // is_null1_

bool is_null2(Toctree* &oc, integer direct, char &c0, char &c1, char &c2, char &c3, char &c4, char &c5, char &c6, char &c7)
{
	// cface - это количество соседей по face грани.

	c0 = 0;
	c1 = 0;
	c2 = 0;
	c3 = 0;
	c4 = 0;
	c5 = 0;
	c6 = 0;
	c7 = 0;

	// direct WSIDE, SSIDE, B:
	integer dir = direct;
	if (dir == E_SIDE) dir = W_SIDE;
	if (dir == N_SIDE) dir = S_SIDE;
	if (dir == T_SIDE) dir = B_SIDE;

	bool b1 = false;

	if (oc != nullptr) {

		switch (dir) {
		case W_SIDE: // 0,3,4,7
			if ((oc->link0 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link7 != nullptr)) {
				if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
					if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
								b1 = true;
							}
						}
					}
				}
			}
			if (oc->link0 != nullptr) {
				c0 = 1;
				char ic0 = 0;
				if (oc->link0->link0 != nullptr) {
					ic0++;
				}
				if (oc->link0->link3 != nullptr) {
					ic0++;
				}
				if (oc->link0->link4 != nullptr) {
					ic0++;
				}
				if (oc->link0->link7 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c0 = 1;
				}
				else {
					c0 = ic0; // 4 или 2.
				}
			}
			if (oc->link3 != nullptr) {
				c3 = 1;
				char ic0 = 0;
				if (oc->link3->link0 != nullptr) {
					ic0++;
				}
				if (oc->link3->link3 != nullptr) {
					ic0++;
				}
				if (oc->link3->link4 != nullptr) {
					ic0++;
				}
				if (oc->link3->link7 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c3 = 1;
				}
				else {
					c3 = ic0; // 4 или 2.
				}
			}
			if (oc->link4 != nullptr) {
				c4 = 1;
				char ic0 = 0;
				if (oc->link4->link0 != nullptr) {
					ic0++;
				}
				if (oc->link4->link3 != nullptr) {
					ic0++;
				}
				if (oc->link4->link4 != nullptr) {
					ic0++;
				}
				if (oc->link4->link7 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c4 = 1;
				}
				else {
					c4 = ic0; // 4 или 2.
				}
			}
			if (oc->link7 != nullptr) {
				c7 = 1;
				char ic0 = 0;
				if (oc->link7->link0 != nullptr) {
					ic0++;
				}
				if (oc->link7->link3 != nullptr) {
					ic0++;
				}
				if (oc->link7->link4 != nullptr) {
					ic0++;
				}
				if (oc->link7->link7 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c7 = 1;
				}
				else {
					c7 = ic0; // 4 или 2.
				}
			}
			break;
		case S_SIDE: // 0,1,4,5 
			if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
				if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
								b1 = true;
							}
						}
					}
				}
			}
			if (oc->link0 != nullptr) {
				c0 = 1;
				char ic0 = 0;
				if (oc->link0->link0 != nullptr) {
					ic0++;
				}
				if (oc->link0->link1 != nullptr) {
					ic0++;
				}
				if (oc->link0->link4 != nullptr) {
					ic0++;
				}
				if (oc->link0->link5 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c0 = 1;
				}
				else {
					c0 = ic0; // 4 или 2.
				}
			}
			if (oc->link1 != nullptr) {
				c1 = 1;
				char ic0 = 0;
				if (oc->link1->link0 != nullptr) {
					ic0++;
				}
				if (oc->link1->link1 != nullptr) {
					ic0++;
				}
				if (oc->link1->link4 != nullptr) {
					ic0++;
				}
				if (oc->link1->link5 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c1 = 1;
				}
				else {
					c1 = ic0; // 4 или 2.
				}
			}
			if (oc->link4 != nullptr) {
				c4 = 1;
				char ic0 = 0;
				if (oc->link4->link0 != nullptr) {
					ic0++;
				}
				if (oc->link4->link1 != nullptr) {
					ic0++;
				}
				if (oc->link4->link4 != nullptr) {
					ic0++;
				}
				if (oc->link4->link5 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c4 = 1;
				}
				else {
					c4 = ic0; // 4 или 2.
				}
			}
			if (oc->link5 != nullptr) {
				c5 = 1;
				char ic0 = 0;
				if (oc->link5->link0 != nullptr) {
					ic0++;
				}
				if (oc->link5->link1 != nullptr) {
					ic0++;
				}
				if (oc->link5->link4 != nullptr) {
					ic0++;
				}
				if (oc->link5->link5 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c5 = 1;
				}
				else {
					c5 = ic0; // 4 или 2.
				}
			}


			break;
		case B_SIDE: // 0,1,2,3
			// Т.к. может быть вырождение по Z.
			if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr)) {
				if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
							if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
								b1 = true;
							}
						}
					}
				}
			}
			if (oc->link0 != nullptr) {
				c0 = 1;
				char ic0 = 0;
				if (oc->link0->link0 != nullptr) {
					ic0++;
				}
				if (oc->link0->link1 != nullptr) {
					ic0++;
				}
				if (oc->link0->link2 != nullptr) {
					ic0++;
				}
				if (oc->link0->link3 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c0 = 1;
				}
				else {
					c0 = ic0; // 4 или 2.
				}
			}

			if (oc->link1 != nullptr) {
				c1 = 1;
				char ic0 = 0;
				if (oc->link1->link0 != nullptr) {
					ic0++;
				}
				if (oc->link1->link1 != nullptr) {
					ic0++;
				}
				if (oc->link1->link2 != nullptr) {
					ic0++;
				}
				if (oc->link1->link3 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c1 = 1;
				}
				else {
					c1 = ic0; // 4 или 2.
				}
			}
			if (oc->link2 != nullptr) {
				c2 = 1;
				char ic0 = 0;
				if (oc->link2->link0 != nullptr) {
					ic0++;
				}
				if (oc->link2->link1 != nullptr) {
					ic0++;
				}
				if (oc->link2->link2 != nullptr) {
					ic0++;
				}
				if (oc->link2->link3 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c2 = 1;
				}
				else {
					c2 = ic0; // 4 или 2.
				}
			}
			if (oc->link3 != nullptr) {
				c3 = 1;
				char ic0 = 0;
				if (oc->link3->link0 != nullptr) {
					ic0++;
				}
				if (oc->link3->link1 != nullptr) {
					ic0++;
				}
				if (oc->link3->link2 != nullptr) {
					ic0++;
				}
				if (oc->link3->link3 != nullptr) {
					ic0++;
				}
				if (ic0 == 0) {
					c3 = 1;
				}
				else {
					c3 = ic0; // 4 или 2.
				}
			}


			break;
		default:
			printf("ERROR!!! is_null1 error in direct\n");
			//system("PAUSE");
			system("PAUSE");
			exit(1);
			break;
		}

	}
	return b1;
} // is_null2

bool is_null3(Toctree* &oc, integer direct, char &c0, char &c1, char &c2, char &c3, char &c4, char &c5, char &c6, char &c7)
{
	// cface - это количество соседей по face грани.

	c0 = 0;
	c1 = 0;
	c2 = 0;
	c3 = 0;
	c4 = 0;
	c5 = 0;
	c6 = 0;
	c7 = 0;

	//    N
	//  W P E
	//    S

	// direct WSIDE, SSIDE, B:
	integer dir = direct;

	bool bSituationX = false;
	bool bSituationY = false;
	bool bSituationZ = false;
	if (oc != nullptr) {
		if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr) && (oc->link4 == nullptr) && (oc->link5 == nullptr) && (oc->link6 == nullptr) && (oc->link7 == nullptr)) {
			bSituationZ = true;
		}
		if ((oc->link0 != nullptr) && (oc->link1 == nullptr) && (oc->link2 == nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link5 == nullptr) && (oc->link6 == nullptr) && (oc->link7 != nullptr)) {
			bSituationX = true;
		}
		if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 == nullptr) && (oc->link3 == nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr) && (oc->link6 == nullptr) && (oc->link7 == nullptr)) {
			bSituationY = true;
		}
	}

	// на данный момент запрограммирован только случай невырожденной ячейки которая раздроблена на 8 равных подъячеек.
	// внешний алгоритм видит эту ячейку именно такой, отдельные случаи вырождения требуют особого прописывания в коде.

	bool b1 = false;
	if ((bSituationZ) && (!bSituationY) && (!bSituationX)) {
		// Вырождение по Z
		if (oc != nullptr) {
			switch (dir) {
			case T_SIDE: case  B_SIDE: // 0,1,2,3

				if (oc->link0 != nullptr) {
					c0 = 1; c4 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link2 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c4 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c4 = ic0;
					}
				}

				if (oc->link1 != nullptr) {
					c1 = 1; c5 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
						c5 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				if (oc->link2 != nullptr) {
					c2 = 1; c6 = 1;
					char ic0 = 0;
					if (oc->link2->link0 != nullptr) {
						ic0++;
					}
					if (oc->link2->link1 != nullptr) {
						ic0++;
					}
					if (oc->link2->link2 != nullptr) {
						ic0++;
					}
					if (oc->link2->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
						c6 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
						c6 = ic0;
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1; c7 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link1 != nullptr) {
						ic0++;
					}
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c7 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}


				break;
			case W_SIDE:  // 1,2
				if ((oc->link1 != nullptr) && (oc->link2 != nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (oc->link1->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link2 != nullptr) {
					c2 = 1;
					char ic0 = 0;
					if (oc->link2->link1 != nullptr) {
						ic0++;
					}
					if (oc->link2->link2 != nullptr) {
						ic0++;
					}
					if (oc->link2->link5 != nullptr) {
						ic0++;
					}
					if (oc->link2->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				// Этих ячеек нет значит и счётчики равны нулю.
				c5 = 0;
				c6 = 0;

				break;
			case E_SIDE: // 0,3
				if ((oc->link0 != nullptr) && (oc->link3 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link4 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				c4 = 0;
				c7 = 0;

				break;
			case S_SIDE: // 2,3
				if ((oc->link2 != nullptr) && (oc->link3 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link2 != nullptr) {
					c2 = 1;
					char ic0 = 0;
					if (oc->link2->link2 != nullptr) {
						ic0++;
					}
					if (oc->link2->link3 != nullptr) {
						ic0++;
					}
					if (oc->link2->link6 != nullptr) {
						ic0++;
					}
					if (oc->link2->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link6 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				c6 = 0;
				c7 = 0;

				break;
			case N_SIDE: // 0,1
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link4 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				c4 = 0;
				c5 = 0;

				break;
			default: printf("error: is_null3 if ((bSituationZ) && (!bSituationY) && (!bSituationX)) \n");
				//system("PAUSE");
				system("PAUSE");
				break;
			}
		}
	}

	if ((bSituationY) && (!bSituationZ) && (!bSituationX)) {
		// Вырождение по Y
		if (oc != nullptr) {
			switch (dir) {
			case N_SIDE: case S_SIDE: // 0,1,4,5 
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
								if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1; c3 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c3 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c3 = ic0;
					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1; c2 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link4 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
						c2 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1; c7 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link1 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
						c7 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}
				if (oc->link5 != nullptr) {
					c5 = 1;
					c6 = 1;
					char ic0 = 0;
					if (oc->link5->link0 != nullptr) {
						ic0++;
					}
					if (oc->link5->link1 != nullptr) {
						ic0++;
					}
					if (oc->link5->link4 != nullptr) {
						ic0++;
					}
					if (oc->link5->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
						c6 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
						c6 = ic0;
					}
				}
				break;
			case E_SIDE: // 0,4
				if ((oc->link0 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}

				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link3 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				c7 = 0;
				c3 = 0;
				break;
			case W_SIDE: // 1,2,5,6
				// 1,5
				if ((oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (oc->link1->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				c2 = 0;

				if (oc->link5 != nullptr) {
					c5 = 1;
					char ic0 = 0;
					if (oc->link5->link1 != nullptr) {
						ic0++;
					}
					if (oc->link5->link2 != nullptr) {
						ic0++;
					}
					if (oc->link5->link5 != nullptr) {
						ic0++;
					}
					if (oc->link5->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				c6 = 0;

				break;
			case T_SIDE: // 0,1,2,3
				// 0,1
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link2 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}

				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				c2 = 0;
				c3 = 0;
				break;
			case B_SIDE: // 4,5,6,7
				// 4,5
				// Т.к. может быть вырождение по Z.
				if ((oc->link4 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
						if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (oc->link4->link6 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}

				if (oc->link5 != nullptr) {
					c5 = 1;
					char ic0 = 0;
					if (oc->link5->link4 != nullptr) {
						ic0++;
					}
					if (oc->link5->link5 != nullptr) {
						ic0++;
					}
					if (oc->link5->link6 != nullptr) {
						ic0++;
					}
					if (oc->link5->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				c6 = 0;
				c7 = 0;
				break;

			default: printf("error: is_null3 if ((bSituationY) && (!bSituationZ) && (!bSituationX))  \n");
				//system("PAUSE");
				system("PAUSE");
				break;
			}
		}
	}

	if ((bSituationX) && (!bSituationZ) && (!bSituationY)) {
		// Вырождение по X
		if (oc != nullptr) {
			switch (dir) {
			case E_SIDE: case W_SIDE:// 0,3,4,7

				if (oc->link0 != nullptr) {
					c0 = 1; c1 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c1 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c1 = ic0;
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1; c2 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link4 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c2 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1; c5 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link3 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
						c5 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				if (oc->link7 != nullptr) {
					c7 = 1; c6 = 1;
					char ic0 = 0;
					if (oc->link7->link0 != nullptr) {
						ic0++;
					}
					if (oc->link7->link3 != nullptr) {
						ic0++;
					}
					if (oc->link7->link4 != nullptr) {
						ic0++;
					}
					if (oc->link7->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
						c6 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
						c6 = ic0;
					}
				}
				break;
			case N_SIDE: // 0,1,4,5 
				// 0,4
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				c1 = 0;

				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link1 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				c5 = 0;

				break;
			case S_SIDE: // 3,7 
				if ((oc->link2 != nullptr) && (oc->link3 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
						if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				c2 = 0;

				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link6 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				c6 = 0;

				if (oc->link7 != nullptr) {
					c7 = 1;
					char ic0 = 0;
					if (oc->link7->link2 != nullptr) {
						ic0++;
					}
					if (oc->link7->link3 != nullptr) {
						ic0++;
					}
					if (oc->link7->link6 != nullptr) {
						ic0++;
					}
					if (oc->link7->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;
			case T_SIDE: // 0,1,2,3
				// 0,3
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link2 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				c1 = 0;
				c2 = 0;


				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link1 != nullptr) {
						ic0++;
					}
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}


				break;
			case B_SIDE: // 4,5,6,7
				// 4,7
				// Т.к. может быть вырождение по Z.
				if ((oc->link4 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
						if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (oc->link4->link6 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				c5 = 0;
				c6 = 0;


				if (oc->link7 != nullptr) {
					c7 = 1;
					char ic0 = 0;
					if (oc->link7->link4 != nullptr) {
						ic0++;
					}
					if (oc->link7->link5 != nullptr) {
						ic0++;
					}
					if (oc->link7->link6 != nullptr) {
						ic0++;
					}
					if (oc->link7->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;

			default: printf("error: is_null3  if ((bSituationX) && (!bSituationZ) && (!bSituationY)) \n");
				//system("PAUSE");
				system("PAUSE");
				break;
			}
		}
	}

	// остались direction вырождения ячейки.
	// Возможны только три случая.
	if ((bSituationZ) && (bSituationY) && (!bSituationX)) {
		// X direction.
		// полноценная ячейка.
		if (oc != nullptr) {

			switch (dir) {
			case W_SIDE: case E_SIDE:
				c0 = c1 = 1;
				c2 = c3 = c4 = c5 = c6 = c7 = 0;
				break;
			case N_SIDE: // 0,1,4,5 
				// 0,1
			case S_SIDE: // 2,3,6,7
				//(0,3) (1,2) (4,7) (5,6)
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1; c3 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c3 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c3 = ic0;
					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1; c2 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link4 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
						c2 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				c4 = c5 = c6 = c7 = 0;

				break;
			case T_SIDE: // 0,1,2,3
				//0,1
			case B_SIDE: // 4,5,6,7
				// 4,5
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1; c4 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link2 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c4 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c4 = ic0;
					}
				}

				if (oc->link1 != nullptr) {
					c1 = 1; c5 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1; c5 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				c2 = c3 = c6 = c7 = 0;

				break;

			}
		}
	}
	if ((bSituationZ) && (!bSituationY) && (bSituationX)) {
		// Y direction.
		// полноценная ячейка.
		if (oc != nullptr) {

			switch (dir) {
			case S_SIDE: case N_SIDE:
				c0 = c3 = 1;
				c2 = c1 = c4 = c5 = c6 = c7 = 0;
				break;
			case E_SIDE: // 0,3,4,7
				// 0,3
			case W_SIDE: // 1,2,5,6
				// (0,1) (3,2) (4,5) (7,6) 
				if ((oc->link0 != nullptr) && (oc->link3 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					c1 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c1 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c1 = ic0;
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1;
					c2 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link4 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c2 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c2 = ic0;
					}
				}
				c4 = c5 = c6 = c7 = 0;
				break;
			case T_SIDE: // 0,1,2,3
				//0,3
			case B_SIDE: // 4, 5, 6, 7
				//(0,4) (1,5) (2,6) (3,7)
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != nullptr) && (oc->link3 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1; c4 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link2 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c4 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c4 = ic0;
					}
				}
				c1 = c5 = c2 = c6 = 0;

				if (oc->link3 != nullptr) {
					c3 = 1; c7 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link1 != nullptr) {
						ic0++;
					}
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
						c7 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}


				break;
			}
		}
	}
	if ((!bSituationZ) && (bSituationY) && (bSituationX)) {
		// Z direction.
		// полноценная ячейка.
		if (oc != nullptr) {

			switch (dir) {
			case T_SIDE: case  B_SIDE:
				c0 = c4 = 1;
				c1 = c2 = c3 = c5 = c6 = c7 = 0;
				break;
			case E_SIDE: case W_SIDE:// 0,3,4,7
				// 0, 4
				// W 1,2,5,6
				// 1,5
				if ((oc->link0 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							b1 = true;
						}

					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1; c1 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1; c1 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c1 = ic0;
					}
				}
				c3 = 0;
				c2 = 0;


				if (oc->link4 != nullptr) {
					c4 = 1; c5 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link3 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1; c5 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c5 = ic0;
					}
				}
				c7 = 0;
				c6 = 0;
				break;
			case N_SIDE: // 0,1,4,5
				// 0, 4
			case S_SIDE: // 2,3,6,7
				// (0,3) (1,2) (4,7) (5,6)
				if ((oc->link0 != nullptr) && (oc->link4 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
							b1 = true;
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1; c3 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
						c3 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
						c3 = ic0;
					}
				}
				c1 = 0;
				c2 = 0;
				if (oc->link4 != nullptr) {
					c4 = 1; c7 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link1 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
						c7 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
						c7 = ic0;
					}
				}
				c5 = 0;
				c6 = 0;
				break;
			}
		}
	}

	if ((!bSituationZ) && (!bSituationY) && (!bSituationX)) {
		// полноценная ячейка.
		if (oc != nullptr) {

			switch (dir) {
			case E_SIDE: // 0,3,4,7
				if ((oc->link0 != nullptr) && (oc->link3 != nullptr) && (oc->link4 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
								if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link4 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link3 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				if (oc->link7 != nullptr) {
					c7 = 1;
					char ic0 = 0;
					if (oc->link7->link0 != nullptr) {
						ic0++;
					}
					if (oc->link7->link3 != nullptr) {
						ic0++;
					}
					if (oc->link7->link4 != nullptr) {
						ic0++;
					}
					if (oc->link7->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}
				break;
			case W_SIDE: // 1,2,5,6
				if ((oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr)) {
					if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
						if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
							if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
								if ((oc->link6->link0 == nullptr) && (oc->link6->link1 == nullptr) && (oc->link6->link2 == nullptr) && (oc->link6->link3 == nullptr) && (oc->link6->link4 == nullptr) && (oc->link6->link5 == nullptr) && (oc->link6->link6 == nullptr) && (oc->link6->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (oc->link1->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link2 != nullptr) {
					c2 = 1;
					char ic0 = 0;
					if (oc->link2->link1 != nullptr) {
						ic0++;
					}
					if (oc->link2->link2 != nullptr) {
						ic0++;
					}
					if (oc->link2->link5 != nullptr) {
						ic0++;
					}
					if (oc->link2->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link5 != nullptr) {
					c5 = 1;
					char ic0 = 0;
					if (oc->link5->link1 != nullptr) {
						ic0++;
					}
					if (oc->link5->link2 != nullptr) {
						ic0++;
					}
					if (oc->link5->link5 != nullptr) {
						ic0++;
					}
					if (oc->link5->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				if (oc->link6 != nullptr) {
					c6 = 1;
					char ic0 = 0;
					if (oc->link6->link1 != nullptr) {
						ic0++;
					}
					if (oc->link6->link2 != nullptr) {
						ic0++;
					}
					if (oc->link6->link5 != nullptr) {
						ic0++;
					}
					if (oc->link6->link6 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c6 = 1;
					}
					else {
						c6 = ic0; // 4 или 2.
					}
				}
				break;
			case N_SIDE: // 0,1,4,5 
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link4 != nullptr) && (oc->link5 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
								if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link4 != nullptr) {
						ic0++;
					}
					if (oc->link0->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}
				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link4 != nullptr) {
						ic0++;
					}
					if (oc->link1->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link0 != nullptr) {
						ic0++;
					}
					if (oc->link4->link1 != nullptr) {
						ic0++;
					}
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}
				if (oc->link5 != nullptr) {
					c5 = 1;
					char ic0 = 0;
					if (oc->link5->link0 != nullptr) {
						ic0++;
					}
					if (oc->link5->link1 != nullptr) {
						ic0++;
					}
					if (oc->link5->link4 != nullptr) {
						ic0++;
					}
					if (oc->link5->link5 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}


				break;
			case S_SIDE: // 2,3,6,7 
				if ((oc->link2 != nullptr) && (oc->link3 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
						if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
							if ((oc->link6->link0 == nullptr) && (oc->link6->link1 == nullptr) && (oc->link6->link2 == nullptr) && (oc->link6->link3 == nullptr) && (oc->link6->link4 == nullptr) && (oc->link6->link5 == nullptr) && (oc->link6->link6 == nullptr) && (oc->link6->link7 == nullptr)) {
								if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link2 != nullptr) {
					c2 = 1;
					char ic0 = 0;
					if (oc->link2->link2 != nullptr) {
						ic0++;
					}
					if (oc->link2->link3 != nullptr) {
						ic0++;
					}
					if (oc->link2->link6 != nullptr) {
						ic0++;
					}
					if (oc->link2->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (oc->link3->link6 != nullptr) {
						ic0++;
					}
					if (oc->link3->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}
				if (oc->link6 != nullptr) {
					c6 = 1;
					char ic0 = 0;
					if (oc->link6->link2 != nullptr) {
						ic0++;
					}
					if (oc->link6->link3 != nullptr) {
						ic0++;
					}
					if (oc->link6->link6 != nullptr) {
						ic0++;
					}
					if (oc->link6->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c6 = 1;
					}
					else {
						c6 = ic0; // 4 или 2.
					}
				}
				if (oc->link7 != nullptr) {
					c7 = 1;
					char ic0 = 0;
					if (oc->link7->link2 != nullptr) {
						ic0++;
					}
					if (oc->link7->link3 != nullptr) {
						ic0++;
					}
					if (oc->link7->link6 != nullptr) {
						ic0++;
					}
					if (oc->link7->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;
			case T_SIDE: // 0,1,2,3
				// Т.к. может быть вырождение по Z.
				if ((oc->link0 != nullptr) && (oc->link1 != nullptr) && (oc->link2 != nullptr) && (oc->link3 != nullptr)) {
					if ((oc->link0->link0 == nullptr) && (oc->link0->link1 == nullptr) && (oc->link0->link2 == nullptr) && (oc->link0->link3 == nullptr) && (oc->link0->link4 == nullptr) && (oc->link0->link5 == nullptr) && (oc->link0->link6 == nullptr) && (oc->link0->link7 == nullptr)) {
						if ((oc->link1->link0 == nullptr) && (oc->link1->link1 == nullptr) && (oc->link1->link2 == nullptr) && (oc->link1->link3 == nullptr) && (oc->link1->link4 == nullptr) && (oc->link1->link5 == nullptr) && (oc->link1->link6 == nullptr) && (oc->link1->link7 == nullptr)) {
							if ((oc->link2->link0 == nullptr) && (oc->link2->link1 == nullptr) && (oc->link2->link2 == nullptr) && (oc->link2->link3 == nullptr) && (oc->link2->link4 == nullptr) && (oc->link2->link5 == nullptr) && (oc->link2->link6 == nullptr) && (oc->link2->link7 == nullptr)) {
								if ((oc->link3->link0 == nullptr) && (oc->link3->link1 == nullptr) && (oc->link3->link2 == nullptr) && (oc->link3->link3 == nullptr) && (oc->link3->link4 == nullptr) && (oc->link3->link5 == nullptr) && (oc->link3->link6 == nullptr) && (oc->link3->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link0 != nullptr) {
					c0 = 1;
					char ic0 = 0;
					if (oc->link0->link0 != nullptr) {
						ic0++;
					}
					if (oc->link0->link1 != nullptr) {
						ic0++;
					}
					if (oc->link0->link2 != nullptr) {
						ic0++;
					}
					if (oc->link0->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c0 = 1;
					}
					else {
						c0 = ic0; // 4 или 2.
					}
				}

				if (oc->link1 != nullptr) {
					c1 = 1;
					char ic0 = 0;
					if (oc->link1->link0 != nullptr) {
						ic0++;
					}
					if (oc->link1->link1 != nullptr) {
						ic0++;
					}
					if (oc->link1->link2 != nullptr) {
						ic0++;
					}
					if (oc->link1->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c1 = 1;
					}
					else {
						c1 = ic0; // 4 или 2.
					}
				}
				if (oc->link2 != nullptr) {
					c2 = 1;
					char ic0 = 0;
					if (oc->link2->link0 != nullptr) {
						ic0++;
					}
					if (oc->link2->link1 != nullptr) {
						ic0++;
					}
					if (oc->link2->link2 != nullptr) {
						ic0++;
					}
					if (oc->link2->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c2 = 1;
					}
					else {
						c2 = ic0; // 4 или 2.
					}
				}
				if (oc->link3 != nullptr) {
					c3 = 1;
					char ic0 = 0;
					if (oc->link3->link0 != nullptr) {
						ic0++;
					}
					if (oc->link3->link1 != nullptr) {
						ic0++;
					}
					if (oc->link3->link2 != nullptr) {
						ic0++;
					}
					if (oc->link3->link3 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c3 = 1;
					}
					else {
						c3 = ic0; // 4 или 2.
					}
				}


				break;
			case B_SIDE: // 4,5,6,7
				// Т.к. может быть вырождение по Z.
				if ((oc->link4 != nullptr) && (oc->link5 != nullptr) && (oc->link6 != nullptr) && (oc->link7 != nullptr)) {
					if ((oc->link4->link0 == nullptr) && (oc->link4->link1 == nullptr) && (oc->link4->link2 == nullptr) && (oc->link4->link3 == nullptr) && (oc->link4->link4 == nullptr) && (oc->link4->link5 == nullptr) && (oc->link4->link6 == nullptr) && (oc->link4->link7 == nullptr)) {
						if ((oc->link5->link0 == nullptr) && (oc->link5->link1 == nullptr) && (oc->link5->link2 == nullptr) && (oc->link5->link3 == nullptr) && (oc->link5->link4 == nullptr) && (oc->link5->link5 == nullptr) && (oc->link5->link6 == nullptr) && (oc->link5->link7 == nullptr)) {
							if ((oc->link6->link0 == nullptr) && (oc->link6->link1 == nullptr) && (oc->link6->link2 == nullptr) && (oc->link6->link3 == nullptr) && (oc->link6->link4 == nullptr) && (oc->link6->link5 == nullptr) && (oc->link6->link6 == nullptr) && (oc->link6->link7 == nullptr)) {
								if ((oc->link7->link0 == nullptr) && (oc->link7->link1 == nullptr) && (oc->link7->link2 == nullptr) && (oc->link7->link3 == nullptr) && (oc->link7->link4 == nullptr) && (oc->link7->link5 == nullptr) && (oc->link7->link6 == nullptr) && (oc->link7->link7 == nullptr)) {
									b1 = true;
								}
							}
						}
					}
				}
				if (oc->link4 != nullptr) {
					c4 = 1;
					char ic0 = 0;
					if (oc->link4->link4 != nullptr) {
						ic0++;
					}
					if (oc->link4->link5 != nullptr) {
						ic0++;
					}
					if (oc->link4->link6 != nullptr) {
						ic0++;
					}
					if (oc->link4->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c4 = 1;
					}
					else {
						c4 = ic0; // 4 или 2.
					}
				}

				if (oc->link5 != nullptr) {
					c5 = 1;
					char ic0 = 0;
					if (oc->link5->link4 != nullptr) {
						ic0++;
					}
					if (oc->link5->link5 != nullptr) {
						ic0++;
					}
					if (oc->link5->link6 != nullptr) {
						ic0++;
					}
					if (oc->link5->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c5 = 1;
					}
					else {
						c5 = ic0; // 4 или 2.
					}
				}
				if (oc->link6 != nullptr) {
					c6 = 1;
					char ic0 = 0;
					if (oc->link6->link4 != nullptr) {
						ic0++;
					}
					if (oc->link6->link5 != nullptr) {
						ic0++;
					}
					if (oc->link6->link6 != nullptr) {
						ic0++;
					}
					if (oc->link6->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c6 = 1;
					}
					else {
						c6 = ic0; // 4 или 2.
					}
				}
				if (oc->link7 != nullptr) {
					c7 = 1;
					char ic0 = 0;
					if (oc->link7->link4 != nullptr) {
						ic0++;
					}
					if (oc->link7->link5 != nullptr) {
						ic0++;
					}
					if (oc->link7->link6 != nullptr) {
						ic0++;
					}
					if (oc->link7->link7 != nullptr) {
						ic0++;
					}
					if (ic0 == 0) {
						c7 = 1;
					}
					else {
						c7 = ic0; // 4 или 2.
					}
				}


				break;
			default:
				printf("ERROR!!! is_null1 error in direct\n");
				//system("PAUSE");
				system("PAUSE");
				exit(1);
				break;
			}

		}
	}
	return b1;
} // is_null3



void patch_neighbour_count(char &ineighbour, octree* &oc_info, integer iside_info) {

	switch (ineighbour) {
	case 0: printf("error!!! patch_neighbour_count increment  ineighbour=0\n");
#if doubleintprecision == 1
		printf("root=%lld\n", oc_info->root);
		if (oc_info->parent != nullptr) {
			printf("parent->root=%lld\n", oc_info->parent->root);
			if (oc_info->parent->parent != nullptr) {
				printf("parent->parent->root=%lld\n", oc_info->parent->parent->root);
			}
	}
#else
		printf("root=%d\n", oc_info->root);
		if (oc_info->parent != nullptr) {
			printf("parent->root=%d\n", oc_info->parent->root);
			if (oc_info->parent->parent != nullptr) {
				printf("parent->parent->root=%d\n", oc_info->parent->parent->root);
			}
		}
#endif
		
		switch (iside_info) {
		case E_SIDE: printf("ESIDE\n"); break;
		case W_SIDE: printf("W\n"); break;
		case N_SIDE: printf("NSIDE\n"); break;
		case S_SIDE: printf("SSIDE\n"); break;
		case T_SIDE: printf("TSIDE\n"); break;
		case B_SIDE: printf("B\n"); break;
		}
		//system("PAUSE");
		system("PAUSE");
		exit(1);
		//ineighbour = 4;
		break;
	case 1: ineighbour = 4;
		break;
	case 4: ineighbour = 7;
		break;
	case 7: ineighbour = 10;
		break;
	case 10: ineighbour = 13; break;
	case 13: ineighbour = 16; break;
	default: // Это признак того что ячейка должна дробиться очень сильно.
		ineighbour += 4 - 1;
		break;
	}
} // patch_neighbour_count

void patch_neighbour_count2(char &ineighbour) {
	// При вырождениии в направлении одной из осей.
	switch (ineighbour) {
	case 0: printf("error!!! patch_neighbour_count2 increment  ineighbour=0\n");
		//system("PAUSE");
		system("PAUSE");
		exit(1);
		//ineighbour = 2;
		break;
	case 1: ineighbour = 2;
		break;
	case 2: ineighbour = 3;
		break;
	case 3: ineighbour = 4;
		break;
	case 4: ineighbour = 5; break;
	case 5: ineighbour = 6; break;
	default: // Это признак того что ячейка должна дробиться очень сильно.
		ineighbour += 2 - 1;
		break;
	}
} // patch_neighbour_count




// Алгоритм дробления листа на 8 частей с учётом вырождений.
void droblenie_internal(octree* &oc, int minx, int maxx, int miny,
	int maxy, int minz, int maxz, 
	doublereal* &xpos, doublereal* &ypos, doublereal* &zpos, integer &ret, bool dodroblenie,
	bool bdrobimX, bool bdrobimY, bool bdrobimZ, BLOCK*& b, TOCHKA &GSep) {

	if (maxx <= minx) {
		printf("maxx <= minx in droblenie_internal\n");
		//system("PAUSE");
		system("PAUSE");
		exit(1);
	}
	if (maxy <= miny) {
		printf("maxy <= miny in droblenie_internal\n");
		//system("PAUSE");
		system("PAUSE");
		exit(1);
	}
	if (maxz <= minz) {
		printf("maxz <= minz in droblenie_internal\n");
		//system("PAUSE");
		system("PAUSE");
		exit(1);
	}

	bool bold_stable_version = true;

	bool b0 = true;
	bool b1 = true;
	bool b2 = true;
	bool b3 = true;
	bool b4 = true;
	bool b5 = true;
	bool b6 = true;
	bool b7 = true;
	ret = 0;

	// Вырождение по Z.
	bool bSituationZ = false;
	// Вырождение по X.
	bool bSituationX = false;
	// Вырождение по Y.
	bool bSituationY = false;

	
	
	int avgx = (minx + maxx)/2;
	int avgy = (miny + maxy)/2;
	int avgz = (minz + maxz)/2;
	
    if (1) {
		// 2 september 2017. Revised 27.08.2019
		// Допуск dpriority_tolerance для использования GSep.
		// 0.	none
		// 1.	Snap to grid
		// 2.	Snap to grid ALICE
		// 3.	Snap to grid ++	
		// 7% работает для модели tgf10 и менее.
		// 10% работает для модели tgf20 и менее.
		const doublereal dpriority_tolerance = 0.1; // ( 4% не работает) 7%
		bool bmod = false;
		if ((bsnap_TO_global == 2) || (bsnap_TO_global == 3)) {
			bmod = true;
		}
		doublereal xc28 = 0.5*(xpos[minx]+xpos[maxx]);
		if (bmod) {
			if (maxx > minx + 5) {
				if (fabs(GSep.x - xc28) < dpriority_tolerance*(fabs(xpos[maxx] - xpos[minx]))) {
					xc28 = GSep.x;
				}
			}
		}
		int isearch = -1;
		doublereal dmax28 = 1.0e36;
		// поиск наимее удалённого от геометрического центра индекса.
		for (int i28 = minx; i28 <= maxx; i28++) {
			if (fabs(xpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(xpos[i28] - xc28);
			}
		}
		avgx = isearch;

		xc28 = 0.5*(ypos[miny] + ypos[maxy]);
		if (bmod) {
			if (maxy > miny + 5) {
				if (fabs(GSep.y - xc28) < dpriority_tolerance*(fabs(ypos[maxy] - ypos[miny]))) {
					xc28 = GSep.y;
				}
			}
		}
		isearch = -1;
		dmax28 = 1.0e36;
		// поиск наимее удалённого от геометрического центра индекса.
		for (int i28 = miny; i28 <= maxy; i28++) {
			if (fabs(ypos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(ypos[i28] - xc28);
			}
		}
		avgy = isearch;

		xc28 = 0.5*(zpos[minz] + zpos[maxz]);
		if (bmod) {
			if (maxz > minz + 5) {
				if (fabs(GSep.z - xc28) < dpriority_tolerance*(fabs(zpos[maxz] - zpos[minz]))) {
					xc28 = GSep.z;
				}
			}
		}
		isearch = -1;
		dmax28 = 1.0e36;
		// поиск наимее удалённого от геометрического центра индекса.
		for (int i28 = minz; i28 <= maxz; i28++) {
			if (fabs(zpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(zpos[i28] - xc28);
			}
		}
		avgz = isearch;
	}

	if (minz + 1 == maxz) {
		avgz = maxz;
		b4 = false;
		b5 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Z.
		bSituationZ = true;
	}
	if (minx + 1 == maxx) {
		avgx = maxx;
		b1 = false;
		b2 = false;
		b5 = false;
		b6 = false;
		// Вырождение по X.
		bSituationX = true;
	}
	if (miny + 1 == maxy) {
		avgy = maxy;
		b2 = false;
		b3 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Y.
		bSituationY = true;
	}

	// Вырождение по Z.
	bool bSituationZ_prefix = bSituationZ;
	// Вырождение по X.
	bool bSituationX_prefix = bSituationX;
	// Вырождение по Y.
	bool bSituationY_prefix = bSituationY;

	if (!bold_stable_version) {
		if (!bdrobimX) {
			avgx = maxx;
			b1 = false;
			b2 = false;
			b5 = false;
			b6 = false;
			// Вырождение по X.
			bSituationX = true;
		}

		if (!bdrobimY) {
			avgy = maxy;
			b2 = false;
			b3 = false;
			b6 = false;
			b7 = false;
			// Вырождение по Y.
			bSituationY = true;
		}

		if (!bdrobimZ) {
			avgz = maxz;
			b4 = false;
			b5 = false;
			b6 = false;
			b7 = false;
			// Вырождение по Z.
			bSituationZ = true;
		}
	}

	bool bold_stable_version1 = bold_stable_version;

	if (!b1&&!b2&&!b3&&!b4&&!b5&&!b6&&!b7) {
		//iret++;
		//printf("error list droblenie internal. ");
		if (DEBUG_ALICE_MESH) {
			printf("list ostaetsq listom.\n");
		}
		oc->dlist = true;
		//system("PAUSE");
	}
	else {

		//bool bonly_dir_X = false;
		//bool bonly_dir_Y = false;
		//bool bonly_dir_Z = false;

		// дробление на iret частей.
		if (b1&&b2&&b3&&b4&&b5&&b6&&b7) {
			ret = 8;
		}
		else {
			if (bSituationX && (!bSituationY) && (!bSituationZ)) ret = 4;
			if (bSituationY && (!bSituationX) && (!bSituationZ)) ret = 4;
			if (bSituationZ && (!bSituationY) && (!bSituationX)) ret = 4;
			if (bSituationX && (bSituationY) && (!bSituationZ)) {
				ret = 2;
				//bonly_dir_Z = true;
			}
			if (bSituationX && (bSituationZ) && (!bSituationY)) {
				ret = 2;
				//bonly_dir_Y = true;
			}
			if (bSituationY && (bSituationZ) && (!bSituationX)) {
				ret = 2;
				//bonly_dir_X = true;
			}
		}

		if (b0&&!b1&&!b2&&!b3&&!b4&&!b5&&!b6&&!b7) {
			printf("ERROR ZACHEM DELITX!!!\n");
			//system("PAUSE");
			system("PAUSE");
		}

		if (minx < 0 ) {
			printf("ERROR minx==-1\n");
			system("PAUSE");
		}
		if (maxx < 0) {
			printf("ERROR maxx==-1\n");
			system("PAUSE");
		}
		// 29.08.2019
		if (maxx <= minx) {
			printf("ERROR maxx<=minx\n");
			system("PAUSE");
		}
		if (avgx < 0) {
			printf("ERROR avgx==-1\n");
			system("PAUSE");
		}
		if (miny < 0) {
			printf("ERROR miny==-1\n");
			system("PAUSE");
		}
		if (maxy < 0) {
			printf("ERROR maxy==-1\n");
			system("PAUSE");
		}
		if (maxy <= miny) {
			printf("ERROR maxy<=miny\n");
			system("PAUSE");
		}
		if (avgy < 0) {
			printf("ERROR avgy==-1\n");
			system("PAUSE");
		}
		if (minz < 0) {
			printf("ERROR minz==-1\n");
			system("PAUSE");
		}
		if (maxz < 0) {
			printf("ERROR maxz==-1\n");
			system("PAUSE");
		}
		if (maxz <= minz) {
			printf("ERROR maxz<=minz\n");
			system("PAUSE");
		}
		if (avgz < 0) {
			printf("ERROR avgz==-1\n");
			system("PAUSE");
		}

		// дробление
		int minx0 = minx;
		int maxx0 = avgx;
		int miny0 = miny;
		int maxy0 = avgy;
		int minz0 = minz;
		int maxz0 = avgz;
		doublereal rminx0 = xpos[minx];
		doublereal rmaxx0 = xpos[avgx];
		doublereal rminy0 = ypos[miny];
		doublereal rmaxy0 = ypos[avgy];
		doublereal rminz0 = zpos[minz];
		doublereal rmaxz0 = zpos[avgz];

		
		if (rminx0 < b[0].g.xS) {
			printf("ERROR Cabinet out rminx0. %e %d\n", rminx0, minx);
			system("PAUSE");
		}
		if (rminy0 < b[0].g.yS) {
			printf("ERROR Cabinet out rminy0. %e %d\n", rminy0, miny);
			system("PAUSE");
		}
		if (rminz0 < b[0].g.zS) {
			printf("ERROR Cabinet out rminz0. %e %d\n", rminz0, minz);
			system("PAUSE");
		}
		

		if (rmaxx0 > b[0].g.xE) {
			printf("ERROR Cabinet out rmaxx0. %e %d\n", rmaxx0, avgx);
			system("PAUSE");
		}

		if (rmaxy0 > b[0].g.yE) {
			printf("ERROR Cabinet out rmaxy0. %e %d\n", rmaxy0, avgy);
			system("PAUSE");
		}

		if (rmaxz0 > b[0].g.zE) {
			printf("ERROR Cabinet out rmaxz0. %e %d\n", rmaxz0, avgz);
			system("PAUSE");
		}
		

		if (b0) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link0,
			//	minx0, maxx0, miny0, maxy0, minz0, maxz0, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx0;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx0;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny0;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy0;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz0;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz0;

			if (oc->link0 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link0!=nullptr.\n");
				system("PAUSE");
			}
			oc->link0 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode= oc->link0;
			
			

			oc->link0->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link0->inum_FD = 0;// Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link0 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link0 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link0->parent = oc;
			oc->link0->ilevel = oc->ilevel + 1;
			if (bold_stable_version1) {
				oc->link0->brootSituationX = bSituationX;
				oc->link0->brootSituationY = bSituationY;
				oc->link0->brootSituationZ = bSituationZ;

				oc->link0->brootSituationX_virtual = bSituationX;
				oc->link0->brootSituationY_virtual = bSituationY;
				oc->link0->brootSituationZ_virtual = bSituationZ;
			}
			else {
				oc->link0->brootSituationX = bSituationX;
				oc->link0->brootSituationY = bSituationY;
				oc->link0->brootSituationZ = bSituationZ;

				oc->link0->brootSituationX_virtual = bSituationX_prefix;
				oc->link0->brootSituationY_virtual = bSituationY_prefix;
				oc->link0->brootSituationZ_virtual = bSituationZ_prefix;
			}
			oc->link0->root = 0;
			oc->link0->minx = minx0;
			oc->link0->maxx = maxx0;
			oc->link0->miny = miny0;
			oc->link0->maxy = maxy0;
			oc->link0->minz = minz0;
			oc->link0->maxz = maxz0;

			oc->link0->p0.x = rminx0;
			oc->link0->p0.y = rminy0;
			oc->link0->p0.z = rminz0;
			oc->link0->p1.x = rmaxx0;
			oc->link0->p1.y = rminy0;
			oc->link0->p1.z = rminz0;
			oc->link0->p2.x = rminx0;
			oc->link0->p2.y = rmaxy0;
			oc->link0->p2.z = rminz0;
			oc->link0->p3.x = rmaxx0;
			oc->link0->p3.y = rmaxy0;
			oc->link0->p3.z = rminz0;

			oc->link0->p4.x = rminx0;
			oc->link0->p4.y = rminy0;
			oc->link0->p4.z = rmaxz0;
			oc->link0->p5.x = rmaxx0;
			oc->link0->p5.y = rminy0;
			oc->link0->p5.z = rmaxz0;
			oc->link0->p6.x = rminx0;
			oc->link0->p6.y = rmaxy0;
			oc->link0->p6.z = rmaxz0;
			oc->link0->p7.x = rmaxx0;
			oc->link0->p7.y = rmaxy0;
			oc->link0->p7.z = rmaxz0;
			oc->link0->link0 = nullptr;
			oc->link0->link1 = nullptr;
			oc->link0->link2 = nullptr;
			oc->link0->link3 = nullptr;
			oc->link0->link4 = nullptr;
			oc->link0->link5 = nullptr;
			oc->link0->link6 = nullptr;
			oc->link0->link7 = nullptr;
			// пока соседей просто нету.
			oc->link0->linkW = nullptr;
			oc->link0->linkE = nullptr;
			oc->link0->linkS = nullptr;
			oc->link0->linkN = nullptr;
			oc->link0->linkB = nullptr;
			oc->link0->linkT = nullptr;
			oc->link0->b4W = false;
			oc->link0->b4E = false;
			oc->link0->b4S = false;
			oc->link0->b4N = false;
			oc->link0->b4B = false;
			oc->link0->b4T = false;
			oc->link0->linkW0 = nullptr;
			oc->link0->linkW3 = nullptr;
			oc->link0->linkW4 = nullptr;
			oc->link0->linkW7 = nullptr;
			oc->link0->linkE1 = nullptr;
			oc->link0->linkE2 = nullptr;
			oc->link0->linkE5 = nullptr;
			oc->link0->linkE6 = nullptr;
			oc->link0->linkS0 = nullptr;
			oc->link0->linkS1 = nullptr;
			oc->link0->linkS4 = nullptr;
			oc->link0->linkS5 = nullptr;
			oc->link0->linkN2 = nullptr;
			oc->link0->linkN3 = nullptr;
			oc->link0->linkN6 = nullptr;
			oc->link0->linkN7 = nullptr;
			oc->link0->linkB0 = nullptr;
			oc->link0->linkB1 = nullptr;
			oc->link0->linkB2 = nullptr;
			oc->link0->linkB3 = nullptr;
			oc->link0->linkT4 = nullptr;
			oc->link0->linkT5 = nullptr;
			oc->link0->linkT6 = nullptr;
			oc->link0->linkT7 = nullptr;
			oc->dlist = false;
			oc->link0->dlist = true;
			oc->link0->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link0->bcrushing_when_balancing = true;
			}
			else {
				oc->link0->bcrushing_when_balancing = false;
			}


			oc->link0->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxEneighbour = MAX_NEIGHBOUR_COUNT;




			my_ALICE_STACK[top_ALICE_STACK].link = oc->link0;
			top_ALICE_STACK++;
		}
		else {
			oc->link0 = nullptr;
		}
		int minx1 = avgx;
		int maxx1 = maxx;
		int miny1 = miny;
		int maxy1 = avgy;
		int minz1 = minz;
		int maxz1 = avgz;
		doublereal rminx1 = xpos[avgx];
		doublereal rmaxx1 = xpos[maxx];
		doublereal rminy1 = ypos[miny];
		doublereal rmaxy1 = ypos[avgy];
		doublereal rminz1 = zpos[minz];
		doublereal rmaxz1 = zpos[avgz];

		if (rminx1 < b[0].g.xS) {
			printf("ERROR Cabinet out rminx1. %e %d\n", rminx1, avgx);
			system("PAUSE");
		}
		if (rminy1 < b[0].g.yS) {
			printf("ERROR Cabinet out rminy1. %e %d\n", rminy1, miny);
			system("PAUSE");
		}
		if (rminz1 < b[0].g.zS) {
			printf("ERROR Cabinet out rminz1. %e %d\n", rminz1, minz);
			system("PAUSE");
		}


		if (rmaxx1 > b[0].g.xE) {
			printf("ERROR Cabinet out rmaxx1. %e %d\n", rmaxx1, maxx);
			system("PAUSE");
		}

		if (rmaxy1 > b[0].g.yE) {
			printf("ERROR Cabinet out rmaxy1. %e %d\n", rmaxy1, avgy);
			system("PAUSE");
		}

		if (rmaxz1 > b[0].g.zE) {
			printf("ERROR Cabinet out rmaxz1. %e %d\n", rmaxz1, avgz);
			system("PAUSE");
		}


		if (b1) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link1,
			//	minx1, maxx1, miny1, maxy1, minz1, maxz1, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx1;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx1;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny1;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy1;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz1;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz1;

			if (oc->link1 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link1!=nullptr.\n");
				system("PAUSE");
			}
			oc->link1 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link1;

			
			

			oc->link1->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link1->inum_FD = 0;// Не принадлежит расчётной области.
		    // После применения оператора new не требуется делать проверку на null.
			//if (oc->link1 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link1 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link1->parent = oc;
			oc->link1->ilevel = oc->ilevel + 1;
			
			if (bold_stable_version1) {
				oc->link1->brootSituationX = bSituationX;
				oc->link1->brootSituationY = bSituationY;
				oc->link1->brootSituationZ = bSituationZ;

				oc->link1->brootSituationX_virtual = bSituationX;
				oc->link1->brootSituationY_virtual = bSituationY;
				oc->link1->brootSituationZ_virtual = bSituationZ;
			}
			else {
				oc->link1->brootSituationX = bSituationX;
				oc->link1->brootSituationY = bSituationY;
				oc->link1->brootSituationZ = bSituationZ;

				oc->link1->brootSituationX_virtual = bSituationX_prefix;
				oc->link1->brootSituationY_virtual = bSituationY_prefix;
				oc->link1->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link1->root = 1;
			oc->link1->minx = minx1;
			oc->link1->maxx = maxx1;
			oc->link1->miny = miny1;
			oc->link1->maxy = maxy1;
			oc->link1->minz = minz1;
			oc->link1->maxz = maxz1;
			oc->link1->p0.x = rminx1;
			oc->link1->p0.y = rminy1;
			oc->link1->p0.z = rminz1;
			oc->link1->p1.x = rmaxx1;
			oc->link1->p1.y = rminy1;
			oc->link1->p1.z = rminz1;
			oc->link1->p2.x = rminx1;
			oc->link1->p2.y = rmaxy1;
			oc->link1->p2.z = rminz1;
			oc->link1->p3.x = rmaxx1;
			oc->link1->p3.y = rmaxy1;
			oc->link1->p3.z = rminz1;
			oc->link1->p4.x = rminx1;
			oc->link1->p4.y = rminy1;
			oc->link1->p4.z = rmaxz1;
			oc->link1->p5.x = rmaxx1;
			oc->link1->p5.y = rminy1;
			oc->link1->p5.z = rmaxz1;
			oc->link1->p6.x = rminx1;
			oc->link1->p6.y = rmaxy1;
			oc->link1->p6.z = rmaxz1;
			oc->link1->p7.x = rmaxx1;
			oc->link1->p7.y = rmaxy1;
			oc->link1->p7.z = rmaxz1;
			oc->link1->link0 = nullptr;
			oc->link1->link1 = nullptr;
			oc->link1->link2 = nullptr;
			oc->link1->link3 = nullptr;
			oc->link1->link4 = nullptr;
			oc->link1->link5 = nullptr;
			oc->link1->link6 = nullptr;
			oc->link1->link7 = nullptr;
			// пока соседей просто нету.
			oc->link1->linkW = nullptr;
			oc->link1->linkE = nullptr;
			oc->link1->linkS = nullptr;
			oc->link1->linkN = nullptr;
			oc->link1->linkB = nullptr;
			oc->link1->linkT = nullptr;
			oc->link1->b4W = false;
			oc->link1->b4E = false;
			oc->link1->b4S = false;
			oc->link1->b4N = false;
			oc->link1->b4B = false;
			oc->link1->b4T = false;
			oc->link1->linkW0 = nullptr;
			oc->link1->linkW3 = nullptr;
			oc->link1->linkW4 = nullptr;
			oc->link1->linkW7 = nullptr;
			oc->link1->linkE1 = nullptr;
			oc->link1->linkE2 = nullptr;
			oc->link1->linkE5 = nullptr;
			oc->link1->linkE6 = nullptr;
			oc->link1->linkS0 = nullptr;
			oc->link1->linkS1 = nullptr;
			oc->link1->linkS4 = nullptr;
			oc->link1->linkS5 = nullptr;
			oc->link1->linkN2 = nullptr;
			oc->link1->linkN3 = nullptr;
			oc->link1->linkN6 = nullptr;
			oc->link1->linkN7 = nullptr;
			oc->link1->linkB0 = nullptr;
			oc->link1->linkB1 = nullptr;
			oc->link1->linkB2 = nullptr;
			oc->link1->linkB3 = nullptr;
			oc->link1->linkT4 = nullptr;
			oc->link1->linkT5 = nullptr;
			oc->link1->linkT6 = nullptr;
			oc->link1->linkT7 = nullptr;
			oc->link1->dlist = true;
			oc->link1->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link1->bcrushing_when_balancing = true;
			}
			else {
				oc->link1->bcrushing_when_balancing = false;
			}
			oc->link1->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxEneighbour = MAX_NEIGHBOUR_COUNT;



			my_ALICE_STACK[top_ALICE_STACK].link = oc->link1;
			top_ALICE_STACK++;
		}
		else {
			oc->link1 = nullptr;
		}
		int minx2 = avgx;
		int maxx2 = maxx;
		int miny2 = avgy;
		int maxy2 = maxy;
		int minz2 = minz;
		int maxz2 = avgz;
		doublereal rminx2 = xpos[avgx];
		doublereal rmaxx2 = xpos[maxx];
		doublereal rminy2 = ypos[avgy];
		doublereal rmaxy2 = ypos[maxy];
		doublereal rminz2 = zpos[minz];
		doublereal rmaxz2 = zpos[avgz];

		if (rminx2 < b[0].g.xS) {
			printf("ERROR Cabinet out rminx2. %e %d\n", rminx2, avgx);
			system("PAUSE");
		}
		if (rminy2 < b[0].g.yS) {
			printf("ERROR Cabinet out rminy2. %e %d\n", rminy2, avgy);
			system("PAUSE");
		}
		if (rminz2 < b[0].g.zS) {
			printf("ERROR Cabinet out rminz2. %e %d\n", rminz2, minz);
			system("PAUSE");
		}


		if (rmaxx2 > b[0].g.xE) {
			printf("ERROR Cabinet out rmaxx2. %e %d\n", rmaxx2, maxx);
			system("PAUSE");
		}

		if (rmaxy2 > b[0].g.yE) {
			printf("ERROR Cabinet out rmaxy2. %e %d\n", rmaxy2, maxy);
			system("PAUSE");
		}

		if (rmaxz2 > b[0].g.zE) {
			printf("ERROR Cabinet out rmaxz2. %e %d\n", rmaxz2, avgz);
			system("PAUSE");
		}

		if (b2) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link2,
			//minx2, maxx2, miny2, maxy2, minz2, maxz2, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx2;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx2;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny2;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy2;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz2;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz2;


			if (oc->link2 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link2!=nullptr.\n");
				system("PAUSE");
			}
			oc->link2 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link2;

			oc->link2->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link2->inum_FD = 0;// Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link2 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link2 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link2->parent = oc;
			oc->link2->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link2->brootSituationX = bSituationX;
				oc->link2->brootSituationY = bSituationY;
				oc->link2->brootSituationZ = bSituationZ;

				oc->link2->brootSituationX_virtual = bSituationX;
				oc->link2->brootSituationY_virtual = bSituationY;
				oc->link2->brootSituationZ_virtual = bSituationZ;
			}
			else {

				oc->link2->brootSituationX = bSituationX;
				oc->link2->brootSituationY = bSituationY;
				oc->link2->brootSituationZ = bSituationZ;

				oc->link2->brootSituationX_virtual = bSituationX_prefix;
				oc->link2->brootSituationY_virtual = bSituationY_prefix;
				oc->link2->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link2->root = 2;
			oc->link2->minx = minx2;
			oc->link2->maxx = maxx2;
			oc->link2->miny = miny2;
			oc->link2->maxy = maxy2;
			oc->link2->minz = minz2;
			oc->link2->maxz = maxz2;
			oc->link2->p0.x = rminx2;
			oc->link2->p0.y = rminy2;
			oc->link2->p0.z = rminz2;
			oc->link2->p1.x = rmaxx2;
			oc->link2->p1.y = rminy2;
			oc->link2->p1.z = rminz2;
			oc->link2->p2.x = rminx2;
			oc->link2->p2.y = rmaxy2;
			oc->link2->p2.z = rminz2;
			oc->link2->p3.x = rmaxx2;
			oc->link2->p3.y = rmaxy2;
			oc->link2->p3.z = rminz2;
			oc->link2->p4.x = rminx2;
			oc->link2->p4.y = rminy2;
			oc->link2->p4.z = rmaxz2;
			oc->link2->p5.x = rmaxx2;
			oc->link2->p5.y = rminy2;
			oc->link2->p5.z = rmaxz2;
			oc->link2->p6.x = rminx2;
			oc->link2->p6.y = rmaxy2;
			oc->link2->p6.z = rmaxz2;
			oc->link2->p7.x = rmaxx2;
			oc->link2->p7.y = rmaxy2;
			oc->link2->p7.z = rmaxz2;
			oc->link2->link0 = nullptr;
			oc->link2->link1 = nullptr;
			oc->link2->link2 = nullptr;
			oc->link2->link3 = nullptr;
			oc->link2->link4 = nullptr;
			oc->link2->link5 = nullptr;
			oc->link2->link6 = nullptr;
			oc->link2->link7 = nullptr;
			// пока соседей просто нету.
			oc->link2->linkW = nullptr;
			oc->link2->linkE = nullptr;
			oc->link2->linkS = nullptr;
			oc->link2->linkN = nullptr;
			oc->link2->linkB = nullptr;
			oc->link2->linkT = nullptr;
			oc->link2->b4W = false;
			oc->link2->b4E = false;
			oc->link2->b4S = false;
			oc->link2->b4N = false;
			oc->link2->b4B = false;
			oc->link2->b4T = false;
			oc->link2->linkW0 = nullptr;
			oc->link2->linkW3 = nullptr;
			oc->link2->linkW4 = nullptr;
			oc->link2->linkW7 = nullptr;
			oc->link2->linkE1 = nullptr;
			oc->link2->linkE2 = nullptr;
			oc->link2->linkE5 = nullptr;
			oc->link2->linkE6 = nullptr;
			oc->link2->linkS0 = nullptr;
			oc->link2->linkS1 = nullptr;
			oc->link2->linkS4 = nullptr;
			oc->link2->linkS5 = nullptr;
			oc->link2->linkN2 = nullptr;
			oc->link2->linkN3 = nullptr;
			oc->link2->linkN6 = nullptr;
			oc->link2->linkN7 = nullptr;
			oc->link2->linkB0 = nullptr;
			oc->link2->linkB1 = nullptr;
			oc->link2->linkB2 = nullptr;
			oc->link2->linkB3 = nullptr;
			oc->link2->linkT4 = nullptr;
			oc->link2->linkT5 = nullptr;
			oc->link2->linkT6 = nullptr;
			oc->link2->linkT7 = nullptr;
			oc->link2->dlist = true;
			oc->link2->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link2->bcrushing_when_balancing = true;
			}
			else {
				oc->link2->bcrushing_when_balancing = false;
			}
			oc->link2->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxEneighbour = MAX_NEIGHBOUR_COUNT;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link2;
			top_ALICE_STACK++;
		}
		else {
			oc->link2 = nullptr;
		}
		int minx3 = minx;
		int maxx3 = avgx;
		int miny3 = avgy;
		int maxy3 = maxy;
		int minz3 = minz;
		int maxz3 = avgz;
		doublereal rminx3 = xpos[minx];
		doublereal rmaxx3 = xpos[avgx];
		doublereal rminy3 = ypos[avgy];
		doublereal rmaxy3 = ypos[maxy];
		doublereal rminz3 = zpos[minz];
		doublereal rmaxz3 = zpos[avgz];

		if (rminx3 < b[0].g.xS) {
			printf("ERROR Cabinet out rminx3. %e %d\n", rminx3, minx);
			system("PAUSE");
		}
		if (rminy3 < b[0].g.yS) {
			printf("ERROR Cabinet out rminy3. %e %d\n", rminy3, avgy);
			system("PAUSE");
		}
		if (rminz3 < b[0].g.zS) {
			printf("ERROR Cabinet out rminz3. %e %d\n", rminz3, minz);
			system("PAUSE");
		}


		if (rmaxx3 > b[0].g.xE) {
			printf("ERROR Cabinet out rmaxx3. %e %d\n", rmaxx3, avgx);
			system("PAUSE");
		}

		if (rmaxy3 > b[0].g.yE) {
			printf("ERROR Cabinet out rmaxy3. %e %d\n", rmaxy3, maxy);
			system("PAUSE");
		}

		if (rmaxz3 > b[0].g.zE) {
			printf("ERROR Cabinet out rmaxz3. %e %d\n", rmaxz3, avgz);
			system("PAUSE");
		}

		if (b3) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link3,
			//	minx3, maxx3, miny3, maxy3, minz3, maxz3, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx3;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx3;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny3;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy3;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz3;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz3;


			if (oc->link3 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link3!=nullptr.\n");
				system("PAUSE");
			}
			oc->link3 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link3;


			oc->link3->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link3->inum_FD = 0;// Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link3 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link3 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link3->parent = oc;
			oc->link3->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link3->brootSituationX = bSituationX;
				oc->link3->brootSituationY = bSituationY;
				oc->link3->brootSituationZ = bSituationZ;

				oc->link3->brootSituationX_virtual = bSituationX;
				oc->link3->brootSituationY_virtual = bSituationY;
				oc->link3->brootSituationZ_virtual = bSituationZ;

			}
			else {

				oc->link3->brootSituationX = bSituationX;
				oc->link3->brootSituationY = bSituationY;
				oc->link3->brootSituationZ = bSituationZ;

				oc->link3->brootSituationX_virtual = bSituationX_prefix;
				oc->link3->brootSituationY_virtual = bSituationY_prefix;
				oc->link3->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link3->root = 3;
			oc->link3->minx = minx3;
			oc->link3->maxx = maxx3;
			oc->link3->miny = miny3;
			oc->link3->maxy = maxy3;
			oc->link3->minz = minz3;
			oc->link3->maxz = maxz3;
			oc->link3->p0.x = rminx3;
			oc->link3->p0.y = rminy3;
			oc->link3->p0.z = rminz3;
			oc->link3->p1.x = rmaxx3;
			oc->link3->p1.y = rminy3;
			oc->link3->p1.z = rminz3;
			oc->link3->p2.x = rminx3;
			oc->link3->p2.y = rmaxy3;
			oc->link3->p2.z = rminz3;
			oc->link3->p3.x = rmaxx3;
			oc->link3->p3.y = rmaxy3;
			oc->link3->p3.z = rminz3;
			oc->link3->p4.x = rminx3;
			oc->link3->p4.y = rminy3;
			oc->link3->p4.z = rmaxz3;
			oc->link3->p5.x = rmaxx3;
			oc->link3->p5.y = rminy3;
			oc->link3->p5.z = rmaxz3;
			oc->link3->p6.x = rminx3;
			oc->link3->p6.y = rmaxy3;
			oc->link3->p6.z = rmaxz3;
			oc->link3->p7.x = rmaxx3;
			oc->link3->p7.y = rmaxy3;
			oc->link3->p7.z = rmaxz3;
			oc->link3->link0 = nullptr;
			oc->link3->link1 = nullptr;
			oc->link3->link2 = nullptr;
			oc->link3->link3 = nullptr;
			oc->link3->link4 = nullptr;
			oc->link3->link5 = nullptr;
			oc->link3->link6 = nullptr;
			oc->link3->link7 = nullptr;
			// пока соседей просто нету.
			oc->link3->linkW = nullptr;
			oc->link3->linkE = nullptr;
			oc->link3->linkS = nullptr;
			oc->link3->linkN = nullptr;
			oc->link3->linkB = nullptr;
			oc->link3->linkT = nullptr;
			oc->link3->b4W = false;
			oc->link3->b4E = false;
			oc->link3->b4S = false;
			oc->link3->b4N = false;
			oc->link3->b4B = false;
			oc->link3->b4T = false;
			oc->link3->linkW0 = nullptr;
			oc->link3->linkW3 = nullptr;
			oc->link3->linkW4 = nullptr;
			oc->link3->linkW7 = nullptr;
			oc->link3->linkE1 = nullptr;
			oc->link3->linkE2 = nullptr;
			oc->link3->linkE5 = nullptr;
			oc->link3->linkE6 = nullptr;
			oc->link3->linkS0 = nullptr;
			oc->link3->linkS1 = nullptr;
			oc->link3->linkS4 = nullptr;
			oc->link3->linkS5 = nullptr;
			oc->link3->linkN2 = nullptr;
			oc->link3->linkN3 = nullptr;
			oc->link3->linkN6 = nullptr;
			oc->link3->linkN7 = nullptr;
			oc->link3->linkB0 = nullptr;
			oc->link3->linkB1 = nullptr;
			oc->link3->linkB2 = nullptr;
			oc->link3->linkB3 = nullptr;
			oc->link3->linkT4 = nullptr;
			oc->link3->linkT5 = nullptr;
			oc->link3->linkT6 = nullptr;
			oc->link3->linkT7 = nullptr;
			oc->link3->dlist = true;
			oc->link3->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link3->bcrushing_when_balancing = true;
			}
			else {
				oc->link3->bcrushing_when_balancing = false;
			}
			oc->link3->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxEneighbour = MAX_NEIGHBOUR_COUNT;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link3;
			top_ALICE_STACK++;
		}
		else {
			oc->link3 = nullptr;
		}

		int minx4 = minx;
		int maxx4 = avgx;
		int miny4 = miny;
		int maxy4 = avgy;
		int minz4 = avgz;
		int maxz4 = maxz;
		doublereal rminx4 = xpos[minx];
		doublereal rmaxx4 = xpos[avgx];
		doublereal rminy4 = ypos[miny];
		doublereal rmaxy4 = ypos[avgy];
		doublereal rminz4 = zpos[avgz];
		doublereal rmaxz4 = zpos[maxz];
		if (b4) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link4,
			//	minx4, maxx4, miny4, maxy4, minz4, maxz4, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx4;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx4;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny4;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy4;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz4;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz4;

			if (oc->link4 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link4!=nullptr.\n");
				system("PAUSE");
			}

			oc->link4 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link4;

			oc->link4->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link4->inum_FD = 0;// Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link4 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link4 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link4->parent = oc;
			oc->link4->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link4->brootSituationX = bSituationX;
				oc->link4->brootSituationY = bSituationY;
				oc->link4->brootSituationZ = bSituationZ;

				oc->link4->brootSituationX_virtual = bSituationX;
				oc->link4->brootSituationY_virtual = bSituationY;
				oc->link4->brootSituationZ_virtual = bSituationZ;

			}
			else {

				oc->link4->brootSituationX = bSituationX;
				oc->link4->brootSituationY = bSituationY;
				oc->link4->brootSituationZ = bSituationZ;

				oc->link4->brootSituationX_virtual = bSituationX_prefix;
				oc->link4->brootSituationY_virtual = bSituationY_prefix;
				oc->link4->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link4->root = 4;
			oc->link4->minx = minx4;
			oc->link4->maxx = maxx4;
			oc->link4->miny = miny4;
			oc->link4->maxy = maxy4;
			oc->link4->minz = minz4;
			oc->link4->maxz = maxz4;
			oc->link4->p0.x = rminx4;
			oc->link4->p0.y = rminy4;
			oc->link4->p0.z = rminz4;
			oc->link4->p1.x = rmaxx4;
			oc->link4->p1.y = rminy4;
			oc->link4->p1.z = rminz4;
			oc->link4->p2.x = rminx4;
			oc->link4->p2.y = rmaxy4;
			oc->link4->p2.z = rminz4;
			oc->link4->p3.x = rmaxx4;
			oc->link4->p3.y = rmaxy4;
			oc->link4->p3.z = rminz4;
			oc->link4->p4.x = rminx4;
			oc->link4->p4.y = rminy4;
			oc->link4->p4.z = rmaxz4;
			oc->link4->p5.x = rmaxx4;
			oc->link4->p5.y = rminy4;
			oc->link4->p5.z = rmaxz4;
			oc->link4->p6.x = rminx4;
			oc->link4->p6.y = rmaxy4;
			oc->link4->p6.z = rmaxz4;
			oc->link4->p7.x = rmaxx4;
			oc->link4->p7.y = rmaxy4;
			oc->link4->p7.z = rmaxz4;
			oc->link4->link0 = nullptr;
			oc->link4->link1 = nullptr;
			oc->link4->link2 = nullptr;
			oc->link4->link3 = nullptr;
			oc->link4->link4 = nullptr;
			oc->link4->link5 = nullptr;
			oc->link4->link6 = nullptr;
			oc->link4->link7 = nullptr;
			// пока соседей просто нету.
			oc->link4->linkW = nullptr;
			oc->link4->linkE = nullptr;
			oc->link4->linkS = nullptr;
			oc->link4->linkN = nullptr;
			oc->link4->linkB = nullptr;
			oc->link4->linkT = nullptr;
			oc->link4->b4W = false;
			oc->link4->b4E = false;
			oc->link4->b4S = false;
			oc->link4->b4N = false;
			oc->link4->b4B = false;
			oc->link4->b4T = false;
			oc->link4->linkW0 = nullptr;
			oc->link4->linkW3 = nullptr;
			oc->link4->linkW4 = nullptr;
			oc->link4->linkW7 = nullptr;
			oc->link4->linkE1 = nullptr;
			oc->link4->linkE2 = nullptr;
			oc->link4->linkE5 = nullptr;
			oc->link4->linkE6 = nullptr;
			oc->link4->linkS0 = nullptr;
			oc->link4->linkS1 = nullptr;
			oc->link4->linkS4 = nullptr;
			oc->link4->linkS5 = nullptr;
			oc->link4->linkN2 = nullptr;
			oc->link4->linkN3 = nullptr;
			oc->link4->linkN6 = nullptr;
			oc->link4->linkN7 = nullptr;
			oc->link4->linkB0 = nullptr;
			oc->link4->linkB1 = nullptr;
			oc->link4->linkB2 = nullptr;
			oc->link4->linkB3 = nullptr;
			oc->link4->linkT4 = nullptr;
			oc->link4->linkT5 = nullptr;
			oc->link4->linkT6 = nullptr;
			oc->link4->linkT7 = nullptr;
			oc->link4->dlist = true;
			oc->link4->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link4->bcrushing_when_balancing = true;
			}
			else {
				oc->link4->bcrushing_when_balancing = false;
			}
			oc->link4->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxEneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxBneighbour = 1;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link4;
			top_ALICE_STACK++;
		}
		else {
			oc->link4 = nullptr;
		}
		int minx5 = avgx;
		int maxx5 = maxx;
		int miny5 = miny;
		int maxy5 = avgy;
		int minz5 = avgz;
		int maxz5 = maxz;
		doublereal rminx5 = xpos[avgx];
		doublereal rmaxx5 = xpos[maxx];
		doublereal rminy5 = ypos[miny];
		doublereal rmaxy5 = ypos[avgy];
		doublereal rminz5 = zpos[avgz];
		doublereal rmaxz5 = zpos[maxz];
		if (b5) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link5,
			//minx5, maxx5, miny5, maxy5, minz5, maxz5, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx5;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx5;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny5;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy5;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz5;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz5;


			if (oc->link5 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link5!=nullptr.\n");
				system("PAUSE");
			}
			oc->link5 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link5;


			oc->link5->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link5->inum_FD = 0;// Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link5 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link5 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link5->parent = oc;
			oc->link5->ilevel = oc->ilevel + 1;
			
			if (bold_stable_version1) {
				oc->link5->brootSituationX = bSituationX;
				oc->link5->brootSituationY = bSituationY;
				oc->link5->brootSituationZ = bSituationZ;

				oc->link5->brootSituationX_virtual = bSituationX;
				oc->link5->brootSituationY_virtual = bSituationY;
				oc->link5->brootSituationZ_virtual = bSituationZ;

			}
			else {

				oc->link5->brootSituationX = bSituationX;
				oc->link5->brootSituationY = bSituationY;
				oc->link5->brootSituationZ = bSituationZ;

				oc->link5->brootSituationX_virtual = bSituationX_prefix;
				oc->link5->brootSituationY_virtual = bSituationY_prefix;
				oc->link5->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link5->root = 5;
			oc->link5->minx = minx5;
			oc->link5->maxx = maxx5;
			oc->link5->miny = miny5;
			oc->link5->maxy = maxy5;
			oc->link5->minz = minz5;
			oc->link5->maxz = maxz5;
			oc->link5->p0.x = rminx5;
			oc->link5->p0.y = rminy5;
			oc->link5->p0.z = rminz5;
			oc->link5->p1.x = rmaxx5;
			oc->link5->p1.y = rminy5;
			oc->link5->p1.z = rminz5;
			oc->link5->p2.x = rminx5;
			oc->link5->p2.y = rmaxy5;
			oc->link5->p2.z = rminz5;
			oc->link5->p3.x = rmaxx5;
			oc->link5->p3.y = rmaxy5;
			oc->link5->p3.z = rminz5;
			oc->link5->p4.x = rminx5;
			oc->link5->p4.y = rminy5;
			oc->link5->p4.z = rmaxz5;
			oc->link5->p5.x = rmaxx5;
			oc->link5->p5.y = rminy5;
			oc->link5->p5.z = rmaxz5;
			oc->link5->p6.x = rminx5;
			oc->link5->p6.y = rmaxy5;
			oc->link5->p6.z = rmaxz5;
			oc->link5->p7.x = rmaxx5;
			oc->link5->p7.y = rmaxy5;
			oc->link5->p7.z = rmaxz5;
			oc->link5->link0 = nullptr;
			oc->link5->link1 = nullptr;
			oc->link5->link2 = nullptr;
			oc->link5->link3 = nullptr;
			oc->link5->link4 = nullptr;
			oc->link5->link5 = nullptr;
			oc->link5->link6 = nullptr;
			oc->link5->link7 = nullptr;
			// пока соседей просто нету.
			oc->link5->linkW = nullptr;
			oc->link5->linkE = nullptr;
			oc->link5->linkS = nullptr;
			oc->link5->linkN = nullptr;
			oc->link5->linkB = nullptr;
			oc->link5->linkT = nullptr;
			oc->link5->b4W = false;
			oc->link5->b4E = false;
			oc->link5->b4S = false;
			oc->link5->b4N = false;
			oc->link5->b4B = false;
			oc->link5->b4T = false;
			oc->link5->linkW0 = nullptr;
			oc->link5->linkW3 = nullptr;
			oc->link5->linkW4 = nullptr;
			oc->link5->linkW7 = nullptr;
			oc->link5->linkE1 = nullptr;
			oc->link5->linkE2 = nullptr;
			oc->link5->linkE5 = nullptr;
			oc->link5->linkE6 = nullptr;
			oc->link5->linkS0 = nullptr;
			oc->link5->linkS1 = nullptr;
			oc->link5->linkS4 = nullptr;
			oc->link5->linkS5 = nullptr;
			oc->link5->linkN2 = nullptr;
			oc->link5->linkN3 = nullptr;
			oc->link5->linkN6 = nullptr;
			oc->link5->linkN7 = nullptr;
			oc->link5->linkB0 = nullptr;
			oc->link5->linkB1 = nullptr;
			oc->link5->linkB2 = nullptr;
			oc->link5->linkB3 = nullptr;
			oc->link5->linkT4 = nullptr;
			oc->link5->linkT5 = nullptr;
			oc->link5->linkT6 = nullptr;
			oc->link5->linkT7 = nullptr;
			oc->link5->dlist = true;
			oc->link5->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link5->bcrushing_when_balancing = true;
			}
			else {
				oc->link5->bcrushing_when_balancing = false;
			}
			oc->link5->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			my_ALICE_STACK[top_ALICE_STACK].link = oc->link5;
			top_ALICE_STACK++;
		}
		else {
			oc->link5 = nullptr;
		}
		int minx6 = avgx;
		int maxx6 = maxx;
		int miny6 = avgy;
		int maxy6 = maxy;
		int minz6 = avgz;
		int maxz6 = maxz;
		doublereal rminx6 = xpos[avgx];
		doublereal rmaxx6 = xpos[maxx];
		doublereal rminy6 = ypos[avgy];
		doublereal rmaxy6 = ypos[maxy];
		doublereal rminz6 = zpos[avgz];
		doublereal rmaxz6 = zpos[maxz];
		if (b6) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link6,
			//minx6, maxx6, miny6, maxy6, minz6, maxz6, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx6;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx6;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny6;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy6;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz6;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz6;


			if (oc->link6 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link6!=nullptr.\n");
				system("PAUSE");
			}
			oc->link6 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link6;

			oc->link6->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link6->inum_FD = 0;// Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link6 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link6 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link6->parent = oc;
			oc->link6->ilevel = oc->ilevel + 1;

			if (bold_stable_version1) {
				oc->link6->brootSituationX = bSituationX;
				oc->link6->brootSituationY = bSituationY;
				oc->link6->brootSituationZ = bSituationZ;

				oc->link6->brootSituationX_virtual = bSituationX;
				oc->link6->brootSituationY_virtual = bSituationY;
				oc->link6->brootSituationZ_virtual = bSituationZ;
			}
			else {

				oc->link6->brootSituationX = bSituationX;
				oc->link6->brootSituationY = bSituationY;
				oc->link6->brootSituationZ = bSituationZ;

				oc->link6->brootSituationX_virtual = bSituationX_prefix;
				oc->link6->brootSituationY_virtual = bSituationY_prefix;
				oc->link6->brootSituationZ_virtual = bSituationZ_prefix;
			}

			oc->link6->root = 6;
			oc->link6->minx = minx6;
			oc->link6->maxx = maxx6;
			oc->link6->miny = miny6;
			oc->link6->maxy = maxy6;
			oc->link6->minz = minz6;
			oc->link6->maxz = maxz6;
			oc->link6->p0.x = rminx6;
			oc->link6->p0.y = rminy6;
			oc->link6->p0.z = rminz6;
			oc->link6->p1.x = rmaxx6;
			oc->link6->p1.y = rminy6;
			oc->link6->p1.z = rminz6;
			oc->link6->p2.x = rminx6;
			oc->link6->p2.y = rmaxy6;
			oc->link6->p2.z = rminz6;
			oc->link6->p3.x = rmaxx6;
			oc->link6->p3.y = rmaxy6;
			oc->link6->p3.z = rminz6;
			oc->link6->p4.x = rminx6;
			oc->link6->p4.y = rminy6;
			oc->link6->p4.z = rmaxz6;
			oc->link6->p5.x = rmaxx6;
			oc->link6->p5.y = rminy6;
			oc->link6->p5.z = rmaxz6;
			oc->link6->p6.x = rminx6;
			oc->link6->p6.y = rmaxy6;
			oc->link6->p6.z = rmaxz6;
			oc->link6->p7.x = rmaxx6;
			oc->link6->p7.y = rmaxy6;
			oc->link6->p7.z = rmaxz6;
			oc->link6->link0 = nullptr;
			oc->link6->link1 = nullptr;
			oc->link6->link2 = nullptr;
			oc->link6->link3 = nullptr;
			oc->link6->link4 = nullptr;
			oc->link6->link5 = nullptr;
			oc->link6->link6 = nullptr;
			oc->link6->link7 = nullptr;
			// пока соседей просто нету.
			oc->link6->linkW = nullptr;
			oc->link6->linkE = nullptr;
			oc->link6->linkS = nullptr;
			oc->link6->linkN = nullptr;
			oc->link6->linkB = nullptr;
			oc->link6->linkT = nullptr;
			oc->link6->b4W = false;
			oc->link6->b4E = false;
			oc->link6->b4S = false;
			oc->link6->b4N = false;
			oc->link6->b4B = false;
			oc->link6->b4T = false;
			oc->link6->linkW0 = nullptr;
			oc->link6->linkW3 = nullptr;
			oc->link6->linkW4 = nullptr;
			oc->link6->linkW7 = nullptr;
			oc->link6->linkE1 = nullptr;
			oc->link6->linkE2 = nullptr;
			oc->link6->linkE5 = nullptr;
			oc->link6->linkE6 = nullptr;
			oc->link6->linkS0 = nullptr;
			oc->link6->linkS1 = nullptr;
			oc->link6->linkS4 = nullptr;
			oc->link6->linkS5 = nullptr;
			oc->link6->linkN2 = nullptr;
			oc->link6->linkN3 = nullptr;
			oc->link6->linkN6 = nullptr;
			oc->link6->linkN7 = nullptr;
			oc->link6->linkB0 = nullptr;
			oc->link6->linkB1 = nullptr;
			oc->link6->linkB2 = nullptr;
			oc->link6->linkB3 = nullptr;
			oc->link6->linkT4 = nullptr;
			oc->link6->linkT5 = nullptr;
			oc->link6->linkT6 = nullptr;
			oc->link6->linkT7 = nullptr;
			oc->link6->dlist = true;
			oc->link6->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link6->bcrushing_when_balancing = true;
			}
			else {
				oc->link6->bcrushing_when_balancing = false;
			}
			oc->link6->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxEneighbour = MAX_NEIGHBOUR_COUNT;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link6;
			top_ALICE_STACK++;
		}
		else {
			oc->link6 = nullptr;
		}
		int minx7 = minx;
		int maxx7 = avgx;
		int miny7 = avgy;
		int maxy7 = maxy;
		int minz7 = avgz;
		int maxz7 = maxz;
		doublereal rminx7 = xpos[minx];
		doublereal rmaxx7 = xpos[avgx];
		doublereal rminy7 = ypos[avgy];
		doublereal rmaxy7 = ypos[maxy];
		doublereal rminz7 = zpos[avgz];
		doublereal rmaxz7 = zpos[maxz];
		if (b7) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link7,
			//minx7, maxx7, miny7, maxy7, minz7, maxz7, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx7;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx7;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny7;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy7;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz7;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz7;

			if (oc->link7 != nullptr) {
				printf("ERROR droblenie_internal in adaptive_local_refinement_mesh oc->link7!=nullptr.\n");
				system("PAUSE");
			}
			oc->link7 = new octree;
			// Ссылки на каждый узел octree дерева для его полной очистки.
			rootClear_octree->next = new octree_list;
			rootClear_octree = rootClear_octree->next;
			rootClear_octree->next = nullptr;
			rootClear_octree->pnode = oc->link7;

			oc->link7->inum_TD = 0; // Не принадлежит расчётной области.
			oc->link7->inum_FD = 0; // Не принадлежит расчётной области.
			// После применения оператора new не требуется делать проверку на null.
			//if (oc->link7 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				//printf("Problem: not enough memory on your equipment for oc->link7 in adaptive_local_refinement_mesh generator...\n");
				//printf("Please any key to exit...\n");
				//exit(1);
			//}
			oc->link7->parent = oc;
			oc->link7->ilevel = oc->ilevel + 1;
			

			if (bold_stable_version1) {
				oc->link7->brootSituationX = bSituationX;
				oc->link7->brootSituationY = bSituationY;
				oc->link7->brootSituationZ = bSituationZ;

				oc->link7->brootSituationX_virtual = bSituationX;
				oc->link7->brootSituationY_virtual = bSituationY;
				oc->link7->brootSituationZ_virtual = bSituationZ;
			}
			else {
				oc->link7->brootSituationX = bSituationX;
				oc->link7->brootSituationY = bSituationY;
				oc->link7->brootSituationZ = bSituationZ;

				oc->link7->brootSituationX_virtual = bSituationX_prefix;
				oc->link7->brootSituationY_virtual = bSituationY_prefix;
				oc->link7->brootSituationZ_virtual = bSituationZ_prefix;
			}


			oc->link7->root = 7;
			oc->link7->minx = minx7;
			oc->link7->maxx = maxx7;
			oc->link7->miny = miny7;
			oc->link7->maxy = maxy7;
			oc->link7->minz = minz7;
			oc->link7->maxz = maxz7;

			oc->link7->p0.x = rminx7;
			oc->link7->p0.y = rminy7;
			oc->link7->p0.z = rminz7;
			oc->link7->p1.x = rmaxx7;
			oc->link7->p1.y = rminy7;
			oc->link7->p1.z = rminz7;
			oc->link7->p2.x = rminx7;
			oc->link7->p2.y = rmaxy7;
			oc->link7->p2.z = rminz7;
			oc->link7->p3.x = rmaxx7;
			oc->link7->p3.y = rmaxy7;
			oc->link7->p3.z = rminz7;

			oc->link7->p4.x = rminx7;
			oc->link7->p4.y = rminy7;
			oc->link7->p4.z = rmaxz7;
			oc->link7->p5.x = rmaxx7;
			oc->link7->p5.y = rminy7;
			oc->link7->p5.z = rmaxz7;
			oc->link7->p6.x = rminx7;
			oc->link7->p6.y = rmaxy7;
			oc->link7->p6.z = rmaxz7;
			oc->link7->p7.x = rmaxx7;
			oc->link7->p7.y = rmaxy7;
			oc->link7->p7.z = rmaxz7;
			oc->link7->link0 = nullptr;
			oc->link7->link1 = nullptr;
			oc->link7->link2 = nullptr;
			oc->link7->link3 = nullptr;
			oc->link7->link4 = nullptr;
			oc->link7->link5 = nullptr;
			oc->link7->link6 = nullptr;
			oc->link7->link7 = nullptr;
			// пока соседей просто нету.
			oc->link7->linkW = nullptr;
			oc->link7->linkE = nullptr;
			oc->link7->linkS = nullptr;
			oc->link7->linkN = nullptr;
			oc->link7->linkB = nullptr;
			oc->link7->linkT = nullptr;
			oc->link7->b4W = false;
			oc->link7->b4E = false;
			oc->link7->b4S = false;
			oc->link7->b4N = false;
			oc->link7->b4B = false;
			oc->link7->b4T = false;
			oc->link7->linkW0 = nullptr;
			oc->link7->linkW3 = nullptr;
			oc->link7->linkW4 = nullptr;
			oc->link7->linkW7 = nullptr;
			oc->link7->linkE1 = nullptr;
			oc->link7->linkE2 = nullptr;
			oc->link7->linkE5 = nullptr;
			oc->link7->linkE6 = nullptr;
			oc->link7->linkS0 = nullptr;
			oc->link7->linkS1 = nullptr;
			oc->link7->linkS4 = nullptr;
			oc->link7->linkS5 = nullptr;
			oc->link7->linkN2 = nullptr;
			oc->link7->linkN3 = nullptr;
			oc->link7->linkN6 = nullptr;
			oc->link7->linkN7 = nullptr;
			oc->link7->linkB0 = nullptr;
			oc->link7->linkB1 = nullptr;
			oc->link7->linkB2 = nullptr;
			oc->link7->linkB3 = nullptr;
			oc->link7->linkT4 = nullptr;
			oc->link7->linkT5 = nullptr;
			oc->link7->linkT6 = nullptr;
			oc->link7->linkT7 = nullptr;
			oc->link7->dlist = true;
			oc->link7->b_the_geometric_fragmentation = true;
			if (dodroblenie) {
				oc->link7->bcrushing_when_balancing = true;
			}
			else {
				oc->link7->bcrushing_when_balancing = false;
			}
			oc->link7->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxEneighbour = MAX_NEIGHBOUR_COUNT;


			my_ALICE_STACK[top_ALICE_STACK].link = oc->link7;
			top_ALICE_STACK++;
		}
		else {
			oc->link7 = nullptr;
		}

		if (DEBUG_ALICE_MESH) {
			if (oc->b4N) {
				printf("Ok b4N vstretilsq pri droblenii.");
				//system("PAUSE");
				system("PAUSE");
			}
		}

		// Здесь  предусмотрен случай четырёх соседей по face грани ячейки.
		if (oc->link0 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link0->linkT = oc->linkT4;
				}
				else {
					oc->link0->linkT = oc->linkT;
				}
			}
			else {
				oc->link0->linkT = oc->link4;
			}
			// Y 0,1,4,5
			if (bSituationY) {
				if (oc->b4N) {
					oc->link0->linkN = oc->linkN3;
				}
				else {
					oc->link0->linkN = oc->linkN;
				}
			}
			else {
				oc->link0->linkN = oc->link3;
			}
			// X 0,3,4,7
			if (bSituationX) {
				if (oc->b4E) {
					oc->link0->linkE = oc->linkE1;
				}
				else {
					oc->link0->linkE = oc->linkE;
				}
			}
			else {
				oc->link0->linkE = oc->link1;
			}

			if (oc->b4B) {
				oc->link0->linkB = oc->linkB0;
			}
			else {
				oc->link0->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link0->linkW = oc->linkW0;
			}
			else {
				oc->link0->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link0->linkS = oc->linkS0;
			}
			else {
				oc->link0->linkS = oc->linkS;
			}
		}
		if (oc->link1 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link1->linkT = oc->linkT5;
				}
				else {
					oc->link1->linkT = oc->linkT;
				}
			}
			else {
				oc->link1->linkT = oc->link5;
			}
			if (bSituationY) {
				if (oc->b4N) {
					oc->link1->linkN = oc->linkN2;
				}
				else {
					oc->link1->linkN = oc->linkN;
				}
			}
			else {
				oc->link1->linkN = oc->link2;
			}
			oc->link1->linkW = oc->link0;

			if (oc->b4B) {
				oc->link1->linkB = oc->linkB1;
			}
			else {
				oc->link1->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link1->linkE = oc->linkE1;
			}
			else {
				oc->link1->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link1->linkS = oc->linkS1;
			}
			else {
				oc->link1->linkS = oc->linkS;
			}
		}
		if (oc->link2 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link2->linkT = oc->linkT6;
				}
				else {
					oc->link2->linkT = oc->linkT;
				}
			}
			else {
				oc->link2->linkT = oc->link6;
			}
			oc->link2->linkS = oc->link1;
			oc->link2->linkW = oc->link3;
			if (oc->b4B) {
				oc->link2->linkB = oc->linkB2;
			}
			else {
				oc->link2->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link2->linkE = oc->linkE2;
			}
			else {
				oc->link2->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link2->linkN = oc->linkN2;
			}
			else {
				oc->link2->linkN = oc->linkN;
			}
		}
		if (oc->link3 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link3->linkT = oc->linkT7;
				}
				else {
					oc->link3->linkT = oc->linkT;
				}
			}
			else {
				oc->link3->linkT = oc->link7;
			}
			oc->link3->linkS = oc->link0;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link3->linkE = oc->linkE2;
				}
				else {
					oc->link3->linkE = oc->linkE;
				}
			}
			else {
				oc->link3->linkE = oc->link2;
			}

			if (oc->b4B) {
				oc->link3->linkB = oc->linkB3;
			}
			else {
				oc->link3->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link3->linkW = oc->linkW3;
			}
			else {
				oc->link3->linkW = oc->linkW;
			}
			if (oc->b4N) {
				oc->link3->linkN = oc->linkN3;
			}
			else {
				oc->link3->linkN = oc->linkN;
			}
		}
		if (oc->link4 != nullptr) {
			oc->link4->linkB = oc->link0;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link4->linkN = oc->linkN7;
				}
				else {
					oc->link4->linkN = oc->linkN;
				}
			}
			else {
				oc->link4->linkN = oc->link7;
			}
			if (bSituationX) {
				if (oc->b4E) {
					oc->link4->linkE = oc->linkE5;
				}
				else {
					oc->link4->linkE = oc->linkE;
				}
			}
			else {
				oc->link4->linkE = oc->link5;
			}

			if (oc->b4T) {
				oc->link4->linkT = oc->linkT4;
			}
			else {
				oc->link4->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link4->linkW = oc->linkW4;
			}
			else {
				oc->link4->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link4->linkS = oc->linkS4;
			}
			else {
				oc->link4->linkS = oc->linkS;
			}
		}
		if (oc->link5 != nullptr) {
			oc->link5->linkB = oc->link1;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link5->linkN = oc->linkN6;
				}
				else {
					oc->link5->linkN = oc->linkN;
				}
			}
			else {
				oc->link5->linkN = oc->link6;
			}
			oc->link5->linkW = oc->link4;
			if (oc->b4T) {
				oc->link5->linkT = oc->linkT5;
			}
			else {
				oc->link5->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link5->linkE = oc->linkE5;
			}
			else {
				oc->link5->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link5->linkS = oc->linkS5;
			}
			else {
				oc->link5->linkS = oc->linkS;
			}
		}
		if (oc->link6 != nullptr) {
			oc->link6->linkB = oc->link2;
			oc->link6->linkS = oc->link5;
			oc->link6->linkW = oc->link7;
			if (oc->b4T) {
				oc->link6->linkT = oc->linkT6;
			}
			else {
				oc->link6->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link6->linkE = oc->linkE6;
			}
			else {
				oc->link6->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link6->linkN = oc->linkN6;
			}
			else {
				oc->link6->linkN = oc->linkN;
			}
		}
		if (oc->link7 != nullptr) {
			oc->link7->linkB = oc->link3;
			oc->link7->linkS = oc->link4;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link7->linkE = oc->linkE6;
				}
				else {
					oc->link7->linkE = oc->linkE;
				}
			}
			else {
				oc->link7->linkE = oc->link6;
			}

			if (oc->b4T) {
				oc->link7->linkT = oc->linkT7;
			}
			else {
				oc->link7->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link7->linkW = oc->linkW7;
			}
			else {
				oc->link7->linkW = oc->linkW;
			}			
			if (oc->b4N) {
				oc->link7->linkN = oc->linkN7;
			}
			else {
				oc->link7->linkN = oc->linkN;
			}
		}
		/*
		if (bSituationZ) {
		// Вырождение по Z
		if (oc->linkB != nullptr) {
		if (is_null(oc->linkB)) {
		//oc->linkB->maxTneighbour += 4 - 1;
		patch_neighbour_count2(oc->linkB->maxTneighbour);
		}
		if (is_null1(oc->linkB)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkB->link4->maxTneighbour = 1; //
		oc->linkB->link5->maxTneighbour = 1;
		oc->linkB->link6->maxTneighbour = 1;
		oc->linkB->link7->maxTneighbour = 1;
		}
		}
		if (oc->linkT != nullptr) {
		if (is_null(oc->linkT)) {
		//oc->linkT->maxBneighbour += 4 - 1;
		patch_neighbour_count2(oc->linkT->maxBneighbour);
		}
		if (is_null1(oc->linkT)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkT->link0->maxBneighbour = 1; //
		oc->linkT->link1->maxBneighbour = 1;
		oc->linkT->link2->maxBneighbour = 1;
		oc->linkT->link3->maxBneighbour = 1;
		}
		}
		}
		else {
		// Полноценное деление на 8 частей.
		if (b0|| b1 || b2 || b3) {
		if (oc->linkB != nullptr) {
		if (is_null(oc->linkB)) {
		//oc->linkB->maxTneighbour += 4 - 1;
		patch_neighbour_count(oc->linkB->maxTneighbour, oc->linkB,T);
		}
		if (is_null1(oc->linkB)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkB->link4->maxTneighbour = 1; //
		oc->linkB->link5->maxTneighbour = 1;
		oc->linkB->link6->maxTneighbour = 1;
		oc->linkB->link7->maxTneighbour = 1;
		}
		}
		}
		if (b4 || b5 || b6 || b7) {
		if (oc->linkT != nullptr) {
		if (is_null(oc->linkT)) {
		//oc->linkT->maxBneighbour += 4 - 1;
		patch_neighbour_count(oc->linkT->maxBneighbour, oc->linkT,B);
		}
		if (is_null1(oc->linkT)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkT->link0->maxBneighbour = 1; //
		oc->linkT->link1->maxBneighbour = 1;
		oc->linkT->link2->maxBneighbour = 1;
		oc->linkT->link3->maxBneighbour = 1;
		}
		}
		}
		}


		if (bSituationY) {
		if (oc->linkN != nullptr) {
		if (is_null(oc->linkN)) {
		//oc->linkN->maxSneighbour += 4 - 1;
		patch_neighbour_count2(oc->linkN->maxSneighbour);
		}
		else if (is_null1(oc->linkN)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkN->link0->maxSneighbour = 1; //
		oc->linkN->link1->maxSneighbour = 1;
		oc->linkN->link4->maxSneighbour = 1;
		oc->linkN->link5->maxSneighbour = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkN, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkN != nullptr) {
		if (oc->linkN->link0 != nullptr) {
		oc->linkN->link0->maxSneighbour = 1; //
		}
		if (oc->linkN->link1 != nullptr) {
		oc->linkN->link1->maxSneighbour = 1;
		}
		if (oc->linkN->link4 != nullptr) {
		oc->linkN->link4->maxSneighbour = 1;
		}
		if (oc->linkN->link5 != nullptr) {
		oc->linkN->link5->maxSneighbour = 1;
		}
		}
		}
		}
		if (oc->linkS != nullptr) {
		if (is_null(oc->linkS)) {
		//oc->linkS->maxNneighbour += 4 - 1;
		patch_neighbour_count2(oc->linkS->maxNneighbour);
		}
		else if (is_null1(oc->linkS)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkS->link2->maxNneighbour = 1; //
		oc->linkS->link3->maxNneighbour = 1;
		oc->linkS->link6->maxNneighbour = 1;
		oc->linkS->link7->maxNneighbour = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkS != nullptr) {
		if (oc->linkS->link2 != nullptr) {
		oc->linkS->link2->maxNneighbour = 1; //
		}
		if (oc->linkS->link3 != nullptr) {
		oc->linkS->link3->maxNneighbour = 1;
		}
		if (oc->linkS->link6 != nullptr) {
		oc->linkS->link6->maxNneighbour = 1;
		}
		if (oc->linkS->link7 != nullptr) {
		oc->linkS->link7->maxNneighbour = 1;
		}
		}
		}
		}
		}
		else {
		// полноценное дробление на 8.
		if (b2 || b3 || b6 || b7) {
		if (oc->linkN != nullptr) {
		if (is_null(oc->linkN)) {
		//oc->linkN->maxSneighbour += 4 - 1;
		patch_neighbour_count(oc->linkN->maxSneighbour, oc->linkN,S);
		}
		}
		else if (is_null1(oc->linkN)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkN->link0->maxSneighbour = 1; //
		oc->linkN->link1->maxSneighbour = 1;
		oc->linkN->link4->maxSneighbour = 1;
		oc->linkN->link5->maxSneighbour = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkN, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkN != nullptr) {
		if (oc->linkN->link0 != nullptr) {
		oc->linkN->link0->maxSneighbour = 1; //
		}
		if (oc->linkN->link1 != nullptr) {
		oc->linkN->link1->maxSneighbour = 1;
		}
		if (oc->linkN->link4 != nullptr) {
		oc->linkN->link4->maxSneighbour = 1;
		}
		if (oc->linkN->link5 != nullptr) {
		oc->linkN->link5->maxSneighbour = 1;
		}
		}
		}
		}
		if (b0 || b1 || b4 || b5) {
		if (oc->linkS != nullptr) {
		if (is_null(oc->linkS)) {
		//oc->linkS->maxNneighbour += 4 - 1;
		patch_neighbour_count(oc->linkS->maxNneighbour, oc->linkS,N);
		}
		else if (is_null1(oc->linkS)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkS->link2->maxNneighbour = 1; //
		oc->linkS->link3->maxNneighbour = 1;
		oc->linkS->link6->maxNneighbour = 1;
		oc->linkS->link7->maxNneighbour = 1;
		}
		else {
		// других вариантов быть не может, здесь только 4.
		// может быть 2, 4, 5, 8
		// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
		char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
		is_null2(oc->linkS, SSIDE, c0, c1, c2, c3, c4, c5, c6, c7);
		if (oc->linkS != nullptr) {
		if (oc->linkS->link2 != nullptr) {
		oc->linkS->link2->maxNneighbour = 1; //
		}
		if (oc->linkS->link3 != nullptr) {
		oc->linkS->link3->maxNneighbour = 1;
		}
		if (oc->linkS->link6 != nullptr) {
		oc->linkS->link6->maxNneighbour = 1;
		}
		if (oc->linkS->link7 != nullptr) {
		oc->linkS->link7->maxNneighbour = 1;
		}
		}
		}
		}
		}
		}

		if (bSituationX) {
		if (oc->linkW != nullptr) {
		if (is_null(oc->linkW)) {
		//oc->linkW->maxEneighbour += 4 - 1;
		patch_neighbour_count2(oc->linkW->maxEneighbour);
		}
		if (is_null1(oc->linkW)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkW->link1->maxEneighbour = 1; //
		oc->linkW->link2->maxEneighbour = 1;
		oc->linkW->link5->maxEneighbour = 1;
		oc->linkW->link6->maxEneighbour = 1;
		}
		}
		if (oc->linkE != nullptr) {
		if (is_null(oc->linkE)) {
		//oc->linkE->maxWneighbour += 4 - 1;
		patch_neighbour_count2(oc->linkE->maxWneighbour);
		}
		if (is_null1(oc->linkE)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkE->link0->maxWneighbour = 1; //
		oc->linkE->link3->maxWneighbour = 1;
		oc->linkE->link4->maxWneighbour = 1;
		oc->linkE->link7->maxWneighbour = 1;
		}
		}
		}
		else {
		// полноценное дробление на 8.
		if (b0 || b3 || b4 || b7) {
		if (oc->linkW != nullptr) {
		if (is_null(oc->linkW)) {
		//oc->linkW->maxEneighbour += 4 - 1;
		patch_neighbour_count(oc->linkW->maxEneighbour, oc->linkW,E);
		}
		if (is_null1(oc->linkW)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkW->link1->maxEneighbour = 1; //
		oc->linkW->link2->maxEneighbour = 1;
		oc->linkW->link5->maxEneighbour = 1;
		oc->linkW->link6->maxEneighbour = 1;
		}
		}
		}
		if (b1 || b2 || b5 || b6) {
		if (oc->linkE != nullptr) {
		if (is_null(oc->linkE)) {
		//oc->linkE->maxWneighbour += 4 - 1;
		patch_neighbour_count(oc->linkE->maxWneighbour, oc->linkE,WSIDE);
		}
		if (is_null1(oc->linkE)) {
		// он представляет собой ячейку делённую на 8 частей.
		oc->linkE->link0->maxWneighbour = 1; //
		oc->linkE->link3->maxWneighbour = 1;
		oc->linkE->link4->maxWneighbour = 1;
		oc->linkE->link7->maxWneighbour = 1;
		}
		}
		}
		}
		*/
	}

} // droblenie_internal


//  droblenie_internal_old завершена в 15:35 27.08.2016. надо делать delenie_internal.
// данный код устарел 30 августа 2016 и больше не поддерживается,
// поэтому см. реализацию droblenie internal.
void droblenie_internal_old(octree* &oc, int minx, int maxx, int miny, int maxy,
	int minz, int maxz, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &ret) {

	bool b0 = true;
	bool b1 = true;
	bool b2 = true;
	bool b3 = true;
	bool b4 = true;
	bool b5 = true;
	bool b6 = true;
	bool b7 = true;
	ret = 0;

	// Вырождение по Z.
	bool bSituationZ = false;
	// Вырождение по X.
	bool bSituationX = false;
	// Вырождение по Y.
	bool bSituationY = false;

	int avgx = (minx + maxx)/2;
	int avgy = (miny + maxy)/2;
	int avgz = (minz + maxz)/2;

	if (1) {
		doublereal xc28 = 0.5*(xpos[minx] + xpos[maxx]);
		int  isearch = -1;
		doublereal dmax28 = 1.0e36;
		// поиск наимее удалённого от геометрического центра индекса.
		for (int i28 = minx; i28 <= maxx; i28++) {
			if (fabs(xpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(xpos[i28] - xc28);
			}
		}
		avgx = isearch;

		xc28 = 0.5*(ypos[miny] + ypos[maxy]);
		isearch = -1;
		dmax28 = 1.0e36;
		// поиск наимее удалённого от геометрического центра индекса.
		for (int i28 = miny; i28 <= maxy; i28++) {
			if (fabs(ypos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(ypos[i28] - xc28);
			}
		}
		avgy = isearch;

		xc28 = 0.5*(zpos[minz] + zpos[maxz]);
		isearch = -1;
		dmax28 = 1.0e36;
		// поиск наимее удалённого от геометрического центра индекса.
		for (int i28 = minz; i28 <= maxz; i28++) {
			if (fabs(zpos[i28] - xc28) < dmax28) {
				isearch = i28;
				dmax28 = fabs(zpos[i28] - xc28);
			}
		}
		avgz = isearch;
	}



	if (minz + 1 == maxz) {
		avgz = maxz;
		b4 = false;
		b5 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Z.
		bSituationZ = true;
	}
	if (minx + 1 == maxx) {
		avgx = maxx;
		b1 = false;
		b2 = false;
		b5 = false;
		b6 = false;
		// Вырождение по X.
		bSituationX = true;
	}
	if (miny + 1 == maxy) {
		avgy = maxy;
		b2 = false;
		b3 = false;
		b6 = false;
		b7 = false;
		// Вырождение по Y.
		bSituationY = true;
	}
	if (!b1&&!b2&&!b3&&!b4&&!b5&&!b6&&!b7) {
		//iret++;
		printf("error list droblenie internal. ");
		//system("PAUSE");
		system("PAUSE");
	}
	else {

		bool bonly_dir_X = false;
		bool bonly_dir_Y = false;
		bool bonly_dir_Z = false;

		// дробление на iret частей.
		if (b1&&b2&&b3&&b4&&b5&&b6&&b7) {
			ret = 8;
		}
		else {
			if (bSituationX && (!bSituationY) && (!bSituationZ)) ret = 4;
			if (bSituationY && (!bSituationX) && (!bSituationZ)) ret = 4;
			if (bSituationZ && (!bSituationY) && (!bSituationX)) ret = 4;
			if (bSituationX && (bSituationY) && (!bSituationZ)) {
				ret = 2;
				bonly_dir_Z = true;
			}
			if (bSituationX && (bSituationZ) && (!bSituationY)) {
				ret = 2;
				bonly_dir_Y = true;
			}
			if (bSituationY && (bSituationZ) && (!bSituationX)) {
				ret = 2;
				bonly_dir_X = true;
			}
		}

		// дробление
		int minx0 = minx;
		int maxx0 = avgx;
		int miny0 = miny;
		int maxy0 = avgy;
		int minz0 = minz;
		int maxz0 = avgz;
		doublereal rminx0 = xpos[minx];
		doublereal rmaxx0 = xpos[avgx];
		doublereal rminy0 = ypos[miny];
		doublereal rmaxy0 = ypos[avgy];
		doublereal rminz0 = zpos[minz];
		doublereal rmaxz0 = zpos[avgz];
		if (b0) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link0,
			//	minx0, maxx0, miny0, maxy0, minz0, maxz0, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx0;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx0;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny0;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy0;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz0;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz0;


			oc->link0 = new octree;
			if (oc->link0 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link0 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			oc->link0->parent = oc;
			oc->link0->ilevel = oc->ilevel + 1;
			oc->link0->brootSituationX = bSituationX;
			oc->link0->brootSituationY = bSituationY;
			oc->link0->brootSituationZ = bSituationZ;
			oc->link0->root = 0;
			oc->link0->minx = minx0;
			oc->link0->maxx = maxx0;
			oc->link0->miny = miny0;
			oc->link0->maxy = maxy0;
			oc->link0->minz = minz0;
			oc->link0->maxz = maxz0;

			oc->link0->p0.x = rminx0;
			oc->link0->p0.y = rminy0;
			oc->link0->p0.z = rminz0;
			oc->link0->p1.x = rmaxx0;
			oc->link0->p1.y = rminy0;
			oc->link0->p1.z = rminz0;
			oc->link0->p2.x = rminx0;
			oc->link0->p2.y = rmaxy0;
			oc->link0->p2.z = rminz0;
			oc->link0->p3.x = rmaxx0;
			oc->link0->p3.y = rmaxy0;
			oc->link0->p3.z = rminz0;

			oc->link0->p4.x = rminx0;
			oc->link0->p4.y = rminy0;
			oc->link0->p4.z = rmaxz0;
			oc->link0->p5.x = rmaxx0;
			oc->link0->p5.y = rminy0;
			oc->link0->p5.z = rmaxz0;
			oc->link0->p6.x = rminx0;
			oc->link0->p6.y = rmaxy0;
			oc->link0->p6.z = rmaxz0;
			oc->link0->p7.x = rmaxx0;
			oc->link0->p7.y = rmaxy0;
			oc->link0->p7.z = rmaxz0;
			oc->link0->link0 = nullptr;
			oc->link0->link1 = nullptr;
			oc->link0->link2 = nullptr;
			oc->link0->link3 = nullptr;
			oc->link0->link4 = nullptr;
			oc->link0->link5 = nullptr;
			oc->link0->link6 = nullptr;
			oc->link0->link7 = nullptr;
			// пока соседей просто нету.
			oc->link0->linkW = nullptr;
			oc->link0->linkE = nullptr;
			oc->link0->linkS = nullptr;
			oc->link0->linkN = nullptr;
			oc->link0->linkB = nullptr;
			oc->link0->linkT = nullptr;
			oc->link0->b4W = false;
			oc->link0->b4E = false;
			oc->link0->b4S = false;
			oc->link0->b4N = false;
			oc->link0->b4B = false;
			oc->link0->b4T = false;
			oc->link0->linkW0 = nullptr;
			oc->link0->linkW3 = nullptr;
			oc->link0->linkW4 = nullptr;
			oc->link0->linkW7 = nullptr;
			oc->link0->linkE1 = nullptr;
			oc->link0->linkE2 = nullptr;
			oc->link0->linkE5 = nullptr;
			oc->link0->linkE6 = nullptr;
			oc->link0->linkS0 = nullptr;
			oc->link0->linkS1 = nullptr;
			oc->link0->linkS4 = nullptr;
			oc->link0->linkS5 = nullptr;
			oc->link0->linkN2 = nullptr;
			oc->link0->linkN3 = nullptr;
			oc->link0->linkN6 = nullptr;
			oc->link0->linkN7 = nullptr;
			oc->link0->linkB0 = nullptr;
			oc->link0->linkB1 = nullptr;
			oc->link0->linkB2 = nullptr;
			oc->link0->linkB3 = nullptr;
			oc->link0->linkT4 = nullptr;
			oc->link0->linkT5 = nullptr;
			oc->link0->linkT6 = nullptr;
			oc->link0->linkT7 = nullptr;
			oc->link0->dlist = true;
			oc->link0->b_the_geometric_fragmentation = true;

			oc->link0->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link0->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != nullptr) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link0->maxTneighbour = 1; // oc->maxTneighbour;
					}
					else if (is_null1(oc->linkT)) {

						if ((bonly_dir_X) || (bonly_dir_Y)) {
							oc->link0->maxTneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxTneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X) || (bonly_dir_Y)) {
							if (bonly_dir_X) {
								// дробим только по оси Ох.
								oc->link0->maxTneighbour = c0 + c3;
							}
							if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link0->maxTneighbour = c0 + c1;
							}
						}
						else {
							//oc->link0->maxTneighbour = 4;
							oc->link0->maxTneighbour = c0;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link0->maxTneighbour = 0;// oc->maxTneighbour;
				}
			}
			else {
				// это была внутренняя ячейка.
				oc->link0->maxTneighbour = 1;

			}
			if (bSituationY) {
				if (oc->linkN != nullptr) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link0->maxNneighbour = 1; // oc->maxNneighbour;
					}
					else if (is_null1(oc->linkN)) {
						if ((bonly_dir_X) || (bonly_dir_Z)) {
							oc->link0->maxNneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxNneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X) || (bonly_dir_Z)) {
							if (bonly_dir_X) {
								oc->link0->maxNneighbour = c0 + c4;
							}
							if (bonly_dir_Z) {
								oc->link0->maxNneighbour = c0 + c1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link0->maxNneighbour = 4;
							oc->link0->maxNneighbour = c0;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link0->maxNneighbour = 0; // oc->maxNneighbour;
				}
			}
			else {

				oc->link0->maxNneighbour = 1;

			}
			if (bSituationX) {
				if (oc->linkE != nullptr) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link0->maxEneighbour = 1; // oc->maxEneighbour;
					}
					else if (is_null1(oc->linkE)) {
						if ((bonly_dir_Z) || (bonly_dir_Y)) {
							oc->link0->maxEneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxEneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Y) || (bonly_dir_Z)) {
							if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link0->maxEneighbour = c0 + c4;
							}
							if (bonly_dir_Z) {
								// дробим только по оси Oz.
								oc->link0->maxEneighbour = c0 + c3;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link0->maxEneighbour = 4;
							oc->link0->maxEneighbour = c0;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link0->maxEneighbour = 0; // oc->maxEneighbour;
				}
			}
			else {
				oc->link0->maxEneighbour = 1;
			}
			// Должно быть уменьшение при дроблении:
			if (oc->linkW != nullptr) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link0->maxWneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link0->maxWneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxWneighbour = c1 + c2;
					}
				}
				else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link0->maxWneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link0->maxWneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxWneighbour = c1 + c5;
					}
				}
				else {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link0->maxWneighbour = 1;// oc->maxWneighbour;
					}
					else if (is_null1(oc->linkW)) {
						if (bonly_dir_Y){
							oc->link0->maxWneighbour = 2;
						}
						else if (bonly_dir_Z) {
							oc->link0->maxWneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxWneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link0->maxWneighbour = 4;
						if (bonly_dir_Y) {
							oc->link0->maxWneighbour = c1 + c5;
						}
						else if (bonly_dir_Z) {
							oc->link0->maxWneighbour = c1 + c2;
						}
						else {
							oc->link0->maxWneighbour = c1;
						}

					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link0->maxWneighbour = 0; // oc->maxWneighbour;
			}
			if (oc->linkS != nullptr) {
				if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link0->maxSneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link0->maxSneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxSneighbour = c3 + c2;
					}
				}
				else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link0->maxSneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link0->maxSneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxSneighbour = c3 + c7;
					}
				}
				else {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link0->maxSneighbour = 1;// oc->maxSneighbour;
					}
					else if (is_null1(oc->linkS)) {
						if (bonly_dir_Z) {
							oc->link0->maxSneighbour = 2;
						}
						else if (bonly_dir_X) {
							oc->link0->maxSneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxSneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						if (bonly_dir_Z) {
							oc->link0->maxSneighbour = c3 + c2;
						}
						else if (bonly_dir_X) {
							oc->link0->maxSneighbour = c3 + c7;
						}
						else {
							//oc->link0->maxSneighbour = 4;
							oc->link0->maxSneighbour = c3;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link0->maxSneighbour = 0;// oc->maxSneighbour;
			}
			if (oc->linkB != nullptr) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link0->maxBneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link0->maxBneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxBneighbour = c4 + c7;
					}
				}
				else if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link0->maxBneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link0->maxBneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link0->maxBneighbour = c4 + c5;
					}
				}
				else {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link0->maxBneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkB)) {
						if (bonly_dir_Y) {
							oc->link0->maxBneighbour = 2;
						}
						else if (bonly_dir_X) {
							oc->link0->maxBneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link0->maxBneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (bonly_dir_Y) {
							oc->link0->maxBneighbour = c4 + c5;
						}
						else if (bonly_dir_X) {
							oc->link0->maxBneighbour = c4 + c7;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link0->maxBneighbour = 4;
							oc->link0->maxBneighbour = c4;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link0->maxBneighbour = 0;// oc->maxBneighbour;
			}


			// А вот у соседей B, SSIDE, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки 
			/*.
			if (oc->linkB != nullptr) {
			oc->linkB->maxTneighbour += 4 - 1;
			}
			if (oc->linkS != nullptr) {
			oc->linkS->maxNneighbour += 4 - 1;
			}
			if (oc->linkW != nullptr) {
			oc->linkW->maxEneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link0;
			top_ALICE_STACK++;
		}
		else {
			oc->link0 = nullptr;
		}
		int  minx1 = avgx;
		int  maxx1 = maxx;
		int  miny1 = miny;
		int  maxy1 = avgy;
		int  minz1 = minz;
		int  maxz1 = avgz;
		doublereal rminx1 = xpos[avgx];
		doublereal rmaxx1 = xpos[maxx];
		doublereal rminy1 = ypos[miny];
		doublereal rmaxy1 = ypos[avgy];
		doublereal rminz1 = zpos[minz];
		doublereal rmaxz1 = zpos[avgz];
		if (b1) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link1,
			//	minx1, maxx1, miny1, maxy1, minz1, maxz1, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx1;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx1;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny1;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy1;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz1;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz1;

			oc->link1 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link1' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 6308.

			if (oc->link1 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link1 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link1->parent = oc;
			oc->link1->ilevel = oc->ilevel + 1;
			oc->link1->brootSituationX = bSituationX;
			oc->link1->brootSituationY = bSituationY;
			oc->link1->brootSituationZ = bSituationZ;
			oc->link1->root = 1;
			oc->link1->minx = minx1;
			oc->link1->maxx = maxx1;
			oc->link1->miny = miny1;
			oc->link1->maxy = maxy1;
			oc->link1->minz = minz1;
			oc->link1->maxz = maxz1;
			oc->link1->p0.x = rminx1;
			oc->link1->p0.y = rminy1;
			oc->link1->p0.z = rminz1;
			oc->link1->p1.x = rmaxx1;
			oc->link1->p1.y = rminy1;
			oc->link1->p1.z = rminz1;
			oc->link1->p2.x = rminx1;
			oc->link1->p2.y = rmaxy1;
			oc->link1->p2.z = rminz1;
			oc->link1->p3.x = rmaxx1;
			oc->link1->p3.y = rmaxy1;
			oc->link1->p3.z = rminz1;
			oc->link1->p4.x = rminx1;
			oc->link1->p4.y = rminy1;
			oc->link1->p4.z = rmaxz1;
			oc->link1->p5.x = rmaxx1;
			oc->link1->p5.y = rminy1;
			oc->link1->p5.z = rmaxz1;
			oc->link1->p6.x = rminx1;
			oc->link1->p6.y = rmaxy1;
			oc->link1->p6.z = rmaxz1;
			oc->link1->p7.x = rmaxx1;
			oc->link1->p7.y = rmaxy1;
			oc->link1->p7.z = rmaxz1;
			oc->link1->link0 = nullptr;
			oc->link1->link1 = nullptr;
			oc->link1->link2 = nullptr;
			oc->link1->link3 = nullptr;
			oc->link1->link4 = nullptr;
			oc->link1->link5 = nullptr;
			oc->link1->link6 = nullptr;
			oc->link1->link7 = nullptr;
			// пока соседей просто нету.
			oc->link1->linkW = nullptr;
			oc->link1->linkE = nullptr;
			oc->link1->linkS = nullptr;
			oc->link1->linkN = nullptr;
			oc->link1->linkB = nullptr;
			oc->link1->linkT = nullptr;
			oc->link1->b4W = false;
			oc->link1->b4E = false;
			oc->link1->b4S = false;
			oc->link1->b4N = false;
			oc->link1->b4B = false;
			oc->link1->b4T = false;
			oc->link1->linkW0 = nullptr;
			oc->link1->linkW3 = nullptr;
			oc->link1->linkW4 = nullptr;
			oc->link1->linkW7 = nullptr;
			oc->link1->linkE1 = nullptr;
			oc->link1->linkE2 = nullptr;
			oc->link1->linkE5 = nullptr;
			oc->link1->linkE6 = nullptr;
			oc->link1->linkS0 = nullptr;
			oc->link1->linkS1 = nullptr;
			oc->link1->linkS4 = nullptr;
			oc->link1->linkS5 = nullptr;
			oc->link1->linkN2 = nullptr;
			oc->link1->linkN3 = nullptr;
			oc->link1->linkN6 = nullptr;
			oc->link1->linkN7 = nullptr;
			oc->link1->linkB0 = nullptr;
			oc->link1->linkB1 = nullptr;
			oc->link1->linkB2 = nullptr;
			oc->link1->linkB3 = nullptr;
			oc->link1->linkT4 = nullptr;
			oc->link1->linkT5 = nullptr;
			oc->link1->linkT6 = nullptr;
			oc->link1->linkT7 = nullptr;
			oc->link1->dlist = true;
			oc->link1->b_the_geometric_fragmentation = true;
			oc->link1->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link1->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != nullptr) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link1->maxTneighbour = 1;// oc->maxTneighbour;
					}
					else if (is_null1(oc->linkT)) {
						if (bonly_dir_X) {
							oc->link1->maxTneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxTneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X)) {
							//if (bonly_dir_X) {
								// дробим только по оси Oy.
								oc->link1->maxTneighbour = c1 + c2;
							//}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть  2, 4, 5, 8
							//oc->link1->maxTneighbour = 4;
							oc->link1->maxTneighbour = c1;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link1->maxTneighbour = 0;// oc->maxTneighbour;
				}
			}
			else {
				oc->link1->maxTneighbour = 1;
			}
			if (bSituationY) {
				if (oc->linkN != nullptr) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link1->maxNneighbour = 1;// oc->maxNneighbour;
					}
					else if (is_null1(oc->linkN)) {
						if (bonly_dir_X) {
							oc->link1->maxNneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxNneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_X)) {
							//if (bonly_dir_X) {
								// дробим только по оси Oy.
								oc->link1->maxNneighbour = c1 + c5;
							//}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link1->maxNneighbour = 4;
							oc->link1->maxNneighbour = c1;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link1->maxNneighbour = 0;// oc->maxNneighbour;
				}
			}
			else {
				oc->link1->maxNneighbour = 1;
			}


			oc->link1->maxWneighbour = 1;



			// Должно быть уменьшение при дроблении:
			if (oc->linkE != nullptr) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link1->maxEneighbour = 1;// oc->maxEneighbour;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link1->maxEneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link1->maxEneighbour = 4;
					oc->link1->maxEneighbour = c0;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link1->maxEneighbour = 0;// oc->maxEneighbour;
			}
			if (oc->linkS != nullptr) {
				if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link1->maxSneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link1->maxSneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link1->maxSneighbour = c2 + c6;
					}
				}
				else {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link1->maxSneighbour = 1;// oc->maxSneighbour;
					}
					else if (is_null1(oc->linkS)) {
						if (bonly_dir_X) {
							oc->link1->maxSneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxSneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (bonly_dir_X) {
							oc->link1->maxSneighbour = c2 + c6;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link1->maxSneighbour = 4;
							oc->link1->maxSneighbour = c2;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link1->maxSneighbour = 0;// oc->maxSneighbour;
			}
			if (oc->linkB != nullptr) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link1->maxBneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link1->maxBneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link1->maxBneighbour = c5 + c6;
					}
				}
				else {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link1->maxBneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkB)) {
						if (bonly_dir_X) {
							oc->link1->maxBneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link1->maxBneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (bonly_dir_X) {
							oc->link1->maxBneighbour = c5 + c6;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link1->maxBneighbour = 4;
							oc->link1->maxBneighbour = c5;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link1->maxBneighbour = 0;// oc->maxBneighbour;
			}
			/*
			// А вот у соседей B, SSIDE, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkB != nullptr) {
			oc->linkB->maxTneighbour += 4 - 1;
			}
			if (oc->linkS != nullptr) {
			oc->linkS->maxNneighbour += 4 - 1;
			}
			if (oc->linkE != nullptr) {
			oc->linkE->maxWneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link1;
			top_ALICE_STACK++;
		}
		else {
			oc->link1 = nullptr;
		}
		int minx2 = avgx;
		int maxx2 = maxx;
		int miny2 = avgy;
		int maxy2 = maxy;
		int minz2 = minz;
		int maxz2 = avgz;
		doublereal rminx2 = xpos[avgx];
		doublereal rmaxx2 = xpos[maxx];
		doublereal rminy2 = ypos[avgy];
		doublereal rmaxy2 = ypos[maxy];
		doublereal rminz2 = zpos[minz];
		doublereal rmaxz2 = zpos[avgz];
		if (b2) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link2,
			//minx2, maxx2, miny2, maxy2, minz2, maxz2, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx2;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx2;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny2;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy2;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz2;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz2;

			oc->link2 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link2' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 6679.

			if (oc->link2 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link2 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link2->parent = oc;
			oc->link2->ilevel = oc->ilevel + 1;
			oc->link2->brootSituationX = bSituationX;
			oc->link2->brootSituationY = bSituationY;
			oc->link2->brootSituationZ = bSituationZ;
			oc->link2->root = 2;
			oc->link2->minx = minx2;
			oc->link2->maxx = maxx2;
			oc->link2->miny = miny2;
			oc->link2->maxy = maxy2;
			oc->link2->minz = minz2;
			oc->link2->maxz = maxz2;
			oc->link2->p0.x = rminx2;
			oc->link2->p0.y = rminy2;
			oc->link2->p0.z = rminz2;
			oc->link2->p1.x = rmaxx2;
			oc->link2->p1.y = rminy2;
			oc->link2->p1.z = rminz2;
			oc->link2->p2.x = rminx2;
			oc->link2->p2.y = rmaxy2;
			oc->link2->p2.z = rminz2;
			oc->link2->p3.x = rmaxx2;
			oc->link2->p3.y = rmaxy2;
			oc->link2->p3.z = rminz2;
			oc->link2->p4.x = rminx2;
			oc->link2->p4.y = rminy2;
			oc->link2->p4.z = rmaxz2;
			oc->link2->p5.x = rmaxx2;
			oc->link2->p5.y = rminy2;
			oc->link2->p5.z = rmaxz2;
			oc->link2->p6.x = rminx2;
			oc->link2->p6.y = rmaxy2;
			oc->link2->p6.z = rmaxz2;
			oc->link2->p7.x = rmaxx2;
			oc->link2->p7.y = rmaxy2;
			oc->link2->p7.z = rmaxz2;
			oc->link2->link0 = nullptr;
			oc->link2->link1 = nullptr;
			oc->link2->link2 = nullptr;
			oc->link2->link3 = nullptr;
			oc->link2->link4 = nullptr;
			oc->link2->link5 = nullptr;
			oc->link2->link6 = nullptr;
			oc->link2->link7 = nullptr;
			// пока соседей просто нету.
			oc->link2->linkW = nullptr;
			oc->link2->linkE = nullptr;
			oc->link2->linkS = nullptr;
			oc->link2->linkN = nullptr;
			oc->link2->linkB = nullptr;
			oc->link2->linkT = nullptr;
			oc->link2->b4W = false;
			oc->link2->b4E = false;
			oc->link2->b4S = false;
			oc->link2->b4N = false;
			oc->link2->b4B = false;
			oc->link2->b4T = false;
			oc->link2->linkW0 = nullptr;
			oc->link2->linkW3 = nullptr;
			oc->link2->linkW4 = nullptr;
			oc->link2->linkW7 = nullptr;
			oc->link2->linkE1 = nullptr;
			oc->link2->linkE2 = nullptr;
			oc->link2->linkE5 = nullptr;
			oc->link2->linkE6 = nullptr;
			oc->link2->linkS0 = nullptr;
			oc->link2->linkS1 = nullptr;
			oc->link2->linkS4 = nullptr;
			oc->link2->linkS5 = nullptr;
			oc->link2->linkN2 = nullptr;
			oc->link2->linkN3 = nullptr;
			oc->link2->linkN6 = nullptr;
			oc->link2->linkN7 = nullptr;
			oc->link2->linkB0 = nullptr;
			oc->link2->linkB1 = nullptr;
			oc->link2->linkB2 = nullptr;
			oc->link2->linkB3 = nullptr;
			oc->link2->linkT4 = nullptr;
			oc->link2->linkT5 = nullptr;
			oc->link2->linkT6 = nullptr;
			oc->link2->linkT7 = nullptr;
			oc->link2->dlist = true;
			oc->link2->b_the_geometric_fragmentation = true;
			oc->link2->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link2->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != nullptr) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link2->maxTneighbour = 1;// oc->maxTneighbour;
					}
					else if (is_null1(oc->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						oc->link2->maxTneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link2->maxTneighbour = 4;
						oc->link2->maxTneighbour = c2;
					}
				}
				else {
					// 0 остаётся 0.
					oc->link2->maxTneighbour = 0;// oc->maxTneighbour;
				}
			}
			else {
				oc->link2->maxTneighbour = 1;
			}
			oc->link2->maxSneighbour = 1;
			oc->link2->maxWneighbour = 1;



			// Должно быть уменьшение при дроблении:
			if (oc->linkE != nullptr) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link2->maxEneighbour = 1;// oc->maxEneighbour;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link2->maxEneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link2->maxEneighbour = 4;
					oc->link2->maxEneighbour = c3;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link2->maxEneighbour = 0;// oc->maxEneighbour;
			}
			if (oc->linkN != nullptr) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link2->maxNneighbour = 1;// oc->maxNneighbour;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link2->maxNneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

					// других вариантов быть не может, здесь только 4.
					//oc->link2->maxNneighbour = 4;
					oc->link2->maxNneighbour = c1;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link2->maxNneighbour = 0;// oc->maxNneighbour;
			}
			if (oc->linkB != nullptr) {
				if (is_null(oc->linkB)) {
					// 1 остаётся 1.
					oc->link2->maxBneighbour = 1;// oc->maxBneighbour;
				}
				else if (is_null1(oc->linkB)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link2->maxBneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link2->maxBneighbour = 4;
					oc->link2->maxBneighbour = c6;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link2->maxBneighbour = 0;// oc->maxBneighbour;
			}
			/*
			// А вот у соседей B, N, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkB != nullptr) {
			oc->linkB->maxTneighbour += 4 - 1;
			}
			if (oc->linkN != nullptr) {
			oc->linkN->maxSneighbour += 4 - 1;
			}
			if (oc->linkE != nullptr) {
			oc->linkE->maxWneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link2;
			top_ALICE_STACK++;
		}
		else {
			oc->link2 = nullptr;
		}
		int minx3 = minx;
		int maxx3 = avgx;
		int miny3 = avgy;
		int maxy3 = maxy;
		int minz3 = minz;
		int maxz3 = avgz;
		doublereal rminx3 = xpos[minx];
		doublereal rmaxx3 = xpos[avgx];
		doublereal rminy3 = ypos[avgy];
		doublereal rmaxy3 = ypos[maxy];
		doublereal rminz3 = zpos[minz];
		doublereal rmaxz3 = zpos[avgz];

		if (b3) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link3,
			//	minx3, maxx3, miny3, maxy3, minz3, maxz3, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx3;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx3;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny3;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy3;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz3;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz3;

			oc->link3 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link3' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 6936.

			if (oc->link3 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link3 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link3->parent = oc;
			oc->link3->ilevel = oc->ilevel + 1;
			oc->link3->brootSituationX = bSituationX;
			oc->link3->brootSituationY = bSituationY;
			oc->link3->brootSituationZ = bSituationZ;
			oc->link3->root = 3;
			oc->link3->minx = minx3;
			oc->link3->maxx = maxx3;
			oc->link3->miny = miny3;
			oc->link3->maxy = maxy3;
			oc->link3->minz = minz3;
			oc->link3->maxz = maxz3;
			oc->link3->p0.x = rminx3;
			oc->link3->p0.y = rminy3;
			oc->link3->p0.z = rminz3;
			oc->link3->p1.x = rmaxx3;
			oc->link3->p1.y = rminy3;
			oc->link3->p1.z = rminz3;
			oc->link3->p2.x = rminx3;
			oc->link3->p2.y = rmaxy3;
			oc->link3->p2.z = rminz3;
			oc->link3->p3.x = rmaxx3;
			oc->link3->p3.y = rmaxy3;
			oc->link3->p3.z = rminz3;
			oc->link3->p4.x = rminx3;
			oc->link3->p4.y = rminy3;
			oc->link3->p4.z = rmaxz3;
			oc->link3->p5.x = rmaxx3;
			oc->link3->p5.y = rminy3;
			oc->link3->p5.z = rmaxz3;
			oc->link3->p6.x = rminx3;
			oc->link3->p6.y = rmaxy3;
			oc->link3->p6.z = rmaxz3;
			oc->link3->p7.x = rmaxx3;
			oc->link3->p7.y = rmaxy3;
			oc->link3->p7.z = rmaxz3;
			oc->link3->link0 = nullptr;
			oc->link3->link1 = nullptr;
			oc->link3->link2 = nullptr;
			oc->link3->link3 = nullptr;
			oc->link3->link4 = nullptr;
			oc->link3->link5 = nullptr;
			oc->link3->link6 = nullptr;
			oc->link3->link7 = nullptr;
			// пока соседей просто нету.
			oc->link3->linkW = nullptr;
			oc->link3->linkE = nullptr;
			oc->link3->linkS = nullptr;
			oc->link3->linkN = nullptr;
			oc->link3->linkB = nullptr;
			oc->link3->linkT = nullptr;
			oc->link3->b4W = false;
			oc->link3->b4E = false;
			oc->link3->b4S = false;
			oc->link3->b4N = false;
			oc->link3->b4B = false;
			oc->link3->b4T = false;
			oc->link3->linkW0 = nullptr;
			oc->link3->linkW3 = nullptr;
			oc->link3->linkW4 = nullptr;
			oc->link3->linkW7 = nullptr;
			oc->link3->linkE1 = nullptr;
			oc->link3->linkE2 = nullptr;
			oc->link3->linkE5 = nullptr;
			oc->link3->linkE6 = nullptr;
			oc->link3->linkS0 = nullptr;
			oc->link3->linkS1 = nullptr;
			oc->link3->linkS4 = nullptr;
			oc->link3->linkS5 = nullptr;
			oc->link3->linkN2 = nullptr;
			oc->link3->linkN3 = nullptr;
			oc->link3->linkN6 = nullptr;
			oc->link3->linkN7 = nullptr;
			oc->link3->linkB0 = nullptr;
			oc->link3->linkB1 = nullptr;
			oc->link3->linkB2 = nullptr;
			oc->link3->linkB3 = nullptr;
			oc->link3->linkT4 = nullptr;
			oc->link3->linkT5 = nullptr;
			oc->link3->linkT6 = nullptr;
			oc->link3->linkT7 = nullptr;
			oc->link3->dlist = true;
			oc->link3->b_the_geometric_fragmentation = true;
			oc->link3->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link3->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			if (bSituationZ) {
				// Вырождение по OZ.
				if (oc->linkT != nullptr) {
					if (is_null(oc->linkT)) {
						// 1 остаётся 1.
						oc->link3->maxTneighbour = 1;// oc->maxTneighbour;
					}
					else if (is_null1(oc->linkT)) {
						if (bonly_dir_Y) {
							oc->link3->maxTneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link3->maxTneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Y)) {
							//if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link3->maxTneighbour = c3 + c2;
							//}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8.
							//oc->link3->maxTneighbour = 4;
							oc->link3->maxTneighbour = c3;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link3->maxTneighbour = 0;// oc->maxTneighbour;
				}
			}
			else {
				oc->link3->maxTneighbour = 1;
			}
			oc->link3->maxSneighbour = 1;



			if (bSituationX) {
				if (oc->linkE != nullptr) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link3->maxEneighbour = 1;// oc->maxEneighbour;
					}
					else if (is_null1(oc->linkE)) {
						if (bonly_dir_Y) {
							oc->link3->maxEneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link3->maxEneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Y)) {
							//if (bonly_dir_Y) {
								// дробим только по оси Oy.
								oc->link3->maxEneighbour = c3 + c7;
							//}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// Может быть 2, 4, 5, 8
							//oc->link3->maxEneighbour = 4;
							oc->link3->maxEneighbour = c3;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link3->maxEneighbour = 0;// oc->maxEneighbour;
				}
			}
			else {
				oc->link3->maxEneighbour = 1;
			}


			if (oc->linkW != nullptr) {
				if (bSituationZ && (!bSituationX) && (!bSituationY)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link3->maxWneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link3->maxWneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link3->maxWneighbour = c2 + c6;
					}
				}
				else {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link3->maxWneighbour = 1;// oc->maxWneighbour;
					}
					else if (is_null1(oc->linkW)) {
						if (bonly_dir_Y) {
							oc->link3->maxWneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link3->maxWneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link3->maxWneighbour = 4;
						if (bonly_dir_Y) {
							oc->link3->maxWneighbour = c2 + c6;
						}
						else {
							oc->link3->maxWneighbour = c2;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link3->maxWneighbour = 0;// oc->maxWneighbour;
			}

			if (oc->linkN != nullptr) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link3->maxNneighbour = 1;// oc->maxNneighbour;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link3->maxNneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link3->maxNneighbour = 4;
					oc->link3->maxNneighbour = c0;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link3->maxNneighbour = 0;// oc->maxNneighbour;
			}
			if (oc->linkB != nullptr) {
				if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkB)) {
						// 1 остаётся 1.
						oc->link3->maxBneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkB)) {
						// двойная прилегает к четверной.
						oc->link3->maxBneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link3->maxBneighbour = c7 + c6;
					}
				}
				else if (is_null(oc->linkB)) {
					// 1 остаётся 1.
					oc->link3->maxBneighbour = 1;// oc->maxBneighbour;
				}
				else if (is_null1(oc->linkB)) {
					if (bonly_dir_Y) {
						oc->link3->maxBneighbour = 2;
					}
					else {
						// две четверные стороны прилегают друг к дружке.
						oc->link3->maxBneighbour = 1;
					}
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (bonly_dir_Y) {
						oc->link3->maxBneighbour = c7 + c6;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						//oc->link3->maxBneighbour = 4;
						oc->link3->maxBneighbour = c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link3->maxBneighbour = 0;// oc->maxBneighbour;
			}

			/*
			// А вот у соседей B, N, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkB != nullptr) {
			oc->linkB->maxTneighbour += 4 - 1;
			}
			if (oc->linkN != nullptr) {
			oc->linkN->maxSneighbour += 4 - 1;
			}
			if (oc->linkW != nullptr) {
			oc->linkW->maxEneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link3;
			top_ALICE_STACK++;
		}
		else {
			oc->link3 = nullptr;
		}

		int minx4 = minx;
		int maxx4 = avgx;
		int miny4 = miny;
		int maxy4 = avgy;
		int minz4 = avgz;
		int maxz4 = maxz;
		doublereal rminx4 = xpos[minx];
		doublereal rmaxx4 = xpos[avgx];
		doublereal rminy4 = ypos[miny];
		doublereal rmaxy4 = ypos[avgy];
		doublereal rminz4 = zpos[avgz];
		doublereal rmaxz4 = zpos[maxz];
		if (b4) {
			//droblenie(xpos, ypos, zpos,
			//	inx, iny, inz, oc->link4,
			//	minx4, maxx4, miny4, maxy4, minz4, maxz4, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx4;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx4;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny4;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy4;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz4;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz4;

			oc->link4 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link4' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 7309.

			if (oc->link4 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link4 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link4->parent = oc;
			oc->link4->ilevel = oc->ilevel + 1;
			oc->link4->brootSituationX = bSituationX;
			oc->link4->brootSituationY = bSituationY;
			oc->link4->brootSituationZ = bSituationZ;
			oc->link4->root = 4;
			oc->link4->minx = minx4;
			oc->link4->maxx = maxx4;
			oc->link4->miny = miny4;
			oc->link4->maxy = maxy4;
			oc->link4->minz = minz4;
			oc->link4->maxz = maxz4;
			oc->link4->p0.x = rminx4;
			oc->link4->p0.y = rminy4;
			oc->link4->p0.z = rminz4;
			oc->link4->p1.x = rmaxx4;
			oc->link4->p1.y = rminy4;
			oc->link4->p1.z = rminz4;
			oc->link4->p2.x = rminx4;
			oc->link4->p2.y = rmaxy4;
			oc->link4->p2.z = rminz4;
			oc->link4->p3.x = rmaxx4;
			oc->link4->p3.y = rmaxy4;
			oc->link4->p3.z = rminz4;
			oc->link4->p4.x = rminx4;
			oc->link4->p4.y = rminy4;
			oc->link4->p4.z = rmaxz4;
			oc->link4->p5.x = rmaxx4;
			oc->link4->p5.y = rminy4;
			oc->link4->p5.z = rmaxz4;
			oc->link4->p6.x = rminx4;
			oc->link4->p6.y = rmaxy4;
			oc->link4->p6.z = rmaxz4;
			oc->link4->p7.x = rmaxx4;
			oc->link4->p7.y = rmaxy4;
			oc->link4->p7.z = rmaxz4;
			oc->link4->link0 = nullptr;
			oc->link4->link1 = nullptr;
			oc->link4->link2 = nullptr;
			oc->link4->link3 = nullptr;
			oc->link4->link4 = nullptr;
			oc->link4->link5 = nullptr;
			oc->link4->link6 = nullptr;
			oc->link4->link7 = nullptr;
			// пока соседей просто нету.
			oc->link4->linkW = nullptr;
			oc->link4->linkE = nullptr;
			oc->link4->linkS = nullptr;
			oc->link4->linkN = nullptr;
			oc->link4->linkB = nullptr;
			oc->link4->linkT = nullptr;
			oc->link4->b4W = false;
			oc->link4->b4E = false;
			oc->link4->b4S = false;
			oc->link4->b4N = false;
			oc->link4->b4B = false;
			oc->link4->b4T = false;
			oc->link4->linkW0 = nullptr;
			oc->link4->linkW3 = nullptr;
			oc->link4->linkW4 = nullptr;
			oc->link4->linkW7 = nullptr;
			oc->link4->linkE1 = nullptr;
			oc->link4->linkE2 = nullptr;
			oc->link4->linkE5 = nullptr;
			oc->link4->linkE6 = nullptr;
			oc->link4->linkS0 = nullptr;
			oc->link4->linkS1 = nullptr;
			oc->link4->linkS4 = nullptr;
			oc->link4->linkS5 = nullptr;
			oc->link4->linkN2 = nullptr;
			oc->link4->linkN3 = nullptr;
			oc->link4->linkN6 = nullptr;
			oc->link4->linkN7 = nullptr;
			oc->link4->linkB0 = nullptr;
			oc->link4->linkB1 = nullptr;
			oc->link4->linkB2 = nullptr;
			oc->link4->linkB3 = nullptr;
			oc->link4->linkT4 = nullptr;
			oc->link4->linkT5 = nullptr;
			oc->link4->linkT6 = nullptr;
			oc->link4->linkT7 = nullptr;
			oc->link4->dlist = true;
			oc->link4->b_the_geometric_fragmentation = true;
			oc->link4->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxEneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link4->maxBneighbour = 1;

			if (bSituationY) {
				if (oc->linkN != nullptr) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link4->maxNneighbour = 1;// oc->maxNneighbour;
					}
					else if (is_null1(oc->linkN)) {
						if (bonly_dir_Z) {
							oc->link4->maxNneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxNneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Z)) {
							//if (bonly_dir_Z) {
								// дробим только по оси Oy.
								oc->link4->maxNneighbour = c4 + c5;
							//}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// Здесь может быть 2, 4, 5, 8
							//oc->link4->maxNneighbour = 4;
							oc->link4->maxNneighbour = c4;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link4->maxNneighbour = 0;// oc->maxNneighbour;
				}
			}
			else {
				oc->link4->maxNneighbour = 1;
			}
			if (bSituationX) {
				if (oc->linkE != nullptr) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link4->maxEneighbour = 1;// oc->maxEneighbour;
					}
					else if (is_null1(oc->linkE)) {
						if (bonly_dir_Z) {
							oc->link4->maxEneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxEneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if ((bonly_dir_Z)) {
							//if (bonly_dir_Z) {
								// дробим только по оси Oy.
								oc->link4->maxEneighbour = c4 + c7;
							//}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							//oc->link4->maxEneighbour = 4;
							oc->link4->maxEneighbour = c4;
						}
					}
				}
				else {
					// 0 остаётся 0.
					oc->link4->maxEneighbour = 0;// oc->maxEneighbour;
				}
			}
			else {
				oc->link4->maxEneighbour = 1;
			}

			if (oc->linkW != nullptr) {
				if (bSituationY && (!bSituationX) && (!bSituationZ)) {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link4->maxWneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkW)) {
						// двойная прилегает к четверной.
						oc->link4->maxWneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link4->maxWneighbour = c5 + c6;
					}
				}
				else {
					if (is_null(oc->linkW)) {
						// 1 остаётся 1.
						oc->link4->maxWneighbour = 1;// oc->maxWneighbour;
					}
					else if (is_null1(oc->linkW)) {
						if (bonly_dir_Z) {
							oc->link4->maxWneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxWneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link4->maxWneighbour = 4;
						if (bonly_dir_Z) {
							oc->link4->maxWneighbour = c5 + c6;
						}
						else {
							oc->link4->maxWneighbour = c5;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link4->maxWneighbour = 0;// oc->maxWneighbour;
			}

			if (oc->linkS != nullptr) {
				if (bSituationX && (!bSituationY) && (!bSituationZ)) {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link4->maxSneighbour = 1;// oc->maxBneighbour;
					}
					else if (is_null1(oc->linkS)) {
						// двойная прилегает к четверной.
						oc->link4->maxSneighbour = 2;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						oc->link4->maxSneighbour = c7 + c6;
					}
				}
				else {
					if (is_null(oc->linkS)) {
						// 1 остаётся 1.
						oc->link4->maxSneighbour = 1;// oc->maxSneighbour;
					}
					else if (is_null1(oc->linkS)) {
						if (bonly_dir_Z) {
							oc->link4->maxSneighbour = 2;
						}
						else {
							// две четверные стороны прилегают друг к дружке.
							oc->link4->maxSneighbour = 1;
						}
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link4->maxSneighbour = 4;
						if (bonly_dir_Z) {
							oc->link4->maxSneighbour = c7 + c6;
						}
						else {
							oc->link4->maxSneighbour = c7;
						}
					}
				}
			}
			else {
				// 0 остаётся 0.
				oc->link4->maxSneighbour = 0;// oc->maxSneighbour;
			}
			if (oc->linkT != nullptr) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link4->maxTneighbour = 1;// oc->maxTneighbour;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link4->maxTneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link4->maxTneighbour = 4;
					oc->link4->maxTneighbour = c0;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link4->maxTneighbour = 0;// oc->maxTneighbour;
			}



			/*
			// А вот у соседей B, SSIDE, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != nullptr) {
			oc->linkT->maxBneighbour += 4 - 1;
			}
			if (oc->linkS != nullptr) {
			oc->linkS->maxNneighbour += 4 - 1;
			}
			if (oc->linkW != nullptr) {
			oc->linkW->maxEneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link4;
			top_ALICE_STACK++;
		}
		else {
			oc->link4 = nullptr;
		}
		int minx5 = avgx;
		int maxx5 = maxx;
		int miny5 = miny;
		int maxy5 = avgy;
		int minz5 = avgz;
		int maxz5 = maxz;
		doublereal rminx5 = xpos[avgx];
		doublereal rmaxx5 = xpos[maxx];
		doublereal rminy5 = ypos[miny];
		doublereal rmaxy5 = ypos[avgy];
		doublereal rminz5 = zpos[avgz];
		doublereal rmaxz5 = zpos[maxz];
		if (b5) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link5,
			//minx5, maxx5, miny5, maxy5, minz5, maxz5, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx5;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx5;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny5;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy5;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz5;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz5;

			oc->link5 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link5' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 7679.


			if (oc->link5 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link5 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link5->parent = oc;
			oc->link5->ilevel = oc->ilevel + 1;
			oc->link5->brootSituationX = bSituationX;
			oc->link5->brootSituationY = bSituationY;
			oc->link5->brootSituationZ = bSituationZ;
			oc->link5->root = 5;
			oc->link5->minx = minx5;
			oc->link5->maxx = maxx5;
			oc->link5->miny = miny5;
			oc->link5->maxy = maxy5;
			oc->link5->minz = minz5;
			oc->link5->maxz = maxz5;
			oc->link5->p0.x = rminx5;
			oc->link5->p0.y = rminy5;
			oc->link5->p0.z = rminz5;
			oc->link5->p1.x = rmaxx5;
			oc->link5->p1.y = rminy5;
			oc->link5->p1.z = rminz5;
			oc->link5->p2.x = rminx5;
			oc->link5->p2.y = rmaxy5;
			oc->link5->p2.z = rminz5;
			oc->link5->p3.x = rmaxx5;
			oc->link5->p3.y = rmaxy5;
			oc->link5->p3.z = rminz5;
			oc->link5->p4.x = rminx5;
			oc->link5->p4.y = rminy5;
			oc->link5->p4.z = rmaxz5;
			oc->link5->p5.x = rmaxx5;
			oc->link5->p5.y = rminy5;
			oc->link5->p5.z = rmaxz5;
			oc->link5->p6.x = rminx5;
			oc->link5->p6.y = rmaxy5;
			oc->link5->p6.z = rmaxz5;
			oc->link5->p7.x = rmaxx5;
			oc->link5->p7.y = rmaxy5;
			oc->link5->p7.z = rmaxz5;
			oc->link5->link0 = nullptr;
			oc->link5->link1 = nullptr;
			oc->link5->link2 = nullptr;
			oc->link5->link3 = nullptr;
			oc->link5->link4 = nullptr;
			oc->link5->link5 = nullptr;
			oc->link5->link6 = nullptr;
			oc->link5->link7 = nullptr;
			// пока соседей просто нету.
			oc->link5->linkW = nullptr;
			oc->link5->linkE = nullptr;
			oc->link5->linkS = nullptr;
			oc->link5->linkN = nullptr;
			oc->link5->linkB = nullptr;
			oc->link5->linkT = nullptr;
			oc->link5->b4W = false;
			oc->link5->b4E = false;
			oc->link5->b4S = false;
			oc->link5->b4N = false;
			oc->link5->b4B = false;
			oc->link5->b4T = false;
			oc->link5->linkW0 = nullptr;
			oc->link5->linkW3 = nullptr;
			oc->link5->linkW4 = nullptr;
			oc->link5->linkW7 = nullptr;
			oc->link5->linkE1 = nullptr;
			oc->link5->linkE2 = nullptr;
			oc->link5->linkE5 = nullptr;
			oc->link5->linkE6 = nullptr;
			oc->link5->linkS0 = nullptr;
			oc->link5->linkS1 = nullptr;
			oc->link5->linkS4 = nullptr;
			oc->link5->linkS5 = nullptr;
			oc->link5->linkN2 = nullptr;
			oc->link5->linkN3 = nullptr;
			oc->link5->linkN6 = nullptr;
			oc->link5->linkN7 = nullptr;
			oc->link5->linkB0 = nullptr;
			oc->link5->linkB1 = nullptr;
			oc->link5->linkB2 = nullptr;
			oc->link5->linkB3 = nullptr;
			oc->link5->linkT4 = nullptr;
			oc->link5->linkT5 = nullptr;
			oc->link5->linkT6 = nullptr;
			oc->link5->linkT7 = nullptr;
			oc->link5->dlist = true;
			oc->link5->b_the_geometric_fragmentation = true;
			oc->link5->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxEneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link5->maxBneighbour = 1;

			if (bSituationY) {
				if (oc->linkN != nullptr) {
					if (is_null(oc->linkN)) {
						// 1 остаётся 1.
						oc->link5->maxNneighbour = 1;// oc->maxNneighbour;
					}
					else if (is_null1(oc->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						oc->link5->maxNneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link5->maxNneighbour = 4;
						oc->link5->maxNneighbour = c5;
					}
				}
				else {
					// 0 остаётся 0.
					oc->link5->maxNneighbour = 0;// oc->maxNneighbour;
				}
			}
			else {
				oc->link5->maxNneighbour = 1;
			}
			oc->link5->maxWneighbour = 1;


			if (oc->linkE != nullptr) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link5->maxEneighbour = 1;// oc->maxEneighbour;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link5->maxEneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link5->maxEneighbour = 4;
					oc->link5->maxEneighbour = c4;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link5->maxEneighbour = 0;// oc->maxEneighbour;
			}
			if (oc->linkS != nullptr) {
				if (is_null(oc->linkS)) {
					// 1 остаётся 1.
					oc->link5->maxSneighbour = 1;// oc->maxSneighbour;
				}
				else if (is_null1(oc->linkS)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link5->maxSneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link5->maxSneighbour = 4;
					oc->link5->maxSneighbour = c6;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link5->maxSneighbour = 0;// oc->maxSneighbour;
			}
			if (oc->linkT != nullptr) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link5->maxTneighbour = 1; // oc->maxTneighbour;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link5->maxTneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link5->maxTneighbour = 4;
					oc->link5->maxTneighbour = c1;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link5->maxTneighbour = 0;// oc->maxTneighbour;
			}
			/*
			// А вот у соседей TSIDE, SSIDE, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != nullptr) {
			oc->linkB->maxBneighbour += 4 - 1;
			}
			if (oc->linkS != nullptr) {
			oc->linkS->maxNneighbour += 4 - 1;
			}
			if (oc->linkE != nullptr) {
			oc->linkE->maxWneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link5;
			top_ALICE_STACK++;
		}
		else {
			oc->link5 = nullptr;
		}
		int minx6 = avgx;
		int maxx6 = maxx;
		int miny6 = avgy;
		int maxy6 = maxy;
		int minz6 = avgz;
		int maxz6 = maxz;
		doublereal rminx6 = xpos[avgx];
		doublereal rmaxx6 = xpos[maxx];
		doublereal rminy6 = ypos[avgy];
		doublereal rmaxy6 = ypos[maxy];
		doublereal rminz6 = zpos[avgz];
		doublereal rmaxz6 = zpos[maxz];
		if (b6) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link6,
			//minx6, maxx6, miny6, maxy6, minz6, maxz6, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx6;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx6;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny6;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy6;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz6;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz6;

			oc->link6 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link6' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 7932.


			if (oc->link6 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link6 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link6->parent = oc;
			oc->link6->ilevel = oc->ilevel + 1;
			oc->link6->brootSituationX = bSituationX;
			oc->link6->brootSituationY = bSituationY;
			oc->link6->brootSituationZ = bSituationZ;
			oc->link6->root = 6;
			oc->link6->minx = minx6;
			oc->link6->maxx = maxx6;
			oc->link6->miny = miny6;
			oc->link6->maxy = maxy6;
			oc->link6->minz = minz6;
			oc->link6->maxz = maxz6;
			oc->link6->p0.x = rminx6;
			oc->link6->p0.y = rminy6;
			oc->link6->p0.z = rminz6;
			oc->link6->p1.x = rmaxx6;
			oc->link6->p1.y = rminy6;
			oc->link6->p1.z = rminz6;
			oc->link6->p2.x = rminx6;
			oc->link6->p2.y = rmaxy6;
			oc->link6->p2.z = rminz6;
			oc->link6->p3.x = rmaxx6;
			oc->link6->p3.y = rmaxy6;
			oc->link6->p3.z = rminz6;
			oc->link6->p4.x = rminx6;
			oc->link6->p4.y = rminy6;
			oc->link6->p4.z = rmaxz6;
			oc->link6->p5.x = rmaxx6;
			oc->link6->p5.y = rminy6;
			oc->link6->p5.z = rmaxz6;
			oc->link6->p6.x = rminx6;
			oc->link6->p6.y = rmaxy6;
			oc->link6->p6.z = rmaxz6;
			oc->link6->p7.x = rmaxx6;
			oc->link6->p7.y = rmaxy6;
			oc->link6->p7.z = rmaxz6;
			oc->link6->link0 = nullptr;
			oc->link6->link1 = nullptr;
			oc->link6->link2 = nullptr;
			oc->link6->link3 = nullptr;
			oc->link6->link4 = nullptr;
			oc->link6->link5 = nullptr;
			oc->link6->link6 = nullptr;
			oc->link6->link7 = nullptr;
			// пока соседей просто нету.
			oc->link6->linkW = nullptr;
			oc->link6->linkE = nullptr;
			oc->link6->linkS = nullptr;
			oc->link6->linkN = nullptr;
			oc->link6->linkB = nullptr;
			oc->link6->linkT = nullptr;
			oc->link6->b4W = false;
			oc->link6->b4E = false;
			oc->link6->b4S = false;
			oc->link6->b4N = false;
			oc->link6->b4B = false;
			oc->link6->b4T = false;
			oc->link6->linkW0 = nullptr;
			oc->link6->linkW3 = nullptr;
			oc->link6->linkW4 = nullptr;
			oc->link6->linkW7 = nullptr;
			oc->link6->linkE1 = nullptr;
			oc->link6->linkE2 = nullptr;
			oc->link6->linkE5 = nullptr;
			oc->link6->linkE6 = nullptr;
			oc->link6->linkS0 = nullptr;
			oc->link6->linkS1 = nullptr;
			oc->link6->linkS4 = nullptr;
			oc->link6->linkS5 = nullptr;
			oc->link6->linkN2 = nullptr;
			oc->link6->linkN3 = nullptr;
			oc->link6->linkN6 = nullptr;
			oc->link6->linkN7 = nullptr;
			oc->link6->linkB0 = nullptr;
			oc->link6->linkB1 = nullptr;
			oc->link6->linkB2 = nullptr;
			oc->link6->linkB3 = nullptr;
			oc->link6->linkT4 = nullptr;
			oc->link6->linkT5 = nullptr;
			oc->link6->linkT6 = nullptr;
			oc->link6->linkT7 = nullptr;
			oc->link6->dlist = true;
			oc->link6->b_the_geometric_fragmentation = true;
			oc->link6->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link6->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			oc->link6->maxBneighbour = 1;
			oc->link6->maxSneighbour = 1;
			oc->link6->maxWneighbour = 1;


			if (oc->linkE != nullptr) {
				if (is_null(oc->linkE)) {
					// 1 остаётся 1.
					oc->link6->maxEneighbour = 1;// oc->maxEneighbour;
				}
				else if (is_null1(oc->linkE)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link6->maxEneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link6->maxEneighbour = 4;
					oc->link6->maxEneighbour = c7;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link6->maxEneighbour = 0;// oc->maxEneighbour;
			}
			if (oc->linkN != nullptr) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link6->maxNneighbour = oc->maxNneighbour;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link6->maxNneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link6->maxNneighbour = 4;
					oc->link6->maxNneighbour = c5;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link6->maxNneighbour = 0;// oc->maxNneighbour;
			}
			if (oc->linkT != nullptr) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link6->maxTneighbour = 1;// oc->maxTneighbour;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link6->maxTneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link6->maxTneighbour = 4;
					oc->link6->maxTneighbour = c2;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link6->maxTneighbour = 0;// oc->maxTneighbour;
			}
			/*
			// А вот у соседей TSIDE, N, E количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != nullptr) {
			oc->linkT->maxBneighbour += 4 - 1;
			}
			if (oc->linkN != nullptr) {
			oc->linkN->maxSneighbour += 4 - 1;
			}
			if (oc->linkE != nullptr) {
			oc->linkE->maxWneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link6;
			top_ALICE_STACK++;
		}
		else {
			oc->link6 = nullptr;
		}
		int minx7 = minx;
		int maxx7 = avgx;
		int miny7 = avgy;
		int maxy7 = maxy;
		int minz7 = avgz;
		int maxz7 = maxz;
		doublereal rminx7 = xpos[minx];
		doublereal rmaxx7 = xpos[avgx];
		doublereal rminy7 = ypos[avgy];
		doublereal rmaxy7 = ypos[maxy];
		doublereal rminz7 = zpos[avgz];
		doublereal rmaxz7 = zpos[maxz];
		if (b7) {
			//droblenie(xpos, ypos, zpos,
			//inx, iny, inz, oc->link7,
			//minx7, maxx7, miny7, maxy7, minz7, maxz7, b, lb, lw, w, SSIDE, ls, epsToolx, epsTooly, epsToolz);
			my_ALICE_STACK[top_ALICE_STACK].minx = minx7;
			my_ALICE_STACK[top_ALICE_STACK].maxx = maxx7;
			my_ALICE_STACK[top_ALICE_STACK].miny = miny7;
			my_ALICE_STACK[top_ALICE_STACK].maxy = maxy7;
			my_ALICE_STACK[top_ALICE_STACK].minz = minz7;
			my_ALICE_STACK[top_ALICE_STACK].maxz = maxz7;

			oc->link7 = new octree;
			/*
			V668 Нет смысла проверять указатель 'oc-> link7' на ноль,
			так как память была выделена с помощью оператора 'new'.
			Исключение будет сгенерировано в случае ошибки выделения
			памяти. adaptive_local_refinement_mesh.cpp 8157.

			if (oc->link7 == nullptr) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem: not enough memory on your equipment for oc->link7 in adaptive_local_refinement_mesh generator...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
			*/
			oc->link7->parent = oc;
			oc->link7->ilevel = oc->ilevel + 1;
			oc->link7->brootSituationX = bSituationX;
			oc->link7->brootSituationY = bSituationY;
			oc->link7->brootSituationZ = bSituationZ;
			oc->link7->root = 7;
			oc->link7->minx = minx7;
			oc->link7->maxx = maxx7;
			oc->link7->miny = miny7;
			oc->link7->maxy = maxy7;
			oc->link7->minz = minz7;
			oc->link7->maxz = maxz7;

			oc->link7->p0.x = rminx7;
			oc->link7->p0.y = rminy7;
			oc->link7->p0.z = rminz7;
			oc->link7->p1.x = rmaxx7;
			oc->link7->p1.y = rminy7;
			oc->link7->p1.z = rminz7;
			oc->link7->p2.x = rminx7;
			oc->link7->p2.y = rmaxy7;
			oc->link7->p2.z = rminz7;
			oc->link7->p3.x = rmaxx7;
			oc->link7->p3.y = rmaxy7;
			oc->link7->p3.z = rminz7;

			oc->link7->p4.x = rminx7;
			oc->link7->p4.y = rminy7;
			oc->link7->p4.z = rmaxz7;
			oc->link7->p5.x = rmaxx7;
			oc->link7->p5.y = rminy7;
			oc->link7->p5.z = rmaxz7;
			oc->link7->p6.x = rminx7;
			oc->link7->p6.y = rmaxy7;
			oc->link7->p6.z = rmaxz7;
			oc->link7->p7.x = rmaxx7;
			oc->link7->p7.y = rmaxy7;
			oc->link7->p7.z = rmaxz7;
			oc->link7->link0 = nullptr;
			oc->link7->link1 = nullptr;
			oc->link7->link2 = nullptr;
			oc->link7->link3 = nullptr;
			oc->link7->link4 = nullptr;
			oc->link7->link5 = nullptr;
			oc->link7->link6 = nullptr;
			oc->link7->link7 = nullptr;
			// пока соседей просто нету.
			oc->link7->linkW = nullptr;
			oc->link7->linkE = nullptr;
			oc->link7->linkS = nullptr;
			oc->link7->linkN = nullptr;
			oc->link7->linkB = nullptr;
			oc->link7->linkT = nullptr;
			oc->link7->b4W = false;
			oc->link7->b4E = false;
			oc->link7->b4S = false;
			oc->link7->b4N = false;
			oc->link7->b4B = false;
			oc->link7->b4T = false;
			oc->link7->linkW0 = nullptr;
			oc->link7->linkW3 = nullptr;
			oc->link7->linkW4 = nullptr;
			oc->link7->linkW7 = nullptr;
			oc->link7->linkE1 = nullptr;
			oc->link7->linkE2 = nullptr;
			oc->link7->linkE5 = nullptr;
			oc->link7->linkE6 = nullptr;
			oc->link7->linkS0 = nullptr;
			oc->link7->linkS1 = nullptr;
			oc->link7->linkS4 = nullptr;
			oc->link7->linkS5 = nullptr;
			oc->link7->linkN2 = nullptr;
			oc->link7->linkN3 = nullptr;
			oc->link7->linkN6 = nullptr;
			oc->link7->linkN7 = nullptr;
			oc->link7->linkB0 = nullptr;
			oc->link7->linkB1 = nullptr;
			oc->link7->linkB2 = nullptr;
			oc->link7->linkB3 = nullptr;
			oc->link7->linkT4 = nullptr;
			oc->link7->linkT5 = nullptr;
			oc->link7->linkT6 = nullptr;
			oc->link7->linkT7 = nullptr;
			oc->link7->dlist = true;
			oc->link7->b_the_geometric_fragmentation = true;
			oc->link7->maxBneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxTneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxSneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxNneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxWneighbour = MAX_NEIGHBOUR_COUNT;
			oc->link7->maxEneighbour = MAX_NEIGHBOUR_COUNT;

			oc->link7->maxBneighbour = 1;
			oc->link7->maxSneighbour = 1;
			if (bSituationX) {
				if (oc->linkE != nullptr) {
					if (is_null(oc->linkE)) {
						// 1 остаётся 1.
						oc->link7->maxEneighbour = 1;// oc->maxEneighbour;
					}
					else if (is_null1(oc->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						oc->link7->maxEneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(oc->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//oc->link7->maxEneighbour = 4;
						oc->link7->maxEneighbour = c7;
					}
				}
				else {
					// 0 остаётся 0.
					oc->link7->maxEneighbour = 0;// oc->maxEneighbour;
				}
			}
			else {
				oc->link7->maxEneighbour = 1;
			}

			if (oc->linkW != nullptr) {
				if (is_null(oc->linkW)) {
					// 1 остаётся 1.
					oc->link7->maxWneighbour = 1;// oc->maxWneighbour;
				}
				else if (is_null1(oc->linkW)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link7->maxWneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link7->maxWneighbour = 4;
					oc->link7->maxWneighbour = c6;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link7->maxWneighbour = 0;// oc->maxWneighbour;
			}

			if (oc->linkN != nullptr) {
				if (is_null(oc->linkN)) {
					// 1 остаётся 1.
					oc->link7->maxNneighbour = 1;// oc->maxNneighbour;
				}
				else if (is_null1(oc->linkN)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link7->maxNneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link7->maxNneighbour = 4;
					oc->link7->maxNneighbour = c4;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link7->maxNneighbour = 0;// oc->maxNneighbour;
			}
			if (oc->linkT != nullptr) {
				if (is_null(oc->linkT)) {
					// 1 остаётся 1.
					oc->link7->maxTneighbour = 1;// oc->maxTneighbour;
				}
				else if (is_null1(oc->linkT)) {
					// две четверные стороны прилегают друг к дружке.
					oc->link7->maxTneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null3(oc->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					// других вариантов быть не может, здесь только 4.
					//oc->link7->maxTneighbour = 4;
					oc->link7->maxTneighbour = c3;
				}
			}
			else {
				// 0 остаётся 0.
				oc->link7->maxTneighbour = 0;// oc->maxTneighbour;
			}

			/*
			// А вот у соседей TSIDE, N, W количество соседей стало уже 4.
			// чтобы к ним обратится нужна ссылка на эти ячейки.
			// для этого нужна ссылка вврх на шести соседей oc ячейки .
			if (oc->linkT != nullptr) {
			oc->linkT->maxBneighbour += 4 - 1;
			}
			if (oc->linkN != nullptr) {
			oc->linkN->maxSneighbour += 4 - 1;
			}
			if (oc->linkW != nullptr) {
			oc->linkW->maxEneighbour += 4 - 1;
			}
			*/
			my_ALICE_STACK[top_ALICE_STACK].link = oc->link7;
			top_ALICE_STACK++;
		}
		else {
			oc->link7 = nullptr;
		}


		// Здесь  предусмотрен случай четырёх соседей по face грани ячейки.
		if (oc->link0 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link0->linkT = oc->linkT4;
				}
				else {
					oc->link0->linkT = oc->linkT;
				}
			}
			else {
				oc->link0->linkT = oc->link4;
			}
			// Y 0,1,4,5
			if (bSituationY) {
				if (oc->b4N) {
					oc->link0->linkN = oc->linkN3;
				}
				else {
					oc->link0->linkN = oc->linkN;
				}
			}
			else {
				oc->link0->linkN = oc->link3;
			}
			// X 0,3,4,7
			if (bSituationX) {
				if (oc->b4E) {
					oc->link0->linkE = oc->linkE1;
				}
				else {
					oc->link0->linkE = oc->linkE;
				}
			}
			else {
				oc->link0->linkE = oc->link1;
			}

			if (oc->b4B) {
				oc->link0->linkB = oc->linkB0;
			}
			else {
				oc->link0->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link0->linkW = oc->linkW0;
			}
			else {
				oc->link0->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link0->linkS = oc->linkS0;
			}
			else {
				oc->link0->linkS = oc->linkS;
			}
		}
		if (oc->link1 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link1->linkT = oc->linkT5;
				}
				else {
					oc->link1->linkT = oc->linkT;
				}
			}
			else {
				oc->link1->linkT = oc->link5;
			}
			if (bSituationY) {
				if (oc->b4N) {
					oc->link1->linkN = oc->linkN2;
				}
				else {
					oc->link1->linkN = oc->linkN;
				}
			}
			else {
				oc->link1->linkN = oc->link2;
			}
			oc->link1->linkW = oc->link0;

			if (oc->b4B) {
				oc->link1->linkB = oc->linkB1;
			}
			else {
				oc->link1->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link1->linkE = oc->linkE1;
			}
			else {
				oc->link1->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link1->linkS = oc->linkS1;
			}
			else {
				oc->link1->linkS = oc->linkS;
			}
		}
		if (oc->link2 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link2->linkT = oc->linkT6;
				}
				else {
					oc->link2->linkT = oc->linkT;
				}
			}
			else {
				oc->link2->linkT = oc->link6;
			}
			oc->link2->linkS = oc->link1;
			oc->link2->linkW = oc->link3;
			if (oc->b4B) {
				oc->link2->linkB = oc->linkB2;
			}
			else {
				oc->link2->linkB = oc->linkB;
			}
			if (oc->b4E) {
				oc->link2->linkE = oc->linkE2;
			}
			else {
				oc->link2->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link2->linkN = oc->linkN2;
			}
			else {
				oc->link2->linkN = oc->linkN;
			}
		}
		if (oc->link3 != nullptr) {
			if (bSituationZ) {
				if (oc->b4T) {
					oc->link3->linkT = oc->linkT7;
				}
				else {
					oc->link3->linkT = oc->linkT;
				}
			}
			else {
				oc->link3->linkT = oc->link7;
			}
			oc->link3->linkS = oc->link0;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link3->linkE = oc->linkE2;
				}
				else {
					oc->link3->linkE = oc->linkE;
				}
			}
			else {
				oc->link3->linkE = oc->link2;
			}

			if (oc->b4B) {
				oc->link3->linkB = oc->linkB3;
			}
			else {
				oc->link3->linkB = oc->linkB;
			}
			if (oc->b4W) {
				oc->link3->linkW = oc->linkW3;
			}
			else {
				oc->link3->linkW = oc->linkW;
			}
			if (oc->b4N) {
				oc->link3->linkN = oc->linkN3;
			}
			else {
				oc->link3->linkN = oc->linkN;
			}
		}
		if (oc->link4 != nullptr) {
			oc->link4->linkB = oc->link0;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link4->linkN = oc->linkN7;
				}
				else {
					oc->link4->linkN = oc->linkN;
				}
			}
			else {
				oc->link4->linkN = oc->link7;
			}
			if (bSituationX) {
				if (oc->b4E) {
					oc->link4->linkE = oc->linkE5;
				}
				else {
					oc->link4->linkE = oc->linkE;
				}
			}
			else {
				oc->link4->linkE = oc->link5;
			}

			if (oc->b4T) {
				oc->link4->linkT = oc->linkT4;
			}
			else {
				oc->link4->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link4->linkW = oc->linkW4;
			}
			else {
				oc->link4->linkW = oc->linkW;
			}
			if (oc->b4S) {
				oc->link4->linkS = oc->linkS4;
			}
			else {
				oc->link4->linkS = oc->linkS;
			}
		}
		if (oc->link5 != nullptr) {
			oc->link5->linkB = oc->link1;
			if (bSituationY) {
				if (oc->b4N) {
					oc->link5->linkN = oc->linkN6;
				}
				else {
					oc->link5->linkN = oc->linkN;
				}
			}
			else {
				oc->link5->linkN = oc->link6;
			}
			oc->link5->linkW = oc->link4;
			if (oc->b4T) {
				oc->link5->linkT = oc->linkT5;
			}
			else {
				oc->link5->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link5->linkE = oc->linkE5;
			}
			else {
				oc->link5->linkE = oc->linkE;
			}
			if (oc->b4S) {
				oc->link5->linkS = oc->linkS5;
			}
			else {
				oc->link5->linkS = oc->linkS;
			}
		}
		if (oc->link6 != nullptr) {
			oc->link6->linkB = oc->link2;
			oc->link6->linkS = oc->link5;
			oc->link6->linkW = oc->link7;
			if (oc->b4T) {
				oc->link6->linkT = oc->linkT6;
			}
			else {
				oc->link6->linkT = oc->linkT;
			}
			if (oc->b4E) {
				oc->link6->linkE = oc->linkE6;
			}
			else {
				oc->link6->linkE = oc->linkE;
			}
			if (oc->b4N) {
				oc->link6->linkN = oc->linkN6;
			}
			else {
				oc->link6->linkN = oc->linkN;
			}
		}
		if (oc->link7 != nullptr) {
			oc->link7->linkB = oc->link3;
			oc->link7->linkS = oc->link4;
			if (bSituationX) {
				if (oc->b4E) {
					oc->link7->linkE = oc->linkE6;
				}
				else {
					oc->link7->linkE = oc->linkE;
				}
			}
			else {
				oc->link7->linkE = oc->link6;
			}

			if (oc->b4T) {
				oc->link7->linkT = oc->linkT7;
			}
			else {
				oc->link7->linkT = oc->linkT;
			}
			if (oc->b4W) {
				oc->link7->linkW = oc->linkW7;
			}
			else {
				oc->link7->linkW = oc->linkW;
			}
			if (oc->b4N) {
				oc->link7->linkN = oc->linkN7;
			}
			else {
				oc->link7->linkN = oc->linkN;
			}
		}


		if (bSituationZ) {
			// Вырождение по Z
			if (oc->linkB != nullptr) {
				if (is_null(oc->linkB)) {
					//oc->linkB->maxTneighbour += 4 - 1;
					patch_neighbour_count2(oc->linkB->maxTneighbour);
				}
				if (is_null1(oc->linkB)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkB->link4->maxTneighbour = 1; // 
					oc->linkB->link5->maxTneighbour = 1;
					oc->linkB->link6->maxTneighbour = 1;
					oc->linkB->link7->maxTneighbour = 1;
				}
			}
			if (oc->linkT != nullptr) {
				if (is_null(oc->linkT)) {
					//oc->linkT->maxBneighbour += 4 - 1;
					patch_neighbour_count2(oc->linkT->maxBneighbour);
				}
				if (is_null1(oc->linkT)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkT->link0->maxBneighbour = 1; // 
					oc->linkT->link1->maxBneighbour = 1;
					oc->linkT->link2->maxBneighbour = 1;
					oc->linkT->link3->maxBneighbour = 1;
				}
			}
		}
		else {
			// Полноценное деление на 8 частей.
			if (b0 || b1 || b2 || b3) {
				if (oc->linkB != nullptr) {
					if (is_null(oc->linkB)) {
						//oc->linkB->maxTneighbour += 4 - 1;
						patch_neighbour_count(oc->linkB->maxTneighbour, oc->linkB, T_SIDE);
					}
					if (is_null1(oc->linkB)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkB->link4->maxTneighbour = 1; // 
						oc->linkB->link5->maxTneighbour = 1;
						oc->linkB->link6->maxTneighbour = 1;
						oc->linkB->link7->maxTneighbour = 1;
					}
				}
			}
			if (b4 || b5 || b6 || b7) {
				if (oc->linkT != nullptr) {
					if (is_null(oc->linkT)) {
						//oc->linkT->maxBneighbour += 4 - 1;
						patch_neighbour_count(oc->linkT->maxBneighbour, oc->linkT, B_SIDE);
					}
					if (is_null1(oc->linkT)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkT->link0->maxBneighbour = 1; // 
						oc->linkT->link1->maxBneighbour = 1;
						oc->linkT->link2->maxBneighbour = 1;
						oc->linkT->link3->maxBneighbour = 1;
					}
				}
			}
		}


		if (bSituationY) {
			if (oc->linkN != nullptr) {
				if (is_null(oc->linkN)) {
					//oc->linkN->maxSneighbour += 4 - 1;
					patch_neighbour_count2(oc->linkN->maxSneighbour);
				}
				else if (is_null1(oc->linkN)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkN->link0->maxSneighbour = 1; // 
					oc->linkN->link1->maxSneighbour = 1;
					oc->linkN->link4->maxSneighbour = 1;
					oc->linkN->link5->maxSneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null2(oc->linkN, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (oc->linkN != nullptr) {
						if (oc->linkN->link0 != nullptr) {
							oc->linkN->link0->maxSneighbour = 1; // 
						}
						if (oc->linkN->link1 != nullptr) {
							oc->linkN->link1->maxSneighbour = 1;
						}
						if (oc->linkN->link4 != nullptr) {
							oc->linkN->link4->maxSneighbour = 1;
						}
						if (oc->linkN->link5 != nullptr) {
							oc->linkN->link5->maxSneighbour = 1;
						}
					}
				}
			}
			if (oc->linkS != nullptr) {
				if (is_null(oc->linkS)) {
					//oc->linkS->maxNneighbour += 4 - 1;
					patch_neighbour_count2(oc->linkS->maxNneighbour);
				}
				else if (is_null1(oc->linkS)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkS->link2->maxNneighbour = 1; // 
					oc->linkS->link3->maxNneighbour = 1;
					oc->linkS->link6->maxNneighbour = 1;
					oc->linkS->link7->maxNneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null2(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (oc->linkS != nullptr) {
						if (oc->linkS->link2 != nullptr) {
							oc->linkS->link2->maxNneighbour = 1; //
						}
						if (oc->linkS->link3 != nullptr) {
							oc->linkS->link3->maxNneighbour = 1;
						}
						if (oc->linkS->link6 != nullptr) {
							oc->linkS->link6->maxNneighbour = 1;
						}
						if (oc->linkS->link7 != nullptr) {
							oc->linkS->link7->maxNneighbour = 1;
						}
					}
				}
			}
		}
		else {
			// полноценное дробление на 8.
			if (b2 || b3 || b6 || b7) {
				if (oc->linkN != nullptr) {
					if (is_null(oc->linkN)) {
						//oc->linkN->maxSneighbour += 4 - 1;
						patch_neighbour_count(oc->linkN->maxSneighbour, oc->linkN, S_SIDE);
					}
				}
				else if (is_null1(oc->linkN)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkN->link0->maxSneighbour = 1; // 
					oc->linkN->link1->maxSneighbour = 1;
					oc->linkN->link4->maxSneighbour = 1;
					oc->linkN->link5->maxSneighbour = 1;
				}
				else {
					// других вариантов быть не может, здесь только 4.
					// может быть 2, 4, 5, 8
					// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
					char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
					is_null2(oc->linkN, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
					if (oc->linkN != nullptr) {
						if (oc->linkN->link0 != nullptr) {
							oc->linkN->link0->maxSneighbour = 1; // 
						}
						if (oc->linkN->link1 != nullptr) {
							oc->linkN->link1->maxSneighbour = 1;
						}
						if (oc->linkN->link4 != nullptr) {
							oc->linkN->link4->maxSneighbour = 1;
						}
						if (oc->linkN->link5 != nullptr) {
							oc->linkN->link5->maxSneighbour = 1;
						}
					}
				}
			}
			if (b0 || b1 || b4 || b5) {
				if (oc->linkS != nullptr) {
					if (is_null(oc->linkS)) {
						//oc->linkS->maxNneighbour += 4 - 1;
						patch_neighbour_count(oc->linkS->maxNneighbour, oc->linkS, N_SIDE);
					}
					else if (is_null1(oc->linkS)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkS->link2->maxNneighbour = 1; // 
						oc->linkS->link3->maxNneighbour = 1;
						oc->linkS->link6->maxNneighbour = 1;
						oc->linkS->link7->maxNneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null2(oc->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						if (oc->linkS != nullptr) {
							if (oc->linkS->link2 != nullptr) {
								oc->linkS->link2->maxNneighbour = 1; //
							}
							if (oc->linkS->link3 != nullptr) {
								oc->linkS->link3->maxNneighbour = 1;
							}
							if (oc->linkS->link6 != nullptr) {
								oc->linkS->link6->maxNneighbour = 1;
							}
							if (oc->linkS->link7 != nullptr) {
								oc->linkS->link7->maxNneighbour = 1;
							}
						}
					}
				}
			}
		}

		if (bSituationX) {
			if (oc->linkW != nullptr) {
				if (is_null(oc->linkW)) {
					//oc->linkW->maxEneighbour += 4 - 1;
					patch_neighbour_count2(oc->linkW->maxEneighbour);
				}
				if (is_null1(oc->linkW)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkW->link1->maxEneighbour = 1; // 
					oc->linkW->link2->maxEneighbour = 1;
					oc->linkW->link5->maxEneighbour = 1;
					oc->linkW->link6->maxEneighbour = 1;
				}
			}
			if (oc->linkE != nullptr) {
				if (is_null(oc->linkE)) {
					//oc->linkE->maxWneighbour += 4 - 1;
					patch_neighbour_count2(oc->linkE->maxWneighbour);
				}
				if (is_null1(oc->linkE)) {
					// он представляет собой ячейку делённую на 8 частей.
					oc->linkE->link0->maxWneighbour = 1; // 
					oc->linkE->link3->maxWneighbour = 1;
					oc->linkE->link4->maxWneighbour = 1;
					oc->linkE->link7->maxWneighbour = 1;
				}
			}
		}
		else {
			// полноценное дробление на 8.
			if (b0 || b3 || b4 || b7) {
				if (oc->linkW != nullptr) {
					if (is_null(oc->linkW)) {
						//oc->linkW->maxEneighbour += 4 - 1;
						patch_neighbour_count(oc->linkW->maxEneighbour, oc->linkW, E_SIDE);
					}
					if (is_null1(oc->linkW)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkW->link1->maxEneighbour = 1; // 
						oc->linkW->link2->maxEneighbour = 1;
						oc->linkW->link5->maxEneighbour = 1;
						oc->linkW->link6->maxEneighbour = 1;
					}
				}
			}
			if (b1 || b2 || b5 || b6) {
				if (oc->linkE != nullptr) {
					if (is_null(oc->linkE)) {
						//oc->linkE->maxWneighbour += 4 - 1;
						patch_neighbour_count(oc->linkE->maxWneighbour, oc->linkE, W_SIDE);
					}
					if (is_null1(oc->linkE)) {
						// он представляет собой ячейку делённую на 8 частей.
						oc->linkE->link0->maxWneighbour = 1; // 
						oc->linkE->link3->maxWneighbour = 1;
						oc->linkE->link4->maxWneighbour = 1;
						oc->linkE->link7->maxWneighbour = 1;
					}
				}
			}
		}

	}

} // droblenie_internal

doublereal raspectratio_for_alice(doublereal a, doublereal b, doublereal c) {
	doublereal ret = 29.0; // инициализация.
	if ((a >= b) && (a >= c)) {
		if (b >= c) return a / c;
		else return a / b;
	}
	else if ((b >= a) && (b >= c)) {
		if (a >= c) return b / c;
		else return b / a;
	}
	else if ((c >= a) && (c >= b)) {
		if (a >= b) return c / b;
		else return c / a;
	}
	return ret;
}


// TODO Устаревшая не используемая функция. 
void division_boundary(TOCHKA &GSep, integer ib83, integer ib84, BLOCK* &b, 
	doublereal xpos_i, doublereal ypos_j, doublereal zpos_k) {
	// Определяем положение границы разделения.
	doublereal granica = xpos_i;
	doublereal dist = 1.0e30;
	if (1) {
		GSep.x = granica;
		if (fabs(b[ib83].g.xS - granica) < dist) {
			dist = fabs(b[ib83].g.xS - granica);
			GSep.x = b[ib83].g.xS;
		}
		if (fabs(b[ib83].g.xE - granica) < dist) {
			dist = fabs(b[ib83].g.xE - granica);
			GSep.x = b[ib83].g.xE;
		}
		if (fabs(b[ib84].g.xS - granica) < dist) {
			dist = fabs(b[ib84].g.xS - granica);
			GSep.x = b[ib84].g.xS;
		}
		if (fabs(b[ib84].g.xE - granica) < dist) {
			dist = fabs(b[ib84].g.xE - granica);
			GSep.x = b[ib84].g.xE;
		}

		granica = ypos_j;
		GSep.y = granica;
		dist = 1.0e30;
		if (fabs(b[ib83].g.yS - granica) < dist) {
			dist = fabs(b[ib83].g.yS - granica);
			GSep.y = b[ib83].g.yS;
		}
		if (fabs(b[ib83].g.yE - granica) < dist) {
			dist = fabs(b[ib83].g.yE - granica);
			GSep.y = b[ib83].g.yE;
		}
		if (fabs(b[ib84].g.yS - granica) < dist) {
			dist = fabs(b[ib84].g.yS - granica);
			GSep.y = b[ib84].g.yS;
		}
		if (fabs(b[ib84].g.yE - granica) < dist) {
			dist = fabs(b[ib84].g.yE - granica);
			GSep.y = b[ib84].g.yE;
		}

		granica = zpos_k;
		GSep.z = granica;
		dist = 1.0e30;
		if (fabs(b[ib83].g.zS - granica) < dist) {
			dist = fabs(b[ib83].g.zS - granica);
			GSep.z = b[ib83].g.zS;
		}
		if (fabs(b[ib83].g.zE - granica) < dist) {
			dist = fabs(b[ib83].g.zE - granica);
			GSep.z = b[ib83].g.zE;
		}
		if (fabs(b[ib84].g.zS - granica) < dist) {
			dist = fabs(b[ib84].g.zS - granica);
			GSep.z = b[ib84].g.zS;
		}
		if (fabs(b[ib84].g.zE - granica) < dist) {
			dist = fabs(b[ib84].g.zE - granica);
			GSep.z = b[ib84].g.zE;
		}
	}
}


bool split_near_the_entrance_or_exit(doublereal* xpos, doublereal* ypos, doublereal* zpos, 
	integer i, integer j, integer k,
	integer lw, WALL*& w, doublereal radius_of_influence, doublereal cabinet_size) {
	// Также нужно мельчить сетку вблизи 
	// входной и выходной границы потока.

	bool bsplit = false;

	TOCHKA GSep2;
	//GSep2.x = xpos[minx];
	//GSep2.y = ypos[miny];
	//GSep2.z = zpos[minz];
	// 06.01.2020
	//GSep2.x = 0.5 * (xpos[minx] + xpos[maxx - 1]);
	//GSep2.y = 0.5 * (ypos[miny] + ypos[maxy - 1]);
	//GSep2.z = 0.5 * (zpos[minz] + zpos[maxz - 1]);
	GSep2.x = xpos[i];
	GSep2.y = ypos[j];
	GSep2.z = zpos[k];

	// Определяем положение границы разделения.
	//division_boundary(GSep2, ib83, ib84, b, xpos[i], ypos[j], zpos[k]);

	for (integer i_35 = 0; i_35 < lw; i_35++) {
		if ((fabs(w[i_35].Vx) > 1.0e-36) || (fabs(w[i_35].Vy) > 1.0e-36) || (fabs(w[i_35].Vz) > 1.0e-36)
			|| (w[i_35].bpressure) || (w[i_35].bopening))
		{
			TOCHKA GSep3;
			GSep3.x = 0.5 * (w[i_35].g.xS + w[i_35].g.xE);
			GSep3.y = 0.5 * (w[i_35].g.yS + w[i_35].g.yE);
			GSep3.z = 0.5 * (w[i_35].g.zS + w[i_35].g.zE);

			doublereal Radius_35 = 0.0;
			//doublereal radius_of_influence = 1.8;// 14.0;// 1.8;
			doublereal wall_size = 0.0;
			switch (w[i_35].iPlane) {
			case XY_PLANE:  wall_size=fmin(fabs(w[i_35].g.xE - w[i_35].g.xS), fabs(w[i_35].g.yE - w[i_35].g.yS));
				Radius_35 = radius_of_influence * wall_size;
				break;
			case XZ_PLANE:  wall_size=fmin(fabs(w[i_35].g.xE - w[i_35].g.xS), fabs(w[i_35].g.zE - w[i_35].g.zS));
				Radius_35 = radius_of_influence * wall_size;
				break;
			case YZ_PLANE: wall_size =fmin(fabs(w[i_35].g.yE - w[i_35].g.yS), fabs(w[i_35].g.zE - w[i_35].g.zS));
				Radius_35 = radius_of_influence * wall_size;
				break;
			}

			if (wall_size < 0.1 * cabinet_size) {
				// Только если это локальная входная выходная граница как в Аляске.

				if (sqrt((GSep2.x - GSep3.x) * (GSep2.x - GSep3.x) +
					(GSep2.y - GSep3.y) * (GSep2.y - GSep3.y) +
					(GSep2.z - GSep3.z) * (GSep2.z - GSep3.z)) < Radius_35) {
					// GSep лучше не вычислять, пусть всё дробиться.

					//printf("popal R=%e %e\n", Radius_35, sqrt((GSep2.x - GSep3.x)* (GSep2.x - GSep3.x) +
						//(GSep2.y - GSep3.y) * (GSep2.y - GSep3.y) +
						//(GSep2.z - GSep3.z) * (GSep2.z - GSep3.z)));
					//system("pause");

					if (iswitchMeshGenerator == CONFORMAL_MESH_GENERATOR_SELECTOR::COARSEMESHGEN_MESHER) {
						// Слишком грубая сетка COARSEMESHGEN_MESHER да еще и АЛИС это очень грубо,
						// поэтому в жидкости здесь фактически будет использоваться структурированная сетка но только 
						// при выборе COARSEMESHGEN_MESHER пользователем.
						bsplit = true;
					}


				}
			}

		}
	}

	return bsplit;

}// split_near_the_entrance_or_exit

// Модификация правила дробления в этой функции открывает широчайшие настройки 
// генерации сетки т.к. можно добиться самого различного поведения сеточного генератора не трогая его ядро
// а модифицируя лишь эту функцию.
// 28.02.2017 Цилиндры не работоспособны.
integer droblenie(doublereal* xpos, doublereal* ypos, doublereal* zpos,
	int inx, int  iny, int  inz, octree* &oc,
	int  minx, int  maxx, int  miny, int  maxy, int  minz, int  maxz,
	BLOCK* &b, integer lb, integer lw, WALL* &w, SOURCE* &s, integer ls, 
	doublereal epsToolx, doublereal epsTooly, doublereal epsToolz, bool bsimpledefine) {
	




	// Дробим во всех координатных направлениях.
	bool bdrobimX = true;
	bool bdrobimY = true;
	bool bdrobimZ = true;

	bool bold_stable_version = true;

	TOCHKA GSep;
	//oc = new octree;
	/*
	my_ALICE_STACK[top_ALICE_STACK - 1].minx = minx;
	my_ALICE_STACK[top_ALICE_STACK - 1].maxx = maxx;
	my_ALICE_STACK[top_ALICE_STACK - 1].miny = miny;
	my_ALICE_STACK[top_ALICE_STACK - 1].maxy = maxy;
	my_ALICE_STACK[top_ALICE_STACK - 1].minz = minz;
	my_ALICE_STACK[top_ALICE_STACK - 1].maxz = maxz;
	*/
	oc->p0.x = xpos[minx];
	oc->p0.y = ypos[miny];
	oc->p0.z = zpos[minz];
	oc->p1.x = xpos[maxx];
	oc->p1.y = ypos[miny];
	oc->p1.z = zpos[minz];
	oc->p2.x = xpos[minx];
	oc->p2.y = ypos[maxy];
	oc->p2.z = zpos[minz];
	oc->p3.x = xpos[maxx];
	oc->p3.y = ypos[maxy];
	oc->p3.z = zpos[minz];
	oc->p4.x = xpos[minx];
	oc->p4.y = ypos[miny];
	oc->p4.z = zpos[maxz];
	oc->p5.x = xpos[maxx];
	oc->p5.y = ypos[miny];
	oc->p5.z = zpos[maxz];
	oc->p6.x = xpos[minx];
	oc->p6.y = ypos[maxy];
	oc->p6.z = zpos[maxz];
	oc->p7.x = xpos[maxx];
	oc->p7.y = ypos[maxy];
	oc->p7.z = zpos[maxz];
	oc->dlist = true;
	//doublereal eps = 1.0e-23;

	GSep.x = xpos[minx];
	GSep.y = ypos[miny];
	GSep.z = zpos[minz];

	const bool btgf_mesh_generator = true;

	

	if (btgf_mesh_generator) {
		// Нам нужна максимально разреженная сетка.

		// 6 августа 2017 начало.
		// Нельзя допускать слишком больших клеток в АлИС сетке,
		// т.е. нельзя превышать размер самой начальной супер грубой сетки.
		// Пусть кабинет имеет размеры LCx, LCy, LCz. Самая большая сторона для определённости LCx.
		// Начальная супер грубая сетка это 20клеток по LCx стороне как самой большой и еще 10 клеток по остальным сторонам.
		if (0) {
			doublereal LCx = fabs(xpos[inx] - xpos[0]);
			doublereal LCy = fabs(ypos[iny] - ypos[0]);
			doublereal LCz = fabs(zpos[inz] - zpos[0]);
			if (raspectratio_for_alice(fabs(xpos[maxx] - xpos[minx]), fabs(ypos[maxy] - ypos[miny]), fabs(zpos[maxz] - zpos[minz])) < 30.0) {
				if ((LCx >= LCy) && (LCx >= LCz)) {
					doublereal multy = 1.0 / (10.0 + 10.0*LCy / LCx);
					doublereal multz = 1.0 / (10.0 + 10.0*LCz / LCx);
					if ((fabs(xpos[maxx] - xpos[minx]) > 0.05*LCx) || (fabs(ypos[maxy] - ypos[miny]) > multy*LCy) || (fabs(zpos[maxz] - zpos[minz]) > multz*LCz)) {
						// Слишком большая клетка
						oc->dlist = false; // будем дробить
						goto DROBIM_NOW;
					}
				}
				else if ((LCy >= LCx) && (LCy >= LCz)) {
					doublereal multx = 1.0 / (10.0 + 10.0*LCx / LCy);
					doublereal multz = 1.0 / (10.0 + 10.0*LCz / LCy);
					if ((fabs(ypos[maxy] - ypos[miny]) > 0.05*LCy) || (fabs(xpos[maxx] - xpos[minx]) > multx*LCx) || (fabs(zpos[maxz] - zpos[minz]) > multz*LCz)) {
						// Слишком большая клетка
						oc->dlist = false; // будем дробить
						goto DROBIM_NOW;
					}
				}
				else if ((LCz >= LCx) && (LCz >= LCy)) {
					doublereal multx = 1.0 / (10.0 + 10.0*LCx / LCz);
					doublereal multy = 1.0 / (10.0 + 10.0*LCy / LCz);
					if ((fabs(zpos[maxz] - zpos[minz]) > 0.05*LCz) || (fabs(ypos[maxy] - ypos[miny]) > multy*LCy) || (fabs(xpos[maxx] - xpos[minx]) > multx*LCx)) {
						// Слишком большая клетка
						oc->dlist = false; // будем дробить
						goto DROBIM_NOW;
					}
				}
			}
		}
		// 6 августа 2017 конец.

		// проверяем есть ли дробление
		// на блоках.
		if (1) {
			// Новый алгоритм сканирующих отрезков в части блоков, работающий для любых форм 
			// блоков: прямоугольная призма, цилиндр, полигон. Использует хеш-таблицу
			// hash_for_droblenie_xyz[i][j][k]. 17 august 2017.
			// Если внутри ячейки дробления встретилась ситуация смены блоков (граница блоков) то данная 
			// ячейка дробится.
			// Это чрезвычайно простой и эффективный код, в частности за счёт использования заранеее 
			// табулированной хеш-таблицы hash_for_droblenie_xyz[i][j][k].
			

			if (bold_stable_version) {
				int ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				if (1 && ((ib83 <= -1) || (ib83 >= lb))) {
					    printf("*** FATAL ERROR!!! ***\n");
                        printf("hash table: hash_for_droblenie_xyz is INCORRUPT.\n");
						printf("error in function droblenie(...) in module adaptive_local_refinement_mesh.cpp.\n");
						printf("minx==%d miny=%d minz=%d\n", minx, miny, minz);
						printf("maxx==%d maxy=%d maxz=%d\n", maxx, maxy, maxz);
						printf("inx=%d iny=%d inz=%d\n", inx, iny, inz);
						printf("lb=%lld ib83==%d \n", lb, ib83);
						system("PAUSE");
				}

				if (0) {
					const int ilim_x = (maxx < inx ? maxx : inx - 1);
					const int ilim_y = (maxy < iny ? maxy : iny - 1);
					const int ilim_z = (maxz < inz ? maxz : inz - 1);

					// Очень быстродействующий вариант.
					for (int  i = minx; i <= ilim_x; ++i) {
						for (int  j = miny; j <= ilim_y; ++j) {
							for (int  k = minz; k <= ilim_z; ++k) {
								if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
									oc->dlist = false; // будем дробить
									goto DROBIM_NOW;
								}
							}
						}
					}
				}
				else {

					// Усовершенствованный экономичный вариант 2019 года.
					// 19.03.2019
					
					int irandom = rand() % 3; // 0,1 или 2
					

					if (irandom == 0) {
						i0r++;

						const int ilim_x = (maxx < inx ? maxx : inx - 1);
						const int ilim_y = (maxy < iny ? maxy : iny - 1);
						const int ilim_z = (maxz < inz ? maxz : inz - 1);

//#pragma omp parallel for
						for (int  i = minx; i <= ilim_x; ++i) {
							if (oc->dlist) {
								for (int j = miny; j <= ilim_y; ++j) {
									for (int k = minz; k <= ilim_z; ++k) {
										if (oc->dlist) {
											if (ib83 != hash_for_droblenie_xyz[i][j][k])
											{
												int ib84 = hash_for_droblenie_xyz[i][j][k];
												if (1 && ((ib84 <= -1) || (ib84 >= lb))) {
													printf("*** FATAL ERROR!!! ***\n");
													printf("hash table: hash_for_droblenie_xyz is INCORRUPT.\n");
													printf("error in function droblenie(...) in module adaptive_local_refinement_mesh.cpp.\n");
													printf("i==%d j=%d k=%d\n", i, j, k);
													printf("minx==%d miny=%d minz=%d\n", minx, miny, minz);
													printf("maxx==%d maxy=%d maxz=%d\n", maxx, maxy, maxz);
													printf("inx=%d iny=%d inz=%d\n", inx, iny, inz);
													printf("lb=%lld ib83==%d ib84==%d\n", lb, ib83, ib84);
													system("PAUSE");
												}


												if ((ib84 != -1) && (((b[ib83].itype == PHYSICS_TYPE_IN_BODY::FLUID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::FLUID)) ||
													((b[ib83].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::HOLLOW)) ||
													((b[ib83].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::SOLID)
														&& (b[ib83].imatid == b[ib84].imatid)))) {
													// Ничего не делаем, продолжаем сканирование.
													// Если два блока типа FLUID то у нас по определению 
													// корректности постановки задачи не может соприкасаться 
													// двух разных жидкостей поэтому мельчить сетку на этой 
													// границе бессмысленно (граница двух одинаковых жидкостей).
													// Аналогично мельчить сетку на границе двух HOLLOW блоков
													// тоже бессмысленно. Мы как бы объединяем эти блоки одинаковых
													// типов и создаём однородной тело сложной пространственной формы.

													// На границе двух SOLID блоков с одинаковым материалом мы тоже 
													// не создаём дополнительного измельчения сетки. Считаем что SOLID
													// блоки одинакового материала составляют единый блок сложной 
													// пространственной формы.

													// Достигается сильная экономия числа ячеек расчётной сетки.

													// 30.08.2019 Обнаружена проблема игнорирования входной и выходной 
													// cfd границ для радиаторов водяного охлаждения на АЛИС в радиаторах модуль ВУМ с радиатором жидкостного охлаждения*.
													// Вывод в том что вблизи входной и выходной границ желательно мельчить
													// АЛИС сетку чтобы не пропустить эти границы.

													if ((b_thermal_source_refinement) && (b[ib83].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::SOLID) &&
														((fabs(b[ib83].arr_Sc[0]) > 1.0e-30) || (fabs(b[ib84].arr_Sc[0]) > 1.0e-30)))
													{
														// 11.12.2019
														// Если два solid блока одинакового материала и хотя бы один из этих блоков
														// тепловыделяющий то границу блоков нужно разбить улучшенной сеткой.

//#pragma omp critical 
														{
															oc->dlist = false; // будем дробить
														}

													}
													else
													{
														doublereal cabinet_size = sqrt((b[0].g.xE - b[0].g.xS) * (b[0].g.xE - b[0].g.xS) + (b[0].g.yE - b[0].g.yS) * (b[0].g.yE - b[0].g.yS) + (b[0].g.zE - b[0].g.zS) * (b[0].g.zE - b[0].g.zS));
														if (split_near_the_entrance_or_exit(xpos, ypos, zpos, i, j, k, lw, w, 1.8, cabinet_size)) {

//#pragma omp critical 
															{
																oc->dlist = false; // будем дробить
															}

														}
													}

												}
												else {
													// Определяем положение границы разделения.
													//division_boundary(GSep, ib83, ib84, b, xpos[i], ypos[j], zpos[k]);
//#pragma omp critical 
													{
														oc->dlist = false; // будем дробить
													}

												}
											}
											else {
												// ib83==ib84, Но мы вблизи входной или выходной границы.
												// Дробим только жидкость и можно большим радиусом.
												if (b[ib83].itype == PHYSICS_TYPE_IN_BODY::FLUID) {
													doublereal cabinet_size = sqrt((b[0].g.xE - b[0].g.xS) * (b[0].g.xE - b[0].g.xS) + (b[0].g.yE - b[0].g.yS) * (b[0].g.yE - b[0].g.yS) + (b[0].g.zE - b[0].g.zS) * (b[0].g.zE - b[0].g.zS));
													if (split_near_the_entrance_or_exit(xpos, ypos, zpos, i, j, k, lw, w, 48.0, cabinet_size)) {

//#pragma omp critical 
														{
															oc->dlist = false; // будем дробить
														}

													}
												}
											}
										}
									}
								}
							}
                        }
					}
					else if (irandom == 1) {
						i1r++;

						const int ilim_x = (maxx < inx ? maxx : inx - 1);
						const int ilim_y = (maxy < iny ? maxy : iny - 1);
						const int ilim_z = (maxz < inz ? maxz : inz - 1);

//#pragma omp parallel for
						for (int j = miny; j <= ilim_y; ++j) {
							if (oc->dlist) {
								for (int k = minz; k <= ilim_z; ++k) {
									for (int i = minx; i <= ilim_x; ++i) {
										if (oc->dlist) {
											if (ib83 != hash_for_droblenie_xyz[i][j][k])
											{
												int ib84 = hash_for_droblenie_xyz[i][j][k];
												if (1 && ((ib84 <= -1) || (ib84 >= lb))) {
													printf("*** FATAL ERROR!!! ***\n");
													printf("hash table: hash_for_droblenie_xyz is INCORRUPT.\n");
													printf("error in function droblenie(...) in module adaptive_local_refinement_mesh.cpp.\n");
													printf("i==%d j=%d k=%d\n", i, j, k);
													printf("minx==%d miny=%d minz=%d\n", minx, miny, minz);
													printf("maxx==%d maxy=%d maxz=%d\n", maxx, maxy, maxz);
													printf("inx=%d iny=%d inz=%d\n", inx, iny, inz);
													printf("lb=%lld ib83==%d ib84==%d\n", lb, ib83, ib84);
													system("PAUSE");
												}


												if ((ib84 != -1) && (((b[ib83].itype == PHYSICS_TYPE_IN_BODY::FLUID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::FLUID)) ||
													((b[ib83].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::HOLLOW)) ||
													((b[ib83].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::SOLID)
														&& (b[ib83].imatid == b[ib84].imatid)))) {
													// Ничего не делаем, продолжаем сканирование.
													// Если два блока типа FLUID то у нас по определению 
													// корректности постановки задачи не может соприкасаться 
													// двух разных жидкостей поэтому мельчить сетку на этой 
													// границе бессмысленно (граница двух одинаковых жидкостей).
													// Аналогично мельчить сетку на границе двух HOLLOW блоков
													// тоже бессмысленно. Мы как бы объединяем эти блоки одинаковых
													// типов и создаём однородной тело сложной пространственной формы.

													// На границе двух SOLID блоков с одинаковым материалом мы тоже 
													// не создаём дополнительного измельчения сетки. Считаем что SOLID
													// блоки одинакового материала составляют единый блок сложной 
													// пространственной формы.

													// Достигается сильная экономия числа ячеек расчётной сетки.

													// 30.08.2019 Обнаружена проблема игнорирования входной и выходной 
													// cfd границ для радиаторов водяного охлаждения на АЛИС в радиаторах модуль ВУМ с радиатором жидкостного охлаждения*.
													// Вывод в том что вблизи входной и выходной границ желательно мельчить
													// АЛИС сетку чтобы не пропустить эти границы.

													if ((b_thermal_source_refinement) && (b[ib83].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::SOLID) &&
														((fabs(b[ib83].arr_Sc[0]) > 1.0e-30) || (fabs(b[ib84].arr_Sc[0]) > 1.0e-30)))
													{
														// 11.12.2019
														// Если два solid блока одинакового материала и хотя бы один из этих блоков
														// тепловыделяющий то границу блоков нужно разбить улучшенной сеткой.

//#pragma omp critical 
														{
															oc->dlist = false; // будем дробить
														}

													}
													else
													{
														doublereal cabinet_size = sqrt((b[0].g.xE - b[0].g.xS) * (b[0].g.xE - b[0].g.xS) + (b[0].g.yE - b[0].g.yS) * (b[0].g.yE - b[0].g.yS) + (b[0].g.zE - b[0].g.zS) * (b[0].g.zE - b[0].g.zS));
														if (split_near_the_entrance_or_exit(xpos, ypos, zpos, i, j, k, lw, w, 1.8, cabinet_size)) {

//#pragma omp critical 
															{
																oc->dlist = false; // будем дробить
															}

														}
													}

												}
												else {
													// Определяем положение границы разделения.
													//division_boundary(GSep, ib83, ib84, b, xpos[i], ypos[j], zpos[k]);
//#pragma omp critical 
													{
														oc->dlist = false; // будем дробить
													}

												}
											}
											else {
												// ib83==ib84, Но мы вблизи входной или выходной границы.
												// Дробим только жидкость и можно большим радиусом.
												if (b[ib83].itype == PHYSICS_TYPE_IN_BODY::FLUID) {
													doublereal cabinet_size = sqrt((b[0].g.xE - b[0].g.xS) * (b[0].g.xE - b[0].g.xS) + (b[0].g.yE - b[0].g.yS) * (b[0].g.yE - b[0].g.yS) + (b[0].g.zE - b[0].g.zS) * (b[0].g.zE - b[0].g.zS));
													if (split_near_the_entrance_or_exit(xpos, ypos, zpos, i, j, k, lw, w, 48.0, cabinet_size)) {

//#pragma omp critical 
														{
															oc->dlist = false; // будем дробить
														}

													}
												}
											}
										}
									}
								}
							}
						}
					}
					else {
						i2r++;

						const int ilim_x = (maxx < inx ? maxx : inx - 1);
						const int ilim_y = (maxy < iny ? maxy : iny - 1);
						const int ilim_z = (maxz < inz ? maxz : inz - 1);

//#pragma omp parallel for
						for (int k = minz; k <= ilim_z; ++k) {
							if (oc->dlist) {
								for (int i = minx; i <= ilim_x; ++i) {
									for (int j = miny; j <= ilim_y; ++j) {
										if (oc->dlist) {
											if (ib83 != hash_for_droblenie_xyz[i][j][k])
											{
												int ib84 = hash_for_droblenie_xyz[i][j][k];
												if (1 && ((ib84 <= -1) || (ib84 >= lb))) {
													printf("*** FATAL ERROR!!! ***\n");
													printf("hash table: hash_for_droblenie_xyz is INCORRUPT.\n");
													printf("error in function droblenie(...) in module adaptive_local_refinement_mesh.cpp.\n");
													printf("i==%d j=%d k=%d\n", i, j, k);
													printf("minx==%d miny=%d minz=%d\n", minx, miny, minz);
													printf("maxx==%d maxy=%d maxz=%d\n", maxx, maxy, maxz);
													printf("inx=%d iny=%d inz=%d\n", inx, iny, inz);
													printf("lb=%lld ib83==%d ib84==%d\n", lb, ib83, ib84);
													system("PAUSE");
												}


												if ((ib84 != -1) && (((b[ib83].itype == PHYSICS_TYPE_IN_BODY::FLUID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::FLUID)) ||
													((b[ib83].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::HOLLOW)) ||
													((b[ib83].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::SOLID)
														&& (b[ib83].imatid == b[ib84].imatid)))) {
													// Ничего не делаем, продолжаем сканирование.
													// Если два блока типа FLUID то у нас по определению 
													// корректности постановки задачи не может соприкасаться 
													// двух разных жидкостей поэтому мельчить сетку на этой 
													// границе бессмысленно (граница двух одинаковых жидкостей).
													// Аналогично мельчить сетку на границе двух HOLLOW блоков
													// тоже бессмысленно. Мы как бы объединяем эти блоки одинаковых
													// типов и создаём однородной тело сложной пространственной формы.

													// На границе двух SOLID блоков с одинаковым материалом мы тоже 
													// не создаём дополнительного измельчения сетки. Считаем что SOLID
													// блоки одинакового материала составляют единый блок сложной 
													// пространственной формы.

													// Достигается сильная экономия числа ячеек расчётной сетки.

													// 30.08.2019 Обнаружена проблема игнорирования входной и выходной 
													// cfd границ для радиаторов водяного охлаждения на АЛИС в радиаторах модуль ВУМ с радиатором жидкостного охлаждения*.
													// Вывод в том что вблизи входной и выходной границ желательно мельчить
													// АЛИС сетку чтобы не пропустить эти границы.

													if ((b_thermal_source_refinement) && (b[ib83].itype == PHYSICS_TYPE_IN_BODY::SOLID) && (b[ib84].itype == PHYSICS_TYPE_IN_BODY::SOLID) &&
														((fabs(b[ib83].arr_Sc[0]) > 1.0e-30) || (fabs(b[ib84].arr_Sc[0]) > 1.0e-30)))
													{
														// 11.12.2019
														// Если два solid блока одинакового материала и хотя бы один из этих блоков
														// тепловыделяющий то границу блоков нужно разбить улучшенной сеткой.

//#pragma omp critical 
														{
															oc->dlist = false; // будем дробить
														}

													}
													else
													{
														doublereal cabinet_size = sqrt((b[0].g.xE - b[0].g.xS) * (b[0].g.xE - b[0].g.xS) + (b[0].g.yE - b[0].g.yS) * (b[0].g.yE - b[0].g.yS) + (b[0].g.zE - b[0].g.zS) * (b[0].g.zE - b[0].g.zS));
														if (split_near_the_entrance_or_exit(xpos, ypos, zpos, i, j, k, lw, w, 1.8, cabinet_size)) {

//#pragma omp critical 
															{
																oc->dlist = false; // будем дробить
															}

														}
													}

												}
												else {
													// Определяем положение границы разделения.
													//division_boundary(GSep, ib83, ib84, b, xpos[i], ypos[j], zpos[k]);
//#pragma omp critical 
													{
														oc->dlist = false; // будем дробить
													}

												}
											}
											else {
												// ib83==ib84, Но мы вблизи входной или выходной границы.
												// Дробим только жидкость и можно большим радиусом.
												if (b[ib83].itype == PHYSICS_TYPE_IN_BODY::FLUID) {
													doublereal cabinet_size = sqrt((b[0].g.xE - b[0].g.xS) * (b[0].g.xE - b[0].g.xS) + (b[0].g.yE - b[0].g.yS) * (b[0].g.yE - b[0].g.yS) + (b[0].g.zE - b[0].g.zS) * (b[0].g.zE - b[0].g.zS));
													if (split_near_the_entrance_or_exit(xpos, ypos, zpos, i, j, k, lw, w, 48.0, cabinet_size)) {

//#pragma omp critical 
														{
															oc->dlist = false; // будем дробить
														}

													}
												}
											}
										}
									}
								}
							}
						}
					}

					const int ilim_x = (maxx < inx ? maxx : inx - 1);
					const int ilim_y = (maxy < iny ? maxy : iny - 1);
					const int ilim_z = (maxz < inz ? maxz : inz - 1);

					
					if (oc->dlist) {
						if (BonLevelDrobim >= 0) {
							

							// Дробим абсолютно все узлы, а не только граничные.

							// 01.01.2021
							// Дробим внутренность
							for (int k = minz; k <= ilim_z; ++k) {
								if (oc->dlist) {
									for (int i = minx; i <= ilim_x; ++i) {
										for (int j = miny; j <= ilim_y; ++j) {
											if (oc->dlist) {
												if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
													oc->dlist = false;// дробим.
												}
											}
										}
									}
								}
							}


							// Здесь мы дробим вблизи границ чтобы получить качественный погран слой.
					        // Причем только на границе с Hollow блоком.

							int j = miny - 1;
							if (j>=0) 
							{
								if (oc->dlist) {
									for (int k = minz; k <= ilim_z; ++k) {
										for (int i = minx; i <= ilim_x; ++i) {
											if (oc->dlist) {
												if (ib83 != hash_for_droblenie_xyz[i][j][k])
												{
													if (b[hash_for_droblenie_xyz[i][j][k]].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) {
														if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
															oc->dlist = false;// дробим.
														}
													}
												}
											}
										}
									}
								}
							}
							else {
								// находится на границе расчетной области
								// Только если он сам не hollow блок.
								if (b[ib83].itype != PHYSICS_TYPE_IN_BODY::HOLLOW) {
									if (oc->ilevel < BonLevelDrobim) {
										oc->dlist = false;// дробим.
									}
								}
							}

							j = maxy;
							if (j < iny)
							{
								if (oc->dlist) {
									for (int k = minz; k <= ilim_z; ++k) {
										for (int i = minx; i <= ilim_x; ++i) {
											if (oc->dlist) {
												if (ib83 != hash_for_droblenie_xyz[i][j][k])
												{
													if (b[hash_for_droblenie_xyz[i][j][k]].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) {
														if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
															oc->dlist = false;// дробим.
														}
													}
												}
											}
										}
									}
								}
							}
							else {
								// находится на границе расчетной области
								// Только если он сам не hollow блок.
								if (b[ib83].itype != PHYSICS_TYPE_IN_BODY::HOLLOW) {
									if (oc->ilevel < BonLevelDrobim) {
										oc->dlist = false;// дробим.
									}
								}
							}

							int i = minx - 1;
							if (i >= 0) {
								for (int j = miny; j <= ilim_y; ++j) {
									if (oc->dlist) {
										for (int k = minz; k <= ilim_z; ++k) {
											 {
												if (oc->dlist) {
													if (ib83 != hash_for_droblenie_xyz[i][j][k])
													{
														if (b[hash_for_droblenie_xyz[i][j][k]].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) {
															if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
																oc->dlist = false;// дробим.
															}
														}

													}
												}
											}
										}
									}
								}
							}
							else {
								// находится на границе расчетной области
								// Только если он сам не hollow блок.
								if (b[ib83].itype != PHYSICS_TYPE_IN_BODY::HOLLOW) {
									if (oc->ilevel < BonLevelDrobim) {
										oc->dlist = false;// дробим.
									}
								}
							}

							i = maxx;
							if (i < inx) {
								for (int j = miny; j <= ilim_y; ++j) {
									if (oc->dlist) {
										for (int k = minz; k <= ilim_z; ++k) {
											 {
												if (oc->dlist) {
													if (ib83 != hash_for_droblenie_xyz[i][j][k])
													{
														if (b[hash_for_droblenie_xyz[i][j][k]].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) {
															if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
																oc->dlist = false;// дробим.
															}
														}
													}
												}
											}
										}
									}
								}
							}
							else {
								// находится на границе расчетной области
								// Только если он сам не hollow блок.
								if (b[ib83].itype != PHYSICS_TYPE_IN_BODY::HOLLOW) {
									if (oc->ilevel < BonLevelDrobim) {
										oc->dlist = false;// дробим.
									}
								}
							}

							int k = minz - 1;
							if (k >= 0) {
								for (int j = miny; j <= ilim_y; ++j) {
									if (oc->dlist) {
										 {
											for (int i = minx; i <= ilim_x; ++i) {
												if (oc->dlist) {
													if (ib83 != hash_for_droblenie_xyz[i][j][k])
													{
														if (b[hash_for_droblenie_xyz[i][j][k]].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) {
															if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
																oc->dlist = false;// дробим.
															}
														}
													}
												}
											}
										}
									}
								}
							}
							else {
								// находится на границе расчетной области
								// Только если он сам не hollow блок.
								if (b[ib83].itype != PHYSICS_TYPE_IN_BODY::HOLLOW) {
									if (oc->ilevel < BonLevelDrobim) {
										oc->dlist = false;// дробим.
									}
								}
							}

						    k = maxz;
							if (k < inz) {
								for (int j = miny; j <= ilim_y; ++j) {
									if (oc->dlist) {
										 {
											for (int i = minx; i <= ilim_x; ++i) {
												if (oc->dlist) {
													if (ib83 != hash_for_droblenie_xyz[i][j][k])
													{
														if (b[hash_for_droblenie_xyz[i][j][k]].itype == PHYSICS_TYPE_IN_BODY::HOLLOW) {
															if (!AdaptivRegionDrobim(oc->ilevel, i, j, k, xpos, ypos, zpos)) {
																oc->dlist = false;// дробим.
															}
														}
													}
												}
											}
										}
									}
								}
							}
							else {
								// находится на границе расчетной области
								// Только если он сам не hollow блок.
								if (b[ib83].itype != PHYSICS_TYPE_IN_BODY::HOLLOW) {
									if (oc->ilevel < BonLevelDrobim) {
										oc->dlist = false;// дробим.
									}
								}
							}


						}
					}
					
				}

				// Переменным bdrobim присвоено тоже значение что
				// и в самом начале функции при инициализации.
				//bdrobimX = true;
				//bdrobimY = true;
				//bdrobimZ = true;
			}
			else {
				// Добавляем избирательности при дроблении.

				printf("if not (bold_stable_version)\n");
				system("pause");

				// 3.01.2017
				// Моя цель - небывалая экономичность АЛИС сетки.
				// Экономичности присуща геометрическая (визуальная) эстетическая привлекательность.
				// Сетка должна выглядеть мелкой только там где это действительно необходимо.
				// Экономичность - расщепление на три признака дробления. По одному на каждую ось координат.

				bdrobimX = false;
				bdrobimY = false;
				bdrobimZ = false;

				// Мы расщепляем информацию о дроблении на три независимых координатных направления для лучшей управляемости процесса дробления,
				// с целью достижения его более высокой экономичности.
				int ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (int  i = minx; i < maxx; ++i) {
					if (!bdrobimZ) {
						for (int  j = miny; j < maxy; ++j) {
							if (!bdrobimZ) {
								ib83 = hash_for_droblenie_xyz[i][j][minz];
								for (int  k = minz + 1; k < maxz; ++k) {
									if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
										oc->dlist = false; // будем дробить
										bdrobimZ = true; // Надо дробить по направлению оси Oz.
										break;
										//goto DROBIM_NOW;
									}
								}
							}
						}
					}
				}


				ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (int  k = minz; k < maxz; ++k) {
					if (!bdrobimX) {
						for (int  j = miny; j < maxy; ++j) {
							if (!bdrobimX) {
								ib83 = hash_for_droblenie_xyz[minx][j][k];
								for (int  i = minx + 1; i < maxx; ++i) {
									if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
										oc->dlist = false; // будем дробить
										bdrobimX = true; // Надо дробить по направлению оси Ox.
										break;
										//goto DROBIM_NOW;
									}
								}
							}
						}
					}
				}

				ib83 = hash_for_droblenie_xyz[minx][miny][minz];
				for (int  k = minz; k < maxz; ++k) {
					if (!bdrobimY) {
						for (int  i = minx; i < maxx; ++i) {
							if (!bdrobimY) {
								ib83 = hash_for_droblenie_xyz[i][miny][k];
								for (int  j = miny+1; j < maxy; ++j) {
									if (ib83 != hash_for_droblenie_xyz[i][j][k]) {
										oc->dlist = false; // будем дробить
										bdrobimY = true; // Надо дробить по направлению оси Oy.
										break;
										//goto DROBIM_NOW;
									}
								}
							}
						}
					}
				}

				if (bdrobimX || bdrobimY || bdrobimZ) {
					goto DROBIM_NOW;
				}
				//bdrobimX = true;
				//bdrobimY = true;
				//bdrobimZ = true;
			}
		}
		else {
			if (1 && bsimpledefine) {
				// Универсальный код для всех сканирующих направлений.
				for (int  i1 = 0; i1 < lb; i1++) {
					if (b[i1].g.itypegeom == PRISM) {
						// Prism
						/*
						if ( (((xpos[minx] <= b[i1].g.xS)&&(xpos[maxx] >= b[i1].g.xS)) || ((xpos[minx] <= b[i1].g.xE) && (xpos[maxx] >= b[i1].g.xE)) )&& (((ypos[miny] <= b[i1].g.yS) && (ypos[maxy] >= b[i1].g.yS)) || ((ypos[miny] <= b[i1].g.yE) && (ypos[maxy] >= b[i1].g.yE))) && (((zpos[minz] <= b[i1].g.zS) && (zpos[maxz] >= b[i1].g.zS)) || ((zpos[minz] <= b[i1].g.zE) && (zpos[maxz] >= b[i1].g.zE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
						*/
						doublereal eps_tolerance = 1.0e-25;
						// Oz
						if ((((xpos[maxx] - eps_tolerance > b[i1].g.xS)) && ((xpos[minx] + eps_tolerance < b[i1].g.xE))) && (((ypos[maxy] - eps_tolerance > b[i1].g.yS)) && ((ypos[miny] + eps_tolerance < b[i1].g.yE))) && (((zpos[minz + 1] <= b[i1].g.zS) && (zpos[maxz - 1] >= b[i1].g.zS)) || ((zpos[minz + 1] <= b[i1].g.zE) && (zpos[maxz - 1] >= b[i1].g.zE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
						// Ox
						if ((((zpos[maxz] - eps_tolerance > b[i1].g.zS)) && ((zpos[minz] + eps_tolerance < b[i1].g.zE))) && (((ypos[maxy] - eps_tolerance > b[i1].g.yS)) && ((ypos[miny] + eps_tolerance < b[i1].g.yE))) && (((xpos[minx + 1] <= b[i1].g.xS) && (xpos[maxx - 1] >= b[i1].g.xS)) || ((xpos[minx + 1] <= b[i1].g.xE) && (xpos[maxx - 1] >= b[i1].g.xE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
						// Oy
						if ((((zpos[maxz] - eps_tolerance > b[i1].g.zS)) && ((zpos[minz] + eps_tolerance < b[i1].g.zE))) && (((xpos[maxx] - eps_tolerance > b[i1].g.xS)) && ((xpos[minx] + eps_tolerance < b[i1].g.xE))) && (((ypos[miny + 1] <= b[i1].g.yS) && (ypos[maxy - 1] >= b[i1].g.yS)) || ((ypos[miny + 1] <= b[i1].g.yE) && (ypos[maxy - 1] >= b[i1].g.yE)))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
			else {

				if (1) {
					// BT
					for (int  i = minx; i < maxx; ++i) {
						for (int  j = miny; j < maxy; ++j) {
							for (int  k = minz + 1; k < maxz; ++k) {
								doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
								doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
								doublereal zc = zpos[k];
								for (integer i1 = 0; i1 < lb; i1++) {
									if (b[i1].g.itypegeom == PRISM) {
										// Prism
										if ((xc > b[i1].g.xS) && (xc < b[i1].g.xE) && (yc > b[i1].g.yS) && (yc < b[i1].g.yE) && ((fabs(b[i1].g.zS - zc) < epsToolz) || (fabs(b[i1].g.zE - zc) < epsToolz))) {
											oc->dlist = false; // будем дробить
											goto DROBIM_NOW;
										}
									}
									if (b[i1].g.itypegeom == CYLINDER) {
										// Cylinder
										switch (b[i1].g.iPlane) {
										case XY_PLANE:
											if (b[i1].g.R_in_cyl < 1.0e-20) {
												if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && ((fabs(b[i1].g.zC - zc) < epsToolz) || (fabs(b[i1].g.zC + b[i1].g.Hcyl - zc) < epsToolz))) {
													oc->dlist = false; // будем дробить
													goto DROBIM_NOW;
												}
											}
											else {
												if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && (sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) > b[i1].g.R_in_cyl) && ((fabs(b[i1].g.zC - zc) < epsToolz) || (fabs(b[i1].g.zC + b[i1].g.Hcyl - zc) < epsToolz))) {
													oc->dlist = false; // будем дробить
													goto DROBIM_NOW;
												}
											}
											break;
										case XZ_PLANE:
											if (b[i1].g.R_in_cyl < 1.0e-20) {
												// без внутреннего радиуса.
												if ((yc > b[i1].g.yC) && (yc < b[i1].g.yC + b[i1].g.Hcyl)) {
													if ((xc > b[i1].g.xC - b[i1].g.R_out_cyl) && (xc < b[i1].g.xC + b[i1].g.R_out_cyl)) {
														doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.xC - xc)*(b[i1].g.xC - xc));
														if ((fabs(zc - (b[i1].g.zC + hloc)) < epsToolz) || (fabs(zc + (b[i1].g.zC + hloc)) < epsToolz)) {
															oc->dlist = false; // будем дробить
															goto DROBIM_NOW;
														}
													}
												}
											}
											else {
												// С внутренним радиусом.

											}
											break;
										case YZ_PLANE:
											if (b[i1].g.R_in_cyl < 1.0e-20) {
												// без внутреннего радиуса.
												if ((xc > b[i1].g.xC) && (xc < b[i1].g.xC + b[i1].g.Hcyl)) {
													if ((yc > b[i1].g.yC - b[i1].g.R_out_cyl) && (yc < b[i1].g.yC + b[i1].g.R_out_cyl)) {
														doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.yC - yc)*(b[i1].g.yC - yc));
														if ((fabs(zc - (b[i1].g.zC + hloc)) < epsToolz) || (fabs(zc + (b[i1].g.zC + hloc)) < epsToolz)) {
															oc->dlist = false; // будем дробить
															goto DROBIM_NOW;
														}
													}
												}
											}
											else {
												// С внутренним радиусом.

											}
											break;
										}
									}
								}
							}
						}
					}
				}

				// WE
				for (int  i = minx + 1; i < maxx; ++i) {
					for (int  j = miny; j < maxy; ++j) {
						for (int  k = minz; k < maxz; ++k) {
							doublereal xc = xpos[i];
							doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
							doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
							for (integer i1 = 0; i1 < lb; i1++) {
								if (b[i1].g.itypegeom == PRISM) {
									// Prism
									if ((zc > b[i1].g.zS) && (zc < b[i1].g.zE) && (yc > b[i1].g.yS) && (yc < b[i1].g.yE) && ((fabs(b[i1].g.xS - xc) < epsToolx) || (fabs(b[i1].g.xE - xc) < epsToolx))) {
										oc->dlist = false; // будем дробить
										goto DROBIM_NOW;
									}
								}
								if (b[i1].g.itypegeom == CYLINDER) {
									// Cylinder
									switch (b[i1].g.iPlane) {
									case XY_PLANE:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											// без внутреннего радиуса.
											if ((zc > b[i1].g.zC) && (zc < b[i1].g.zC + b[i1].g.Hcyl)) {
												if ((yc > b[i1].g.yC - b[i1].g.R_out_cyl) && (yc < b[i1].g.yC + b[i1].g.R_out_cyl)) {
													doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.yC - yc)*(b[i1].g.yC - yc));
													if ((fabs(xc - (b[i1].g.xC + hloc)) < epsToolz) || (fabs(xc + (b[i1].g.xC + hloc)) < epsToolz)) {
														oc->dlist = false; // будем дробить
														goto DROBIM_NOW;
													}
												}
											}
										}
										else {
											// С внутренним радиусом.

										}
										break;
									case XZ_PLANE:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											// без внутреннего радиуса.
											if ((yc > b[i1].g.yC) && (yc < b[i1].g.yC + b[i1].g.Hcyl)) {
												if ((zc > b[i1].g.zC - b[i1].g.R_out_cyl) && (zc < b[i1].g.zC + b[i1].g.R_out_cyl)) {
													doublereal hloc = sqrt(b[i1].g.R_out_cyl*b[i1].g.R_out_cyl - (b[i1].g.zC - zc)*(b[i1].g.zC - zc));
													if ((fabs(xc - (b[i1].g.xC + hloc)) < epsToolz) || (fabs(xc + (b[i1].g.xC + hloc)) < epsToolz)) {
														oc->dlist = false; // будем дробить
														goto DROBIM_NOW;
													}
												}
											}
										}
										else {
											// С внутренним радиусом.

										}
										break;
									case YZ_PLANE:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											if ((sqrt((zc - b[i1].g.zC)*(zc - b[i1].g.zC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && ((fabs(b[i1].g.xC - xc) < epsToolz) || (fabs(b[i1].g.xC + b[i1].g.Hcyl - xc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}
										else {
											if ((sqrt((zc - b[i1].g.zC)*(zc - b[i1].g.zC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) < b[i1].g.R_out_cyl) && (sqrt((zc - b[i1].g.zC)*(zc - b[i1].g.zC) + (yc - b[i1].g.yC)*(yc - b[i1].g.yC)) > b[i1].g.R_in_cyl) && ((fabs(b[i1].g.xC - xc) < epsToolz) || (fabs(b[i1].g.xC + b[i1].g.Hcyl - xc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}
										break;
									}
								}
							}
						}
					}
				}
				// SN
				for (int  i = minx; i < maxx; ++i) {
					for (int  j = miny + 1; j < maxy; ++j) {
						for (int  k = minz; k < maxz; ++k) {
							doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
							doublereal yc = ypos[j];
							doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
							for (integer i1 = 0; i1 < lb; i1++) {
								if (b[i1].g.itypegeom == PRISM) {
									// Prism
									if ((zc > b[i1].g.zS) && (zc < b[i1].g.zE) && (xc > b[i1].g.xS) && (xc < b[i1].g.xE) && ((fabs(b[i1].g.yS - yc) < epsTooly) || (fabs(b[i1].g.yE - yc) < epsTooly))) {
										oc->dlist = false; // будем дробить
										goto DROBIM_NOW;
									}
								}
								if (b[i1].g.itypegeom == CYLINDER) {
									// Cylinder
									switch (b[i1].g.iPlane) {
									case XY_PLANE:

										break;
									case XZ_PLANE:
										if (b[i1].g.R_in_cyl < 1.0e-20) {
											if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (zc - b[i1].g.zC)*(zc - b[i1].g.zC)) < b[i1].g.R_out_cyl) && ((fabs(b[i1].g.yC - yc) < epsToolz) || (fabs(b[i1].g.yC + b[i1].g.Hcyl - yc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}
										else {
											if ((sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (zc - b[i1].g.zC)*(zc - b[i1].g.zC)) < b[i1].g.R_out_cyl) && (sqrt((xc - b[i1].g.xC)*(xc - b[i1].g.xC) + (zc - b[i1].g.zC)*(zc - b[i1].g.zC)) > b[i1].g.R_in_cyl) && ((fabs(b[i1].g.yC - yc) < epsToolz) || (fabs(b[i1].g.yC + b[i1].g.Hcyl - yc) < epsToolz))) {
												oc->dlist = false; // будем дробить
												goto DROBIM_NOW;
											}
										}

										break;
									case YZ_PLANE:
										break;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	else {
		// проверяем есть ли дробление
		// на блоках.
		// BT
		for (int  i = minx; i < maxx; ++i) {
			for (int  j = miny; j < maxy; ++j) {
				for (int  k = minz; k <= maxz; ++k) {
					doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
					doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
					doublereal zc = zpos[k];
					for (integer i1 = 0; i1 < lb; i1++) {
						if ((xc >= b[i1].g.xS - epsToolx) && (xc <= b[i1].g.xE + epsToolx) && (yc >= b[i1].g.yS - epsTooly) && (yc <= b[i1].g.yE + epsTooly) && ((fabs(b[i1].g.zS - zc) < epsToolz) || (fabs(b[i1].g.zE - zc) < epsToolz))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
		// WE
		for (int  i = minx; i <= maxx; ++i) {
			for (int  j = miny; j < maxy; ++j) {
				for (int  k = minz; k < maxz; ++k) {
					doublereal xc = xpos[i];
					doublereal yc = 0.5*(ypos[j] + ypos[j + 1]);
					doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
					for (integer i1 = 0; i1 < lb; i1++) {
						if ((zc >= b[i1].g.zS - epsToolz) && (zc <= b[i1].g.zE + epsToolz) && (yc >= b[i1].g.yS - epsTooly) && (yc <= b[i1].g.yE + epsTooly) && ((fabs(b[i1].g.xS - xc) < epsToolx) || (fabs(b[i1].g.xE - xc) < epsToolx))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
		// SN
		for (int  i = minx; i < maxx; ++i) {
			for (int  j = miny; j <= maxy; ++j) {
				for (int  k = minz; k < maxz; ++k) {
					doublereal xc = 0.5*(xpos[i] + xpos[i + 1]);
					doublereal yc = ypos[j];
					doublereal zc = 0.5*(zpos[k] + zpos[k + 1]);
					for (integer i1 = 0; i1 < lb; i1++) {
						if ((zc >= b[i1].g.zS - epsToolz) && (zc <= b[i1].g.zE + epsToolz) && (xc >= b[i1].g.xS - epsToolx) && (xc <= b[i1].g.xE + epsToolx) && ((fabs(b[i1].g.yS - yc) < epsTooly) || (fabs(b[i1].g.yE - yc) < epsTooly))) {
							oc->dlist = false; // будем дробить
							goto DROBIM_NOW;
						}
					}
				}
			}
		}
	}


	if (!btgf_mesh_generator) {
		

		// проверяем есть ли дробление
		// на стенках.
		if (oc->dlist) {
			// BT
//#pragma omp parallel for
			for (int i = minx; i < maxx; ++i) {
				for (int j = miny; j < maxy; ++j) {
					//for (integer k = minz + 1; k < maxz; ++k) {
					for (int k = minz; k <= maxz; ++k) {
						if (oc->dlist)
						{
							doublereal xc = 0.5 * (xpos[i] + xpos[i + 1]);
							doublereal yc = 0.5 * (ypos[j] + ypos[j + 1]);
							doublereal zc = zpos[k];
							for (integer i1 = 0; i1 < lw; i1++) {
								if ((xc > w[i1].g.xS - epsToolx) && (xc < w[i1].g.xE + epsToolx) && (yc > w[i1].g.yS - epsTooly) && (yc < w[i1].g.yE + epsTooly) && ((fabs(w[i1].g.zS - zc) < epsToolz) || (fabs(w[i1].g.zE - zc) < epsToolz))) {

//#pragma omp critical 
									{
										oc->dlist = false; // будем дробить
									}

								}
							}
						}
					}
				}
			}
		}
		if (oc->dlist) {
			// WE
			//for (integer i = minx + 1; i < maxx; ++i) {
//#pragma omp parallel for
			for (int i = minx; i <= maxx; ++i) {
				for (int j = miny; j < maxy; ++j) {
					for (int k = minz; k < maxz; ++k) {
						if (oc->dlist)
						{
							doublereal xc = xpos[i];
							doublereal yc = 0.5 * (ypos[j] + ypos[j + 1]);
							doublereal zc = 0.5 * (zpos[k] + zpos[k + 1]);
							for (integer i1 = 0; i1 < lw; i1++) {
								if ((zc > w[i1].g.zS - epsToolz) && (zc < w[i1].g.zE + epsToolz) && (yc > w[i1].g.yS - epsTooly) && (yc < w[i1].g.yE + epsTooly) && ((fabs(w[i1].g.xS - xc) < epsToolx) || (fabs(w[i1].g.xE - xc) < epsToolx))) {

//#pragma omp critical 
									{
										oc->dlist = false; // будем дробить
									}

								}
							}
						}
					}
				}
			}
		}
		if (oc->dlist) {
			// SN
//#pragma omp parallel for
			for (int i = minx; i < maxx; ++i) {
				//for (int  j = miny + 1; j < maxy; ++j) {
				for (int j = miny; j <= maxy; ++j) {
					for (int k = minz; k < maxz; ++k) {
						if (oc->dlist)
						{
							doublereal xc = 0.5 * (xpos[i] + xpos[i + 1]);
							doublereal yc = ypos[j];
							doublereal zc = 0.5 * (zpos[k] + zpos[k + 1]);
							for (integer i1 = 0; i1 < lw; i1++) {
								if ((zc > w[i1].g.zS - epsToolz) && (zc < w[i1].g.zE + epsToolz) && (xc > w[i1].g.xS - epsToolx) && (xc < w[i1].g.xE + epsToolx) && ((fabs(w[i1].g.yS - yc) < epsTooly) || (fabs(w[i1].g.yE - yc) < epsTooly))) {
//#pragma omp critical 
									{
										oc->dlist = false; // будем дробить
									}
								}
							}
						}
					}
				}
			}
		}
	}
	else {
		// В tgf серии задач стенка есть нижняя граница кабинета, дно МД40 корпуса и 
		// там не нужна очень подробная расчётная сетка.
		// Мы предполагаем, что других стенок пользователь не использует.
	}

	if (bsimpledefine) {
		// Универсальный код для всех сканирующих направлений.
		for (integer i1 = 0; i1 < ls; i1++) {
			
			// Source
			if (bold_stable_version) {
				bdrobimX = true;
				bdrobimY = true;
				bdrobimZ = true;

				doublereal eps_tolerance = 1.0e-25;
				// Oz
				if ((((xpos[maxx] - eps_tolerance > s[i1].g.xS)) && 
					((xpos[minx] + eps_tolerance < s[i1].g.xE))) && 
					(((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && 
						((ypos[miny] + eps_tolerance < s[i1].g.yE))) 
					&& (((zpos[minz] <= s[i1].g.zS) && (zpos[maxz] >= s[i1].g.zS)) ||
						((zpos[minz] <= s[i1].g.zE) && (zpos[maxz] >= s[i1].g.zE)))) {
					oc->dlist = false; // будем дробить
					goto DROBIM_NOW;
				}
				// Ox
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) &&
					((zpos[minz] + eps_tolerance < s[i1].g.zE))) && 
					(((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && 
						((ypos[miny] + eps_tolerance < s[i1].g.yE))) &&
					(((xpos[minx] <= s[i1].g.xS) && (xpos[maxx] >= s[i1].g.xS)) ||
						((xpos[minx] <= s[i1].g.xE) && (xpos[maxx] >= s[i1].g.xE)))) {
					oc->dlist = false; // будем дробить
					goto DROBIM_NOW;
				}
				// Oy
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) && 
					((zpos[minz] + eps_tolerance < s[i1].g.zE))) && 
					(((xpos[maxx] - eps_tolerance > s[i1].g.xS)) && 
						((xpos[minx] + eps_tolerance < s[i1].g.xE))) &&
					(((ypos[miny] <= s[i1].g.yS) && (ypos[maxy] >= s[i1].g.yS)) ||
						((ypos[miny] <= s[i1].g.yE) && (ypos[maxy] >= s[i1].g.yE)))) {
					oc->dlist = false; // будем дробить
					goto DROBIM_NOW;
				}


			}
			else {
				doublereal eps_tolerance = 1.0e-25;
				// Oz
				if ((((xpos[maxx] - eps_tolerance > s[i1].g.xS)) &&
					((xpos[minx] + eps_tolerance < s[i1].g.xE))) &&
					(((ypos[maxy] - eps_tolerance > s[i1].g.yS)) &&
						((ypos[miny] + eps_tolerance < s[i1].g.yE))) &&
					(((zpos[minz] <= s[i1].g.zS) && (zpos[maxz] >= s[i1].g.zS)) ||
						((zpos[minz] <= s[i1].g.zE) && (zpos[maxz] >= s[i1].g.zE)))) {
					oc->dlist = false; // будем дробить
					bdrobimX = true;
					break;
					//goto DROBIM_NOW;
				}
				// Ox
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) &&
					((zpos[minz] + eps_tolerance < s[i1].g.zE))) &&
					(((ypos[maxy] - eps_tolerance > s[i1].g.yS)) && 
						((ypos[miny] + eps_tolerance < s[i1].g.yE))) && 
					(((xpos[minx] <= s[i1].g.xS) && (xpos[maxx] >= s[i1].g.xS)) || 
						((xpos[minx] <= s[i1].g.xE) && (xpos[maxx] >= s[i1].g.xE)))) {
					oc->dlist = false; // будем дробить
					bdrobimY = true;
					break;
					//goto DROBIM_NOW;
				}
				// Oy
				if ((((zpos[maxz] - eps_tolerance > s[i1].g.zS)) &&
					((zpos[minz] + eps_tolerance < s[i1].g.zE))) && 
					(((xpos[maxx] - eps_tolerance > s[i1].g.xS)) &&
						((xpos[minx] + eps_tolerance < s[i1].g.xE))) && 
					(((ypos[miny] <= s[i1].g.yS) && (ypos[maxy] >= s[i1].g.yS)) ||
						((ypos[miny] <= s[i1].g.yE) && (ypos[maxy] >= s[i1].g.yE)))) {
					oc->dlist = false; // будем дробить
					bdrobimZ = true;
					break;
					//goto DROBIM_NOW;
				}

				if (bdrobimX || bdrobimY || bdrobimZ) {
					goto DROBIM_NOW;
				}

			}
			
		}
	}
	else {

		if (bold_stable_version) {
			// Переменным bdrobim присвоено тоже значение что
			// и в самом начале функции при инициализации.
			//bdrobimX = true;
			//bdrobimY = true;
			//bdrobimZ = true;

			if (ls > 0) {
				// проверяем есть ли дробление
				// на источниках тепла.
				if (oc->dlist) {
					// BT
//#pragma omp parallel for
					for (int i = minx; i < maxx; ++i) {
						for (int j = miny; j < maxy; ++j) {
							//for (integer k = minz + 1; k < maxz; ++k) {
							for (int k = minz; k <= maxz; ++k) {
								if (oc->dlist) {
									doublereal xc = 0.5 * (xpos[i] + xpos[i + 1]);
									doublereal yc = 0.5 * (ypos[j] + ypos[j + 1]);
									doublereal zc = zpos[k];
									for (integer i1 = 0; i1 < ls; i1++) {
										if ((xc > s[i1].g.xS - epsToolx) &&
											(xc < s[i1].g.xE + epsToolx) &&
											(yc > s[i1].g.yS - epsTooly) &&
											(yc < s[i1].g.yE + epsTooly) &&
											((fabs(s[i1].g.zS - zc) < epsToolz) || (fabs(s[i1].g.zE - zc) < epsToolz))) {

//#pragma omp critical
												{
													oc->dlist = false; // будем дробить
												}
										}
									}
								}
							}
						}
					}
				}
				if (oc->dlist) {
					// WE
					//for (integer i = minx + 1; i < maxx; ++i) {
//#pragma omp parallel for
					for (int i = minx; i <= maxx; ++i) {
						for (int j = miny; j < maxy; ++j) {
							for (int k = minz; k < maxz; ++k) {
								if (oc->dlist) {
									doublereal xc = xpos[i];
									doublereal yc = 0.5 * (ypos[j] + ypos[j + 1]);
									doublereal zc = 0.5 * (zpos[k] + zpos[k + 1]);
									for (integer i1 = 0; i1 < ls; i1++) {
										if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.xS - xc) < epsToolx) || (fabs(s[i1].g.xE - xc) < epsToolx))) {

//#pragma omp critical
											{
												oc->dlist = false; // будем дробить
											}
										}
									}
								}
							}
						}
					}
				}
				if (oc->dlist) {
					// SN
//#pragma omp parallel for
					for (int i = minx; i < maxx; ++i) {
						//for (integer j = miny + 1; j < maxy; ++j) {
						for (int j = miny; j <= maxy; ++j) {
							for (int k = minz; k < maxz; ++k) {
								if (oc->dlist) {
									doublereal xc = 0.5 * (xpos[i] + xpos[i + 1]);
									doublereal yc = ypos[j];
									doublereal zc = 0.5 * (zpos[k] + zpos[k + 1]);
									for (integer i1 = 0; i1 < ls; i1++) {
										if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && ((fabs(s[i1].g.yS - yc) < epsTooly) || (fabs(s[i1].g.yE - yc) < epsTooly))) {

//#pragma omp critical
											{
												oc->dlist = false; // будем дробить
											}

										}
									}
								}
							}
						}
					}
				}
			}
		}
		else {

			if (ls > 0) {
				// проверяем есть ли дробление
				// на источниках тепла.
				if (oc->dlist) {
					// BT
//#pragma omp parallel for
					for (int i = minx; i < maxx; ++i) {
						for (int j = miny; j < maxy; ++j) {
							//for (integer k = minz + 1; k < maxz; ++k) {
							for (int k = minz; k <= maxz; ++k) {
								if (oc->dlist) {
									doublereal xc = 0.5 * (xpos[i] + xpos[i + 1]);
									doublereal yc = 0.5 * (ypos[j] + ypos[j + 1]);
									doublereal zc = zpos[k];
									for (integer i1 = 0; i1 < ls; i1++) {
										if ((xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.zS - zc) < epsToolz) || (fabs(s[i1].g.zE - zc) < epsToolz))) {

//#pragma omp critical 
											{
												oc->dlist = false; // будем дробить
												bdrobimZ = true;
											}

										}
									}
								}
							}
						}
					}
				}
				if (oc->dlist) {
					// WE
					//for (integer i = minx + 1; i < maxx; ++i) {
//#pragma omp parallel for
					for (int i = minx; i <= maxx; ++i) {
						for (int j = miny; j < maxy; ++j) {
							for (int k = minz; k < maxz; ++k) {
								if (oc->dlist) {
									doublereal xc = xpos[i];
									doublereal yc = 0.5 * (ypos[j] + ypos[j + 1]);
									doublereal zc = 0.5 * (zpos[k] + zpos[k + 1]);
									for (integer i1 = 0; i1 < ls; i1++) {
										if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (yc > s[i1].g.yS - epsTooly) && (yc < s[i1].g.yE + epsTooly) && ((fabs(s[i1].g.xS - xc) < epsToolx) || (fabs(s[i1].g.xE - xc) < epsToolx))) {

//#pragma omp critical 
											{
												oc->dlist = false; // будем дробить
												bdrobimX = true;
											}

										}
									}
								}
							}
						}
					}
				}

				if (oc->dlist) {
					// SN
//#pragma omp parallel for
					for (int i = minx; i < maxx; ++i) {
						//for (integer j = miny + 1; j < maxy; ++j) {
						for (int j = miny; j <= maxy; ++j) {
							for (int k = minz; k < maxz; ++k) {
								if (oc->dlist) {
									doublereal xc = 0.5 * (xpos[i] + xpos[i + 1]);
									doublereal yc = ypos[j];
									doublereal zc = 0.5 * (zpos[k] + zpos[k + 1]);
									for (integer i1 = 0; i1 < ls; i1++) {
										if ((zc > s[i1].g.zS - epsToolz) && (zc < s[i1].g.zE + epsToolz) && (xc > s[i1].g.xS - epsToolx) && (xc < s[i1].g.xE + epsToolx) && ((fabs(s[i1].g.yS - yc) < epsTooly) || (fabs(s[i1].g.yE - yc) < epsTooly))) {

//#pragma omp critical 
											{
												oc->dlist = false; // будем дробить
												bdrobimY = true;
											}

										}
									}
								}
							}
						}
					}
				}


				if (bdrobimX || bdrobimY || bdrobimZ) {
					goto DROBIM_NOW;
				}
			}

		}
	}
	
DROBIM_NOW:

	integer  iret = 0;

	if (bVerySimpleGeometryforALICE&&oc->dlist) {
		// 21.01.2018.
		// Исключительная ситуация: расчётная область состоит из кубика по размерам Cabinet и не содержит внутри внутренних перегородок.
		// Мы принимаем решение дробить такую ситуацию до достижения структурированной сетки.
		// Структурированная сетка является частным случаем АЛИС сетки.

		if ((minx == maxx - 1) && (miny == maxy - 1) && (minz == maxz - 1)) {
			// Достигнут уровень первоначальной расчётной сетки.


			//system("PAUSE");
			// лист.
			// minx, maxx, miny, maxy, minz, maxz
			// Количество соседей по видимому правильно посчитано прежде.
			oc->p0.x = xpos[minx];
			oc->p0.y = ypos[miny];
			oc->p0.z = zpos[minz];
			oc->p1.x = xpos[maxx];
			oc->p1.y = ypos[miny];
			oc->p1.z = zpos[minz];
			oc->p2.x = xpos[minx];
			oc->p2.y = ypos[maxy];
			oc->p2.z = zpos[minz];
			oc->p3.x = xpos[maxx];
			oc->p3.y = ypos[maxy];
			oc->p3.z = zpos[minz];
			oc->p4.x = xpos[minx];
			oc->p4.y = ypos[miny];
			oc->p4.z = zpos[maxz];
			oc->p5.x = xpos[maxx];
			oc->p5.y = ypos[miny];
			oc->p5.z = zpos[maxz];
			oc->p6.x = xpos[minx];
			oc->p6.y = ypos[maxy];
			oc->p6.z = zpos[maxz];
			oc->p7.x = xpos[maxx];
			oc->p7.y = ypos[maxy];
			oc->p7.z = zpos[maxz];
			oc->link0 = nullptr;
			oc->link1 = nullptr;
			oc->link2 = nullptr;
			oc->link3 = nullptr;
			oc->link4 = nullptr;
			oc->link5 = nullptr;
			oc->link6 = nullptr;
			oc->link7 = nullptr;
			//oc->b_the_geometric_fragmentation = false;
			// Исправлено 31.08.2016
			// Он обязательно лист, но лист который геометрически не дробится на части.
			// этот лист должен дробится при балансировке !!!
			oc->dlist = true;


		}
		else {

			oc->dlist = false;
			bdrobimX = true;
			bdrobimY = true;
			bdrobimZ = true;

			// Данное дробление вызвано чисто геометрической причиной и это
			// никак не дробление балансировки.
			const bool b_crushing_when_balancing_now = false;
			droblenie_internal(oc, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret, b_crushing_when_balancing_now, bdrobimX, bdrobimY, bdrobimZ,b, GSep);
		}
	}
	else {

		bVerySimpleGeometryforALICE = false;

		if (!oc->dlist) {
			// Данное дробление вызвано чисто геометрической причиной и это
			// никак не дробление балансировки.
			const bool b_crushing_when_balancing_now = false;
			droblenie_internal(oc, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret, b_crushing_when_balancing_now, bdrobimX, bdrobimY, bdrobimZ,b, GSep);
		}
		else {
			// Эта ячейка уже была создана до этого момента (память уже была выделена),
			// поэтому мы просто не трогаем эту ячейку в плане соседства в данном месте кода.

			/*
			//printf("list popal\n");
			integer i_X, i_Y, i_Z;
			if (oc->brootSituationX) {
				i_X = 1;
			}
			else {
				i_X = 0;
			}
			if (oc->brootSituationY) {
				i_Y = 1;
			}
			else {
				i_Y = 0;
			}
			if (oc->brootSituationZ) {
				i_Z = 1;
			}
			else {
				i_Z = 0;
			}
			integer i_X1, i_Y1, i_Z1;

			if (oc->parent->minx + 1 == oc->parent->maxx) {
				i_X1 = 1;
			}
			else {
				i_X1 = 0;
			}
			if (oc->parent->miny + 1 == oc->parent->maxx) {
				i_Y1 = 1;
			}
			else {
				i_Y1 = 0;
			}
			if (oc->parent->minz + 1 == oc->parent->maxz) {
				i_Z1 = 1;
			}
			else {
				i_Z1 = 0;
			}
			*/
#if doubleintprecision == 1
			//printf("root=%lld ilevel=%lld\n",oc->root,oc->ilevel);
			//printf("E=%lld W=%lld N=%lld S=%lld T=%lld B=%lld\n", oc->maxEneighbour, oc->maxWneighbour, oc->maxNneighbour, oc->maxSneighbour, oc->maxTneighbour, oc->maxBneighbour);
			//printf("X=%lld Y=%lld Z=%lld %lld %lld %lld \n", i_X, i_Y, i_Z, i_X1, i_Y1, i_Z1);
#else
			//printf("root=%d ilevel=%d\n",oc->root,oc->ilevel);
			//printf("E=%d W=%d N=%d S=%d T=%d B=%d\n", oc->maxEneighbour, oc->maxWneighbour, oc->maxNneighbour, oc->maxSneighbour, oc->maxTneighbour, oc->maxBneighbour);
			//printf("X=%d Y=%d Z=%d %d %d %d \n", i_X, i_Y, i_Z, i_X1, i_Y1, i_Z1);
#endif
		//system("PAUSE");
		// лист.
		// minx, maxx, miny, maxy, minz, maxz
		// Количество соседей по видимому правильно посчитано прежде.
			oc->p0.x = xpos[minx];
			oc->p0.y = ypos[miny];
			oc->p0.z = zpos[minz];
			oc->p1.x = xpos[maxx];
			oc->p1.y = ypos[miny];
			oc->p1.z = zpos[minz];
			oc->p2.x = xpos[minx];
			oc->p2.y = ypos[maxy];
			oc->p2.z = zpos[minz];
			oc->p3.x = xpos[maxx];
			oc->p3.y = ypos[maxy];
			oc->p3.z = zpos[minz];
			oc->p4.x = xpos[minx];
			oc->p4.y = ypos[miny];
			oc->p4.z = zpos[maxz];
			oc->p5.x = xpos[maxx];
			oc->p5.y = ypos[miny];
			oc->p5.z = zpos[maxz];
			oc->p6.x = xpos[minx];
			oc->p6.y = ypos[maxy];
			oc->p6.z = zpos[maxz];
			oc->p7.x = xpos[maxx];
			oc->p7.y = ypos[maxy];
			oc->p7.z = zpos[maxz];
			oc->link0 = nullptr;
			oc->link1 = nullptr;
			oc->link2 = nullptr;
			oc->link3 = nullptr;
			oc->link4 = nullptr;
			oc->link5 = nullptr;
			oc->link6 = nullptr;
			oc->link7 = nullptr;
			//oc->b_the_geometric_fragmentation = false;
			// Исправлено 31.08.2016
			// Он обязательно лист, но лист который геометрически не дробится на части.
			// этот лист должен дробится при балансировке !!!
			oc->dlist = true;


		}
	}



	return iret;
}


// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Emultineighbour_patch(octree* &octree1) {
	// 4 соседа.
	char icsos = 0;
	if (octree1->linkE1 != nullptr) {
		if (is_null(octree1->linkE1)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE1)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE1, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	if (octree1->linkE2 != nullptr) {
		if (is_null(octree1->linkE2)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE2)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE2, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	if (octree1->linkE5 != nullptr) {
		if (is_null(octree1->linkE5)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE5)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE5, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	if (octree1->linkE6 != nullptr) {
		if (is_null(octree1->linkE6)) {
			icsos++;
		}
		else if (is_null1(octree1->linkE6)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkE6, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c3 + c4 + c7;
		}
	}
	octree1->maxEneighbour = icsos;
} // Emultineighbour_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Wmultineighbour_patch(octree* &octree1) {
	// 4 соседа.
	char icsos = 0;
	if (octree1->linkW0 != nullptr) {
		if (is_null(octree1->linkW0)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW0)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW0, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	if (octree1->linkW3 != nullptr) {
		if (is_null(octree1->linkW3)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW3)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW3, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	if (octree1->linkW4 != nullptr) {
		if (is_null(octree1->linkW4)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW4)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW4, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	if (octree1->linkW7 != nullptr) {
		if (is_null(octree1->linkW7)) {
			icsos++;
		}
		else if (is_null1(octree1->linkW7)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkW7, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c1 + c2 + c5 + c6;
		}
	}
	octree1->maxWneighbour = icsos;
} // Wmultineighbour_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Nmultineighbour_patch(octree* &octree1) {
	// 4 соседа.
	char icsos = 0;
	if (octree1->linkN2 != nullptr) {
		if (is_null(octree1->linkN2)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN2)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN2, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}
	if (octree1->linkN3 != nullptr) {
		if (is_null(octree1->linkN3)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN3)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN3, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}
	if (octree1->linkN6 != nullptr) {
		if (is_null(octree1->linkN6)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN6)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN6, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}
	if (octree1->linkN7 != nullptr) {
		if (is_null(octree1->linkN7)) {
			icsos++;
		}
		else if (is_null1(octree1->linkN7)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkN7, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c4 + c5;
		}
	}

	//integer i_X = 0;
	//integer i_Y = 0;
	//integer i_Z = 0;
	//if (octree1->brootSituationX) i_X = 1;
	//if (octree1->brootSituationY) i_Y = 1;
	//if (octree1->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
	//printf("WARNING !!! incomming Nmultineighbour_patch %lld X=%lld Y=%lld Z=%lld\n",icsos,i_X,i_Y,i_Z);
#else
	//printf("WARNING !!! incomming Nmultineighbour_patch %d X=%d Y=%d Z=%d\n",icsos,i_X,i_Y,i_Z);
#endif
	//system("PAUSE");
	octree1->maxNneighbour = icsos;

} //  Nmultineighbour_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Smultineighbour_patch(octree* &octree1) {
	// 4 соседа.
	char icsos = 0;
	if (octree1->linkS0 != nullptr) {
		if (is_null(octree1->linkS0)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS0)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS0, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	if (octree1->linkS1 != nullptr) {
		if (is_null(octree1->linkS1)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS1)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS1, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	if (octree1->linkS4 != nullptr) {
		if (is_null(octree1->linkS4)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS4)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS4, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	if (octree1->linkS5 != nullptr) {
		if (is_null(octree1->linkS5)) {
			icsos++;
		}
		else if (is_null1(octree1->linkS5)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkS5, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c2 + c3 + c6 + c7;
		}
	}
	octree1->maxSneighbour = icsos;

} //  Smultineighbour_patch


// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Bmultineighbour_patch(octree* &octree1) {
	// 4 соседа.
	char icsos = 0;
	if (octree1->linkB0 != nullptr) {
		if (is_null(octree1->linkB0)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB0)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB0, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	if (octree1->linkB1 != nullptr) {
		if (is_null(octree1->linkB1)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB1)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB1, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	if (octree1->linkB2 != nullptr) {
		if (is_null(octree1->linkB2)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB2)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB2, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	if (octree1->linkB3 != nullptr) {
		if (is_null(octree1->linkB3)) {
			icsos++;
		}
		else if (is_null1(octree1->linkB3)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkB3, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c4 + c5 + c6 + c7;
		}
	}
	octree1->maxBneighbour = icsos;
} // Bmultineighbour_patch

// Подсчёт вторичных соседей в случае четырёх первичных соседей.
void Tmultineighbour_patch(octree* &octree1) {
	// 4 соседа.
	char icsos = 0;
	if (octree1->linkT4 != nullptr) {
		if (is_null(octree1->linkT4)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT4)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT4, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	if (octree1->linkT5 != nullptr) {
		if (is_null(octree1->linkT5)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT5)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT5, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	if (octree1->linkT6 != nullptr) {
		if (is_null(octree1->linkT6)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT6)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT6, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	if (octree1->linkT7 != nullptr) {
		if (is_null(octree1->linkT7)) {
			icsos++;
		}
		else if (is_null1(octree1->linkT7)) {
			icsos += 4;
		}
		else {
			char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
			is_null3(octree1->linkT7, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
			icsos += c0 + c1 + c2 + c3;
		}
	}
	octree1->maxTneighbour = icsos;

} //Tmultineighbour_patch


void log_cs(octree* &octree1) {
	printf("logcs incomming brootSituationX");
	system("PAUSE");
	// octree1 это лист. Situation это ситуация в octree1->parent.
	bool bSituationX = octree1->brootSituationX;
	bool bSituationY = octree1->brootSituationY;
	bool bSituationZ = octree1->brootSituationZ;
	bool bonly_dir_X = false;
	bool bonly_dir_Y = false;
	bool bonly_dir_Z = false;
	if (bSituationX && (bSituationY) && (!bSituationZ)) {
		bonly_dir_Z = true;
	}
	if (bSituationX && (bSituationZ) && (!bSituationY)) {
		bonly_dir_Y = true;
	}
	if (bSituationY && (bSituationZ) && (!bSituationX)) {
		bonly_dir_X = true;
	}

	// работаем с octree1
	switch (octree1->root) {
	case 0:

		if (octree1->b4T) { // + 2.09.2016 12.30
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.
					if (bSituationZ) {
						// Вырождение по OZ.

						if (octree1->linkT != nullptr) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								printf("T root 0 is_null _1");
								octree1->maxTneighbour = 1;
							}
							else if (is_null1(octree1->linkT)) {

								if ((bonly_dir_X) || (bonly_dir_Y)) {
									printf("T root 0 is_null1 dirX || dirY _2 ");
									octree1->maxTneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									printf("T root 0 is_null1 _1");
									octree1->maxTneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X) || (bonly_dir_Y)) {
									if (bonly_dir_X) {
										// дробим только по оси Ох.
										printf("TSIDE root 0 is_null3 _c0+c3");
										octree1->maxTneighbour = c0 + c3;
									}
									if (bonly_dir_Y) {
										// дробим только по оси Oy.
										printf("TSIDE root 0 is_null3 _c0+c1");
										octree1->maxTneighbour = c0 + c1;
									}
								}
								else {
									//octree1->maxTneighbour = 4;
									printf("TSIDE root 0 is_null3 _c0");
									octree1->maxTneighbour = c0;
								}
							}
						}
						else {
							// 0 остаётся 0.
							printf("TSIDE root 0 nullptr 0");
							octree1->maxTneighbour = 0;
						}

					}
					else {
						// это была внутренняя ячейка.
						printf("TSIDE root 0 not bSituation Z.");
						octree1->maxTneighbour = 1;

					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (octree1->linkT != nullptr) {
						if (is_null(octree1->linkT)) {
							// 1 остаётся 1.
							printf("TSIDE root 0 root na odnom urovne is_null _1");
							octree1->maxTneighbour = 1;
						}
						else if (is_null1(octree1->linkT)) {
							printf("TSIDE root 0 root na odnom urovne is_null1 _4");
							octree1->maxTneighbour = 4;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

							//octree1->maxTneighbour = 4;
							printf("TSIDE root 0 na odnom urovne is_null3 _c0+c1+c2+c3");
							octree1->maxTneighbour = c0 + c1 + c2 + c3;
						}
					}
					else {
						// 0 остаётся 0.
						printf("TSIDE root 0 nullptr _0");
						octree1->maxTneighbour = 0;
					}
				}
			}
			else {
				// 0 остаётся 0.
				printf("TSIDE root 0 nullptr _0");
				octree1->maxTneighbour = 0;
			}
		}

		// root==0	
		if (octree1->b4N) {// + 2.09.2016 12.30
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.
					if (bSituationY) {

						if (octree1->linkN != nullptr) {
							if (is_null(octree1->linkN)) {
								// 1 остаётся 1.
								printf("N root 0 is_null _1");
								octree1->maxNneighbour = 1;
							}
							else if (is_null1(octree1->linkN)) {
								if ((bonly_dir_X) || (bonly_dir_Z)) {
									printf("N root 0 dirX or dir Z is_null1 _2");
									octree1->maxNneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									printf("N root 0  is_null1 _1");
									octree1->maxNneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X) || (bonly_dir_Z)) {
									if (bonly_dir_X) {
										printf("NSIDE root 0  dir X is_null3 _c0+c4");
										octree1->maxNneighbour = c0 + c4;
									}
									if (bonly_dir_Z) {
										printf("NSIDE root 0  dir Z is_null3 _c0+c1");
										octree1->maxNneighbour = c0 + c1;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxNneighbour = 4;
									// 4_2
									printf("N root 0 is_null3 _c0\n");
#if doubleintprecision == 1
									printf("octree1->ilevel=%c octree1->linkN->ilevel=%c c0=%c\n", octree1->ilevel, octree1->linkN->ilevel, c0);
#else
									printf("octree1->ilevel=%c octree1->linkN->ilevel=%c c0=%c\n", octree1->ilevel, octree1->linkN->ilevel, c0);
#endif
										octree1->maxNneighbour = c0;
								}
							}
						}
						else {
							// 0 остаётся 0.
							printf("nullptr 0");
							octree1->maxNneighbour = 0;
						}

					}
					else {
						printf("not bSituation Y");
						octree1->maxNneighbour = 1;
					}

				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.

					if (octree1->linkN != nullptr) {
						if (is_null(octree1->linkN)) {
							// 1 остаётся 1.
							printf("N root 0 na odnom urovne is_null _1");
							octree1->maxNneighbour = 1;
						}
						else if (is_null1(octree1->linkN)) {
							printf("N root 0 na odnom urovne is_null1 _4");
							// две четверные стороны прилегают друг к дружке.
							octree1->maxNneighbour = 4;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							printf("N root 0 na odnom urovne is_null3 _c0+c1+c4+c5");
							// других вариантов быть не может, здесь только 4.
							//octree1->maxNneighbour = 4;
							octree1->maxNneighbour = c0 + c1 + c4 + c5;

						}
					}
					else {
						printf("NSIDE root 0 nullptr na odnom urovne\n");
						// 0 остаётся 0.
						octree1->maxNneighbour = 0;
					}

				}
			}
			else {
				// 0 остаётся 0.
				printf("N root 0 nullptr na odnom urovne\n");
				octree1->maxNneighbour = 0;
			}
		}


		if (octree1->b4E) {
			// 4 соседа.
			Emultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.
					if (bSituationX) {


						if (octree1->linkE != nullptr) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEneighbour = 1;
							}
							else if (is_null1(octree1->linkE)) {
								if ((bonly_dir_Z) || (bonly_dir_Y)) {
									octree1->maxEneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxEneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Y) || (bonly_dir_Z)) {
									if (bonly_dir_Y) {
										// дробим только по оси Oy.
										octree1->maxEneighbour = c0 + c4;
									}
									if (bonly_dir_Z) {
										// дробим только по оси Oz.
										octree1->maxEneighbour = c0 + c3;
									}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxEneighbour = 4;
									octree1->maxEneighbour = c0;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEneighbour = 0;
						}

					}
					else {
						octree1->maxEneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (octree1->linkE != nullptr) {
						if (is_null(octree1->linkE)) {
							// 1 остаётся 1.
							octree1->maxEneighbour = 1;
						}
						else if (is_null1(octree1->linkE)) {
							// две четверные стороны прилегают друг к дружке.
							octree1->maxEneighbour = 4;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

							// других вариантов быть не может, здесь только 4.
							//octree1->maxEneighbour = 4;
							octree1->maxEneighbour = c0 + c3 + c4 + c7;

						}
					}
					else {
						// 0 остаётся 0.
						octree1->maxEneighbour = 0;
					}
				}
			}
			else {
				// nullptr 
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}

		if (octree1->b4W) {
			// 4 соседа.
			Wmultineighbour_patch(octree1);
		}
		else {
			// Должно быть уменьшение при дроблении:
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях.

					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWneighbour = c1 + c2;
						}
					}
					else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWneighbour = c1 + c5;
						}
					}
					else {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							if (bonly_dir_Y){
								octree1->maxWneighbour = 2;
							}
							else if (bonly_dir_Z) {
								octree1->maxWneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxWneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxWneighbour = 4;
							if (bonly_dir_Y) {
								octree1->maxWneighbour = c1 + c5;
							}
							else if (bonly_dir_Z) {
								octree1->maxWneighbour = c1 + c2;
							}
							else {
								octree1->maxWneighbour = c1;
							}

						}
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWneighbour = 4;
						octree1->maxWneighbour = c1 + c2 + c5 + c6;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWneighbour = 0;
			}
		}


		if (octree1->b4S) {
			// 4 соседа.
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.


					if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSneighbour = c3 + c2;
						}
					}
					else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSneighbour = c3 + c7;
						}
					}
					else {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							if (bonly_dir_Z) {
								octree1->maxSneighbour = 2;
							}
							else if (bonly_dir_X) {
								octree1->maxSneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxSneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							if (bonly_dir_Z) {
								octree1->maxSneighbour = c3 + c2;
							}
							else if (bonly_dir_X) {
								octree1->maxSneighbour = c3 + c7;
							}
							else {
								//octree1->maxSneighbour = 4;
								octree1->maxSneighbour = c3;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// Один контачит с четырьмя.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.

						//octree1->maxSneighbour = 4;
						octree1->maxSneighbour = c3 + c2 + c6 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSneighbour = 0;
			}
		}

		if (octree1->b4B) {
			// 4 соседа.
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// На разных уровнях.


					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBneighbour = c4 + c7;
						}
					}
					else if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBneighbour = c4 + c5;
						}
					}
					else {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							if (bonly_dir_Y) {
								octree1->maxBneighbour = 2;
							}
							else if (bonly_dir_X) {
								octree1->maxBneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxBneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_Y) {
								octree1->maxBneighbour = c4 + c5;
							}
							else if (bonly_dir_X) {
								octree1->maxBneighbour = c4 + c7;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxBneighbour = 4;
								octree1->maxBneighbour = c4;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четырём четвертинкам.
						octree1->maxBneighbour = 4;

					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxBneighbour = 4;
						octree1->maxBneighbour = c4 + c5 + c6 + c7;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBneighbour = 0;
			}
		}
		break;
	case 1:

		if (octree1->b4T) { // +
			// 4 соседа.
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.

					if (bSituationZ) {


						// Вырождение по OZ.
						if (octree1->linkT != nullptr) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								octree1->maxTneighbour = 1;
							}
							else if (is_null1(octree1->linkT)) {
								if (bonly_dir_X) {
									octree1->maxTneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxTneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X)) {
									//if (bonly_dir_X) {
										// дробим только по оси Oy.
										octree1->maxTneighbour = c1 + c2;
									//}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// может быть  2, 4, 5, 8
									//octree1->maxTneighbour = 4;
									octree1->maxTneighbour = c1;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxTneighbour = 0;
						}
					}
					else {
						octree1->maxTneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// однушка прилегает к четвертушке.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// может быть  2, 4, 5, 8
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c1 + c0 + c2 + c3;

					}
				}
			}
			else {
				// nullptr
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}

		if (octree1->b4N) { // + 2.sept.2016 13.59
			// 4 соседа.
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.
					if (bSituationY) {


						if (octree1->linkN != nullptr) {
							if (is_null(octree1->linkN)) {
								// 1 остаётся 1.
								octree1->maxNneighbour = 1;
							}
							else if (is_null1(octree1->linkN)) {
								if (bonly_dir_X) {
									octree1->maxNneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxNneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_X)) {
									//if (bonly_dir_X) {
										// дробим только по оси Oy.
										octree1->maxNneighbour = c1 + c5;
									//}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxNneighbour = 4;
									octree1->maxNneighbour = c1;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxNneighbour = 0;
						}

					}
					else {
						octree1->maxNneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c1 + c0 + c4 + c5;

					}
				}
			}
			else {
				// nullptr.
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}

		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxWneighbour = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxWneighbour = 0;
			}
		}



		if (octree1->b4E) {// +
			// 4 соседа.
			Emultineighbour_patch(octree1);
		}
		else {
			// Должно быть уменьшение при дроблении:
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c0;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c0 + c3 + c4 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}


		if (octree1->b4S) {// +
			// 4 соседа.
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.


					if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSneighbour = c2 + c6;
						}
					}
					else {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							if (bonly_dir_X) {
								octree1->maxSneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxSneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_X) {
								octree1->maxSneighbour = c2 + c6;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxSneighbour = 4;
								octree1->maxSneighbour = c2;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxSneighbour = 4;
						octree1->maxSneighbour = c2 + c3 + c6 + c7;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSneighbour = 0;
			}
		}

		if (octree1->b4B) {// +
			// 4 соседа.
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// На разных уровнях.


					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBneighbour = c5 + c6;
						}
					}
					else {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							if (bonly_dir_X) {
								octree1->maxBneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxBneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_X) {
								octree1->maxBneighbour = c5 + c6;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxBneighbour = 4;
								octree1->maxBneighbour = c5;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четветушке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxBneighbour = 4;
						octree1->maxBneighbour = c5 + c4 + c6 + c7;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBneighbour = 0;
			}
		}
		break;
	case 2:


		if (octree1->b4T) { // +
			// 4 соседа.
			Tmultineighbour_patch(octree1);
		}
		else {

			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.


					if (bSituationZ) {
						// Вырождение по OZ.


						if (octree1->linkT != nullptr) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								octree1->maxTneighbour = 1;
							}
							else if (is_null1(octree1->linkT)) {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxTneighbour = 1;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								// других вариантов быть не может, здесь только 4.
								//octree1->maxTneighbour = 4;
								octree1->maxTneighbour = c2;
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxTneighbour = 0;
						}

					}
					else {
						octree1->maxTneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.

					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c2 + c0 + c1 + c3;
					}
				}

			}
			else {
				// nullptr
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}



		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxSneighbour = c6 + c7 + c2 + c3;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxSneighbour = 0;
			}
		}


		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxWneighbour = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxWneighbour = 0;
			}
		}


		if (octree1->b4E) { // + 2.sept.2016 14:27
			// 4 соседа.
			Emultineighbour_patch(octree1);
		}
		else {
			// Должно быть уменьшение при дроблении:
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c3;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c3 + c0 + c4 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}


		if (octree1->b4N) {// + 
			// 4 соседа.
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c1 + c0 + c4 + c5;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}


		if (octree1->b4B) {
			// 4 соседа.
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {

					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxBneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxBneighbour = 4;
						octree1->maxBneighbour = c6;
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxBneighbour = 4;
						octree1->maxBneighbour = c6 + c5 + c7 + c4;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBneighbour = 0;
			}
		}


		break;
	case 3:

		if (octree1->b4T) {  // + 2.september 2016 17:47
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.


					if (bSituationZ) {
						// Вырождение по OZ.

						if (octree1->linkT != nullptr) {
							if (is_null(octree1->linkT)) {
								// 1 остаётся 1.
								octree1->maxTneighbour = 1;
							}
							else if (is_null1(octree1->linkT)) {
								if (bonly_dir_Y) {
									octree1->maxTneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxTneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Y)) {
									//if (bonly_dir_Y) {
										// дробим только по оси Oy.
										octree1->maxTneighbour = c3 + c2;
									//}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// может быть 2, 4, 5, 8.
									//octree1->maxTneighbour = 4;
									octree1->maxTneighbour = c3;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxTneighbour = 0;
						}

					}
					else {
						octree1->maxTneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {

						// Целая прилегает к четырём четвертинкам.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c3 + c0 + c1 + c2;
					}
				}
			}
			else {
				// nullptr:
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}


		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxSneighbour = c2 + c3 + c6 + c7;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxSneighbour = 0;
			}
		}


		if (octree1->b4E) { // + 2.september.2016 17:41
			Emultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (bSituationX) {


						if (octree1->linkE != nullptr) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEneighbour = 1;
							}
							else if (is_null1(octree1->linkE)) {
								if (bonly_dir_Y) {
									octree1->maxEneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxEneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Y)) {
									//if (bonly_dir_Y) {
										// дробим только по оси Oy.
										octree1->maxEneighbour = c3 + c7;
									//}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// Может быть 2, 4, 5, 8
									//octree1->maxEneighbour = 4;
									octree1->maxEneighbour = c3;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEneighbour = 0;
						}

					}
					else {
						octree1->maxEneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {

						// однушка примыкает к четырем четвертинкам.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// Может быть 2, 4, 5, 8
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c3 + c0 + c4 + c7;
					}
				}
			}
			else {
				// nullptr;
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}

		if (octree1->b4W) { // + 2.sept.2016 17:24
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях.


					if (bSituationZ && (!bSituationX) && (!bSituationY)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWneighbour = c2 + c6;
						}
					}
					else {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							if (bonly_dir_Y) {
								octree1->maxWneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxWneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxWneighbour = 4;
							if (bonly_dir_Y) {
								octree1->maxWneighbour = c2 + c6;
							}
							else {
								octree1->maxWneighbour = c2;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка примыкает к четырём четвертинкам.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWneighbour = 4;

						octree1->maxWneighbour = c2 + c1 + c5 + c6;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWneighbour = 0;
			}
		}

		if (octree1->b4N) { // +
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.


					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c0;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// однушка примыкает к четвертинке.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c0 + c1 + c4 + c5;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}

		if (octree1->b4B) { // +
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// На разных уровнях.
					if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							// двойная прилегает к четверной.
							octree1->maxBneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxBneighbour = c7 + c6;
						}
					}
					else {
						if (is_null(octree1->linkB)) {
							// 1 остаётся 1.
							octree1->maxBneighbour = 1;
						}
						else if (is_null1(octree1->linkB)) {
							if (bonly_dir_Y) {
								octree1->maxBneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxBneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							if (bonly_dir_Y) {
								octree1->maxBneighbour = c7 + c6;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								//octree1->maxBneighbour = 4;
								octree1->maxBneighbour = c7;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остаётся 1.
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxBneighbour = 4;
						octree1->maxBneighbour = c7 + c6 + c5 + c4;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxBneighbour = 0;
			}
		}

		break;
	case 4:

		if (octree1->b4N) { // + 2.september.2016 17:10
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.


					if (bSituationY) {

						if (octree1->linkN != nullptr) {
							if (is_null(octree1->linkN)) {
								// 1 остаётся 1.
								octree1->maxNneighbour = 1;
							}
							else if (is_null1(octree1->linkN)) {
								if (bonly_dir_Z) {
									octree1->maxNneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxNneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Z)) {
									//if (bonly_dir_Z) {
										// дробим только по оси Oy.
										octree1->maxNneighbour = c4 + c5;
									//}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									// Здесь может быть 2, 4, 5, 8
									//octree1->maxNneighbour = 4;
									octree1->maxNneighbour = c4;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxNneighbour = 0;
						}

					}
					else {
						octree1->maxNneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// однушка примыкает к четырём четвертинкам.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						// Здесь может быть 2, 4, 5, 8
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c4 + c0 + c1 + c5;

					}
				}
				/*else {
				#if doubleintprecision == 1
					printf("FATAL ERROR! octree1->ilevel=%lld octree1->linkN->ilevel=%lld\n", octree1->ilevel, octree1->linkN->ilevel);
					printf("octree1->maxNneighbour=%lld\n", octree1->maxNneighbour);
				#else
					printf("FATAL ERROR! octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
					printf("octree1->maxNneighbour=%d\n", octree1->maxNneighbour);
				#endif
				
				system("PAUSE");
				}*/
			}
			else {
				// nullptr
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}

		if (octree1->b4E) { // + 2 sept 2016 16:49
			Emultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (bSituationX) {

						if (octree1->linkE != nullptr) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEneighbour = 1;
							}
							else if (is_null1(octree1->linkE)) {
								if (bonly_dir_Z) {
									octree1->maxEneighbour = 2;
								}
								else {
									// две четверные стороны прилегают друг к дружке.
									octree1->maxEneighbour = 1;
								}
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								if ((bonly_dir_Z)) {
									//if (bonly_dir_Z) {
										// дробим только по оси Oy.
										octree1->maxEneighbour = c4 + c7;
									//}
								}
								else {
									// других вариантов быть не может, здесь только 4.
									//octree1->maxEneighbour = 4;
									octree1->maxEneighbour = c4;
								}
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEneighbour = 0;
						}
					}
					else {
						octree1->maxEneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c4 + c0 + c3 + c7;
					}
				}
			}
			else {
				// nullptr
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}


		if (octree1->b4W) { // +
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях.

					if (bSituationY && (!bSituationX) && (!bSituationZ)) {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							// двойная прилегает к четверной.
							octree1->maxWneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxWneighbour = c5 + c6;
						}
					}
					else {
						if (is_null(octree1->linkW)) {
							// 1 остаётся 1.
							octree1->maxWneighbour = 1;
						}
						else if (is_null1(octree1->linkW)) {
							if (bonly_dir_Z) {
								octree1->maxWneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxWneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxWneighbour = 4;
							if (bonly_dir_Z) {
								octree1->maxWneighbour = c5 + c6;
							}
							else {
								octree1->maxWneighbour = c5;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка примыкает к четвертинкам.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWneighbour = 4;

						octree1->maxWneighbour = c5 + c1 + c2 + c6;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWneighbour = 0;
			}
		}

		if (octree1->b4S) { // + 2.september. 2016 16:59
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.


					if (bSituationX && (!bSituationY) && (!bSituationZ)) {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							// двойная прилегает к четверной.
							octree1->maxSneighbour = 2;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							octree1->maxSneighbour = c7 + c6;
						}
					}
					else {
						if (is_null(octree1->linkS)) {
							// 1 остаётся 1.
							octree1->maxSneighbour = 1;
						}
						else if (is_null1(octree1->linkS)) {
							if (bonly_dir_Z) {
								octree1->maxSneighbour = 2;
							}
							else {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxSneighbour = 1;
							}
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxSneighbour = 4;
							if (bonly_dir_Z) {
								octree1->maxSneighbour = c7 + c6;
							}
							else {
								octree1->maxSneighbour = c7;
							}
						}
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка примыкает к четырем четвертинкам.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxSneighbour = 4;

						octree1->maxSneighbour = c7 + c2 + c3 + c6;

					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSneighbour = 0;
			}
		}


		if (octree1->b4T) { // +
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c0;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// однушка примыкает к четырём четвертинкам.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c0 + c1 + c2 + c3;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}

		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxBneighbour = c4 + c5 + c6 + c7;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxBneighbour = 0;
			}
		}

		break;
	case 5:

		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxBneighbour = c4 + c5 + c6 + c7;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxBneighbour = 0;
			}
		}


		if (octree1->b4N) {// + 2.sept.2016 16:18
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (bSituationY) {
						if (is_null(octree1->linkN)) {
							// 1 остаётся 1.
							octree1->maxNneighbour = 1;
						}
						else if (is_null1(octree1->linkN)) {
							// две четверные стороны прилегают друг к дружке.
							octree1->maxNneighbour = 1;
						}
						else {
							// других вариантов быть не может, здесь только 4.
							// может быть 2, 4, 5, 8
							// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
							char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
							is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
							// других вариантов быть не может, здесь только 4.
							//octree1->maxNneighbour = 4;
							octree1->maxNneighbour = c5;
						}
					}
					else {
						octree1->maxNneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// одна ячейка прилегает к четверной.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c5 + c0 + c1 + c4;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}




		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxWneighbour = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxWneighbour = 0;
			}
		}



		if (octree1->b4E) { // +
			Emultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c4;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// одинарная ячейка прилегает к четверной.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c4 + c0 + c3 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}

		if (octree1->b4S) { // +
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// На разных уровнях.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxSneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxSneighbour = 4;
						octree1->maxSneighbour = c6;
					}
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkS)) {
						// 1 остаётся 1.
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однва ячейка прилегает к четыврём.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxSneighbour = 4;
						octree1->maxSneighbour = c6 + c2 + c3 + c7;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxSneighbour = 0;
			}
		}

		if (octree1->b4T) { // + 2 september 2016 16:14
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.


					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1; // octree1->maxTneighbour;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c1;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1; // octree1->maxTneighbour;
					}
					else if (is_null1(octree1->linkT)) {
						// одинарная ячейка прилегает к четверной.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c1 + c0 + c2 + c3;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}

		break;
	case 6:

		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxBneighbour = c4 + c5 + c6 + c7;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxBneighbour = 0;
			}
		}


		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxSneighbour = c2 + c3 + c6 + c7;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxSneighbour = 0;
			}
		}


		if (octree1->b4W) { // + 2.sept.2016 13.30
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// на разных уровнях.
					octree1->maxWneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkW)) {
						// 1 остается 1
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// однушка прилегает к четвертушке.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxWneighbour = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxWneighbour = 0;
			}
		}


		if (octree1->b4E) { // +
			Emultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c7;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одном уровнене.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c7 + c0 + c3 + c4;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}

		if (octree1->b4N) {  // +
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c5;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одном уровне.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c5 + c0 + c1 + c4;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}

		if (octree1->b4T) { // + 2 sept 2016 15:33
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c2;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c2 + c0 + c1 + c3;
					}

				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}
		break;
	case 7:


		if (octree1->b4B) { // + 2.sept.2016 13.30
			Bmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkB != nullptr) {
				//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
				if (octree1->ilevel != octree1->linkB->ilevel) {
					// на разных уровнях.
					octree1->maxBneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkB->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkB)) {
						// 1 остается 1
						octree1->maxBneighbour = 1;
					}
					else if (is_null1(octree1->linkB)) {
						// однушка прилегает к четвертушке.
						octree1->maxBneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxBneighbour = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxBneighbour = 0;
			}
		}


		if (octree1->b4S) { // + 2.sept.2016 13.30
			Smultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkS != nullptr) {
				//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
				if (octree1->ilevel != octree1->linkS->ilevel) {
					// на разных уровнях.
					octree1->maxSneighbour = 1;
				}
				else if (octree1->ilevel == octree1->linkS->ilevel) {
					// На одном уровне.
					if (is_null(octree1->linkS)) {
						// 1 остается 1
						octree1->maxSneighbour = 1;
					}
					else if (is_null1(octree1->linkS)) {
						// однушка прилегает к четвертушке.
						octree1->maxSneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkS, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxSneighbour = c1 + c2 + c5 + c6;
					}
				}
			}
			else {
				// nullptr 0 остаётся нулём.
				octree1->maxSneighbour = 0;
			}
		}

		if (octree1->b4E) { // +
			Emultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkE != nullptr) {
				//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
				if (octree1->ilevel != octree1->linkE->ilevel) {
					// На разных уровнях.
					if (bSituationX) {

						if (octree1->linkE != nullptr) {
							if (is_null(octree1->linkE)) {
								// 1 остаётся 1.
								octree1->maxEneighbour = 1;
							}
							else if (is_null1(octree1->linkE)) {
								// две четверные стороны прилегают друг к дружке.
								octree1->maxEneighbour = 1;
							}
							else {
								// других вариантов быть не может, здесь только 4.
								// может быть 2, 4, 5, 8
								// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
								char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
								is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
								// других вариантов быть не может, здесь только 4.
								//octree1->maxEneighbour = 4;
								octree1->maxEneighbour = c7;
							}
						}
						else {
							// 0 остаётся 0.
							octree1->maxEneighbour = 0;
						}
					}
					else {
						octree1->maxEneighbour = 1;
					}
				}
				else if (octree1->ilevel == octree1->linkE->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkE)) {
						// 1 остаётся 1.
						octree1->maxEneighbour = 1;
					}
					else if (is_null1(octree1->linkE)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxEneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxEneighbour = 4;
						octree1->maxEneighbour = c7 + c0 + c4 + c3;
					}
				}
			}
			else {
				// nullptr
				// 0 остаётся 0.
				octree1->maxEneighbour = 0;
			}
		}

		if (octree1->b4W) { // +
			Wmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkW != nullptr) {
				//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
				if (octree1->ilevel != octree1->linkW->ilevel) {
					// На разных уровнях


					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxWneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWneighbour = 4;
						octree1->maxWneighbour = c6;
					}
				}
				else if (octree1->ilevel == octree1->linkW->ilevel) {
					// На одинаковых уровнях
					if (is_null(octree1->linkW)) {
						// 1 остаётся 1.
						octree1->maxWneighbour = 1;
					}
					else if (is_null1(octree1->linkW)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxWneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxWneighbour = 4;
						octree1->maxWneighbour = c6 + c1 + c5 + c2;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxWneighbour = 0;
			}
		}


		if (octree1->b4N) { // +
			Nmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkN != nullptr) {
				//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
				if (octree1->ilevel != octree1->linkN->ilevel) {
					// На разных уровнях.

					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxNneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c4;
					}
				}
				else if (octree1->ilevel == octree1->linkN->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkN)) {
						// 1 остаётся 1.
						octree1->maxNneighbour = 1;
					}
					else if (is_null1(octree1->linkN)) {
						// Единичка прилегает к четвертушке.
						octree1->maxNneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxNneighbour = 4;
						octree1->maxNneighbour = c4 + c0 + c1 + c5;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxNneighbour = 0;
			}
		}


		if (octree1->b4T) { // + 2.sept.2016 15:57
			Tmultineighbour_patch(octree1);
		}
		else {
			if (octree1->linkT != nullptr) {
				//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
				if (octree1->ilevel != octree1->linkT->ilevel) {
					// На разных уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// две четверные стороны прилегают друг к дружке.
						octree1->maxTneighbour = 1;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c3;
					}
				}
				else if (octree1->ilevel == octree1->linkT->ilevel) {
					// На одинаковых уровнях.
					if (is_null(octree1->linkT)) {
						// 1 остаётся 1.
						octree1->maxTneighbour = 1;
					}
					else if (is_null1(octree1->linkT)) {
						// Единичка примыкает к четырём соседяим.
						octree1->maxTneighbour = 4;
					}
					else {
						// других вариантов быть не может, здесь только 4.
						// может быть 2, 4, 5, 8
						// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
						char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
						is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
						// других вариантов быть не может, здесь только 4.
						//octree1->maxTneighbour = 4;
						octree1->maxTneighbour = c3 + c0 + c1 + c2;
					}
				}
			}
			else {
				// 0 остаётся 0.
				octree1->maxTneighbour = 0;
			}
		}
		break;
	default: 
#if doubleintprecision == 1
		printf("error: root=%lld\n", octree1->root);
#else
		printf("error: root=%d\n", octree1->root);
#endif
		
		//system("PAUSE");
		system("PAUSE");
		exit(1);
		break;
	}
	// закончили работать.
	//octree1 = nullptr;
}

// После каждого сканирования листьев всего дерева мы должны 
// восстановить соседственные связи т.к. они  изменились после дробления.
void update_max_count_neighbour(octree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				//if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation  ) {


					octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

					// разбиение на 8.
					//integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
					//integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
					//integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
					//integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
					//integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
					//integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

					// Дробление  вызывается.
					my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
					top_ALICE_STACK--;

					// octree1 это лист. Situation это ситуация в octree1->parent.
					//printf("incomming update_max_count_neighbour");
					//system("PAUSE");
					bool bSituationX = octree1->brootSituationX;
					bool bSituationY = octree1->brootSituationY;
					bool bSituationZ = octree1->brootSituationZ;
					//bool bSituationX = octree1->brootSituationX_virtual;
					//bool bSituationY = octree1->brootSituationY_virtual;
					//bool bSituationZ = octree1->brootSituationZ_virtual;
					//octree1->brootSituationX= octree1->brootSituationX_virtual;
					//octree1->brootSituationY = octree1->brootSituationY_virtual;
					//octree1->brootSituationZ = octree1->brootSituationZ_virtual;

					bool bonly_dir_X = false;
					bool bonly_dir_Y = false;
					bool bonly_dir_Z = false;
					if (bSituationX && (bSituationY) && (!bSituationZ)) {
						bonly_dir_Z = true;
					}
					if (bSituationX && (bSituationZ) && (!bSituationY)) {
						bonly_dir_Y = true;
					}
					if (bSituationY && (bSituationZ) && (!bSituationX)) {
						bonly_dir_X = true;
					}

					// 0 остаётся 0.
					// Если что-то неопределённое то соседа просто нет
					octree1->maxTneighbour = 0;
					octree1->maxBneighbour = 0;
					octree1->maxNneighbour = 0;
					octree1->maxSneighbour = 0;
					octree1->maxEneighbour = 0;
					octree1->maxWneighbour = 0;

					// работаем с octree1
					switch (octree1->root) {
					case 0: 

						if (octree1->b4T) { // + 2.09.2016 12.30
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.
									if (bSituationZ) {
										// Вырождение по OZ.

										if (octree1->linkT != nullptr) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTneighbour = 1;
											}
											else if (is_null1(octree1->linkT)) {

												if ((bonly_dir_X) || (bonly_dir_Y)) {
													octree1->maxTneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxTneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_X) || (bonly_dir_Y)) {
													if (bonly_dir_X) {
														// дробим только по оси Ох.
														octree1->maxTneighbour = c0 + c3;
													}
													if (bonly_dir_Y) {
														// дробим только по оси Oy.
														octree1->maxTneighbour = c0 + c1;
													}
												}
												else {
													//octree1->maxTneighbour = 4;
													octree1->maxTneighbour = c0;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTneighbour = 0;
										}

									}
									else {
										// это была внутренняя ячейка.
										octree1->maxTneighbour = 1;

									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.
									if (octree1->linkT != nullptr) {
										if (is_null(octree1->linkT)) {
											// 1 остаётся 1.
											octree1->maxTneighbour = 1;
										}
										else if (is_null1(octree1->linkT)) {
												octree1->maxTneighbour = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											
												//octree1->maxTneighbour = 4;
												octree1->maxTneighbour = c0+c1+c2+c3;
										}
									}
									else {
										// 0 остаётся 0.
										octree1->maxTneighbour = 0;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}

							// root==0	
							if (octree1->b4N) {// + 2.09.2016 12.30
								Nmultineighbour_patch(octree1);
							}
							else {
								if (octree1->linkN != nullptr) {
									//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
									if (octree1->ilevel != octree1->linkN->ilevel ) {
										// На разных уровнях.
										if (bSituationY) {

											if (octree1->linkN != nullptr) {
												if (is_null(octree1->linkN)) {
													// 1 остаётся 1.
													octree1->maxNneighbour = 1;
												}
												else if (is_null1(octree1->linkN)) {
													if ((bonly_dir_X) || (bonly_dir_Z)) {
														octree1->maxNneighbour = 2;
													}
													else {
														// две четверные стороны прилегают друг к дружке.
														octree1->maxNneighbour = 1;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть 2, 4, 5, 8
													// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
													char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
													is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
													if ((bonly_dir_X) || (bonly_dir_Z)) {
														if (bonly_dir_X) {
															octree1->maxNneighbour = c0 + c4;
														}
														if (bonly_dir_Z) {
															octree1->maxNneighbour = c0 + c1;
														}
													}
													else {
														// других вариантов быть не может, здесь только 4.
														//octree1->maxNneighbour = 4;
														octree1->maxNneighbour = c0;
													}
												}
											}
											else {
												// 0 остаётся 0.
												octree1->maxNneighbour = 0;
											}

										}
										else {
											octree1->maxNneighbour = 1;
										}

									}
									else if (octree1->ilevel == octree1->linkN->ilevel) {
										// На одном уровне.

										if (octree1->linkN != nullptr) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNneighbour = 1;
											}
											else if (is_null1(octree1->linkN)) {

												// две четверные стороны прилегают друг к дружке.
												octree1->maxNneighbour = 4;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

												// других вариантов быть не может, здесь только 4.
												//octree1->maxNneighbour = 4;
												octree1->maxNneighbour = c0 + c1 + c4 + c5;

											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxNneighbour = 0;
										}

									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxNneighbour = 0;
								}
							}


							if (octree1->b4E) {
								// 4 соседа.
								Emultineighbour_patch(octree1);
							}
							else {
								if (octree1->linkE != nullptr) {
									//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
									if (octree1->ilevel != octree1->linkE->ilevel) {
										// На разных уровнях.
										if (bSituationX) {


											if (octree1->linkE != nullptr) {
												if (is_null(octree1->linkE)) {
													// 1 остаётся 1.
													octree1->maxEneighbour = 1;
												}
												else if (is_null1(octree1->linkE)) {
													if ((bonly_dir_Z) || (bonly_dir_Y)) {
														octree1->maxEneighbour = 2;
													}
													else {
														// две четверные стороны прилегают друг к дружке.
														octree1->maxEneighbour = 1;
													}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть 2, 4, 5, 8
													// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
													char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
													is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
													if ((bonly_dir_Y) || (bonly_dir_Z)) {
														if (bonly_dir_Y) {
															// дробим только по оси Oy.
															octree1->maxEneighbour = c0 + c4;
														}
														if (bonly_dir_Z) {
															// дробим только по оси Oz.
															octree1->maxEneighbour = c0 + c3;
														}
													}
													else {
														// других вариантов быть не может, здесь только 4.
														//octree1->maxEneighbour = 4;
														octree1->maxEneighbour = c0;
													}
												}
											}
											else {
												// 0 остаётся 0.
												octree1->maxEneighbour = 0;
											}

										}
										else {
											octree1->maxEneighbour = 1;
										}
									}
									else if (octree1->ilevel == octree1->linkE->ilevel) {
										// На одном уровне.
										if (octree1->linkE != nullptr) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEneighbour = 1;
											}
											else if (is_null1(octree1->linkE)) {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxEneighbour = 4;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												
													// других вариантов быть не может, здесь только 4.
													//octree1->maxEneighbour = 4;
													octree1->maxEneighbour = c0+c3+c4+c7;
												
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEneighbour = 0;
										}
									}
								}
								else {
									// nullptr 
									// 0 остаётся 0.
									octree1->maxEneighbour = 0;
								}
							}

							if (octree1->b4W) {
								// 4 соседа.
								Wmultineighbour_patch(octree1);
							}
							else {
								// Должно быть уменьшение при дроблении:
								if (octree1->linkW != nullptr) {
									//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
									if (octree1->ilevel != octree1->linkW->ilevel) {
										// На разных уровнях.

										if (bSituationY && (!bSituationX) && (!bSituationZ)) {
											if (is_null(octree1->linkW)) {
												// 1 остаётся 1.
												octree1->maxWneighbour = 1;
											}
											else if (is_null1(octree1->linkW)) {
												// двойная прилегает к четверной.
												octree1->maxWneighbour = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxWneighbour = c1 + c2;
											}
										}
										else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
											if (is_null(octree1->linkW)) {
												// 1 остаётся 1.
												octree1->maxWneighbour = 1;
											}
											else if (is_null1(octree1->linkW)) {
												// двойная прилегает к четверной.
												octree1->maxWneighbour = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxWneighbour = c1 + c5;
											}
										}
										else {
											if (is_null(octree1->linkW)) {
												// 1 остаётся 1.
												octree1->maxWneighbour = 1;
											}
											else if (is_null1(octree1->linkW)) {
												if (bonly_dir_Y){
													octree1->maxWneighbour = 2;
												}
												else if (bonly_dir_Z) {
													octree1->maxWneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxWneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxWneighbour = 4;
												if (bonly_dir_Y) {
													octree1->maxWneighbour = c1 + c5;
												}
												else if (bonly_dir_Z) {
													octree1->maxWneighbour = c1 + c2;
												}
												else {
													octree1->maxWneighbour = c1;
												}

											}
										}
									}
									else if (octree1->ilevel == octree1->linkW->ilevel) {
										// На одном уровне.
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWneighbour = 1;
										}
										else if (is_null1(octree1->linkW)) {
											// две четверные стороны прилегают друг к дружке.
											octree1->maxWneighbour = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxWneighbour = 4;
											octree1->maxWneighbour = c1+c2+c5+c6;

										}
									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxWneighbour = 0; 
								}
							}


							if (octree1->b4S) {
								// 4 соседа.
								Smultineighbour_patch(octree1);
							}
							else {
								if (octree1->linkS != nullptr) {
									//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
									if (octree1->ilevel != octree1->linkS->ilevel) {
									    // На разных уровнях.


										if (bSituationX && (!bSituationY) && (!bSituationZ)) {
											if (is_null(octree1->linkS)) {
												// 1 остаётся 1.
												octree1->maxSneighbour = 1;
											}
											else if (is_null1(octree1->linkS)) {
												// двойная прилегает к четверной.
												octree1->maxSneighbour = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxSneighbour = c3 + c2;
											}
										}
										else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
											if (is_null(octree1->linkS)) {
												// 1 остаётся 1.
												octree1->maxSneighbour = 1;
											}
											else if (is_null1(octree1->linkS)) {
												// двойная прилегает к четверной.
												octree1->maxSneighbour = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxSneighbour = c3 + c7;
											}
										}
										else {
											if (is_null(octree1->linkS)) {
												// 1 остаётся 1.
												octree1->maxSneighbour = 1;
											}
											else if (is_null1(octree1->linkS)) {
												if (bonly_dir_Z) {
													octree1->maxSneighbour = 2;
												}
												else if (bonly_dir_X) {
													octree1->maxSneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxSneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												if (bonly_dir_Z) {
													octree1->maxSneighbour = c3 + c2;
												}
												else if (bonly_dir_X) {
													octree1->maxSneighbour = c3 + c7;
												}
												else {
													//octree1->maxSneighbour = 4;
													octree1->maxSneighbour = c3;
												}
											}
										}
									}
									else if (octree1->ilevel == octree1->linkS->ilevel) {
										// На одном уровне.
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSneighbour = 1;
										}
										else if (is_null1(octree1->linkS)) {
											// Один контачит с четырьмя.
												octree1->maxSneighbour = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											
											//octree1->maxSneighbour = 4;
											octree1->maxSneighbour = c3+c2+c6+c7;
										}
									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxSneighbour = 0;
								}
							}

							if (octree1->b4B) {
								// 4 соседа.
								Bmultineighbour_patch(octree1);
							}
							else {
								if (octree1->linkB != nullptr) {
									//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
									if (octree1->ilevel != octree1->linkB->ilevel) {
										// На разных уровнях.


										if (bSituationY && (!bSituationX) && (!bSituationZ)) {
											if (is_null(octree1->linkB)) {
												// 1 остаётся 1.
												octree1->maxBneighbour = 1;
											}
											else if (is_null1(octree1->linkB)) {
												// двойная прилегает к четверной.
												octree1->maxBneighbour = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxBneighbour = c4 + c7;
											}
										}
										else if (bSituationX && (!bSituationY) && (!bSituationZ)) {
											if (is_null(octree1->linkB)) {
												// 1 остаётся 1.
												octree1->maxBneighbour = 1;
											}
											else if (is_null1(octree1->linkB)) {
												// двойная прилегает к четверной.
												octree1->maxBneighbour = 2;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												octree1->maxBneighbour = c4 + c5;
											}
										}
										else {
											if (is_null(octree1->linkB)) {
												// 1 остаётся 1.
												octree1->maxBneighbour = 1;
											}
											else if (is_null1(octree1->linkB)) {
												if (bonly_dir_Y) {
													octree1->maxBneighbour = 2;
												}
												else if (bonly_dir_X) {
													octree1->maxBneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxBneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if (bonly_dir_Y) {
													octree1->maxBneighbour = c4 + c5;
												}
												else if (bonly_dir_X) {
													octree1->maxBneighbour = c4 + c7;
												}
												else {
													// других вариантов быть не может, здесь только 4.
													//octree1->maxBneighbour = 4;
													octree1->maxBneighbour = c4;
												}
											}
										}
									}
									else if (octree1->ilevel == octree1->linkB->ilevel) {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBneighbour = 1;
										}
										else if (is_null1(octree1->linkB)) {
												// однушка прилегает к четырём четвертинкам.
												octree1->maxBneighbour = 4;
											
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											
												// других вариантов быть не может, здесь только 4.
												//octree1->maxBneighbour = 4;
												octree1->maxBneighbour = c4+c5+c6+c7;
											
										}
									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxBneighbour = 0;
								}
							}
							break;
					case 1:

						if (octree1->b4T) { // +
							// 4 соседа.
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.

									if (bSituationZ) {


										// Вырождение по OZ.
										if (octree1->linkT != nullptr) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTneighbour = 1;
											}
											else if (is_null1(octree1->linkT)) {
												if (bonly_dir_X) {
													octree1->maxTneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxTneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_X)) {
													//if (bonly_dir_X) {
														// дробим только по оси Oy.
														octree1->maxTneighbour = c1 + c2;
													//}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть  2, 4, 5, 8
													//octree1->maxTneighbour = 4;
													octree1->maxTneighbour = c1;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTneighbour = 0;
										}
									}
									else {
										octree1->maxTneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
											// однушка прилегает к четвертушке.
											octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// может быть  2, 4, 5, 8
											//octree1->maxTneighbour = 4;
											octree1->maxTneighbour = c1+c0+c2+c3;
										
									}
								}
							}
							else {
								// nullptr
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}

						if (octree1->b4N) { // + 2.sept.2016 13.59
							// 4 соседа.
							Nmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkN != nullptr) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
									// На разных уровнях.
									if (bSituationY) {


										if (octree1->linkN != nullptr) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNneighbour = 1;
											}
											else if (is_null1(octree1->linkN)) {
												if (bonly_dir_X) {
													octree1->maxNneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxNneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_X)) {
													//if (bonly_dir_X) {
														// дробим только по оси Oy.
														octree1->maxNneighbour = c1 + c5;
													//}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													//octree1->maxNneighbour = 4;
													octree1->maxNneighbour = c1;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxNneighbour = 0;
										}

									}
									else {
										octree1->maxNneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c1+c0+c4+c5;
										
									}
								}
							}
							else {
								// nullptr.
								// 0 остаётся 0.
								octree1->maxNneighbour = 0;
							}
						}

						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
									// на разных уровнях.
									octree1->maxWneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxWneighbour = c1+c2+c5+c6;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxWneighbour = 0;
							}
						}
						


						if (octree1->b4E) {// +
							// 4 соседа.
							Emultineighbour_patch(octree1);
						}
						else {
							// Должно быть уменьшение при дроблении:
							if (octree1->linkE != nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c0;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c0+c3+c4+c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEneighbour = 0;
							}
						}


						if (octree1->b4S) {// +
							// 4 соседа.
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
									// На разных уровнях.


									if (bSituationZ && (!bSituationX) && (!bSituationY)) {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSneighbour = 1;
										}
										else if (is_null1(octree1->linkS)) {
											// двойная прилегает к четверной.
											octree1->maxSneighbour = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxSneighbour = c2 + c6;
										}
									}
									else {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSneighbour = 1;
										}
										else if (is_null1(octree1->linkS)) {
											if (bonly_dir_X) {
												octree1->maxSneighbour = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxSneighbour = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											if (bonly_dir_X) {
												octree1->maxSneighbour = c2 + c6;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												//octree1->maxSneighbour = 4;
												octree1->maxSneighbour = c2;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
											// однушка прилегает к четвертушке.
											octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSneighbour = 4;
										octree1->maxSneighbour = c2+c3+c6+c7;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxSneighbour = 0;
							}
						}

						if (octree1->b4B) {// +
							// 4 соседа.
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // На разных уровнях.


									if (bSituationY && (!bSituationX) && (!bSituationZ)) {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBneighbour = 1;
										}
										else if (is_null1(octree1->linkB)) {
											// двойная прилегает к четверной.
											octree1->maxBneighbour = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxBneighbour = c5 + c6;
										}
									}
									else {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBneighbour = 1;
										}
										else if (is_null1(octree1->linkB)) {
											if (bonly_dir_X) {
												octree1->maxBneighbour = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxBneighbour = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											if (bonly_dir_X) {
												octree1->maxBneighbour = c5 + c6;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												//octree1->maxBneighbour = 4;
												octree1->maxBneighbour = c5;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
											// однушка прилегает к четветушке.
											octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											//octree1->maxBneighbour = 4;
											octree1->maxBneighbour = c5+c4+c6+c7;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxBneighbour = 0;
							}
						}
						break;
					case 2:


						if (octree1->b4T) { // +
							// 4 соседа.
							Tmultineighbour_patch(octree1);
						}
						else {

							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
								    // На разных уровнях.


									if (bSituationZ) {
										// Вырождение по OZ.


										if (octree1->linkT != nullptr) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTneighbour = 1;
											}
											else if (is_null1(octree1->linkT)) {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxTneighbour = 1;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxTneighbour = 4;
												octree1->maxTneighbour = c2;
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTneighbour = 0;
										}

									}
									else {
										octree1->maxTneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.

									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c2 + c0 + c1 + c3;
									}
								}

							}
							else {
								// nullptr
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}


						
						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
									// на разных уровнях.
									octree1->maxSneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxSneighbour = c6 + c7 + c2 + c3;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxSneighbour = 0;
							}
						}


						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // на разных уровнях.
									octree1->maxWneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxWneighbour = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxWneighbour = 0;
							}
						}


						if (octree1->b4E) { // + 2.sept.2016 14:27
							// 4 соседа.
							Emultineighbour_patch(octree1);
						}
						else {
							// Должно быть уменьшение при дроблении:
							if (octree1->linkE != nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c3;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c3 + c0 + c4 + c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEneighbour = 0;
							}
						}


						if (octree1->b4N) {// + 
							// 4 соседа.
							Nmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkN != nullptr) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c1;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c1 + c0 + c4 + c5;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNneighbour = 0;
							}
						}


						if (octree1->b4B) {
							// 4 соседа.
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {

									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxBneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxBneighbour = 4;
										octree1->maxBneighbour = c6;
									}
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxBneighbour = 4;
										octree1->maxBneighbour = c6+c5+c7+c4;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxBneighbour = 0;
							}
						}


						break;
					case 3:

						if (octree1->b4T) {  // + 2.september 2016 17:47
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.


									if (bSituationZ) {
										// Вырождение по OZ.

										if (octree1->linkT != nullptr) {
											if (is_null(octree1->linkT)) {
												// 1 остаётся 1.
												octree1->maxTneighbour = 1;
											}
											else if (is_null1(octree1->linkT)) {
												if (bonly_dir_Y) {
													octree1->maxTneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxTneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Y)) {
													//if (bonly_dir_Y) {
														// дробим только по оси Oy.
														octree1->maxTneighbour = c3 + c2;
													//}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// может быть 2, 4, 5, 8.
													//octree1->maxTneighbour = 4;
													octree1->maxTneighbour = c3;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxTneighbour = 0;
										}

									}
									else {
										octree1->maxTneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										
											// Целая прилегает к четырём четвертинкам.
											octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8.
											//octree1->maxTneighbour = 4;
											octree1->maxTneighbour = c3 + c0 + c1 + c2;
									}
								}
							}
							else {
								// nullptr:
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}
						

						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // на разных уровнях.
									octree1->maxSneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxSneighbour = c2 + c3 + c6 + c7;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxSneighbour = 0;
							}
						}


						if (octree1->b4E) { // + 2.september.2016 17:41
							Emultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkE != nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (bSituationX) {


										if (octree1->linkE != nullptr) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEneighbour = 1;
											}
											else if (is_null1(octree1->linkE)) {
												if (bonly_dir_Y) {
													octree1->maxEneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxEneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Y)) {
													//if (bonly_dir_Y) {
														// дробим только по оси Oy.
														octree1->maxEneighbour = c3 + c7;
													//}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// Может быть 2, 4, 5, 8
													//octree1->maxEneighbour = 4;
													octree1->maxEneighbour = c3;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEneighbour = 0;
										}

									}
									else {
										octree1->maxEneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										
											// однушка примыкает к четырем четвертинкам.
											octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// Может быть 2, 4, 5, 8
											//octree1->maxEneighbour = 4;
											octree1->maxEneighbour = c3 + c0 + c4 + c7;
									}
								}
							}
							else {
								// nullptr;
								// 0 остаётся 0.
								octree1->maxEneighbour = 0;
							}
						}

						if (octree1->b4W) { // + 2.sept.2016 17:24
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // На разных уровнях.


									if (bSituationZ && (!bSituationX) && (!bSituationY)) {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWneighbour = 1;
										}
										else if (is_null1(octree1->linkW)) {
											// двойная прилегает к четверной.
											octree1->maxWneighbour = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxWneighbour = c2 + c6;
										}
									}
									else {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWneighbour = 1;
										}
										else if (is_null1(octree1->linkW)) {
											if (bonly_dir_Y) {
												octree1->maxWneighbour = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxWneighbour = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxWneighbour = 4;
											if (bonly_dir_Y) {
												octree1->maxWneighbour = c2 + c6;
											}
											else {
												octree1->maxWneighbour = c2;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка примыкает к четырём четвертинкам.
										octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWneighbour = 4;
										
										octree1->maxWneighbour = c2 + c1 + c5 + c6;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxWneighbour = 0;
							}
						}

						if (octree1->b4N) { // +
							Nmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkN != nullptr) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								     // На разных уровнях.


									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c0;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// однушка примыкает к четвертинке.
										octree1->maxNneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c0 + c1 + c4 + c5;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNneighbour = 0;
							}
						}

						if (octree1->b4B) { // +
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
									// На разных уровнях.
									if (bSituationX && (!bSituationY) && (!bSituationZ)) {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBneighbour = 1;
										}
										else if (is_null1(octree1->linkB)) {
											// двойная прилегает к четверной.
											octree1->maxBneighbour = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxBneighbour = c7 + c6;
										}
									}
									else {
										if (is_null(octree1->linkB)) {
											// 1 остаётся 1.
											octree1->maxBneighbour = 1;
										}
										else if (is_null1(octree1->linkB)) {
											if (bonly_dir_Y) {
												octree1->maxBneighbour = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxBneighbour = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											if (bonly_dir_Y) {
												octree1->maxBneighbour = c7 + c6;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												//octree1->maxBneighbour = 4;
												octree1->maxBneighbour = c7;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остаётся 1.
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											//octree1->maxBneighbour = 4;
											octree1->maxBneighbour = c7+c6+c5+c4;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxBneighbour = 0;
							}
						}

						break;
					case 4:

						if (octree1->b4N) { // + 2.september.2016 17:10
							Nmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkN != nullptr) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								    // На разных уровнях.


									if (bSituationY) {

										if (octree1->linkN != nullptr) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNneighbour = 1;
											}
											else if (is_null1(octree1->linkN)) {
												if (bonly_dir_Z) {
													octree1->maxNneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxNneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Z)) {
													//if (bonly_dir_Z) {
														// дробим только по оси Oy.
														octree1->maxNneighbour = c4 + c5;
													//}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													// Здесь может быть 2, 4, 5, 8
													//octree1->maxNneighbour = 4;
													octree1->maxNneighbour = c4;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxNneighbour = 0;
										}

									}
									else {
										octree1->maxNneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
											// однушка примыкает к четырём четвертинкам.
											octree1->maxNneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											// Здесь может быть 2, 4, 5, 8
											//octree1->maxNneighbour = 4;
											octree1->maxNneighbour = c4 + c0 + c1 + c5;
										
									}
								}
								/*else {
								#if doubleintprecision == 1
									printf("FATAL ERROR! octree1->ilevel=%lld octree1->linkN->ilevel=%lld\n", octree1->ilevel, octree1->linkN->ilevel);
									printf("octree1->maxNneighbour=%lld\n", octree1->maxNneighbour);
								#else
									printf("FATAL ERROR! octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
									printf("octree1->maxNneighbour=%d\n", octree1->maxNneighbour);
								#endif
									
									system("PAUSE");
								}*/
							}
							else {
								// nullptr
								// 0 остаётся 0.
								octree1->maxNneighbour = 0;
							}
						}

						if (octree1->b4E) { // + 2 sept 2016 16:49
							Emultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkE!=nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (bSituationX) {

										if (octree1->linkE != nullptr) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEneighbour = 1;
											}
											else if (is_null1(octree1->linkE)) {
												if (bonly_dir_Z) {
													octree1->maxEneighbour = 2;
												}
												else {
													// две четверные стороны прилегают друг к дружке.
													octree1->maxEneighbour = 1;
												}
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												if ((bonly_dir_Z)) {
													//if (bonly_dir_Z) {
														// дробим только по оси Oy.
														octree1->maxEneighbour = c4 + c7;
													//}
												}
												else {
													// других вариантов быть не может, здесь только 4.
													//octree1->maxEneighbour = 4;
													octree1->maxEneighbour = c4;
												}
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEneighbour = 0;
										}
									}
									else {
										octree1->maxEneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
											// две четверные стороны прилегают друг к дружке.
											octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										
											// других вариантов быть не может, здесь только 4.
											//octree1->maxEneighbour = 4;
											octree1->maxEneighbour = c4+c0+c3+c7;
									}
								}
								}
								else {
									// nullptr
									// 0 остаётся 0.
									octree1->maxEneighbour = 0;
								}
						}
						

						if (octree1->b4W) { // +
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
									// На разных уровнях.

									if (bSituationY && (!bSituationX) && (!bSituationZ)) {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWneighbour = 1;
										}
										else if (is_null1(octree1->linkW)) {
											// двойная прилегает к четверной.
											octree1->maxWneighbour = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxWneighbour = c5 + c6;
										}
									}
									else {
										if (is_null(octree1->linkW)) {
											// 1 остаётся 1.
											octree1->maxWneighbour = 1;
										}
										else if (is_null1(octree1->linkW)) {
											if (bonly_dir_Z) {
												octree1->maxWneighbour = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxWneighbour = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxWneighbour = 4;
											if (bonly_dir_Z) {
												octree1->maxWneighbour = c5 + c6;
											}
											else {
												octree1->maxWneighbour = c5;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
											// однушка примыкает к четвертинкам.
											octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWneighbour = 4;
										
											octree1->maxWneighbour = c5+c1+c2+c6;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxWneighbour = 0;
							}
						}

						if (octree1->b4S) { // + 2.september. 2016 16:59
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // На разных уровнях.


									if (bSituationX && (!bSituationY) && (!bSituationZ)) {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSneighbour = 1;
										}
										else if (is_null1(octree1->linkS)) {
											// двойная прилегает к четверной.
											octree1->maxSneighbour = 2;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											octree1->maxSneighbour = c7 + c6;
										}
									}
									else {
										if (is_null(octree1->linkS)) {
											// 1 остаётся 1.
											octree1->maxSneighbour = 1;
										}
										else if (is_null1(octree1->linkS)) {
											if (bonly_dir_Z) {
												octree1->maxSneighbour = 2;
											}
											else {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxSneighbour = 1;
											}
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxSneighbour = 4;
											if (bonly_dir_Z) {
												octree1->maxSneighbour = c7 + c6;
											}
											else {
												octree1->maxSneighbour = c7;
											}
										}
									}
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
											// однушка примыкает к четырем четвертинкам.
											octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSneighbour = 4;
										
											octree1->maxSneighbour = c7+c2+c3+c6;
										
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxSneighbour = 0;
							}
						}


						if (octree1->b4T) { // +
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c0;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// однушка примыкает к четырём четвертинкам.
										octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c0 + c1 + c2 + c3;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}

						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // на разных уровнях.
									octree1->maxBneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxBneighbour = c4 + c5 + c6 + c7;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxBneighbour = 0;
							}
						}

						break;
					case 5:
						
						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // на разных уровнях.
									octree1->maxBneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxBneighbour = c4 + c5 + c6 + c7;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxBneighbour = 0;
							}
						}

						 
							if (octree1->b4N) {// + 2.sept.2016 16:18
								Nmultineighbour_patch(octree1);
							}
							else {
								if (octree1->linkN != nullptr) {
									//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
									if (octree1->ilevel != octree1->linkN->ilevel) {
										// На разных уровнях.

										if (bSituationY) {
											if (is_null(octree1->linkN)) {
												// 1 остаётся 1.
												octree1->maxNneighbour = 1;
											}
											else if (is_null1(octree1->linkN)) {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxNneighbour = 1;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxNneighbour = 4;
												octree1->maxNneighbour = c5;
											}
										}
										else {
											octree1->maxNneighbour = 1;
										}
									}
									else if (octree1->ilevel == octree1->linkN->ilevel) {
										// На одинаковых уровнях.
										if (is_null(octree1->linkN)) {
											// 1 остаётся 1.
											octree1->maxNneighbour = 1;
										}
										else if (is_null1(octree1->linkN)) {
											// одна ячейка прилегает к четверной.
											octree1->maxNneighbour = 4;
										}
										else {
											// других вариантов быть не может, здесь только 4.
											// может быть 2, 4, 5, 8
											// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
											char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
											is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
											// других вариантов быть не может, здесь только 4.
											//octree1->maxNneighbour = 4;
											octree1->maxNneighbour = c5 + c0 + c1 + c4;
										}

									}
								}
								else {
									// 0 остаётся 0.
									octree1->maxNneighbour = 0;
								}
							}
						
						

						
						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
									// на разных уровнях.
									octree1->maxWneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxWneighbour = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxWneighbour = 0;
							}
						}



						if (octree1->b4E) { // +
							Emultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkE != nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c4;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// одинарная ячейка прилегает к четверной.
										octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c4+c0+c3+c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEneighbour = 0;
							}
						}

						if (octree1->b4S) { // +
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // На разных уровнях.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxSneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSneighbour = 4;
										octree1->maxSneighbour = c6;
									}
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkS)) {
										// 1 остаётся 1.
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однва ячейка прилегает к четыврём.
										octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxSneighbour = 4;
										octree1->maxSneighbour = c6 + c2 + c3 + c7;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxSneighbour = 0;
							}
						}

						if (octree1->b4T) { // + 2 september 2016 16:14
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
								    // На разных уровнях.


									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1; // octree1->maxTneighbour;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c1;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1; // octree1->maxTneighbour;
									}
									else if (is_null1(octree1->linkT)) {
										// одинарная ячейка прилегает к четверной.
										octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c1 + c0 + c2 + c3;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}

						break;
					case 6:
						
						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
									// на разных уровнях.
									octree1->maxBneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxBneighbour = c4 + c5 + c6 + c7;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxBneighbour = 0;
							}
						}


						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // на разных уровнях.
									octree1->maxSneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxSneighbour = c2 + c3 + c6 + c7;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxSneighbour = 0;
							}
						}


						if (octree1->b4W) { // + 2.sept.2016 13.30
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // на разных уровнях.
									octree1->maxWneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkW)) {
										// 1 остается 1
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// однушка прилегает к четвертушке.
										octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxWneighbour = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxWneighbour = 0;
							}
						}


						if (octree1->b4E) { // +
							Emultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkE != nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c7;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одном уровнене.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c7+c0+c3+c4;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxEneighbour = 0;
							}
						}

						if (octree1->b4N) {  // +
							Nmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkN != nullptr) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
									// На разных уровнях.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c5;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одном уровне.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c5+c0+c1+c4;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNneighbour = 0;
							}
						}

						if (octree1->b4T) { // + 2 sept 2016 15:33
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c2;
									}
								}
								else if (octree1->ilevel==octree1->linkT->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c2 + c0 + c1 + c3;
									}

								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}
						break;
					case 7:

					
						if (octree1->b4B) { // + 2.sept.2016 13.30
							Bmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkB != nullptr) {
								//if (octree1->ilevel - octree1->linkB->ilevel == 1) {
								if (octree1->ilevel != octree1->linkB->ilevel) {
								    // на разных уровнях.
									octree1->maxBneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkB->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkB)) {
										// 1 остается 1
										octree1->maxBneighbour = 1;
									}
									else if (is_null1(octree1->linkB)) {
										// однушка прилегает к четвертушке.
										octree1->maxBneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkB, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxBneighbour = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxBneighbour = 0;
							}
						}


						if (octree1->b4S) { // + 2.sept.2016 13.30
							Smultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkS != nullptr) {
								//if (octree1->ilevel - octree1->linkS->ilevel == 1) {
								if (octree1->ilevel != octree1->linkS->ilevel) {
								    // на разных уровнях.
									octree1->maxSneighbour = 1;
								}
								else if (octree1->ilevel == octree1->linkS->ilevel) {
									// На одном уровне.
									if (is_null(octree1->linkS)) {
										// 1 остается 1
										octree1->maxSneighbour = 1;
									}
									else if (is_null1(octree1->linkS)) {
										// однушка прилегает к четвертушке.
										octree1->maxSneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkS, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxSneighbour = c1 + c2 + c5 + c6;
									}
								}
							}
							else {
								// nullptr 0 остаётся нулём.
								octree1->maxSneighbour = 0;
							}
						}

						if (octree1->b4E) { // +
							Emultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkE != nullptr) {
								//if (octree1->ilevel - octree1->linkE->ilevel == 1) {
								if (octree1->ilevel != octree1->linkE->ilevel ) {
								    // На разных уровнях.
									if (bSituationX) {

										if (octree1->linkE != nullptr) {
											if (is_null(octree1->linkE)) {
												// 1 остаётся 1.
												octree1->maxEneighbour = 1;
											}
											else if (is_null1(octree1->linkE)) {
												// две четверные стороны прилегают друг к дружке.
												octree1->maxEneighbour = 1;
											}
											else {
												// других вариантов быть не может, здесь только 4.
												// может быть 2, 4, 5, 8
												// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
												char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
												is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
												// других вариантов быть не может, здесь только 4.
												//octree1->maxEneighbour = 4;
												octree1->maxEneighbour = c7;
											}
										}
										else {
											// 0 остаётся 0.
											octree1->maxEneighbour = 0;
										}
									}
									else {
										octree1->maxEneighbour = 1;
									}
								}
								else if (octree1->ilevel == octree1->linkE->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkE)) {
										// 1 остаётся 1.
										octree1->maxEneighbour = 1;
									}
									else if (is_null1(octree1->linkE)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxEneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxEneighbour = 4;
										octree1->maxEneighbour = c7+c0+c4+c3;
									}
								}
						    }
							else {
								// nullptr
								// 0 остаётся 0.
								octree1->maxEneighbour = 0;
							}
						}

						if (octree1->b4W) { // +
							Wmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkW != nullptr) {
								//if (octree1->ilevel - octree1->linkW->ilevel == 1) {
								if (octree1->ilevel != octree1->linkW->ilevel) {
								    // На разных уровнях


									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxWneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWneighbour = 4;
										octree1->maxWneighbour = c6;
									}
								}
								else if (octree1->ilevel == octree1->linkW->ilevel) {
									// На одинаковых уровнях
									if (is_null(octree1->linkW)) {
										// 1 остаётся 1.
										octree1->maxWneighbour = 1;
									}
									else if (is_null1(octree1->linkW)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxWneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxWneighbour = 4;
										octree1->maxWneighbour = c6+c1+c5+c2;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxWneighbour = 0;
							}
						}


						if (octree1->b4N) { // +
							Nmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkN != nullptr) {
								//if (octree1->ilevel - octree1->linkN->ilevel == 1) {
								if (octree1->ilevel != octree1->linkN->ilevel) {
								    // На разных уровнях.

									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxNneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c4;
									}
								}
								else if (octree1->ilevel == octree1->linkN->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkN)) {
										// 1 остаётся 1.
										octree1->maxNneighbour = 1;
									}
									else if (is_null1(octree1->linkN)) {
										// Единичка прилегает к четвертушке.
										octree1->maxNneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxNneighbour = 4;
										octree1->maxNneighbour = c4+c0+c1+c5;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxNneighbour = 0;
							}
						}


						if (octree1->b4T) { // + 2.sept.2016 15:57
							Tmultineighbour_patch(octree1);
						}
						else {
							if (octree1->linkT != nullptr) {
								//if (octree1->ilevel - octree1->linkT->ilevel == 1) {
								if (octree1->ilevel != octree1->linkT->ilevel) {
									// На разных уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// две четверные стороны прилегают друг к дружке.
										octree1->maxTneighbour = 1;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c3;
									}
								}
								else if (octree1->ilevel == octree1->linkT->ilevel) {
									// На одинаковых уровнях.
									if (is_null(octree1->linkT)) {
										// 1 остаётся 1.
										octree1->maxTneighbour = 1;
									}
									else if (is_null1(octree1->linkT)) {
										// Единичка примыкает к четырём соседяим.
										octree1->maxTneighbour = 4;
									}
									else {
										// других вариантов быть не может, здесь только 4.
										// может быть 2, 4, 5, 8
										// здесь ci - (i=0..7) количество ячеек поддробления в каждом из восьми частей root дробления.
										char c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0, c5 = 0, c6 = 0, c7 = 0;
										is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
										// других вариантов быть не может, здесь только 4.
										//octree1->maxTneighbour = 4;
										octree1->maxTneighbour = c3 + c0 + c1 + c2;
									}
								}
							}
							else {
								// 0 остаётся 0.
								octree1->maxTneighbour = 0;
							}
						}
						break;
					default: 
#if doubleintprecision == 1
						printf("error: root=%lld\n", octree1->root);
#else
						printf("error: root=%d\n", octree1->root);
#endif
						
						//system("PAUSE");
						system("PAUSE");
						exit(1);
						break;
					}
					// закончили работать.
					octree1 = nullptr;
				//}
				//else {
					// закомментировано 30.08.2016.
					//my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
					//top_ALICE_STACK--;
				//}

			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // update_max_count_neighbour


// После каждого сканирования листьев всего дерева мы должны 
// восстановить соседственные связи т.к. они  изменились после дробления.
void update_link_neighbor(octree* &oc) {


#ifdef _OPENMP
	//int i_my_num_core_parallelesation = omp_get_max_threads();
	//omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif


	bool bold_stable_version = true;

	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				// Внимание обязательно нужно оставить закомментированным 30.08.2016.
				//if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation) 
				//{

					// Внимание обязательно нужно оставить закомментированным 30.08.2016.
					//my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = false;

					octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

					// разбиение на 8.
					//integer minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
					//integer maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
					//integer miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
					//integer maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
					//integer minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
					//integer maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

					// Дробление  вызывается.
					my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
					top_ALICE_STACK--;

					// работаем с octree1

//#pragma omp parallel sections
					{

//#pragma omp section
						{

							// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
							if (octree1->b4E == false) {
								if (octree1->linkE != nullptr) {

									if (octree1->linkE->link0 != nullptr) {
										if ((octree1->linkE->link1 == nullptr) && (octree1->linkE->link2 == nullptr) && (octree1->linkE->link3 == nullptr) && (octree1->linkE->link4 == nullptr) && (octree1->linkE->link5 == nullptr) && (octree1->linkE->link6 == nullptr) && (octree1->linkE->link7 == nullptr)) {
											printf("error: octree1->linkE->link0!=nullptr a na samom dele ==nullptr\n");
											//system("PAUSE");
											system("PAUSE");
											exit(1);
										}

										// octree1 это лист.
										// Situation внутри Е соседа.
										bool bSituationX = false;
										bool bSituationY = false;
										bool bSituationZ = false;
										if (bold_stable_version) {
											if (octree1->linkE->minx + 1 == octree1->linkE->maxx) {
												bSituationX = true;
											}
											if (octree1->linkE->miny + 1 == octree1->linkE->maxy) {
												bSituationY = true;
											}
											if (octree1->linkE->minz + 1 == octree1->linkE->maxz) {
												bSituationZ = true;
											}
											if ((octree1->linkE->link0 != nullptr)) {
												if (bSituationX != octree1->linkE->link0->brootSituationX) {
													printf("error ne sovpadenie Situation X.");
												}
												if (bSituationY != octree1->linkE->link0->brootSituationY) {
													printf("error ne sovpadenie Situation Y.");
												}
												if (bSituationZ != octree1->linkE->link0->brootSituationZ) {
													printf("error ne sovpadenie Situation Z.");
												}
											}
										}
										else {
											// 4.01.2018 Попробуем так. Чисто на интуиции пока.
											// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
											bSituationX = octree1->linkE->link0->brootSituationX;
											bSituationY = octree1->linkE->link0->brootSituationY;
											bSituationZ = octree1->linkE->link0->brootSituationZ;
										}
										bool bsitX = false;
										if (((!bSituationX) && (bSituationY) && (bSituationZ))) bsitX = true;


										//if ((!octree1->b_the_geometric_fragmentation)||(octree1->bcrushing_when_balancing)) {
										if ((octree1->ilevel == octree1->linkE->ilevel) || (bsitX)) {
											// Не дробленный лист контачит по грани E с дроблённым обектом.
											// Situaton - это ситуация в Е соседе.
											if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
												// вырождение по Х
												// 0,3,4,7 
												octree1->b4E = true;
												octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = octree1->linkE->link3;
												octree1->linkE5 = octree1->linkE->link4;
												octree1->linkE6 = octree1->linkE->link7;
												octree1->linkE = nullptr;
											}
											else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
												// вырождение по Y
												// 0,1,4,5 
												octree1->b4E = true;
												octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = nullptr;
												octree1->linkE5 = octree1->linkE->link4;
												octree1->linkE6 = nullptr;
												octree1->linkE = nullptr;
											}
											else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
												// вырождение по Z
												// 0,1,2,3
												octree1->b4E = true;
												octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = octree1->linkE->link3;
												octree1->linkE5 = nullptr;
												octree1->linkE6 = nullptr;
												octree1->linkE = nullptr;
											}
											else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
												// direction Z
												// 0,4
												octree1->b4E = true;
												octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = nullptr;
												octree1->linkE5 = octree1->linkE->link4;
												octree1->linkE6 = nullptr;
												octree1->linkE = nullptr;
											}
											else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
												// direction X
												// 0,1
												//octree1->b4E = true;
												//octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = nullptr;
												octree1->linkE5 = nullptr;
												octree1->linkE6 = nullptr;
												// Оратное редуцирование т.к. связь только одна.
												octree1->b4E = false;
												octree1->linkE1 = nullptr;
												octree1->linkE = octree1->linkE->link0;
												//printf("FOUND ERROR!!! E direction X\n");
												//system("PAUSE");
											}
											else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
												// direction Y
												// 0,3
												octree1->b4E = true;
												octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = octree1->linkE->link3;
												octree1->linkE5 = nullptr;
												octree1->linkE6 = nullptr;
												octree1->linkE = nullptr;
											}
											else if (is_null1(octree1->linkE)) {
												// Разбита на 8 равных частей:
												// 1,2,5,6
												octree1->b4E = true;
												octree1->linkE1 = octree1->linkE->link0;
												octree1->linkE2 = octree1->linkE->link3;
												octree1->linkE5 = octree1->linkE->link4;
												octree1->linkE6 = octree1->linkE->link7;
												octree1->linkE = nullptr;
											}


										}
										else {
											if (octree1->ilevel - octree1->linkE->ilevel != 1) {

												if (is_null1_new(octree1->linkE)) {
													if (DEBUG_ALICE_MESH) {
														printf("linkE  is_null1_new\n");
													}
													if (octree1->ilevel - octree1->linkE->ilevel == 2) {

														if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
															// вырождение по Х
															// 0,3,4,7 
															// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link4;
																	break;
																case 6: octree1->linkE = octree1->linkE->link7;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link7;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link4;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}


														}
														else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
															// вырождение по Y
															// 0,1,4,5 
															// (3->0),(2->1),(7->4), (6->5)
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link0;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link4;
																	break;
																case 6: octree1->linkE = octree1->linkE->link4;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link0;
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link4;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link4;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link0;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link0;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

														}
														else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
															// вырождение по Z
															// 0,1,2,3
															// (4->0) (5->1) (6->2) (7->3)
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link0;
																	break;
																case 6: octree1->linkE = octree1->linkE->link3;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:octree1->linkE = octree1->linkE->link0;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link3;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link0;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link0;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
														}
														else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
															// direction Z
															// 0,4
															// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link0;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link4;
																	break;
																case 6: octree1->linkE = octree1->linkE->link4;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link0;
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link4;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link4;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link0;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link0;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

														}
														else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
															// direction X
															// 0,1
															// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link0;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link0;
																	break;
																case 6: octree1->linkE = octree1->linkE->link0;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link0;
																	break;
																case 4:octree1->linkE = octree1->linkE->link0;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link0;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link0;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link0;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link0;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link0;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
														}
														else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
															// direction Y
															// 0,3
															// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link0;
																	break;
																case 6: octree1->linkE = octree1->linkE->link3;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:octree1->linkE = octree1->linkE->link0;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link3;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link0;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link0;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
														}
														else if (is_null1(octree1->linkE)) {
															// Разбита на 8 равных частей:
															// 1,2,5,6
															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// нет вырождения.
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1: octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5: octree1->linkE = octree1->linkE->link4;
																	break;
																case 6: octree1->linkE = octree1->linkE->link7;
																	break;
																case 7:
																	break;
																}
															}
															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Х
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:octree1->linkE = octree1->linkE->link7;
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// вырождение по Y
																//1,5
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:octree1->linkE = octree1->linkE->link4;
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// вырождение по Z
																//1,2
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:octree1->linkE = octree1->linkE->link3;
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
																// direction Z
																// 0,4
																switch (octree1->parent->root) {
																case 0: octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:octree1->linkE = octree1->linkE->link4;
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}
															if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction X
																//1
																switch (octree1->parent->root) {
																case 0:
																	break;
																case 1:octree1->linkE = octree1->linkE->link0;
																	break;
																case 2:
																	break;
																case 3:
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

															if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
																// direction Y
																//0,3
																switch (octree1->parent->root) {
																case 0:octree1->linkE = octree1->linkE->link0;
																	break;
																case 1:
																	break;
																case 2:
																	break;
																case 3:octree1->linkE = octree1->linkE->link3;
																	break;
																case 4:
																	break;
																case 5:
																	break;
																case 6:
																	break;
																case 7:
																	break;
																}
															}

														}
													}
													else {
														printf("Fatal error!!! E distance meshdu urovnqmi > 2\n");
														if (is_null1_new(octree1->linkE)) {
															printf("linkE  is_null1_new\n");
														}
#if doubleintprecision == 1
														printf("octree1->ilevel=%c octree1->linkE->ilevel=%c\n", octree1->ilevel, octree1->linkE->ilevel);
#else
														printf("octree1->ilevel=%c octree1->linkE->ilevel=%c\n", octree1->ilevel, octree1->linkE->ilevel);
#endif

														//system("PAUSE");
														system("PAUSE");
														//exit(1);
													}


												}
												else {
													printf("error: linkE nepravilnje urovni.\n");
													char c0 = 0;
													char c1 = 0;
													char c2 = 0;
													char c3 = 0;
													char c4 = 0;
													char c5 = 0;
													char c6 = 0;
													char c7 = 0;
													is_null3(octree1->linkE, E_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
													printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
													printf("%lld ", print_link(octree1->linkE->link0));
													if (octree1->linkE->link0 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link0->link0));
														printf("%lld ", print_link(octree1->linkE->link0->link1));
														printf("%lld ", print_link(octree1->linkE->link0->link2));
														printf("%lld ", print_link(octree1->linkE->link0->link3));
														printf("%lld ", print_link(octree1->linkE->link0->link4));
														printf("%lld ", print_link(octree1->linkE->link0->link5));
														printf("%lld ", print_link(octree1->linkE->link0->link6));
														printf("%lld ", print_link(octree1->linkE->link0->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link1));
													if (octree1->linkE->link1 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link1->link0));
														printf("%lld ", print_link(octree1->linkE->link1->link1));
														printf("%lld ", print_link(octree1->linkE->link1->link2));
														printf("%lld ", print_link(octree1->linkE->link1->link3));
														printf("%lld ", print_link(octree1->linkE->link1->link4));
														printf("%lld ", print_link(octree1->linkE->link1->link5));
														printf("%lld ", print_link(octree1->linkE->link1->link6));
														printf("%lld ", print_link(octree1->linkE->link1->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link2));
													if (octree1->linkE->link2 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link2->link0));
														printf("%lld ", print_link(octree1->linkE->link2->link1));
														printf("%lld ", print_link(octree1->linkE->link2->link2));
														printf("%lld ", print_link(octree1->linkE->link2->link3));
														printf("%lld ", print_link(octree1->linkE->link2->link4));
														printf("%lld ", print_link(octree1->linkE->link2->link5));
														printf("%lld ", print_link(octree1->linkE->link2->link6));
														printf("%lld ", print_link(octree1->linkE->link2->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link3));
													if (octree1->linkE->link3 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link3->link0));
														printf("%lld ", print_link(octree1->linkE->link3->link1));
														printf("%lld ", print_link(octree1->linkE->link3->link2));
														printf("%lld ", print_link(octree1->linkE->link3->link3));
														printf("%lld ", print_link(octree1->linkE->link3->link4));
														printf("%lld ", print_link(octree1->linkE->link3->link5));
														printf("%lld ", print_link(octree1->linkE->link3->link6));
														printf("%lld ", print_link(octree1->linkE->link3->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link4));
													if (octree1->linkE->link4 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link4->link0));
														printf("%lld ", print_link(octree1->linkE->link4->link1));
														printf("%lld ", print_link(octree1->linkE->link4->link2));
														printf("%lld ", print_link(octree1->linkE->link4->link3));
														printf("%lld ", print_link(octree1->linkE->link4->link4));
														printf("%lld ", print_link(octree1->linkE->link4->link5));
														printf("%lld ", print_link(octree1->linkE->link4->link6));
														printf("%lld ", print_link(octree1->linkE->link4->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link5));
													if (octree1->linkE->link5 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link5->link0));
														printf("%lld ", print_link(octree1->linkE->link5->link1));
														printf("%lld ", print_link(octree1->linkE->link5->link2));
														printf("%lld ", print_link(octree1->linkE->link5->link3));
														printf("%lld ", print_link(octree1->linkE->link5->link4));
														printf("%lld ", print_link(octree1->linkE->link5->link5));
														printf("%lld ", print_link(octree1->linkE->link5->link6));
														printf("%lld ", print_link(octree1->linkE->link5->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link6));
													if (octree1->linkE->link6 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link6->link0));
														printf("%lld ", print_link(octree1->linkE->link6->link1));
														printf("%lld ", print_link(octree1->linkE->link6->link2));
														printf("%lld ", print_link(octree1->linkE->link6->link3));
														printf("%lld ", print_link(octree1->linkE->link6->link4));
														printf("%lld ", print_link(octree1->linkE->link6->link5));
														printf("%lld ", print_link(octree1->linkE->link6->link6));
														printf("%lld ", print_link(octree1->linkE->link6->link7));
													}
													printf("%lld ", print_link(octree1->linkE->link7));
													if (oc->linkE->link7 != nullptr) {
														printf("%lld ", print_link(octree1->linkE->link7->link0));
														printf("%lld ", print_link(octree1->linkE->link7->link1));
														printf("%lld ", print_link(octree1->linkE->link7->link2));
														printf("%lld ", print_link(octree1->linkE->link7->link3));
														printf("%lld ", print_link(octree1->linkE->link7->link4));
														printf("%lld ", print_link(octree1->linkE->link7->link5));
														printf("%lld ", print_link(octree1->linkE->link7->link6));
														printf("%lld ", print_link(octree1->linkE->link7->link7));
													}
#else
													printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
													printf("%d ", print_link(octree1->linkE->link0));
													if (octree1->linkE->link0 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link0->link0));
														printf("%d ", print_link(octree1->linkE->link0->link1));
														printf("%d ", print_link(octree1->linkE->link0->link2));
														printf("%d ", print_link(octree1->linkE->link0->link3));
														printf("%d ", print_link(octree1->linkE->link0->link4));
														printf("%d ", print_link(octree1->linkE->link0->link5));
														printf("%d ", print_link(octree1->linkE->link0->link6));
														printf("%d ", print_link(octree1->linkE->link0->link7));
													}
													printf("%d ", print_link(octree1->linkE->link1));
													if (octree1->linkE->link1 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link1->link0));
														printf("%d ", print_link(octree1->linkE->link1->link1));
														printf("%d ", print_link(octree1->linkE->link1->link2));
														printf("%d ", print_link(octree1->linkE->link1->link3));
														printf("%d ", print_link(octree1->linkE->link1->link4));
														printf("%d ", print_link(octree1->linkE->link1->link5));
														printf("%d ", print_link(octree1->linkE->link1->link6));
														printf("%d ", print_link(octree1->linkE->link1->link7));
													}
													printf("%d ", print_link(octree1->linkE->link2));
													if (octree1->linkE->link2 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link2->link0));
														printf("%d ", print_link(octree1->linkE->link2->link1));
														printf("%d ", print_link(octree1->linkE->link2->link2));
														printf("%d ", print_link(octree1->linkE->link2->link3));
														printf("%d ", print_link(octree1->linkE->link2->link4));
														printf("%d ", print_link(octree1->linkE->link2->link5));
														printf("%d ", print_link(octree1->linkE->link2->link6));
														printf("%d ", print_link(octree1->linkE->link2->link7));
													}
													printf("%d ", print_link(octree1->linkE->link3));
													if (octree1->linkE->link3 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link3->link0));
														printf("%d ", print_link(octree1->linkE->link3->link1));
														printf("%d ", print_link(octree1->linkE->link3->link2));
														printf("%d ", print_link(octree1->linkE->link3->link3));
														printf("%d ", print_link(octree1->linkE->link3->link4));
														printf("%d ", print_link(octree1->linkE->link3->link5));
														printf("%d ", print_link(octree1->linkE->link3->link6));
														printf("%d ", print_link(octree1->linkE->link3->link7));
													}
													printf("%d ", print_link(octree1->linkE->link4));
													if (octree1->linkE->link4 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link4->link0));
														printf("%d ", print_link(octree1->linkE->link4->link1));
														printf("%d ", print_link(octree1->linkE->link4->link2));
														printf("%d ", print_link(octree1->linkE->link4->link3));
														printf("%d ", print_link(octree1->linkE->link4->link4));
														printf("%d ", print_link(octree1->linkE->link4->link5));
														printf("%d ", print_link(octree1->linkE->link4->link6));
														printf("%d ", print_link(octree1->linkE->link4->link7));
													}
													printf("%d ", print_link(octree1->linkE->link5));
													if (octree1->linkE->link5 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link5->link0));
														printf("%d ", print_link(octree1->linkE->link5->link1));
														printf("%d ", print_link(octree1->linkE->link5->link2));
														printf("%d ", print_link(octree1->linkE->link5->link3));
														printf("%d ", print_link(octree1->linkE->link5->link4));
														printf("%d ", print_link(octree1->linkE->link5->link5));
														printf("%d ", print_link(octree1->linkE->link5->link6));
														printf("%d ", print_link(octree1->linkE->link5->link7));
													}
													printf("%d ", print_link(octree1->linkE->link6));
													if (octree1->linkE->link6 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link6->link0));
														printf("%d ", print_link(octree1->linkE->link6->link1));
														printf("%d ", print_link(octree1->linkE->link6->link2));
														printf("%d ", print_link(octree1->linkE->link6->link3));
														printf("%d ", print_link(octree1->linkE->link6->link4));
														printf("%d ", print_link(octree1->linkE->link6->link5));
														printf("%d ", print_link(octree1->linkE->link6->link6));
														printf("%d ", print_link(octree1->linkE->link6->link7));
													}
													printf("%d ", print_link(octree1->linkE->link7));
													if (oc->linkE->link7 != nullptr) {
														printf("%d ", print_link(octree1->linkE->link7->link0));
														printf("%d ", print_link(octree1->linkE->link7->link1));
														printf("%d ", print_link(octree1->linkE->link7->link2));
														printf("%d ", print_link(octree1->linkE->link7->link3));
														printf("%d ", print_link(octree1->linkE->link7->link4));
														printf("%d ", print_link(octree1->linkE->link7->link5));
														printf("%d ", print_link(octree1->linkE->link7->link6));
														printf("%d ", print_link(octree1->linkE->link7->link7));
													}
#endif

													//system("PAUSE");
													system("PAUSE");

												}

												//system("PAUSE");
											}
											else {
												if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
													// вырождение по Х
													// 0,3,4,7 
													// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link4;
															break;
														case 6: octree1->linkE = octree1->linkE->link7;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link7;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link4;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}


												}
												else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
													// вырождение по Y
													// 0,1,4,5 
													// (3->0),(2->1),(7->4), (6->5)
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link0;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link4;
															break;
														case 6: octree1->linkE = octree1->linkE->link4;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link0;
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link4;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link4;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link0;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}
												else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
													// вырождение по Z
													// 0,1,2,3
													// (4->0) (5->1) (6->2) (7->3)
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link0;
															break;
														case 6: octree1->linkE = octree1->linkE->link3;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:octree1->linkE = octree1->linkE->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link3;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link0;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
													// direction Z
													// 0,4
													// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link0;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link4;
															break;
														case 6: octree1->linkE = octree1->linkE->link4;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link0;
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link4;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link4;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link0;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}
												else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
													// direction X
													// 0,1
													// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link0;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link0;
															break;
														case 6: octree1->linkE = octree1->linkE->link0;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link0;
															break;
														case 4:octree1->linkE = octree1->linkE->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link0;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link0;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link0;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
													// direction Y
													// 0,3
													// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link0;
															break;
														case 6: octree1->linkE = octree1->linkE->link3;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:octree1->linkE = octree1->linkE->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link3;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link0;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if (is_null1(octree1->linkE)) {
													// Разбита на 8 равных частей:
													// 1,2,5,6
													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// нет вырождения.
														switch (octree1->root) {
														case 0:
															break;
														case 1: octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5: octree1->linkE = octree1->linkE->link4;
															break;
														case 6: octree1->linkE = octree1->linkE->link7;
															break;
														case 7:
															break;
														}
													}
													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Х
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkE = octree1->linkE->link7;
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// вырождение по Y
														//1,5
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:octree1->linkE = octree1->linkE->link4;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// вырождение по Z
														//1,2
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:octree1->linkE = octree1->linkE->link3;
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->root) {
														case 0: octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkE = octree1->linkE->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction X
														//1
														switch (octree1->root) {
														case 0:
															break;
														case 1:octree1->linkE = octree1->linkE->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->root) {
														case 0:octree1->linkE = octree1->linkE->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkE = octree1->linkE->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}
											}
										}
									}
								}
							}


						}
//#pragma omp section
						{

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4W == false) {
					if (octree1->linkW != nullptr) {
						if (octree1->linkW->link0!=nullptr) {
							if ((octree1->linkW->link1 == nullptr) && (octree1->linkW->link2 == nullptr) && (octree1->linkW->link3 == nullptr) && (octree1->linkW->link4 == nullptr) && (octree1->linkW->link5 == nullptr) && (octree1->linkW->link6 == nullptr) && (octree1->linkW->link7 == nullptr)) {
								printf("error: octree1->linkW->link0!=nullptr a na samom dele ==nullptr\n");
								//system("PAUSE");
								system("PAUSE");
								exit(1);
							}

						// octree1 это лист.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkW->minx + 1 == octree1->linkW->maxx) {
								bSituationX = true;
							}
							if (octree1->linkW->miny + 1 == octree1->linkW->maxy) {
								bSituationY = true;
							}
							if (octree1->linkW->minz + 1 == octree1->linkW->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkW->link0 != nullptr)) {
								if (bSituationX != octree1->linkW->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkW->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkW->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkW->link0->brootSituationX;
							bSituationY = octree1->linkW->link0->brootSituationY;
							bSituationZ = octree1->linkW->link0->brootSituationZ;
						}

						bool bsitX = false;
						if (((!bSituationX) && (bSituationY) && (bSituationZ))) bsitX = true;

						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkW->ilevel)||(bsitX)) {
						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link0;
								octree1->linkW3 = octree1->linkW->link3;
								octree1->linkW4 = octree1->linkW->link4;
								octree1->linkW7 = octree1->linkW->link7;
								octree1->linkW = nullptr;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = nullptr;
								octree1->linkW4 = octree1->linkW->link5;
								octree1->linkW7 = nullptr;
								octree1->linkW = nullptr;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = octree1->linkW->link2;
								octree1->linkW4 = nullptr; 
								octree1->linkW7 = nullptr; 
								octree1->linkW = nullptr;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link0;
								octree1->linkW3 = nullptr; 
								octree1->linkW4 = octree1->linkW->link4;
								octree1->linkW7 = nullptr; 
								octree1->linkW = nullptr;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								//octree1->b4W = true;
								//octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = nullptr; 
								octree1->linkW4 = nullptr; 
								octree1->linkW7 = nullptr; 
								// Редуцирование четырёх соседей, связь только одна.
								octree1->b4W = false;
								octree1->linkW0 = nullptr;
								octree1->linkW = octree1->linkW->link1;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link0;
								octree1->linkW3 = octree1->linkW->link3;
								octree1->linkW4 = nullptr; 
								octree1->linkW7 = nullptr; 
								octree1->linkW = nullptr;
							}
							else if (is_null1(octree1->linkW)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4W = true;
								octree1->linkW0 = octree1->linkW->link1;
								octree1->linkW3 = octree1->linkW->link2;
								octree1->linkW4 = octree1->linkW->link5;
								octree1->linkW7 = octree1->linkW->link6;
								octree1->linkW = nullptr;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkW->ilevel != 1) {
								
								if (is_null1_new(octree1->linkW)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkW  is_null1_new\n");
									}
									if (octree1->ilevel-octree1->linkW->ilevel==2) {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link7;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link3;
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link7;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link5;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link1;
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link5;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link2;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link2;
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link2;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link0;
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link0;
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link1;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link1;
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link1;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link1;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link1;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link3;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link3;
													break;
												case 4: octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link3;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if (is_null1(octree1->linkW)) {
											// Разбита на 8 равных частей:
											// 0,3,4,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkW = octree1->linkW->link6;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3,4,7
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkW = octree1->linkW->link2;
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkW = octree1->linkW->link6;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0: octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkW = octree1->linkW->link5;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkW = octree1->linkW->link1;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkW = octree1->linkW->link2;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}

								    }
								    else {
									     printf("Fatal error!!! W distance meshdu urovnqmi > 2\n");
									     //system("PAUSE");
										 system("PAUSE");
									    // exit(1);
								    }
								}
								else {
									printf("error: linkW nepravilnje urovni.\n");
									char c0 = 0;
									char c1 = 0;
									char c2 = 0;
									char c3 = 0;
									char c4 = 0;
									char c5 = 0;
									char c6 = 0;
									char c7 = 0;
									is_null3(octree1->linkW, W_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);

#if doubleintprecision == 1
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkW->link0));
									if (octree1->linkW->link0 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link0->link0));
										printf("%lld ", print_link(octree1->linkW->link0->link1));
										printf("%lld ", print_link(octree1->linkW->link0->link2));
										printf("%lld ", print_link(octree1->linkW->link0->link3));
										printf("%lld ", print_link(octree1->linkW->link0->link4));
										printf("%lld ", print_link(octree1->linkW->link0->link5));
										printf("%lld ", print_link(octree1->linkW->link0->link6));
										printf("%lld ", print_link(octree1->linkW->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link1));
									if (octree1->linkW->link1 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link1->link0));
										printf("%lld ", print_link(octree1->linkW->link1->link1));
										printf("%lld ", print_link(octree1->linkW->link1->link2));
										printf("%lld ", print_link(octree1->linkW->link1->link3));
										printf("%lld ", print_link(octree1->linkW->link1->link4));
										printf("%lld ", print_link(octree1->linkW->link1->link5));
										printf("%lld ", print_link(octree1->linkW->link1->link6));
										printf("%lld ", print_link(octree1->linkW->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link2));
									if (octree1->linkW->link2 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link2->link0));
										printf("%lld ", print_link(octree1->linkW->link2->link1));
										printf("%lld ", print_link(octree1->linkW->link2->link2));
										printf("%lld ", print_link(octree1->linkW->link2->link3));
										printf("%lld ", print_link(octree1->linkW->link2->link4));
										printf("%lld ", print_link(octree1->linkW->link2->link5));
										printf("%lld ", print_link(octree1->linkW->link2->link6));
										printf("%lld ", print_link(octree1->linkW->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link3));
									if (octree1->linkW->link3 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link3->link0));
										printf("%lld ", print_link(octree1->linkW->link3->link1));
										printf("%lld ", print_link(octree1->linkW->link3->link2));
										printf("%lld ", print_link(octree1->linkW->link3->link3));
										printf("%lld ", print_link(octree1->linkW->link3->link4));
										printf("%lld ", print_link(octree1->linkW->link3->link5));
										printf("%lld ", print_link(octree1->linkW->link3->link6));
										printf("%lld ", print_link(octree1->linkW->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link4));
									if (octree1->linkW->link4 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link4->link0));
										printf("%lld ", print_link(octree1->linkW->link4->link1));
										printf("%lld ", print_link(octree1->linkW->link4->link2));
										printf("%lld ", print_link(octree1->linkW->link4->link3));
										printf("%lld ", print_link(octree1->linkW->link4->link4));
										printf("%lld ", print_link(octree1->linkW->link4->link5));
										printf("%lld ", print_link(octree1->linkW->link4->link6));
										printf("%lld ", print_link(octree1->linkW->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link5));
									if (octree1->linkW->link5 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link5->link0));
										printf("%lld ", print_link(octree1->linkW->link5->link1));
										printf("%lld ", print_link(octree1->linkW->link5->link2));
										printf("%lld ", print_link(octree1->linkW->link5->link3));
										printf("%lld ", print_link(octree1->linkW->link5->link4));
										printf("%lld ", print_link(octree1->linkW->link5->link5));
										printf("%lld ", print_link(octree1->linkW->link5->link6));
										printf("%lld ", print_link(octree1->linkW->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link6));
									if (octree1->linkW->link6 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link6->link0));
										printf("%lld ", print_link(octree1->linkW->link6->link1));
										printf("%lld ", print_link(octree1->linkW->link6->link2));
										printf("%lld ", print_link(octree1->linkW->link6->link3));
										printf("%lld ", print_link(octree1->linkW->link6->link4));
										printf("%lld ", print_link(octree1->linkW->link6->link5));
										printf("%lld ", print_link(octree1->linkW->link6->link6));
										printf("%lld ", print_link(octree1->linkW->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkW->link7));
									if (oc->linkW->link7 != nullptr) {
										printf("%lld ", print_link(octree1->linkW->link7->link0));
										printf("%lld ", print_link(octree1->linkW->link7->link1));
										printf("%lld ", print_link(octree1->linkW->link7->link2));
										printf("%lld ", print_link(octree1->linkW->link7->link3));
										printf("%lld ", print_link(octree1->linkW->link7->link4));
										printf("%lld ", print_link(octree1->linkW->link7->link5));
										printf("%lld ", print_link(octree1->linkW->link7->link6));
										printf("%lld ", print_link(octree1->linkW->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkW->link0));
									if (octree1->linkW->link0 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link0->link0));
										printf("%d ", print_link(octree1->linkW->link0->link1));
										printf("%d ", print_link(octree1->linkW->link0->link2));
										printf("%d ", print_link(octree1->linkW->link0->link3));
										printf("%d ", print_link(octree1->linkW->link0->link4));
										printf("%d ", print_link(octree1->linkW->link0->link5));
										printf("%d ", print_link(octree1->linkW->link0->link6));
										printf("%d ", print_link(octree1->linkW->link0->link7));
									}
									printf("%d ", print_link(octree1->linkW->link1));
									if (octree1->linkW->link1 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link1->link0));
										printf("%d ", print_link(octree1->linkW->link1->link1));
										printf("%d ", print_link(octree1->linkW->link1->link2));
										printf("%d ", print_link(octree1->linkW->link1->link3));
										printf("%d ", print_link(octree1->linkW->link1->link4));
										printf("%d ", print_link(octree1->linkW->link1->link5));
										printf("%d ", print_link(octree1->linkW->link1->link6));
										printf("%d ", print_link(octree1->linkW->link1->link7));
									}
									printf("%d ", print_link(octree1->linkW->link2));
									if (octree1->linkW->link2 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link2->link0));
										printf("%d ", print_link(octree1->linkW->link2->link1));
										printf("%d ", print_link(octree1->linkW->link2->link2));
										printf("%d ", print_link(octree1->linkW->link2->link3));
										printf("%d ", print_link(octree1->linkW->link2->link4));
										printf("%d ", print_link(octree1->linkW->link2->link5));
										printf("%d ", print_link(octree1->linkW->link2->link6));
										printf("%d ", print_link(octree1->linkW->link2->link7));
									}
									printf("%d ", print_link(octree1->linkW->link3));
									if (octree1->linkW->link3 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link3->link0));
										printf("%d ", print_link(octree1->linkW->link3->link1));
										printf("%d ", print_link(octree1->linkW->link3->link2));
										printf("%d ", print_link(octree1->linkW->link3->link3));
										printf("%d ", print_link(octree1->linkW->link3->link4));
										printf("%d ", print_link(octree1->linkW->link3->link5));
										printf("%d ", print_link(octree1->linkW->link3->link6));
										printf("%d ", print_link(octree1->linkW->link3->link7));
									}
									printf("%d ", print_link(octree1->linkW->link4));
									if (octree1->linkW->link4 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link4->link0));
										printf("%d ", print_link(octree1->linkW->link4->link1));
										printf("%d ", print_link(octree1->linkW->link4->link2));
										printf("%d ", print_link(octree1->linkW->link4->link3));
										printf("%d ", print_link(octree1->linkW->link4->link4));
										printf("%d ", print_link(octree1->linkW->link4->link5));
										printf("%d ", print_link(octree1->linkW->link4->link6));
										printf("%d ", print_link(octree1->linkW->link4->link7));
									}
									printf("%d ", print_link(octree1->linkW->link5));
									if (octree1->linkW->link5 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link5->link0));
										printf("%d ", print_link(octree1->linkW->link5->link1));
										printf("%d ", print_link(octree1->linkW->link5->link2));
										printf("%d ", print_link(octree1->linkW->link5->link3));
										printf("%d ", print_link(octree1->linkW->link5->link4));
										printf("%d ", print_link(octree1->linkW->link5->link5));
										printf("%d ", print_link(octree1->linkW->link5->link6));
										printf("%d ", print_link(octree1->linkW->link5->link7));
									}
									printf("%d ", print_link(octree1->linkW->link6));
									if (octree1->linkW->link6 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link6->link0));
										printf("%d ", print_link(octree1->linkW->link6->link1));
										printf("%d ", print_link(octree1->linkW->link6->link2));
										printf("%d ", print_link(octree1->linkW->link6->link3));
										printf("%d ", print_link(octree1->linkW->link6->link4));
										printf("%d ", print_link(octree1->linkW->link6->link5));
										printf("%d ", print_link(octree1->linkW->link6->link6));
										printf("%d ", print_link(octree1->linkW->link6->link7));
									}
									printf("%d ", print_link(octree1->linkW->link7));
									if (oc->linkW->link7 != nullptr) {
										printf("%d ", print_link(octree1->linkW->link7->link0));
										printf("%d ", print_link(octree1->linkW->link7->link1));
										printf("%d ", print_link(octree1->linkW->link7->link2));
										printf("%d ", print_link(octree1->linkW->link7->link3));
										printf("%d ", print_link(octree1->linkW->link7->link4));
										printf("%d ", print_link(octree1->linkW->link7->link5));
										printf("%d ", print_link(octree1->linkW->link7->link6));
										printf("%d ", print_link(octree1->linkW->link7->link7));
									}
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}


								//system("PAUSE");
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link7;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link3;
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link7;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link5;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link1;
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link5;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link2;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link2;
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link2;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link0;
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link0;
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link1;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link1;
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link1;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link1;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link1;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link3;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link3;
									break;
								case 4: octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link3;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if (is_null1(octree1->linkW)) {
							// Разбита на 8 равных частей:
							// 0,3,4,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:octree1->linkW = octree1->linkW->link6;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3,4,7
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkW = octree1->linkW->link2;
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkW = octree1->linkW->link6;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,4
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0: octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4: octree1->linkW = octree1->linkW->link5;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0:octree1->linkW = octree1->linkW->link1;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkW = octree1->linkW->link2;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						}
						}
						}
					}
					}

					}

//#pragma omp section
						{

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4N == false) {
						// только одиночная связь.
					if (octree1->linkN != nullptr) {
						// Если одиночная связь не пустая и
						// если одна содержит дробление.
						if (octree1->linkN->link0!=nullptr) {
							if ((octree1->linkN->link1 == nullptr) && (octree1->linkN->link2 == nullptr) && (octree1->linkN->link3 == nullptr) && (octree1->linkN->link4 == nullptr) && (octree1->linkN->link5 == nullptr) && (octree1->linkN->link6 == nullptr) && (octree1->linkN->link7 == nullptr)) {
								printf("error: octree1->linkN->link0!=nullptr a na samom dele ==nullptr\n");
								//system("PAUSE");
								system("PAUSE");
								exit(1);
							}
						// octree1 это лист.

                        // это ситуации вырождения внутри соседа.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkN->minx + 1 == octree1->linkN->maxx) {
								bSituationX = true;
							}
							if (octree1->linkN->miny + 1 == octree1->linkN->maxy) {
								bSituationY = true;
							}
							if (octree1->linkN->minz + 1 == octree1->linkN->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkN->link0 != nullptr)) {
								if (bSituationX != octree1->linkN->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkN->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkN->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkN->link0->brootSituationX;
							bSituationY = octree1->linkN->link0->brootSituationY;
							bSituationZ = octree1->linkN->link0->brootSituationZ;
						}

						// Чрезвычайно коварный случай. 7сентября 2016.
						bool bsitY = false;
						if (((!bSituationY) && (bSituationX) && (bSituationZ))) bsitY = true;


						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkN->ilevel)||(bsitY)) {
							if (DEBUG_ALICE_MESH) {
								printf("incomming b4N Create. Ok\n");
								//system("PAUSE");
							}

						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4N = true;
								octree1->linkN2 = nullptr;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = nullptr;
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = nullptr;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 

								//printf("N situation Y\n");
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = octree1->linkN->link5;
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = nullptr;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = nullptr; 
								octree1->linkN7 = nullptr; 
								octree1->linkN = nullptr;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								octree1->b4N = true;
								octree1->linkN2 = nullptr;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = nullptr; 
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = nullptr;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = nullptr; 
								octree1->linkN7 = nullptr; 
								octree1->linkN = nullptr;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								//octree1->b4N = true;
								octree1->linkN2 = nullptr; 
								//octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = nullptr; 
								octree1->linkN7 = nullptr;
								// Редуцирование четырёх соседей.
								octree1->b4N = false;
								octree1->linkN3 = nullptr;
								octree1->linkN = octree1->linkN->link0;
							}
							else if (is_null1(octree1->linkN)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
#if doubleintprecision == 1
			//printf("N div by 8 octree1->root=%lld",octree1->root); // Во всех 16.
#else
			//printf("N div by 8 octree1->root=%d",octree1->root); // Во всех 16.
#endif
								
								if (octree1->brootSituationY) {
									//printf(" sitY=1\n");
								}
								else {
									//printf(" sitY=0\n");
								}
								octree1->b4N = true;
								octree1->linkN2 = octree1->linkN->link1;
								octree1->linkN3 = octree1->linkN->link0;
								octree1->linkN6 = octree1->linkN->link5;
								octree1->linkN7 = octree1->linkN->link4;
								octree1->linkN = nullptr;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkN->ilevel != 1) {
								
								if (is_null1_new(octree1->linkN)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkN is_null1_new.\n");
									}
									if (octree1->ilevel - octree1->linkN->ilevel ==2) {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link4;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link5;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link1;
													break;
												case 7:octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:octree1->linkN = octree1->linkN->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link4;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link1;
													break;
												case 7:octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:octree1->linkN = octree1->linkN->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link0;
													break;
												case 7:octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link0;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:octree1->linkN = octree1->linkN->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link0;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkN)) {
											// Разбита на 8 равных частей:
											// 3,2,6,7
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6: octree1->linkN = octree1->linkN->link5;
													break;
												case 7:octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 3, 7
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3: octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7: octree1->linkN = octree1->linkN->link4;
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:octree1->linkN = octree1->linkN->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//2,3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:octree1->linkN = octree1->linkN->link1;
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkN = octree1->linkN->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkN = octree1->linkN->link0;
													break;
												case 1:octree1->linkN = octree1->linkN->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//3
												switch (octree1->parent->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkN = octree1->linkN->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}

									}
									else {
										printf("Fatal error!!! N distance meshdu urovnqmi > 2\n");
										//system("PAUSE");
										system("PAUSE");
										//exit(1);
									}

								}
								else {
									printf("error: linkN nepravilnje urovni.\n");
#if doubleintprecision == 1
									printf("octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
#else
									printf("octree1->ilevel=%d octree1->linkN->ilevel=%d\n", octree1->ilevel, octree1->linkN->ilevel);
#endif
									char c0 = 0;
									char c1 = 0;
									char c2 = 0;
									char c3 = 0;
									char c4 = 0;
									char c5 = 0;
									char c6 = 0;
									char c7 = 0;
									is_null3(octree1->linkN, N_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1

									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkN->link0));
									if (octree1->linkN->link0 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link0->link0));
										printf("%lld ", print_link(octree1->linkN->link0->link1));
										printf("%lld ", print_link(octree1->linkN->link0->link2));
										printf("%lld ", print_link(octree1->linkN->link0->link3));
										printf("%lld ", print_link(octree1->linkN->link0->link4));
										printf("%lld ", print_link(octree1->linkN->link0->link5));
										printf("%lld ", print_link(octree1->linkN->link0->link6));
										printf("%lld ", print_link(octree1->linkN->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link1));
									if (octree1->linkN->link1 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link1->link0));
										printf("%lld ", print_link(octree1->linkN->link1->link1));
										printf("%lld ", print_link(octree1->linkN->link1->link2));
										printf("%lld ", print_link(octree1->linkN->link1->link3));
										printf("%lld ", print_link(octree1->linkN->link1->link4));
										printf("%lld ", print_link(octree1->linkN->link1->link5));
										printf("%lld ", print_link(octree1->linkN->link1->link6));
										printf("%lld ", print_link(octree1->linkN->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link2));
									if (octree1->linkN->link2 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link2->link0));
										printf("%lld ", print_link(octree1->linkN->link2->link1));
										printf("%lld ", print_link(octree1->linkN->link2->link2));
										printf("%lld ", print_link(octree1->linkN->link2->link3));
										printf("%lld ", print_link(octree1->linkN->link2->link4));
										printf("%lld ", print_link(octree1->linkN->link2->link5));
										printf("%lld ", print_link(octree1->linkN->link2->link6));
										printf("%lld ", print_link(octree1->linkN->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link3));
									if (octree1->linkN->link3 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link3->link0));
										printf("%lld ", print_link(octree1->linkN->link3->link1));
										printf("%lld ", print_link(octree1->linkN->link3->link2));
										printf("%lld ", print_link(octree1->linkN->link3->link3));
										printf("%lld ", print_link(octree1->linkN->link3->link4));
										printf("%lld ", print_link(octree1->linkN->link3->link5));
										printf("%lld ", print_link(octree1->linkN->link3->link6));
										printf("%lld ", print_link(octree1->linkN->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link4));
									if (octree1->linkN->link4 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link4->link0));
										printf("%lld ", print_link(octree1->linkN->link4->link1));
										printf("%lld ", print_link(octree1->linkN->link4->link2));
										printf("%lld ", print_link(octree1->linkN->link4->link3));
										printf("%lld ", print_link(octree1->linkN->link4->link4));
										printf("%lld ", print_link(octree1->linkN->link4->link5));
										printf("%lld ", print_link(octree1->linkN->link4->link6));
										printf("%lld ", print_link(octree1->linkN->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link5));
									if (octree1->linkN->link5 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link5->link0));
										printf("%lld ", print_link(octree1->linkN->link5->link1));
										printf("%lld ", print_link(octree1->linkN->link5->link2));
										printf("%lld ", print_link(octree1->linkN->link5->link3));
										printf("%lld ", print_link(octree1->linkN->link5->link4));
										printf("%lld ", print_link(octree1->linkN->link5->link5));
										printf("%lld ", print_link(octree1->linkN->link5->link6));
										printf("%lld ", print_link(octree1->linkN->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link6));
									if (octree1->linkN->link6 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link6->link0));
										printf("%lld ", print_link(octree1->linkN->link6->link1));
										printf("%lld ", print_link(octree1->linkN->link6->link2));
										printf("%lld ", print_link(octree1->linkN->link6->link3));
										printf("%lld ", print_link(octree1->linkN->link6->link4));
										printf("%lld ", print_link(octree1->linkN->link6->link5));
										printf("%lld ", print_link(octree1->linkN->link6->link6));
										printf("%lld ", print_link(octree1->linkN->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkN->link7));
									if (oc->linkN->link7 != nullptr) {
										printf("%lld ", print_link(octree1->linkN->link7->link0));
										printf("%lld ", print_link(octree1->linkN->link7->link1));
										printf("%lld ", print_link(octree1->linkN->link7->link2));
										printf("%lld ", print_link(octree1->linkN->link7->link3));
										printf("%lld ", print_link(octree1->linkN->link7->link4));
										printf("%lld ", print_link(octree1->linkN->link7->link5));
										printf("%lld ", print_link(octree1->linkN->link7->link6));
										printf("%lld ", print_link(octree1->linkN->link7->link7));
									}
#else

									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkN->link0));
									if (octree1->linkN->link0 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link0->link0));
										printf("%d ", print_link(octree1->linkN->link0->link1));
										printf("%d ", print_link(octree1->linkN->link0->link2));
										printf("%d ", print_link(octree1->linkN->link0->link3));
										printf("%d ", print_link(octree1->linkN->link0->link4));
										printf("%d ", print_link(octree1->linkN->link0->link5));
										printf("%d ", print_link(octree1->linkN->link0->link6));
										printf("%d ", print_link(octree1->linkN->link0->link7));
									}
									printf("%d ", print_link(octree1->linkN->link1));
									if (octree1->linkN->link1 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link1->link0));
										printf("%d ", print_link(octree1->linkN->link1->link1));
										printf("%d ", print_link(octree1->linkN->link1->link2));
										printf("%d ", print_link(octree1->linkN->link1->link3));
										printf("%d ", print_link(octree1->linkN->link1->link4));
										printf("%d ", print_link(octree1->linkN->link1->link5));
										printf("%d ", print_link(octree1->linkN->link1->link6));
										printf("%d ", print_link(octree1->linkN->link1->link7));
									}
									printf("%d ", print_link(octree1->linkN->link2));
									if (octree1->linkN->link2 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link2->link0));
										printf("%d ", print_link(octree1->linkN->link2->link1));
										printf("%d ", print_link(octree1->linkN->link2->link2));
										printf("%d ", print_link(octree1->linkN->link2->link3));
										printf("%d ", print_link(octree1->linkN->link2->link4));
										printf("%d ", print_link(octree1->linkN->link2->link5));
										printf("%d ", print_link(octree1->linkN->link2->link6));
										printf("%d ", print_link(octree1->linkN->link2->link7));
									}
									printf("%d ", print_link(octree1->linkN->link3));
									if (octree1->linkN->link3 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link3->link0));
										printf("%d ", print_link(octree1->linkN->link3->link1));
										printf("%d ", print_link(octree1->linkN->link3->link2));
										printf("%d ", print_link(octree1->linkN->link3->link3));
										printf("%d ", print_link(octree1->linkN->link3->link4));
										printf("%d ", print_link(octree1->linkN->link3->link5));
										printf("%d ", print_link(octree1->linkN->link3->link6));
										printf("%d ", print_link(octree1->linkN->link3->link7));
									}
									printf("%d ", print_link(octree1->linkN->link4));
									if (octree1->linkN->link4 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link4->link0));
										printf("%d ", print_link(octree1->linkN->link4->link1));
										printf("%d ", print_link(octree1->linkN->link4->link2));
										printf("%d ", print_link(octree1->linkN->link4->link3));
										printf("%d ", print_link(octree1->linkN->link4->link4));
										printf("%d ", print_link(octree1->linkN->link4->link5));
										printf("%d ", print_link(octree1->linkN->link4->link6));
										printf("%d ", print_link(octree1->linkN->link4->link7));
									}
									printf("%d ", print_link(octree1->linkN->link5));
									if (octree1->linkN->link5 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link5->link0));
										printf("%d ", print_link(octree1->linkN->link5->link1));
										printf("%d ", print_link(octree1->linkN->link5->link2));
										printf("%d ", print_link(octree1->linkN->link5->link3));
										printf("%d ", print_link(octree1->linkN->link5->link4));
										printf("%d ", print_link(octree1->linkN->link5->link5));
										printf("%d ", print_link(octree1->linkN->link5->link6));
										printf("%d ", print_link(octree1->linkN->link5->link7));
									}
									printf("%d ", print_link(octree1->linkN->link6));
									if (octree1->linkN->link6 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link6->link0));
										printf("%d ", print_link(octree1->linkN->link6->link1));
										printf("%d ", print_link(octree1->linkN->link6->link2));
										printf("%d ", print_link(octree1->linkN->link6->link3));
										printf("%d ", print_link(octree1->linkN->link6->link4));
										printf("%d ", print_link(octree1->linkN->link6->link5));
										printf("%d ", print_link(octree1->linkN->link6->link6));
										printf("%d ", print_link(octree1->linkN->link6->link7));
									}
									printf("%d ", print_link(octree1->linkN->link7));
									if (oc->linkN->link7 != nullptr) {
										printf("%d ", print_link(octree1->linkN->link7->link0));
										printf("%d ", print_link(octree1->linkN->link7->link1));
										printf("%d ", print_link(octree1->linkN->link7->link2));
										printf("%d ", print_link(octree1->linkN->link7->link3));
										printf("%d ", print_link(octree1->linkN->link7->link4));
										printf("%d ", print_link(octree1->linkN->link7->link5));
										printf("%d ", print_link(octree1->linkN->link7->link6));
										printf("%d ", print_link(octree1->linkN->link7->link7));
									}
#endif
									//system("PAUSE");
									system("PAUSE");

								}
								
								//system("PAUSE");
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link4;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link5;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link5;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link1;
									break;
								case 7:octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:octree1->linkN = octree1->linkN->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link4;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link4;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link1;
									break;
								case 7:octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:octree1->linkN = octree1->linkN->link1;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link0;
									break;
								case 7:octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link0;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:octree1->linkN = octree1->linkN->link0;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link0;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link0;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkN)) {
							// Разбита на 8 равных частей:
							// 3,2,6,7
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6: octree1->linkN = octree1->linkN->link5;
									break;
								case 7:octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 3, 7
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3: octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7: octree1->linkN = octree1->linkN->link4;
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1,4,5
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:octree1->linkN = octree1->linkN->link5;
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//2,3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:octree1->linkN = octree1->linkN->link1;
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0,4
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:octree1->linkN = octree1->linkN->link4;
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkN = octree1->linkN->link0;
									break;
								case 1:octree1->linkN = octree1->linkN->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//3
								switch (octree1->root) {
								case 0:
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkN = octree1->linkN->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						}
						}
						}
					}
					}

					}

//#pragma omp section
						{

						// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4S == false) {
						if (octree1->linkS != nullptr) {
							if (octree1->linkS->link0 != nullptr) {
								if ((octree1->linkS->link1 == nullptr) && (octree1->linkS->link2 == nullptr) && (octree1->linkS->link3 == nullptr) && (octree1->linkS->link4 == nullptr) && (octree1->linkS->link5 == nullptr) && (octree1->linkS->link6 == nullptr) && (octree1->linkS->link7 == nullptr)) {
									printf("error: octree1->linkS->link0!=nullptr a na samom dele ==nullptr\n");
									//system("PAUSE");
									system("PAUSE");
									exit(1);
								}


								// octree1 это лист.
								bool bSituationX = false;
								bool bSituationY = false;
								bool bSituationZ = false;

								if (bold_stable_version) {
									if (octree1->linkS->minx + 1 == octree1->linkS->maxx) {
										bSituationX = true;
									}
									if (octree1->linkS->miny + 1 == octree1->linkS->maxy) {
										bSituationY = true;
									}
									if (octree1->linkS->minz + 1 == octree1->linkS->maxz) {
										bSituationZ = true;
									}
									if ((octree1->linkS->link0 != nullptr)) {
										if (bSituationX != octree1->linkS->link0->brootSituationX) {
											printf("error ne sovpadenie Situation X.");
										}
										if (bSituationY != octree1->linkS->link0->brootSituationY) {
											printf("error ne sovpadenie Situation Y.");
										}
										if (bSituationZ != octree1->linkS->link0->brootSituationZ) {
											printf("error ne sovpadenie Situation Z.");
										}
									}
								}
								else {
									// 4.01.2018 Попробуем так. Чисто на интуиции пока.
									// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
									bSituationX = octree1->linkS->link0->brootSituationX;
									bSituationY = octree1->linkS->link0->brootSituationY;
									bSituationZ = octree1->linkS->link0->brootSituationZ;
								}

								// Чрезвычайно коварный случай. 7 сентября 2016.
								bool bsitY = false;
								if (((!bSituationY) && (bSituationX) && (bSituationZ))) bsitY = true;

								//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
								if ((octree1->ilevel == octree1->linkS->ilevel) || (bsitY)) {
									// Не дробленный лист контачит по грани E с дроблённым обектом.
									if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
										// вырождение по Х
										// 0,3,4,7 
										octree1->b4S = true;
										octree1->linkS0 = octree1->linkS->link3;
										octree1->linkS1 = nullptr;
										octree1->linkS4 = octree1->linkS->link7;
										octree1->linkS5 = nullptr;
										octree1->linkS = nullptr;
									}
									else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
										// вырождение по Y
										// 0,1,4,5 
										octree1->b4S = true;
										octree1->linkS0 = octree1->linkS->link0;
										octree1->linkS1 = octree1->linkS->link1;
										octree1->linkS4 = octree1->linkS->link4;
										octree1->linkS5 = octree1->linkS->link5;
										octree1->linkS = nullptr;
									}
									else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
										// вырождение по Z
										// 0,1,2,3
										octree1->b4S = true;
										octree1->linkS0 = octree1->linkS->link3;
										octree1->linkS1 = octree1->linkS->link2;
										octree1->linkS4 = nullptr;
										octree1->linkS5 = nullptr;
										octree1->linkS = nullptr;
									}
									else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
										// direction Z
										// 0,4
										octree1->b4S = true;
										octree1->linkS0 = octree1->linkS->link0;
										octree1->linkS1 = nullptr;
										octree1->linkS4 = octree1->linkS->link4;
										octree1->linkS5 = nullptr;
										octree1->linkS = nullptr;
									}
									else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
										// direction X
										// 0,1
										octree1->b4S = true;
										octree1->linkS0 = octree1->linkS->link0;
										octree1->linkS1 = octree1->linkS->link1;
										octree1->linkS4 = nullptr;
										octree1->linkS5 = nullptr;
										octree1->linkS = nullptr;
									}
									else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
										// direction Y
										// 0,3
										//octree1->b4S = true;
										//octree1->linkS0 = octree1->linkS->link3;
										octree1->linkS1 = nullptr;
										octree1->linkS4 = nullptr;
										octree1->linkS5 = nullptr;
										// редуцирование четырёх соседов к одному.
										octree1->b4S = false;
										octree1->linkS0 = nullptr;
										octree1->linkS = octree1->linkS->link3;
									}
									else if (is_null1(octree1->linkS)) {
										// Разбита на 8 равных частей:
										// 1,2,5,6
										octree1->b4S = true;
										octree1->linkS0 = octree1->linkS->link3;
										octree1->linkS1 = octree1->linkS->link2;
										octree1->linkS4 = octree1->linkS->link7;
										octree1->linkS5 = octree1->linkS->link6;
										octree1->linkS = nullptr;
									}
								}
								else {
									if (octree1->ilevel - octree1->linkS->ilevel != 1) {

										if (is_null1_new(octree1->linkS)) {
											if (DEBUG_ALICE_MESH) {
												printf("linkS  is_null1_new. \n");
											}
											if (octree1->ilevel - octree1->linkS->ilevel == 2) {
												if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
													// вырождение по Х
													// 0,3,4,7 
													// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link7;
															break;
														case 5: octree1->linkS = octree1->linkS->link7;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link7;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link7;
															break;
														case 5:octree1->linkS = octree1->linkS->link7;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link7;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}
												else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
													// вырождение по Y
													// 0,1,4,5 
													// (3->0),(2->1),(7->4), (6->5)
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1: octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link4;
															break;
														case 5: octree1->linkS = octree1->linkS->link5;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link4;
															break;
														case 5:octree1->linkS = octree1->linkS->link5;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1: octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}
												else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
													// вырождение по Z
													// 0,1,2,3
													// (4->0) (5->1) (6->2) (7->3)
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link3;
															break;
														case 5: octree1->linkS = octree1->linkS->link2;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link3;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link3;
															break;
														case 5:octree1->linkS = octree1->linkS->link2;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link3;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}
												else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
													// direction Z
													// 0,4
													// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1: octree1->linkS = octree1->linkS->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link4;
															break;
														case 5: octree1->linkS = octree1->linkS->link4;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:octree1->linkS = octree1->linkS->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link4;
															break;
														case 5:octree1->linkS = octree1->linkS->link4;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1: octree1->linkS = octree1->linkS->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link4;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:octree1->linkS = octree1->linkS->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
													// direction X
													// 0,1
													// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1: octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link0;
															break;
														case 5: octree1->linkS = octree1->linkS->link1;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link0;
															break;
														case 5:octree1->linkS = octree1->linkS->link1;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1: octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link0;
															break;
														case 1:octree1->linkS = octree1->linkS->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
													// direction Y
													// 0,3
													// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link3;
															break;
														case 5: octree1->linkS = octree1->linkS->link3;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link3;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link3;
															break;
														case 5:octree1->linkS = octree1->linkS->link3;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link3;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link3;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if (is_null1(octree1->linkS)) {
													// Разбита на 8 равных частей:
													// 0,1,4,5
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkS = octree1->linkS->link7;
															break;
														case 5: octree1->linkS = octree1->linkS->link6;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link7;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//0,1,4,5
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link7;
															break;
														case 5:octree1->linkS = octree1->linkS->link6;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1: octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkS = octree1->linkS->link7;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkS = octree1->linkS->link3;
															break;
														case 1:octree1->linkS = octree1->linkS->link2;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0
														switch (octree1->parent->root) {
														case 0: octree1->linkS = octree1->linkS->link3;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}

											}
											else {
												printf("Fatal error!!! S distance meshdu urovnqmi > 2\n");
												//system("PAUSE");
												system("PAUSE");
												//exit(1);
											}

										}
										else {
											printf("error: linkS nepravilnje urovni.\n");

											char c0 = 0;
											char c1 = 0;
											char c2 = 0;
											char c3 = 0;
											char c4 = 0;
											char c5 = 0;
											char c6 = 0;
											char c7 = 0;
											is_null3(octree1->linkS, S_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
											printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
											printf("%lld ", print_link(octree1->linkS->link0));
											if (octree1->linkS->link0 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link0->link0));
												printf("%lld ", print_link(octree1->linkS->link0->link1));
												printf("%lld ", print_link(octree1->linkS->link0->link2));
												printf("%lld ", print_link(octree1->linkS->link0->link3));
												printf("%lld ", print_link(octree1->linkS->link0->link4));
												printf("%lld ", print_link(octree1->linkS->link0->link5));
												printf("%lld ", print_link(octree1->linkS->link0->link6));
												printf("%lld ", print_link(octree1->linkS->link0->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link1));
											if (octree1->linkS->link1 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link1->link0));
												printf("%lld ", print_link(octree1->linkS->link1->link1));
												printf("%lld ", print_link(octree1->linkS->link1->link2));
												printf("%lld ", print_link(octree1->linkS->link1->link3));
												printf("%lld ", print_link(octree1->linkS->link1->link4));
												printf("%lld ", print_link(octree1->linkS->link1->link5));
												printf("%lld ", print_link(octree1->linkS->link1->link6));
												printf("%lld ", print_link(octree1->linkS->link1->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link2));
											if (octree1->linkS->link2 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link2->link0));
												printf("%lld ", print_link(octree1->linkS->link2->link1));
												printf("%lld ", print_link(octree1->linkS->link2->link2));
												printf("%lld ", print_link(octree1->linkS->link2->link3));
												printf("%lld ", print_link(octree1->linkS->link2->link4));
												printf("%lld ", print_link(octree1->linkS->link2->link5));
												printf("%lld ", print_link(octree1->linkS->link2->link6));
												printf("%lld ", print_link(octree1->linkS->link2->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link3));
											if (octree1->linkS->link3 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link3->link0));
												printf("%lld ", print_link(octree1->linkS->link3->link1));
												printf("%lld ", print_link(octree1->linkS->link3->link2));
												printf("%lld ", print_link(octree1->linkS->link3->link3));
												printf("%lld ", print_link(octree1->linkS->link3->link4));
												printf("%lld ", print_link(octree1->linkS->link3->link5));
												printf("%lld ", print_link(octree1->linkS->link3->link6));
												printf("%lld ", print_link(octree1->linkS->link3->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link4));
											if (octree1->linkS->link4 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link4->link0));
												printf("%lld ", print_link(octree1->linkS->link4->link1));
												printf("%lld ", print_link(octree1->linkS->link4->link2));
												printf("%lld ", print_link(octree1->linkS->link4->link3));
												printf("%lld ", print_link(octree1->linkS->link4->link4));
												printf("%lld ", print_link(octree1->linkS->link4->link5));
												printf("%lld ", print_link(octree1->linkS->link4->link6));
												printf("%lld ", print_link(octree1->linkS->link4->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link5));
											if (octree1->linkS->link5 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link5->link0));
												printf("%lld ", print_link(octree1->linkS->link5->link1));
												printf("%lld ", print_link(octree1->linkS->link5->link2));
												printf("%lld ", print_link(octree1->linkS->link5->link3));
												printf("%lld ", print_link(octree1->linkS->link5->link4));
												printf("%lld ", print_link(octree1->linkS->link5->link5));
												printf("%lld ", print_link(octree1->linkS->link5->link6));
												printf("%lld ", print_link(octree1->linkS->link5->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link6));
											if (octree1->linkS->link6 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link6->link0));
												printf("%lld ", print_link(octree1->linkS->link6->link1));
												printf("%lld ", print_link(octree1->linkS->link6->link2));
												printf("%lld ", print_link(octree1->linkS->link6->link3));
												printf("%lld ", print_link(octree1->linkS->link6->link4));
												printf("%lld ", print_link(octree1->linkS->link6->link5));
												printf("%lld ", print_link(octree1->linkS->link6->link6));
												printf("%lld ", print_link(octree1->linkS->link6->link7));
											}
											printf("%lld ", print_link(octree1->linkS->link7));
											if (oc->linkS->link7 != nullptr) {
												printf("%lld ", print_link(octree1->linkS->link7->link0));
												printf("%lld ", print_link(octree1->linkS->link7->link1));
												printf("%lld ", print_link(octree1->linkS->link7->link2));
												printf("%lld ", print_link(octree1->linkS->link7->link3));
												printf("%lld ", print_link(octree1->linkS->link7->link4));
												printf("%lld ", print_link(octree1->linkS->link7->link5));
												printf("%lld ", print_link(octree1->linkS->link7->link6));
												printf("%lld ", print_link(octree1->linkS->link7->link7));
											}
#else
											printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
											printf("%d ", print_link(octree1->linkS->link0));
											if (octree1->linkS->link0 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link0->link0));
												printf("%d ", print_link(octree1->linkS->link0->link1));
												printf("%d ", print_link(octree1->linkS->link0->link2));
												printf("%d ", print_link(octree1->linkS->link0->link3));
												printf("%d ", print_link(octree1->linkS->link0->link4));
												printf("%d ", print_link(octree1->linkS->link0->link5));
												printf("%d ", print_link(octree1->linkS->link0->link6));
												printf("%d ", print_link(octree1->linkS->link0->link7));
											}
											printf("%d ", print_link(octree1->linkS->link1));
											if (octree1->linkS->link1 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link1->link0));
												printf("%d ", print_link(octree1->linkS->link1->link1));
												printf("%d ", print_link(octree1->linkS->link1->link2));
												printf("%d ", print_link(octree1->linkS->link1->link3));
												printf("%d ", print_link(octree1->linkS->link1->link4));
												printf("%d ", print_link(octree1->linkS->link1->link5));
												printf("%d ", print_link(octree1->linkS->link1->link6));
												printf("%d ", print_link(octree1->linkS->link1->link7));
											}
											printf("%d ", print_link(octree1->linkS->link2));
											if (octree1->linkS->link2 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link2->link0));
												printf("%d ", print_link(octree1->linkS->link2->link1));
												printf("%d ", print_link(octree1->linkS->link2->link2));
												printf("%d ", print_link(octree1->linkS->link2->link3));
												printf("%d ", print_link(octree1->linkS->link2->link4));
												printf("%d ", print_link(octree1->linkS->link2->link5));
												printf("%d ", print_link(octree1->linkS->link2->link6));
												printf("%d ", print_link(octree1->linkS->link2->link7));
											}
											printf("%d ", print_link(octree1->linkS->link3));
											if (octree1->linkS->link3 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link3->link0));
												printf("%d ", print_link(octree1->linkS->link3->link1));
												printf("%d ", print_link(octree1->linkS->link3->link2));
												printf("%d ", print_link(octree1->linkS->link3->link3));
												printf("%d ", print_link(octree1->linkS->link3->link4));
												printf("%d ", print_link(octree1->linkS->link3->link5));
												printf("%d ", print_link(octree1->linkS->link3->link6));
												printf("%d ", print_link(octree1->linkS->link3->link7));
											}
											printf("%d ", print_link(octree1->linkS->link4));
											if (octree1->linkS->link4 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link4->link0));
												printf("%d ", print_link(octree1->linkS->link4->link1));
												printf("%d ", print_link(octree1->linkS->link4->link2));
												printf("%d ", print_link(octree1->linkS->link4->link3));
												printf("%d ", print_link(octree1->linkS->link4->link4));
												printf("%d ", print_link(octree1->linkS->link4->link5));
												printf("%d ", print_link(octree1->linkS->link4->link6));
												printf("%d ", print_link(octree1->linkS->link4->link7));
											}
											printf("%d ", print_link(octree1->linkS->link5));
											if (octree1->linkS->link5 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link5->link0));
												printf("%d ", print_link(octree1->linkS->link5->link1));
												printf("%d ", print_link(octree1->linkS->link5->link2));
												printf("%d ", print_link(octree1->linkS->link5->link3));
												printf("%d ", print_link(octree1->linkS->link5->link4));
												printf("%d ", print_link(octree1->linkS->link5->link5));
												printf("%d ", print_link(octree1->linkS->link5->link6));
												printf("%d ", print_link(octree1->linkS->link5->link7));
											}
											printf("%d ", print_link(octree1->linkS->link6));
											if (octree1->linkS->link6 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link6->link0));
												printf("%d ", print_link(octree1->linkS->link6->link1));
												printf("%d ", print_link(octree1->linkS->link6->link2));
												printf("%d ", print_link(octree1->linkS->link6->link3));
												printf("%d ", print_link(octree1->linkS->link6->link4));
												printf("%d ", print_link(octree1->linkS->link6->link5));
												printf("%d ", print_link(octree1->linkS->link6->link6));
												printf("%d ", print_link(octree1->linkS->link6->link7));
											}
											printf("%d ", print_link(octree1->linkS->link7));
											if (oc->linkS->link7 != nullptr) {
												printf("%d ", print_link(octree1->linkS->link7->link0));
												printf("%d ", print_link(octree1->linkS->link7->link1));
												printf("%d ", print_link(octree1->linkS->link7->link2));
												printf("%d ", print_link(octree1->linkS->link7->link3));
												printf("%d ", print_link(octree1->linkS->link7->link4));
												printf("%d ", print_link(octree1->linkS->link7->link5));
												printf("%d ", print_link(octree1->linkS->link7->link6));
												printf("%d ", print_link(octree1->linkS->link7->link7));
											}
#endif

											//system("PAUSE");
											system("PAUSE");

										}
										//system("PAUSE");
									}
									else {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link7;
													break;
												case 5: octree1->linkS = octree1->linkS->link7;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:octree1->linkS = octree1->linkS->link7;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link4;
													break;
												case 5: octree1->linkS = octree1->linkS->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:octree1->linkS = octree1->linkS->link5;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link3;
													break;
												case 5: octree1->linkS = octree1->linkS->link2;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:octree1->linkS = octree1->linkS->link2;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link4;
													break;
												case 5: octree1->linkS = octree1->linkS->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:octree1->linkS = octree1->linkS->link4;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link4;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link0;
													break;
												case 5: octree1->linkS = octree1->linkS->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link0;
													break;
												case 5:octree1->linkS = octree1->linkS->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1: octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link0;
													break;
												case 1:octree1->linkS = octree1->linkS->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link3;
													break;
												case 5: octree1->linkS = octree1->linkS->link3;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:octree1->linkS = octree1->linkS->link3;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link3;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link3;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkS)) {
											// Разбита на 8 равных частей:
											// 0,1,4,5
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkS = octree1->linkS->link7;
													break;
												case 5: octree1->linkS = octree1->linkS->link6;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//0,1,4,5
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:octree1->linkS = octree1->linkS->link6;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1: octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkS = octree1->linkS->link7;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkS = octree1->linkS->link3;
													break;
												case 1:octree1->linkS = octree1->linkS->link2;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0
												switch (octree1->root) {
												case 0: octree1->linkS = octree1->linkS->link3;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
									}
								}
							}
						}
					}

					}

					//#pragma omp section
					{
					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4T == false) {
						if (octree1->linkT != nullptr) {
							if (octree1->linkT->link0 != nullptr) {
								if ((octree1->linkT->link1 == nullptr) && (octree1->linkT->link2 == nullptr) && (octree1->linkT->link3 == nullptr) && (octree1->linkT->link4 == nullptr) && (octree1->linkT->link5 == nullptr) && (octree1->linkT->link6 == nullptr) && (octree1->linkT->link7 == nullptr)) {
									printf("error: octree1->linkT->link0!=nullptr a na samom dele ==nullptr\n");
									//system("PAUSE");
									system("PAUSE");
									exit(1);
								}

								// octree1 это лист.
								bool bSituationX = false;
								bool bSituationY = false;
								bool bSituationZ = false;

								if (bold_stable_version) {
									if (octree1->linkT->minx + 1 == octree1->linkT->maxx) {
										bSituationX = true;
									}
									if (octree1->linkT->miny + 1 == octree1->linkT->maxy) {
										bSituationY = true;
									}
									if (octree1->linkT->minz + 1 == octree1->linkT->maxz) {
										bSituationZ = true;
									}
									if ((octree1->linkT->link0 != nullptr)) {
										if (bSituationX != octree1->linkT->link0->brootSituationX) {
											printf("error ne sovpadenie Situation X.");
										}
										if (bSituationY != octree1->linkT->link0->brootSituationY) {
											printf("error ne sovpadenie Situation Y.");
										}
										if (bSituationZ != octree1->linkT->link0->brootSituationZ) {
											printf("error ne sovpadenie Situation Z.");
										}
									}
								}
								else {
									// 4.01.2018 Попробуем так. Чисто на интуиции пока.
									// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
									bSituationX = octree1->linkT->link0->brootSituationX;
									bSituationY = octree1->linkT->link0->brootSituationY;
									bSituationZ = octree1->linkT->link0->brootSituationZ;
								}


								// Чрезвычайно коварный случай. 7сентября 2016.
								bool bsitZ = false;
								if (((!bSituationZ) && (bSituationX) && (bSituationY))) bsitZ = true;

								//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
								if ((octree1->ilevel == octree1->linkT->ilevel) || (bsitZ)) {
									// Не дробленный лист контачит по грани E с дроблённым обектом.
									if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
										// вырождение по Х
										// 0,3,4,7 
										octree1->b4T = true;
										octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = nullptr;
										octree1->linkT6 = nullptr;
										octree1->linkT7 = octree1->linkT->link3;
										octree1->linkT = nullptr;
									}
									else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
										// вырождение по Y
										// 0,1,4,5 
										octree1->b4T = true;
										octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = octree1->linkT->link1;
										octree1->linkT6 = nullptr;
										octree1->linkT7 = nullptr;
										octree1->linkT = nullptr;
									}
									else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
										// вырождение по Z
										// 0,1,2,3
										octree1->b4T = true;
										octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = octree1->linkT->link1;
										octree1->linkT6 = octree1->linkT->link2;
										octree1->linkT7 = octree1->linkT->link3;
										octree1->linkT = nullptr;
									}
									else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
										// direction Z
										// 0,4
										//octree1->b4T = true;
										//octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = nullptr;
										octree1->linkT6 = nullptr;
										octree1->linkT7 = nullptr;
										// Вырождение четырёх соседов к одному.
										octree1->b4T = false;
										octree1->linkT4 = nullptr;
										octree1->linkT = octree1->linkT->link0;
									}
									else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
										// direction X
										// 0,1
										octree1->b4T = true;
										octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = octree1->linkT->link1;
										octree1->linkT6 = nullptr;
										octree1->linkT7 = nullptr;
										octree1->linkT = nullptr;
									}
									else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
										// direction Y
										// 0,3
										octree1->b4T = true;
										octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = nullptr;
										octree1->linkT6 = nullptr;
										octree1->linkT7 = octree1->linkT->link3;
										octree1->linkT = nullptr;
									}
									else if (is_null1(octree1->linkT)) {
										// Разбита на 8 равных частей:
										// 1,2,5,6
										octree1->b4T = true;
										octree1->linkT4 = octree1->linkT->link0;
										octree1->linkT5 = octree1->linkT->link1;
										octree1->linkT6 = octree1->linkT->link2;
										octree1->linkT7 = octree1->linkT->link3;
										octree1->linkT = nullptr;
									}
								}
								else {
									if (octree1->ilevel - octree1->linkT->ilevel != 1) {

										if (is_null1_new(octree1->linkT)) {
											if (DEBUG_ALICE_MESH) {
												printf("linkT  is_null1_new. \n");
											}
											if (octree1->ilevel - octree1->linkT->ilevel == 2) {
												if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
													// вырождение по Х
													// 0,3,4,7 
													// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link0;
															break;
														case 6: octree1->linkT = octree1->linkT->link3;
															break;
														case 7: octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link0;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link0;
															break;
														case 2:octree1->linkT = octree1->linkT->link3;
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}


												}
												else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
													// вырождение по Y
													// 0,1,4,5 
													// (3->0),(2->1),(7->4), (6->5)
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link1;
															break;
														case 6: octree1->linkT = octree1->linkT->link1;
															break;
														case 7: octree1->linkT = octree1->linkT->link0;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link0;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link1;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link1;
															break;
														case 2:octree1->linkT = octree1->linkT->link1;
															break;
														case 3:octree1->linkT = octree1->linkT->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
													// вырождение по Z
													// 0,1,2,3
													// (4->0) (5->1) (6->2) (7->3)
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link1;
															break;
														case 6: octree1->linkT = octree1->linkT->link2;
															break;
														case 7: octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link1;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link1;
															break;
														case 2:octree1->linkT = octree1->linkT->link2;
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
													// direction Z
													// 0,4
													// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link0;
															break;
														case 6: octree1->linkT = octree1->linkT->link0;
															break;
														case 7: octree1->linkT = octree1->linkT->link0;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link0;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link0;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link0;
															break;
														case 2:octree1->linkT = octree1->linkT->link0;
															break;
														case 3:octree1->linkT = octree1->linkT->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
													// direction X
													// 0,1
													// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {

														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link1;
															break;
														case 6: octree1->linkT = octree1->linkT->link1;
															break;
														case 7: octree1->linkT = octree1->linkT->link0;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link0;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link1;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link1;
															break;
														case 2:octree1->linkT = octree1->linkT->link1;
															break;
														case 3:octree1->linkT = octree1->linkT->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link0;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
													// direction Y
													// 0,3
													// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link0;
															break;
														case 6: octree1->linkT = octree1->linkT->link3;
															break;
														case 7: octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link0;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link0;
															break;
														case 2:octree1->linkT = octree1->linkT->link3;
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link0;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}
												}
												else if (is_null1(octree1->linkT)) {
													// Разбита на 8 равных частей:
													// 4,5,6,7
													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4: octree1->linkT = octree1->linkT->link0;
															break;
														case 5: octree1->linkT = octree1->linkT->link1;
															break;
														case 6: octree1->linkT = octree1->linkT->link2;
															break;
														case 7: octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Х
														// 4,7
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:octree1->linkT = octree1->linkT->link3;
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// вырождение по Y
														//4,5
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:octree1->linkT = octree1->linkT->link1;
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// вырождение по Z
														//0,1,2,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1: octree1->linkT = octree1->linkT->link1;
															break;
														case 2:octree1->linkT = octree1->linkT->link2;
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
														// direction Z
														// 0,4
														switch (octree1->parent->root) {
														case 0:
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:octree1->linkT = octree1->linkT->link0;
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction X
														//0,1
														switch (octree1->parent->root) {
														case 0:octree1->linkT = octree1->linkT->link0;
															break;
														case 1:octree1->linkT = octree1->linkT->link1;
															break;
														case 2:
															break;
														case 3:
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

													if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
														// direction Y
														//0,3
														switch (octree1->parent->root) {
														case 0: octree1->linkT = octree1->linkT->link0;
															break;
														case 1:
															break;
														case 2:
															break;
														case 3:octree1->linkT = octree1->linkT->link3;
															break;
														case 4:
															break;
														case 5:
															break;
														case 6:
															break;
														case 7:
															break;
														}
													}

												}

											}
											else {
												printf("Fatal error!!! T distance meshdu urovnqmi > 2\n");
												//system("PAUSE");
												system("PAUSE");
												//exit(1);
											}

										}
										else {
											printf("error: linkT nepravilnje urovni.\n");

											char c0 = 0;
											char c1 = 0;
											char c2 = 0;
											char c3 = 0;
											char c4 = 0;
											char c5 = 0;
											char c6 = 0;
											char c7 = 0;
											is_null3(octree1->linkT, T_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
											printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
											printf("%lld ", print_link(octree1->linkT->link0));
											if (octree1->linkT->link0 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link0->link0));
												printf("%lld ", print_link(octree1->linkT->link0->link1));
												printf("%lld ", print_link(octree1->linkT->link0->link2));
												printf("%lld ", print_link(octree1->linkT->link0->link3));
												printf("%lld ", print_link(octree1->linkT->link0->link4));
												printf("%lld ", print_link(octree1->linkT->link0->link5));
												printf("%lld ", print_link(octree1->linkT->link0->link6));
												printf("%lld ", print_link(octree1->linkT->link0->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link1));
											if (octree1->linkT->link1 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link1->link0));
												printf("%lld ", print_link(octree1->linkT->link1->link1));
												printf("%lld ", print_link(octree1->linkT->link1->link2));
												printf("%lld ", print_link(octree1->linkT->link1->link3));
												printf("%lld ", print_link(octree1->linkT->link1->link4));
												printf("%lld ", print_link(octree1->linkT->link1->link5));
												printf("%lld ", print_link(octree1->linkT->link1->link6));
												printf("%lld ", print_link(octree1->linkT->link1->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link2));
											if (octree1->linkT->link2 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link2->link0));
												printf("%lld ", print_link(octree1->linkT->link2->link1));
												printf("%lld ", print_link(octree1->linkT->link2->link2));
												printf("%lld ", print_link(octree1->linkT->link2->link3));
												printf("%lld ", print_link(octree1->linkT->link2->link4));
												printf("%lld ", print_link(octree1->linkT->link2->link5));
												printf("%lld ", print_link(octree1->linkT->link2->link6));
												printf("%lld ", print_link(octree1->linkT->link2->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link3));
											if (octree1->linkT->link3 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link3->link0));
												printf("%lld ", print_link(octree1->linkT->link3->link1));
												printf("%lld ", print_link(octree1->linkT->link3->link2));
												printf("%lld ", print_link(octree1->linkT->link3->link3));
												printf("%lld ", print_link(octree1->linkT->link3->link4));
												printf("%lld ", print_link(octree1->linkT->link3->link5));
												printf("%lld ", print_link(octree1->linkT->link3->link6));
												printf("%lld ", print_link(octree1->linkT->link3->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link4));
											if (octree1->linkT->link4 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link4->link0));
												printf("%lld ", print_link(octree1->linkT->link4->link1));
												printf("%lld ", print_link(octree1->linkT->link4->link2));
												printf("%lld ", print_link(octree1->linkT->link4->link3));
												printf("%lld ", print_link(octree1->linkT->link4->link4));
												printf("%lld ", print_link(octree1->linkT->link4->link5));
												printf("%lld ", print_link(octree1->linkT->link4->link6));
												printf("%lld ", print_link(octree1->linkT->link4->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link5));
											if (octree1->linkT->link5 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link5->link0));
												printf("%lld ", print_link(octree1->linkT->link5->link1));
												printf("%lld ", print_link(octree1->linkT->link5->link2));
												printf("%lld ", print_link(octree1->linkT->link5->link3));
												printf("%lld ", print_link(octree1->linkT->link5->link4));
												printf("%lld ", print_link(octree1->linkT->link5->link5));
												printf("%lld ", print_link(octree1->linkT->link5->link6));
												printf("%lld ", print_link(octree1->linkT->link5->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link6));
											if (octree1->linkT->link6 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link6->link0));
												printf("%lld ", print_link(octree1->linkT->link6->link1));
												printf("%lld ", print_link(octree1->linkT->link6->link2));
												printf("%lld ", print_link(octree1->linkT->link6->link3));
												printf("%lld ", print_link(octree1->linkT->link6->link4));
												printf("%lld ", print_link(octree1->linkT->link6->link5));
												printf("%lld ", print_link(octree1->linkT->link6->link6));
												printf("%lld ", print_link(octree1->linkT->link6->link7));
											}
											printf("%lld ", print_link(octree1->linkT->link7));
											if (oc->linkT->link7 != nullptr) {
												printf("%lld ", print_link(octree1->linkT->link7->link0));
												printf("%lld ", print_link(octree1->linkT->link7->link1));
												printf("%lld ", print_link(octree1->linkT->link7->link2));
												printf("%lld ", print_link(octree1->linkT->link7->link3));
												printf("%lld ", print_link(octree1->linkT->link7->link4));
												printf("%lld ", print_link(octree1->linkT->link7->link5));
												printf("%lld ", print_link(octree1->linkT->link7->link6));
												printf("%lld ", print_link(octree1->linkT->link7->link7));
											}
#else
											printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
											printf("%d ", print_link(octree1->linkT->link0));
											if (octree1->linkT->link0 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link0->link0));
												printf("%d ", print_link(octree1->linkT->link0->link1));
												printf("%d ", print_link(octree1->linkT->link0->link2));
												printf("%d ", print_link(octree1->linkT->link0->link3));
												printf("%d ", print_link(octree1->linkT->link0->link4));
												printf("%d ", print_link(octree1->linkT->link0->link5));
												printf("%d ", print_link(octree1->linkT->link0->link6));
												printf("%d ", print_link(octree1->linkT->link0->link7));
											}
											printf("%d ", print_link(octree1->linkT->link1));
											if (octree1->linkT->link1 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link1->link0));
												printf("%d ", print_link(octree1->linkT->link1->link1));
												printf("%d ", print_link(octree1->linkT->link1->link2));
												printf("%d ", print_link(octree1->linkT->link1->link3));
												printf("%d ", print_link(octree1->linkT->link1->link4));
												printf("%d ", print_link(octree1->linkT->link1->link5));
												printf("%d ", print_link(octree1->linkT->link1->link6));
												printf("%d ", print_link(octree1->linkT->link1->link7));
											}
											printf("%d ", print_link(octree1->linkT->link2));
											if (octree1->linkT->link2 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link2->link0));
												printf("%d ", print_link(octree1->linkT->link2->link1));
												printf("%d ", print_link(octree1->linkT->link2->link2));
												printf("%d ", print_link(octree1->linkT->link2->link3));
												printf("%d ", print_link(octree1->linkT->link2->link4));
												printf("%d ", print_link(octree1->linkT->link2->link5));
												printf("%d ", print_link(octree1->linkT->link2->link6));
												printf("%d ", print_link(octree1->linkT->link2->link7));
											}
											printf("%d ", print_link(octree1->linkT->link3));
											if (octree1->linkT->link3 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link3->link0));
												printf("%d ", print_link(octree1->linkT->link3->link1));
												printf("%d ", print_link(octree1->linkT->link3->link2));
												printf("%d ", print_link(octree1->linkT->link3->link3));
												printf("%d ", print_link(octree1->linkT->link3->link4));
												printf("%d ", print_link(octree1->linkT->link3->link5));
												printf("%d ", print_link(octree1->linkT->link3->link6));
												printf("%d ", print_link(octree1->linkT->link3->link7));
											}
											printf("%d ", print_link(octree1->linkT->link4));
											if (octree1->linkT->link4 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link4->link0));
												printf("%d ", print_link(octree1->linkT->link4->link1));
												printf("%d ", print_link(octree1->linkT->link4->link2));
												printf("%d ", print_link(octree1->linkT->link4->link3));
												printf("%d ", print_link(octree1->linkT->link4->link4));
												printf("%d ", print_link(octree1->linkT->link4->link5));
												printf("%d ", print_link(octree1->linkT->link4->link6));
												printf("%d ", print_link(octree1->linkT->link4->link7));
											}
											printf("%d ", print_link(octree1->linkT->link5));
											if (octree1->linkT->link5 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link5->link0));
												printf("%d ", print_link(octree1->linkT->link5->link1));
												printf("%d ", print_link(octree1->linkT->link5->link2));
												printf("%d ", print_link(octree1->linkT->link5->link3));
												printf("%d ", print_link(octree1->linkT->link5->link4));
												printf("%d ", print_link(octree1->linkT->link5->link5));
												printf("%d ", print_link(octree1->linkT->link5->link6));
												printf("%d ", print_link(octree1->linkT->link5->link7));
											}
											printf("%d ", print_link(octree1->linkT->link6));
											if (octree1->linkT->link6 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link6->link0));
												printf("%d ", print_link(octree1->linkT->link6->link1));
												printf("%d ", print_link(octree1->linkT->link6->link2));
												printf("%d ", print_link(octree1->linkT->link6->link3));
												printf("%d ", print_link(octree1->linkT->link6->link4));
												printf("%d ", print_link(octree1->linkT->link6->link5));
												printf("%d ", print_link(octree1->linkT->link6->link6));
												printf("%d ", print_link(octree1->linkT->link6->link7));
											}
											printf("%d ", print_link(octree1->linkT->link7));
											if (oc->linkT->link7 != nullptr) {
												printf("%d ", print_link(octree1->linkT->link7->link0));
												printf("%d ", print_link(octree1->linkT->link7->link1));
												printf("%d ", print_link(octree1->linkT->link7->link2));
												printf("%d ", print_link(octree1->linkT->link7->link3));
												printf("%d ", print_link(octree1->linkT->link7->link4));
												printf("%d ", print_link(octree1->linkT->link7->link5));
												printf("%d ", print_link(octree1->linkT->link7->link6));
												printf("%d ", print_link(octree1->linkT->link7->link7));
											}
#endif


											//system("PAUSE");
											system("PAUSE");

										}



										//system("PAUSE");
									}
									else {
										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link0;
													break;
												case 6: octree1->linkT = octree1->linkT->link3;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link0;
													break;
												case 2:octree1->linkT = octree1->linkT->link3;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link1;
													break;
												case 7: octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link1;
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link2;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link2;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link0;
													break;
												case 6: octree1->linkT = octree1->linkT->link0;
													break;
												case 7: octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link0;
													break;
												case 2:octree1->linkT = octree1->linkT->link0;
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link1;
													break;
												case 7: octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link0;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link1;
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link0;
													break;
												case 6: octree1->linkT = octree1->linkT->link3;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link0;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link0;
													break;
												case 2:octree1->linkT = octree1->linkT->link3;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkT)) {
											// Разбита на 8 равных частей:
											// 4,5,6,7
											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4: octree1->linkT = octree1->linkT->link0;
													break;
												case 5: octree1->linkT = octree1->linkT->link1;
													break;
												case 6: octree1->linkT = octree1->linkT->link2;
													break;
												case 7: octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Х
												// 4,7
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:octree1->linkT = octree1->linkT->link3;
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// вырождение по Y
												//4,5
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:octree1->linkT = octree1->linkT->link1;
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1: octree1->linkT = octree1->linkT->link1;
													break;
												case 2:octree1->linkT = octree1->linkT->link2;
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
												// direction Z
												// 0,4
												switch (octree1->root) {
												case 0:
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:octree1->linkT = octree1->linkT->link0;
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->root) {
												case 0:octree1->linkT = octree1->linkT->link0;
													break;
												case 1:octree1->linkT = octree1->linkT->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->root) {
												case 0: octree1->linkT = octree1->linkT->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkT = octree1->linkT->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
									}
								}
							}
						}
					}
					}

//#pragma omp section
						{

					// А другие случаи исключаются при додроблении.
					// одиночная связь, НЕ 4
					if (octree1->b4B == false) {
					if (octree1->linkB != nullptr) {
						if (octree1->linkB->link0!=nullptr) {
							if ((octree1->linkB->link1 == nullptr) && (octree1->linkB->link2 == nullptr) && (octree1->linkB->link3 == nullptr) && (octree1->linkB->link4 == nullptr) && (octree1->linkB->link5 == nullptr) && (octree1->linkB->link6 == nullptr) && (octree1->linkB->link7 == nullptr)) {
								printf("error: octree1->linkB->link0!=nullptr a na samom dele ==nullptr\n");
								//system("PAUSE");
								system("PAUSE");
								exit(1);
							}

						// octree1 это лист.
						bool bSituationX = false;
						bool bSituationY = false;
						bool bSituationZ = false;

						if (bold_stable_version) {
							if (octree1->linkB->minx + 1 == octree1->linkB->maxx) {
								bSituationX = true;
							}
							if (octree1->linkB->miny + 1 == octree1->linkB->maxy) {
								bSituationY = true;
							}
							if (octree1->linkB->minz + 1 == octree1->linkB->maxz) {
								bSituationZ = true;
							}
							if ((octree1->linkB->link0 != nullptr)) {
								if (bSituationX != octree1->linkB->link0->brootSituationX) {
									printf("error ne sovpadenie Situation X.");
								}
								if (bSituationY != octree1->linkB->link0->brootSituationY) {
									printf("error ne sovpadenie Situation Y.");
								}
								if (bSituationZ != octree1->linkB->link0->brootSituationZ) {
									printf("error ne sovpadenie Situation Z.");
								}
							}
						}
						else {
							// 4.01.2018 Попробуем так. Чисто на интуиции пока.
							// Здесь мы сохраняем запрет дробления в заданном координатном направлении.
							bSituationX = octree1->linkB->link0->brootSituationX;
							bSituationY = octree1->linkB->link0->brootSituationY;
							bSituationZ = octree1->linkB->link0->brootSituationZ;
						}


						
						// Чрезвычайно коварный случай. 7сентября 2016.
						bool bsitZ = false;
						if (((!bSituationZ) && (bSituationX) && (bSituationY))) bsitZ = true;


						//if ((!octree1->b_the_geometric_fragmentation) || (octree1->bcrushing_when_balancing)) {
						if ((octree1->ilevel==octree1->linkB->ilevel)||(bsitZ)) {
						    // Не дробленный лист контачит по грани E с дроблённым обектом.
							if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
								// вырождение по Х
								// 0,3,4,7 
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = nullptr; 
								octree1->linkB2 = nullptr; 
								octree1->linkB3 = octree1->linkB->link7;
								octree1->linkB = nullptr;
							}
							else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
								// вырождение по Y
								// 0,1,4,5 
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = octree1->linkB->link5;
								octree1->linkB2 = nullptr; 
								octree1->linkB3 = nullptr;
								octree1->linkB = nullptr;
							}
							else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
								// вырождение по Z
								// 0,1,2,3
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link0;
								octree1->linkB1 = octree1->linkB->link1;
								octree1->linkB2 = octree1->linkB->link2;
								octree1->linkB3 = octree1->linkB->link3;
								octree1->linkB = nullptr;
							}
							else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
								// direction Z
								// 0,4
								//octree1->b4B = true;
								//octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = nullptr; 
								octree1->linkB2 = nullptr; 
								octree1->linkB3 = nullptr; 
								// Редуцирование четырёх соседов к одному.
								octree1->b4B = false;
								octree1->linkB0 = nullptr;
								octree1->linkB = octree1->linkB->link4;
							}
							else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
								// direction X
								// 0,1
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link0;
								octree1->linkB1 = octree1->linkB->link1;
								octree1->linkB2 = nullptr; 
								octree1->linkB3 = nullptr; 
								octree1->linkB = nullptr;
							}
							else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
								// direction Y
								// 0,3
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link0;
								octree1->linkB1 = nullptr; 
								octree1->linkB2 = nullptr; 
								octree1->linkB3 = octree1->linkB->link3;
								octree1->linkB = nullptr;
							}
							else if (is_null1(octree1->linkB)) {
								// Разбита на 8 равных частей:
								// 1,2,5,6
								octree1->b4B = true;
								octree1->linkB0 = octree1->linkB->link4;
								octree1->linkB1 = octree1->linkB->link5;
								octree1->linkB2 = octree1->linkB->link6;
								octree1->linkB3 = octree1->linkB->link7;
								octree1->linkB = nullptr;
							}
						}
						else {
							if (octree1->ilevel - octree1->linkB->ilevel != 1) {
								
								if (is_null1_new(octree1->linkB)) {
									if (DEBUG_ALICE_MESH) {
										printf("linkB  is_null1_new. \n");
									}
									if (octree1->ilevel - octree1->linkB->ilevel ==2) {

										if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
											// вырождение по Х
											// 0,3,4,7 
											// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2: octree1->linkB = octree1->linkB->link7;
													break;
												case 3: octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2:octree1->linkB = octree1->linkB->link7;
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
											// вырождение по Y
											// 0,1,4,5 
											// (3->0),(2->1),(7->4), (6->5)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2: octree1->linkB = octree1->linkB->link5;
													break;
												case 3: octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2:octree1->linkB = octree1->linkB->link5;
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}


										}
										else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
											// вырождение по Z
											// 0,1,2,3
											// (4->0) (5->1) (6->2) (7->3)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2: octree1->linkB = octree1->linkB->link2;
													break;
												case 3: octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2:octree1->linkB = octree1->linkB->link2;
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
											// direction Z
											// 0,4
											// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2: octree1->linkB = octree1->linkB->link4;
													break;
												case 3: octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link4;
													break;
												case 2:octree1->linkB = octree1->linkB->link4;
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link4;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link4;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
											// direction X
											// 0,1
											// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2: octree1->linkB = octree1->linkB->link1;
													break;
												case 3: octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link1;
													break;
												case 2:octree1->linkB = octree1->linkB->link1;
													break;
												case 3:octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link1;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link0;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}
										else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
											// direction Y
											// 0,3
											// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link0;
													break;
												case 2: octree1->linkB = octree1->linkB->link3;
													break;
												case 3: octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1: octree1->linkB = octree1->linkB->link0;
													break;
												case 2:octree1->linkB = octree1->linkB->link3;
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link0;
													break;
												case 1:octree1->linkB = octree1->linkB->link0;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link0;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link3;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}
										}
										else if (is_null1(octree1->linkB)) {
											// Разбита на 8 равных частей:
											// 0,1,2,3
											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2: octree1->linkB = octree1->linkB->link6;
													break;
												case 3: octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Х
												// 0,3
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// вырождение по Y
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// вырождение по Z
												//0,1,2,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1: octree1->linkB = octree1->linkB->link5;
													break;
												case 2:octree1->linkB = octree1->linkB->link6;
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (!octree1->parent->brootSituationZ)) {
												// direction Z
												// 0
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((!octree1->parent->brootSituationX) && (octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction X
												//0,1
												switch (octree1->parent->root) {
												case 0:octree1->linkB = octree1->linkB->link4;
													break;
												case 1:octree1->linkB = octree1->linkB->link5;
													break;
												case 2:
													break;
												case 3:
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

											if ((octree1->parent->brootSituationX) && (!octree1->parent->brootSituationY) && (octree1->parent->brootSituationZ)) {
												// direction Y
												//0,3
												switch (octree1->parent->root) {
												case 0: octree1->linkB = octree1->linkB->link4;
													break;
												case 1:
													break;
												case 2:
													break;
												case 3:octree1->linkB = octree1->linkB->link7;
													break;
												case 4:
													break;
												case 5:
													break;
												case 6:
													break;
												case 7:
													break;
												}
											}

										}

									}
									else {
										printf("Fatal error!!! B distance meshdu urovnqmi > 2\n");
										//system("PAUSE");
										system("PAUSE");
										//exit(1);
									}
								}
								else {
									printf("error: linkB nepravilnje urovni.\n");

									char c0 = 0;
									char c1 = 0;
									char c2 = 0;
									char c3 = 0;
									char c4 = 0;
									char c5 = 0;
									char c6 = 0;
									char c7 = 0;
									is_null3(octree1->linkB, B_SIDE, c0, c1, c2, c3, c4, c5, c6, c7);
#if doubleintprecision == 1
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%lld ", print_link(octree1->linkB->link0));
									if (octree1->linkB->link0 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link0->link0));
										printf("%lld ", print_link(octree1->linkB->link0->link1));
										printf("%lld ", print_link(octree1->linkB->link0->link2));
										printf("%lld ", print_link(octree1->linkB->link0->link3));
										printf("%lld ", print_link(octree1->linkB->link0->link4));
										printf("%lld ", print_link(octree1->linkB->link0->link5));
										printf("%lld ", print_link(octree1->linkB->link0->link6));
										printf("%lld ", print_link(octree1->linkB->link0->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link1));
									if (octree1->linkB->link1 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link1->link0));
										printf("%lld ", print_link(octree1->linkB->link1->link1));
										printf("%lld ", print_link(octree1->linkB->link1->link2));
										printf("%lld ", print_link(octree1->linkB->link1->link3));
										printf("%lld ", print_link(octree1->linkB->link1->link4));
										printf("%lld ", print_link(octree1->linkB->link1->link5));
										printf("%lld ", print_link(octree1->linkB->link1->link6));
										printf("%lld ", print_link(octree1->linkB->link1->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link2));
									if (octree1->linkB->link2 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link2->link0));
										printf("%lld ", print_link(octree1->linkB->link2->link1));
										printf("%lld ", print_link(octree1->linkB->link2->link2));
										printf("%lld ", print_link(octree1->linkB->link2->link3));
										printf("%lld ", print_link(octree1->linkB->link2->link4));
										printf("%lld ", print_link(octree1->linkB->link2->link5));
										printf("%lld ", print_link(octree1->linkB->link2->link6));
										printf("%lld ", print_link(octree1->linkB->link2->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link3));
									if (octree1->linkB->link3 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link3->link0));
										printf("%lld ", print_link(octree1->linkB->link3->link1));
										printf("%lld ", print_link(octree1->linkB->link3->link2));
										printf("%lld ", print_link(octree1->linkB->link3->link3));
										printf("%lld ", print_link(octree1->linkB->link3->link4));
										printf("%lld ", print_link(octree1->linkB->link3->link5));
										printf("%lld ", print_link(octree1->linkB->link3->link6));
										printf("%lld ", print_link(octree1->linkB->link3->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link4));
									if (octree1->linkB->link4 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link4->link0));
										printf("%lld ", print_link(octree1->linkB->link4->link1));
										printf("%lld ", print_link(octree1->linkB->link4->link2));
										printf("%lld ", print_link(octree1->linkB->link4->link3));
										printf("%lld ", print_link(octree1->linkB->link4->link4));
										printf("%lld ", print_link(octree1->linkB->link4->link5));
										printf("%lld ", print_link(octree1->linkB->link4->link6));
										printf("%lld ", print_link(octree1->linkB->link4->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link5));
									if (octree1->linkB->link5 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link5->link0));
										printf("%lld ", print_link(octree1->linkB->link5->link1));
										printf("%lld ", print_link(octree1->linkB->link5->link2));
										printf("%lld ", print_link(octree1->linkB->link5->link3));
										printf("%lld ", print_link(octree1->linkB->link5->link4));
										printf("%lld ", print_link(octree1->linkB->link5->link5));
										printf("%lld ", print_link(octree1->linkB->link5->link6));
										printf("%lld ", print_link(octree1->linkB->link5->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link6));
									if (octree1->linkB->link6 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link6->link0));
										printf("%lld ", print_link(octree1->linkB->link6->link1));
										printf("%lld ", print_link(octree1->linkB->link6->link2));
										printf("%lld ", print_link(octree1->linkB->link6->link3));
										printf("%lld ", print_link(octree1->linkB->link6->link4));
										printf("%lld ", print_link(octree1->linkB->link6->link5));
										printf("%lld ", print_link(octree1->linkB->link6->link6));
										printf("%lld ", print_link(octree1->linkB->link6->link7));
									}
									printf("%lld ", print_link(octree1->linkB->link7));
									if (oc->linkB->link7 != nullptr) {
										printf("%lld ", print_link(octree1->linkB->link7->link0));
										printf("%lld ", print_link(octree1->linkB->link7->link1));
										printf("%lld ", print_link(octree1->linkB->link7->link2));
										printf("%lld ", print_link(octree1->linkB->link7->link3));
										printf("%lld ", print_link(octree1->linkB->link7->link4));
										printf("%lld ", print_link(octree1->linkB->link7->link5));
										printf("%lld ", print_link(octree1->linkB->link7->link6));
										printf("%lld ", print_link(octree1->linkB->link7->link7));
									}
#else
									printf("c0=%d c1=%d c2=%d c3=%d c4=%d c5=%d c6=%d c7=%d\n", c0, c1, c2, c3, c4, c5, c6, c7);
									printf("%d ", print_link(octree1->linkB->link0));
									if (octree1->linkB->link0 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link0->link0));
										printf("%d ", print_link(octree1->linkB->link0->link1));
										printf("%d ", print_link(octree1->linkB->link0->link2));
										printf("%d ", print_link(octree1->linkB->link0->link3));
										printf("%d ", print_link(octree1->linkB->link0->link4));
										printf("%d ", print_link(octree1->linkB->link0->link5));
										printf("%d ", print_link(octree1->linkB->link0->link6));
										printf("%d ", print_link(octree1->linkB->link0->link7));
									}
									printf("%d ", print_link(octree1->linkB->link1));
									if (octree1->linkB->link1 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link1->link0));
										printf("%d ", print_link(octree1->linkB->link1->link1));
										printf("%d ", print_link(octree1->linkB->link1->link2));
										printf("%d ", print_link(octree1->linkB->link1->link3));
										printf("%d ", print_link(octree1->linkB->link1->link4));
										printf("%d ", print_link(octree1->linkB->link1->link5));
										printf("%d ", print_link(octree1->linkB->link1->link6));
										printf("%d ", print_link(octree1->linkB->link1->link7));
									}
									printf("%d ", print_link(octree1->linkB->link2));
									if (octree1->linkB->link2 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link2->link0));
										printf("%d ", print_link(octree1->linkB->link2->link1));
										printf("%d ", print_link(octree1->linkB->link2->link2));
										printf("%d ", print_link(octree1->linkB->link2->link3));
										printf("%d ", print_link(octree1->linkB->link2->link4));
										printf("%d ", print_link(octree1->linkB->link2->link5));
										printf("%d ", print_link(octree1->linkB->link2->link6));
										printf("%d ", print_link(octree1->linkB->link2->link7));
									}
									printf("%d ", print_link(octree1->linkB->link3));
									if (octree1->linkB->link3 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link3->link0));
										printf("%d ", print_link(octree1->linkB->link3->link1));
										printf("%d ", print_link(octree1->linkB->link3->link2));
										printf("%d ", print_link(octree1->linkB->link3->link3));
										printf("%d ", print_link(octree1->linkB->link3->link4));
										printf("%d ", print_link(octree1->linkB->link3->link5));
										printf("%d ", print_link(octree1->linkB->link3->link6));
										printf("%d ", print_link(octree1->linkB->link3->link7));
									}
									printf("%d ", print_link(octree1->linkB->link4));
									if (octree1->linkB->link4 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link4->link0));
										printf("%d ", print_link(octree1->linkB->link4->link1));
										printf("%d ", print_link(octree1->linkB->link4->link2));
										printf("%d ", print_link(octree1->linkB->link4->link3));
										printf("%d ", print_link(octree1->linkB->link4->link4));
										printf("%d ", print_link(octree1->linkB->link4->link5));
										printf("%d ", print_link(octree1->linkB->link4->link6));
										printf("%d ", print_link(octree1->linkB->link4->link7));
									}
									printf("%d ", print_link(octree1->linkB->link5));
									if (octree1->linkB->link5 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link5->link0));
										printf("%d ", print_link(octree1->linkB->link5->link1));
										printf("%d ", print_link(octree1->linkB->link5->link2));
										printf("%d ", print_link(octree1->linkB->link5->link3));
										printf("%d ", print_link(octree1->linkB->link5->link4));
										printf("%d ", print_link(octree1->linkB->link5->link5));
										printf("%d ", print_link(octree1->linkB->link5->link6));
										printf("%d ", print_link(octree1->linkB->link5->link7));
									}
									printf("%d ", print_link(octree1->linkB->link6));
									if (octree1->linkB->link6 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link6->link0));
										printf("%d ", print_link(octree1->linkB->link6->link1));
										printf("%d ", print_link(octree1->linkB->link6->link2));
										printf("%d ", print_link(octree1->linkB->link6->link3));
										printf("%d ", print_link(octree1->linkB->link6->link4));
										printf("%d ", print_link(octree1->linkB->link6->link5));
										printf("%d ", print_link(octree1->linkB->link6->link6));
										printf("%d ", print_link(octree1->linkB->link6->link7));
									}
									printf("%d ", print_link(octree1->linkB->link7));
									if (oc->linkB->link7 != nullptr) {
										printf("%d ", print_link(octree1->linkB->link7->link0));
										printf("%d ", print_link(octree1->linkB->link7->link1));
										printf("%d ", print_link(octree1->linkB->link7->link2));
										printf("%d ", print_link(octree1->linkB->link7->link3));
										printf("%d ", print_link(octree1->linkB->link7->link4));
										printf("%d ", print_link(octree1->linkB->link7->link5));
										printf("%d ", print_link(octree1->linkB->link7->link6));
										printf("%d ", print_link(octree1->linkB->link7->link7));
									}
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}

								
							}
							else {
						if ((bSituationX) && (!bSituationY) && (!bSituationZ)) {
							// вырождение по Х
							// 0,3,4,7 
							// Эквивалентность: (0,1) (3,2) (4,5) (7,6)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2: octree1->linkB = octree1->linkB->link7;
									break;
								case 3: octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2:octree1->linkB = octree1->linkB->link7;
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}


						}
						else if ((!bSituationX) && (bSituationY) && (!bSituationZ)) {
							// вырождение по Y
							// 0,1,4,5 
							// (3->0),(2->1),(7->4), (6->5)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2: octree1->linkB = octree1->linkB->link5;
									break;
								case 3: octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2:octree1->linkB = octree1->linkB->link5;
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}


						}
						else if ((!bSituationX) && (!bSituationY) && (bSituationZ)) {
							// вырождение по Z
							// 0,1,2,3
							// (4->0) (5->1) (6->2) (7->3)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2: octree1->linkB = octree1->linkB->link2;
									break;
								case 3: octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2:octree1->linkB = octree1->linkB->link2;
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((bSituationX) && (bSituationY) && (!bSituationZ)) {
							// direction Z
							// 0,4
							// (1->0),(3->0),(2->0), (5->4), (6->4), (7->4)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2: octree1->linkB = octree1->linkB->link4;
									break;
								case 3: octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link4;
									break;
								case 2:octree1->linkB = octree1->linkB->link4;
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link4;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link4;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if ((!bSituationX) && (bSituationY) && (bSituationZ)) {
							// direction X
							// 0,1
							// (3->0), (4->0), (7->0), (2->1), (5->1), (6->1)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2: octree1->linkB = octree1->linkB->link1;
									break;
								case 3: octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link1;
									break;
								case 2:octree1->linkB = octree1->linkB->link1;
									break;
								case 3:octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link1;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link0;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						else if ((bSituationX) && (!bSituationY) && (bSituationZ)) {
							// direction Y
							// 0,3
							// (1->0) (4->0) (5->0) (2->3) (7->3) (6->3)
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link0;
									break;
								case 2: octree1->linkB = octree1->linkB->link3;
									break;
								case 3: octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1: octree1->linkB = octree1->linkB->link0;
									break;
								case 2:octree1->linkB = octree1->linkB->link3;
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link0;
									break;
								case 1:octree1->linkB = octree1->linkB->link0;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link0;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link3;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}
						}
						else if (is_null1(octree1->linkB)) {
							// Разбита на 8 равных частей:
							// 0,1,2,3
							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2: octree1->linkB = octree1->linkB->link6;
									break;
								case 3: octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Х
								// 0,3
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// вырождение по Y
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// вырождение по Z
								//0,1,2,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1: octree1->linkB = octree1->linkB->link5;
									break;
								case 2:octree1->linkB = octree1->linkB->link6;
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (octree1->brootSituationY) && (!octree1->brootSituationZ)) {
								// direction Z
								// 0
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((!octree1->brootSituationX) && (octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction X
								//0,1
								switch (octree1->root) {
								case 0:octree1->linkB = octree1->linkB->link4;
									break;
								case 1:octree1->linkB = octree1->linkB->link5;
									break;
								case 2:
									break;
								case 3:
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

							if ((octree1->brootSituationX) && (!octree1->brootSituationY) && (octree1->brootSituationZ)) {
								// direction Y
								//0,3
								switch (octree1->root) {
								case 0: octree1->linkB = octree1->linkB->link4;
									break;
								case 1:
									break;
								case 2:
									break;
								case 3:octree1->linkB = octree1->linkB->link7;
									break;
								case 4:
									break;
								case 5:
									break;
								case 6:
									break;
								case 7:
									break;
								}
							}

						}
						}
						}
						}
					}
					}


					}
				}

					// НАДО ПРЕДУСМОТРЕТЬ ВЫРОЖДЕНИЯ 294 варианта!!!. TODO
					// Для этого нужно хранить вырождения родителя внутри листа (потомка).
					// вырождения сделаны 25 08 2016.

					// закончили работать.
					octree1 = nullptr;
				//}
				//else {
					// Дробление  вызывается.
					//my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
					//top_ALICE_STACK--;
				//}

			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}



#ifdef _OPENMP
	//omp_set_num_threads(i_my_num_core_parallelesation); // Возвращаем количество потоков которое было изначально.
#endif

} // update_link_neighbor



void balance_octree2(octree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret, doublereal epsTool, BLOCK*& b) {
	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	integer ikount_dir_X = 0;
	integer ikount_dir_Y = 0;
	integer ikount_dir_Z = 0;
	integer ikount_sit_X = 0;
	integer ikount_sit_Y = 0;
	integer ikount_sit_Z = 0;
	integer ikount_list = 0;
	//bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	//while (bcont) 
	{
		//bcont = false;
		top_ALICE_STACK = 0;
		if (oc->link0 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
			top_ALICE_STACK++;
		}
		if (oc->link1 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
			top_ALICE_STACK++;
		}
		if (oc->link2 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
			top_ALICE_STACK++;
		}
		if (oc->link3 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
			top_ALICE_STACK++;
		}
		if (oc->link4 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
			top_ALICE_STACK++;
		}
		if (oc->link5 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
			top_ALICE_STACK++;
		}
		if (oc->link6 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
			top_ALICE_STACK++;
		}
		if (oc->link7 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
			top_ALICE_STACK++;
		}
		while (top_ALICE_STACK > 0) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
				if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
					if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation == false) {
						// Во избежании повторного дробления узла за раз.
						my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = true;
						ikount_list++;

						octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
						int minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
						int maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
						int miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
						int maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
						int minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
						int maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

						// Вырождение по Z.
						bool bSituationZ = false;
						// Вырождение по X.
						bool bSituationX = false;
						// Вырождение по Y.
						bool bSituationY = false;


						bool bonly_dir_X = false;
						bool bonly_dir_Y = false;
						bool bonly_dir_Z = false;
						
						if (minz + 1 == maxz) {

							// Вырождение по Z.
							bSituationZ = true;
						}
						if (minx + 1 == maxx) {

							// Вырождение по X.
							bSituationX = true;
						}
						if (miny + 1 == maxy) {

							// Вырождение по Y.
							bSituationY = true;
						}
						
						/*
						if (octree1->brootSituationX != bSituationX) {
							printf("error  bSituationX ne sovpalo.\n");
							system("PAUSE");
						}
						if (octree1->brootSituationY != bSituationY) {
							printf("error  bSituationY ne sovpalo.\n");
							system("PAUSE");
						}
						if (octree1->brootSituationZ != bSituationZ) {
							printf("error  bSituationZ ne sovpalo.\n");
							system("PAUSE");
						}
						*/
						//bSituationX = octree1->brootSituationX;
						//bSituationY = octree1->brootSituationY;
						//bSituationZ = octree1->brootSituationZ;

						if (bSituationX && (bSituationY) && (!bSituationZ)) {

							bonly_dir_Z = true;
						}
						if (bSituationX && (bSituationZ) && (!bSituationY)) {

							bonly_dir_Y = true;
						}
						if (bSituationY && (bSituationZ) && (!bSituationX)) {

							bonly_dir_X = true;
						}



						if (bonly_dir_Z) {
							if ((octree1->maxWneighbour > 2) || (octree1->maxEneighbour > 2) || (octree1->maxSneighbour > 2) || (octree1->maxNneighbour > 2)) {
								//printf("bonly_dir_Z\n");
								//system("PAUSE");
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Z\n", ikount_dir_Z++, octree1->root);
#else
								printf("%d octree1->root=%d Z\n", ikount_dir_Z++, octree1->root);
#endif
								
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, false, false, true,b, GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bonly_dir_Z ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bonly_dir_Z ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
								//bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
						}
						else if (bonly_dir_X) {
							if ((octree1->maxBneighbour > 2) || (octree1->maxTneighbour > 2) || (octree1->maxSneighbour > 2) || (octree1->maxNneighbour > 2)) {
								//	printf("bonly_dir_X\n");
								//system("PAUSE");
								integer i_X = 0;
								integer i_Y = 0;
								integer i_Z = 0;
								if (octree1->brootSituationX) i_X = 1;
								if (octree1->brootSituationY) i_Y = 1;
								if (octree1->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld parent=%lld parent>parent=%lld bonly_dir_X  \n", ikount_dir_X++, octree1->root, octree1->parent->root, octree1->parent->parent->root);
								printf("sitx=%lld sity=%lld sitz=%lld S=%d N=%d B=%d T=%d E=%d W=%d linkW=%lld linkE=%lld linkS=%lld linkN=%lld linkB=%lld linkT=%lld\n", i_X, i_Y, i_Z, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour, octree1->maxEneighbour, octree1->maxWneighbour, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
#else
								printf("%d octree1->root=%d parent=%d parent>parent=%d bonly_dir_X  \n", ikount_dir_X++, octree1->root, octree1->parent->root, octree1->parent->parent->root);
								printf("sitx=%d sity=%d sitz=%d S=%d N=%d B=%d T=%d E=%d W=%d linkW=%d linkE=%d linkS=%d linkN=%d linkB=%d linkT=%d\n", i_X, i_Y, i_Z, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour, octree1->maxEneighbour, octree1->maxWneighbour, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
#endif
								i_X = 0;
								i_Y = 0;
								i_Z = 0;
								if (octree1->parent->brootSituationX) i_X = 1;
								if (octree1->parent->brootSituationY) i_Y = 1;
								if (octree1->parent->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
								printf("->parent sitx=%lld sity=%lld sitz=%lld  S=%d N=%d B=%d T=%d E=%d W=%d linkW=%lld linkE=%lld linkS=%lld linkN=%lld linkB=%lld linkT=%lld\n", i_X, i_Y, i_Z, octree1->parent->maxSneighbour, octree1->parent->maxNneighbour, octree1->parent->maxBneighbour, octree1->parent->maxTneighbour, octree1->parent->maxEneighbour, octree1->parent->maxWneighbour, print_link(octree1->parent->linkW), print_link(octree1->parent->linkE), print_link(octree1->parent->linkS), print_link(octree1->parent->linkN), print_link(octree1->parent->linkB), print_link(octree1->parent->linkT));
#else
								printf("->parent sitx=%d sity=%d sitz=%d  S=%d N=%d B=%d T=%d E=%d W=%d linkW=%d linkE=%d linkS=%d linkN=%d linkB=%d linkT=%d\n", i_X, i_Y, i_Z, octree1->parent->maxSneighbour, octree1->parent->maxNneighbour, octree1->parent->maxBneighbour, octree1->parent->maxTneighbour, octree1->parent->maxEneighbour, octree1->parent->maxWneighbour, print_link(octree1->parent->linkW), print_link(octree1->parent->linkE), print_link(octree1->parent->linkS), print_link(octree1->parent->linkN), print_link(octree1->parent->linkB), print_link(octree1->parent->linkT));
#endif
								i_X = 0;
								i_Y = 0;
								i_Z = 0;
								if (octree1->parent->parent->brootSituationX) i_X = 1;
								if (octree1->parent->parent->brootSituationY) i_Y = 1;
								if (octree1->parent->parent->brootSituationZ) i_Z = 1;
#if doubleintprecision == 1
								printf("->parent->parent sitx=%lld sity=%lld sitz=%lld  S=%d N=%d B=%d T=%d E=%d W=%d linkW=%lld linkE=%lld linkS=%lld linkN=%lld linkB=%lld linkT=%lld\n", i_X, i_Y, i_Z, octree1->parent->parent->maxSneighbour, octree1->parent->parent->maxNneighbour, octree1->parent->parent->maxBneighbour, octree1->parent->parent->maxTneighbour, octree1->parent->parent->maxEneighbour, octree1->parent->parent->maxWneighbour, print_link(octree1->parent->parent->linkW), print_link(octree1->parent->parent->linkE), print_link(octree1->parent->parent->linkS), print_link(octree1->parent->parent->linkN), print_link(octree1->parent->parent->linkB), print_link(octree1->parent->parent->linkT));
#else
								printf("->parent->parent sitx=%d sity=%d sitz=%d  S=%d N=%d B=%d T=%d E=%d W=%d linkW=%d linkE=%d linkS=%d linkN=%d linkB=%d linkT=%d\n", i_X, i_Y, i_Z, octree1->parent->parent->maxSneighbour, octree1->parent->parent->maxNneighbour, octree1->parent->parent->maxBneighbour, octree1->parent->parent->maxTneighbour, octree1->parent->parent->maxEneighbour, octree1->parent->parent->maxWneighbour, print_link(octree1->parent->parent->linkW), print_link(octree1->parent->parent->linkE), print_link(octree1->parent->parent->linkS), print_link(octree1->parent->parent->linkN), print_link(octree1->parent->parent->linkB), print_link(octree1->parent->parent->linkT));
#endif
								

								if (1) {
								if (octree1->b4B) {
								printf("b4B = true ");
								}
								else {
								printf("b4B=false  ");
								}
								if (octree1->b4T) {
								printf("b4T = true ");
								}
								else {
								printf("b4T=false  ");
								}
								if (octree1->b4E) {
								printf("b4E = true ");
								}
								else {
								printf("b4E=false  ");
								}
								if (octree1->b4W) {
								printf("b4W = true ");
								}
								else {
								printf("b4W = false ");
								}
								if (octree1->b4S) {
								printf("b4S = true ");
								}
								else {
								printf("b4S=false  ");
								}
								if (octree1->b4N) {
								printf("b4N = true ");
								}
								else {
								printf("b4N=false  ");
								}
								printf("\n");
								if (octree1->parent->b4B) {
								printf("b4B = true ");
								}
								else {
								printf("b4B=false  ");
								}
								if (octree1->parent->b4T) {
								printf("b4T = true ");
								}
								else {
								printf("b4T=false  ");
								}
								if (octree1->parent->b4E) {
								printf("b4E = true ");
								}
								else {
								printf("b4E=false  ");
								}
								if (octree1->parent->b4W) {
								printf("b4W = true ");
								}
								else {
								printf("b4W = false ");
								}
								if (octree1->parent->b4S) {
								printf("b4S = true ");
								}
								else {
								printf("b4S=false  ");
								}
								if (octree1->parent->b4N) {
								printf("b4N = true ");
								}
								else {
								printf("b4N=false  ");
								}
								printf("\n");
								if (octree1->parent->parent->b4B) {
								printf("b4B = true ");
								}
								else {
								printf("b4B=false  ");
								}
								if (octree1->parent->parent->b4T) {
								printf("b4T = true ");
								}
								else {
								printf("b4T=false  ");
								}
								if (octree1->parent->parent->b4E) {
								printf("b4E = true ");
								}
								else {
								printf("b4E=false  ");
								}
								if (octree1->parent->parent->b4W) {
								printf("b4W = true ");
								}
								else {
								printf("b4W = false ");
								}
								if (octree1->parent->parent->b4S) {
								printf("b4S = true ");
								}
								else {
								printf("b4S=false  ");
								}
								if (octree1->parent->parent->b4N) {
								printf("b4N = true ");
								}
								else {
								printf("b4N=false  ");
								}
								printf("\n");

								log_cs(octree1);

								}
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, false, false,b, GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bonly_dir_X ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bonly_dir_X ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
								//bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
						}
						else if (bonly_dir_Y) {
							if ((octree1->maxWneighbour > 2) || (octree1->maxEneighbour > 2) || (octree1->maxBneighbour > 2) || (octree1->maxTneighbour > 2)) {
								//printf("bonly_dir_Y\n");
								//system("PAUSE");
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Y\n", ikount_dir_Y++, octree1->root);
#else
								printf("%d octree1->root=%d Y\n", ikount_dir_Y++, octree1->root);
#endif
								
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, false, true, false,b,GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bonly_dir_Y ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bonly_dir_Y ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
								//bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
						}
						else if (bSituationZ && (!bSituationX) && (!bSituationY)) {
							if ((octree1->maxWneighbour > 2) || (octree1->maxEneighbour > 2) || (octree1->maxSneighbour > 2) || (octree1->maxNneighbour > 2) || (octree1->maxBneighbour > 4) || (octree1->maxTneighbour > 4)) {
								//printf("bSituationZ\n");
								//system("PAUSE");
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Situation Z\n", ikount_sit_Z++, octree1->root);
#else
								printf("%d octree1->root=%d Situation Z\n", ikount_sit_Z++, octree1->root);
#endif
								
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, true, false,b,GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bSituationZ ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bSituationZ ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}

								/*if (iret64 == 0) {
								octree1->dlist = true;
								my_ALICE_STACK[top_ALICE_STACK].link = octree1;
								my_ALICE_STACK[top_ALICE_STACK].minx = minx;
								my_ALICE_STACK[top_ALICE_STACK ].maxx=maxx;
								my_ALICE_STACK[top_ALICE_STACK ].miny=miny;
								my_ALICE_STACK[top_ALICE_STACK ].maxy=maxy;
								my_ALICE_STACK[top_ALICE_STACK ].minz=minz;
								my_ALICE_STACK[top_ALICE_STACK ].maxz=maxz;
								top_ALICE_STACK++;
								}
								else {
								*/
								iret += top_ALICE_STACK - i_76;
								//}

								//bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
						}
						else if (bSituationY && (!bSituationX) && (!bSituationZ)) {
							if ((octree1->maxWneighbour > 2) || (octree1->maxEneighbour > 2) || (octree1->maxBneighbour > 2) || (octree1->maxTneighbour > 2) || (octree1->maxNneighbour > 4) || (octree1->maxSneighbour > 4)) {
#if doubleintprecision == 1
								//	printf("bSituationY: W =%lld E=%lld B=%lld T=%lld\n", octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxBneighbour, octree1->maxTneighbour);
#else
								//	printf("bSituationY: W =%d E=%d B=%d T=%d\n", octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxBneighbour, octree1->maxTneighbour);
#endif
								//system("PAUSE");
								// move STACK
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld SituationY W=%d E=%d B=%d T=%d N=%d S=%d octree1->parent->root=%lld %lld\n", ikount_sit_Y++, octree1->root, octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxBneighbour, octree1->maxTneighbour, octree1->maxNneighbour, octree1->maxSneighbour, octree1->parent->root, octree1->parent->parent->root);
#else
								printf("%d octree1->root=%d SituationY W=%d E=%d B=%d T=%d N=%d S=%d octree1->parent->root=%d %d\n", ikount_sit_Y++, octree1->root, octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxBneighbour, octree1->maxTneighbour, octree1->maxNneighbour, octree1->maxSneighbour, octree1->parent->root, octree1->parent->parent->root);
#endif
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, false, true,b,GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bSituationY ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bSituationY ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}

								/*if (iret64 == 0) {
								octree1->dlist = true;
								my_ALICE_STACK[top_ALICE_STACK].link = octree1;
								my_ALICE_STACK[top_ALICE_STACK].minx = minx;
								my_ALICE_STACK[top_ALICE_STACK].maxx = maxx;
								my_ALICE_STACK[top_ALICE_STACK].miny = miny;
								my_ALICE_STACK[top_ALICE_STACK].maxy = maxy;
								my_ALICE_STACK[top_ALICE_STACK].minz = minz;
								my_ALICE_STACK[top_ALICE_STACK].maxz = maxz;
								top_ALICE_STACK++;
								}
								else {
								*/
								iret += top_ALICE_STACK - i_76;
								//}

								//bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
						}
						else if (bSituationX && (!bSituationZ) && (!bSituationY)) {
							if ((octree1->maxSneighbour > 2) || (octree1->maxNneighbour > 2) || (octree1->maxBneighbour > 2) || (octree1->maxTneighbour > 2) || (octree1->maxWneighbour > 4) || (octree1->maxEneighbour > 4)) {
								//printf("bSituationX\n");
								//system("PAUSE");
								// move STACK
#if doubleintprecision == 1
								printf("%lld octree1->root=%lld Situation X\n", ikount_sit_X++, octree1->root);
#else
								printf("%d octree1->root=%d Situation X\n", ikount_sit_X++, octree1->root);
#endif
								
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, false, true, true,b,GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error bSituationX ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error bSituationX ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}
								/*if (iret64 == 0) {
								octree1->dlist = true;
								my_ALICE_STACK[top_ALICE_STACK].link = octree1;
								my_ALICE_STACK[top_ALICE_STACK].minx = minx;
								my_ALICE_STACK[top_ALICE_STACK].maxx = maxx;
								my_ALICE_STACK[top_ALICE_STACK].miny = miny;
								my_ALICE_STACK[top_ALICE_STACK].maxy = maxy;
								my_ALICE_STACK[top_ALICE_STACK].minz = minz;
								my_ALICE_STACK[top_ALICE_STACK].maxz = maxz;
								top_ALICE_STACK++;
								}
								else {*/
								iret += top_ALICE_STACK - i_76;
								//}

								///bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								top_ALICE_STACK++;// компенсация.

							}
							octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
						}
						else if ((octree1->maxBneighbour > 4) || (octree1->maxTneighbour > 4) || (octree1->maxWneighbour > 4) || (octree1->maxEneighbour > 4) || (octree1->maxSneighbour > 4) || (octree1->maxNneighbour > 4)) {

							// разбиение на 8.

							if ((minx + 1 == maxx) && (miny + 1 == maxy) && (minz + 1 == maxz)) {
								printf("fatal error: atomarnaq\n");
#if doubleintprecision == 1
								printf("root=%lld\n", octree1->root);
								printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour);
#else
								printf("root=%d\n", octree1->root);
								printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour);
#endif
								integer i_X = 0;
								integer i_Y = 0;
								integer i_Z = 0;
								if (octree1->brootSituationX) {
									i_X = 1;
								}
								else {
									i_X = 0;
								}
								if (octree1->brootSituationY) {
									i_Y = 1;
								}
								else {
									i_Y = 0;
								}
								if (octree1->brootSituationZ) {
									i_Z = 1;
								}
								else {
									i_Z = 0;
								}
#if doubleintprecision == 1
								printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
								printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
								
								if (octree1->parent != nullptr) {
#if doubleintprecision == 1
									printf("parent->root=%lld\n", octree1->parent->root);
									printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->maxWneighbour, octree1->parent->maxEneighbour, octree1->parent->maxSneighbour, octree1->parent->maxNneighbour, octree1->parent->maxBneighbour, octree1->parent->maxTneighbour);
#else
									printf("parent->root=%d\n", octree1->parent->root);
									printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->maxWneighbour, octree1->parent->maxEneighbour, octree1->parent->maxSneighbour, octree1->parent->maxNneighbour, octree1->parent->maxBneighbour, octree1->parent->maxTneighbour);
#endif
									if (octree1->parent->brootSituationX) {
										i_X = 1;
									}
									else {
										i_X = 0;
									}
									if (octree1->parent->brootSituationY) {
										i_Y = 1;
									}
									else {
										i_Y = 0;
									}
									if (octree1->parent->brootSituationZ) {
										i_Z = 1;
									}
									else {
										i_Z = 0;
									}
#if doubleintprecision == 1
									printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
									printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
									
									if (octree1->parent->parent != nullptr) {
#if doubleintprecision == 1
										printf("parent->parent->root=%lld\n", octree1->parent->parent->root);
										printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->parent->maxWneighbour, octree1->parent->parent->maxEneighbour, octree1->parent->parent->maxSneighbour, octree1->parent->parent->maxNneighbour, octree1->parent->parent->maxBneighbour, octree1->parent->parent->maxTneighbour);
#else
										printf("parent->parent->root=%d\n", octree1->parent->parent->root);
										printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->parent->maxWneighbour, octree1->parent->parent->maxEneighbour, octree1->parent->parent->maxSneighbour, octree1->parent->parent->maxNneighbour, octree1->parent->parent->maxBneighbour, octree1->parent->parent->maxTneighbour);
#endif
										if (octree1->parent->parent->brootSituationX) {
											i_X = 1;
										}
										else {
											i_X = 0;
										}
										if (octree1->parent->parent->brootSituationY) {
											i_Y = 1;
										}
										else {
											i_Y = 0;
										}
										if (octree1->parent->parent->brootSituationZ) {
											i_Z = 1;
										}
										else {
											i_Z = 0;
										}
#if doubleintprecision == 1
										printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
										printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
										
										if (octree1->parent->parent->parent != nullptr) {
#if doubleintprecision == 1
											printf("parent->parent->parent->root=%lld\n", octree1->parent->parent->parent->root);
											printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->parent->parent->maxWneighbour, octree1->parent->parent->parent->maxEneighbour, octree1->parent->parent->parent->maxSneighbour, octree1->parent->parent->parent->maxNneighbour, octree1->parent->parent->parent->maxBneighbour, octree1->parent->parent->parent->maxTneighbour);
#else
											printf("parent->parent->parent->root=%d\n", octree1->parent->parent->parent->root);
											printf("W=%d E=%d S=%d N=%d B=%d T=%d\n", octree1->parent->parent->parent->maxWneighbour, octree1->parent->parent->parent->maxEneighbour, octree1->parent->parent->parent->maxSneighbour, octree1->parent->parent->parent->maxNneighbour, octree1->parent->parent->parent->maxBneighbour, octree1->parent->parent->parent->maxTneighbour);
#endif
											if (octree1->parent->parent->parent->brootSituationX) {
												i_X = 1;
											}
											else {
												i_X = 0;
											}
											if (octree1->parent->parent->parent->brootSituationY) {
												i_Y = 1;
											}
											else {
												i_Y = 0;
											}
											if (octree1->parent->parent->parent->brootSituationZ) {
												i_Z = 1;
											}
											else {
												i_Z = 0;
											}
#if doubleintprecision == 1
											printf("bSituationX=%lld bSituationY=%lld bSituationZ=%lld\n", i_X, i_Y, i_Z);
#else
											printf("bSituationX=%d bSituationY=%d bSituationZ=%d\n", i_X, i_Y, i_Z);
#endif
											
										}
									}
								}
								//system("PAUSE");
								system("PAUSE");
								// Это атомарная ячейка и она не может быть раздроблена.
								// Количество соседей атомарной ячейки по определению 1. 
								// Или даже ноль если соответсвующая связь nullptr.
								if (octree1->linkB == nullptr) {
									octree1->maxBneighbour = 0;
								}
								else {
									octree1->maxBneighbour = 1;
								}
								if (octree1->linkT == nullptr) {
									octree1->maxTneighbour = 0;
								}
								else {
									octree1->maxTneighbour = 1;
								}

								if (octree1->linkS == nullptr) {
									octree1->maxSneighbour = 0;
								}
								else {
									octree1->maxSneighbour = 1;
								}
								if (octree1->linkN == nullptr) {
									octree1->maxNneighbour = 0;
								}
								else {
									octree1->maxNneighbour = 1;
								}
								if (octree1->linkW == nullptr) {
									octree1->maxWneighbour = 0;
								}
								else {
									octree1->maxWneighbour = 1;
								}
								if (octree1->linkE == nullptr) {
									octree1->maxEneighbour = 0;
								}
								else {
									octree1->maxEneighbour = 1;
								}

								printf("atomarnaq\n");
								//system("PAUSE");
								// Дробление не вызывается.
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;

							}
							else {
								// move STACK
								my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
								top_ALICE_STACK--;
								octree1->dlist = false; // он больше никак не лист (это важно).
								integer i_76 = top_ALICE_STACK;
								integer iret64 = 0;
								printf("balance octrree 2 droblenie_internal incomming\n");
								system("PAUSE");
								// При такой инициализации GSep игнорируется.
								TOCHKA GSep;
								GSep.x = xpos[minx];
								GSep.y = ypos[miny];
								GSep.z = zpos[minz];
								droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, true, true,b,GSep);
								//i_76 = top_ALICE_STACK - i_76;
								if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
									printf("error ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
									printf("error ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
									
									//system("PAUSE");
									system("PAUSE");
								}
								iret += top_ALICE_STACK - i_76;
#if doubleintprecision == 1
								//printf("i_76=%lld\n", top_ALICE_STACK - i_76);
#else
								//printf("i_76=%d\n", top_ALICE_STACK - i_76);
#endif
								
								//bool b54 = true;
								//for (integer i_74 = i_76; i_74 < top_ALICE_STACK; i_74++) {
								//if (my_ALICE_STACK[i_74].link->dlist  ) {
								//	printf("true\n");
								//}
								//else {
								//printf("false\n");
								//	}
								//}
								//system("PAUSE");
								//bcont = true;
								for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
									my_ALICE_STACK[j_i].link = nullptr;
								}
								top_ALICE_STACK = i_76;
								//top_ALICE_STACK -= i_76;
								top_ALICE_STACK++;// компенсация.
							}
							//octree1 = nullptr;
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
							octree1 = nullptr;
						}
					}
					else {
						//обычный лист который ненадо дробить.
						my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
						top_ALICE_STACK--;
					}
					

				}
				else {
					// продолжаем добираться до листьев.
					STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
					STACK_ALICE* buf = &buf1;
					top_ALICE_STACK--;
					if (buf->link->link0 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link1 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link2 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link3 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link4 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link5 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link6 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link7 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
						top_ALICE_STACK++;
					}
				}
			}
		}
#if doubleintprecision == 1
		printf("all number of lists=%lld\t", ikount_list);
#else
		printf("all number of lists=%d\t", ikount_list);
#endif
		
		if (DEBUG_ALICE_MESH) {
			//system("PAUSE");
			system("PAUSE");
		}

	}
} // balance_octree2

void droblenie_disbalance(octree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret, BLOCK*& b) {
	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	
	integer ikount_list = 0;
	//bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	//while (bcont) 
	{
		//bcont = false;
		top_ALICE_STACK = 0;
		if (oc->link0 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
			top_ALICE_STACK++;
		}
		if (oc->link1 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
			top_ALICE_STACK++;
		}
		if (oc->link2 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
			top_ALICE_STACK++;
		}
		if (oc->link3 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
			top_ALICE_STACK++;
		}
		if (oc->link4 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
			top_ALICE_STACK++;
		}
		if (oc->link5 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
			top_ALICE_STACK++;
		}
		if (oc->link6 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
			top_ALICE_STACK++;
		}
		if (oc->link7 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
			top_ALICE_STACK++;
		}
		while (top_ALICE_STACK > 0) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
				if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
					//if (my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation == false) {
						// Во избежании повторного дробления узла за раз.
						//my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = true;
						ikount_list++;

						octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
						int minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
						int maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
						int miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
						int maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
						int minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
						int maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

						if (octree1->disbalance_now) {
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
							octree1->dlist = false; // он больше никак не лист (это важно).
							integer i_76 = top_ALICE_STACK;
							integer iret64 = 0;

							octree1->brootSituationX = octree1->brootSituationX_virtual;
							octree1->brootSituationY = octree1->brootSituationY_virtual;
							octree1->brootSituationZ = octree1->brootSituationZ_virtual;
							//droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, true, true, true,b);
							// При такой инициализации GSep игнорируется.
							TOCHKA GSep;
							GSep.x = xpos[minx];
							GSep.y = ypos[miny];
							GSep.z = zpos[minz];
							droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, octree1->brootSituationX_virtual, octree1->brootSituationY_virtual, octree1->brootSituationZ_virtual,b,GSep);
							//droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64, true, octree1->brootSituationX, octree1->brootSituationY, octree1->brootSituationZ,b);

							//i_76 = top_ALICE_STACK - i_76;
							if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
								printf("error bonly_dir_Z ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
								printf("error bonly_dir_Z ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
								
								//system("PAUSE");
								system("PAUSE");
							}
							iret += top_ALICE_STACK - i_76;
							//bcont = true;
							for (integer j_i = top_ALICE_STACK - 1; j_i >= i_76; j_i--) {
								my_ALICE_STACK[j_i].link = nullptr;
							}
							top_ALICE_STACK = i_76;
							top_ALICE_STACK++;// компенсация.
						}
						octree1 = nullptr;
						my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
						top_ALICE_STACK--;


					//}

				}
				else {
					// продолжаем добираться до листьев.
					STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
					STACK_ALICE* buf = &buf1;
					top_ALICE_STACK--;
					if (buf->link->link0 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link1 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link2 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link3 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link4 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link5 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link6 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link7 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
						top_ALICE_STACK++;
					}
				}
			}
		}
#if doubleintprecision == 1
		printf("droblenie disbalance: all number of lists=%lld\t", ikount_list);
#else
		printf("droblenie disbalance: all number of lists=%d\t", ikount_list);
#endif
		
		if (DEBUG_ALICE_MESH) {
			//system("PAUSE");
			system("PAUSE");
		}

	}
} // droblenie_disbalance

// Устаревная неиспользуемая версия кода.
// см. balance_octree2.
void balance_octree3(octree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret, doublereal epsTool, BLOCK*& b) {
	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	while (bcont) {
		bcont = false;
		top_ALICE_STACK = 0;
		if (oc->link0 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
			top_ALICE_STACK++;
		}
		if (oc->link1 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
			top_ALICE_STACK++;
		}
		if (oc->link2 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
			top_ALICE_STACK++;
		}
		if (oc->link3 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
			top_ALICE_STACK++;
		}
		if (oc->link4 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
			top_ALICE_STACK++;
		}
		if (oc->link5 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
			top_ALICE_STACK++;
		}
		if (oc->link6 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
			top_ALICE_STACK++;
		}
		if (oc->link7 != nullptr) {
			my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
			my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
			my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
			my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
			my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
			my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
			my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
			top_ALICE_STACK++;
		}
		while (top_ALICE_STACK > 0) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
				if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {

					octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
					int minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
					int maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
					int miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
					int maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
					int minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
					int maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

					// Вырождение по Z.
					bool bSituationZ = false;
					// Вырождение по X.
					bool bSituationX = false;
					// Вырождение по Y.
					bool bSituationY = false;


					//bool bonly_dir_X = false;
					//bool bonly_dir_Y = false;
					//bool bonly_dir_Z = false;
					if (minz + 1 == maxz) {

						// Вырождение по Z.
						bSituationZ = true;
					}
					if (minx + 1 == maxx) {

						// Вырождение по X.
						bSituationX = true;
					}
					if (miny + 1 == maxy) {

						// Вырождение по Y.
						bSituationY = true;
					}

					if (bSituationX && (bSituationY) && (!bSituationZ)) {

						//bonly_dir_Z = true;
					}
					if (bSituationX && (bSituationZ) && (!bSituationY)) {

						///bonly_dir_Y = true;
					}
					if (bSituationY && (bSituationZ) && (!bSituationX)) {

						//bonly_dir_X = true;
					}

					if ((octree1->maxBneighbour > 4) || (octree1->maxTneighbour > 4) || (octree1->maxWneighbour > 4) || (octree1->maxEneighbour > 4) || (octree1->maxSneighbour > 4) || (octree1->maxNneighbour > 4)) {

						// разбиение на 8.

						if ((minx + 1 == maxx) && (miny + 1 == maxy) && (minz + 1 == maxz)) {
							printf("fatal error: atomarnaq\n");
							//system("PAUSE");
							// Это атомарная ячейка и она не может быть раздроблена.
							// Количество соседей атомарной ячейки по определению 1. 
							// Или даже ноль если соответсвующая связь nullptr.
							if (octree1->linkB == nullptr) {
								octree1->maxBneighbour = 0;
							}
							else {
								octree1->maxBneighbour = 1;
							}
							if (octree1->linkT == nullptr) {
								octree1->maxTneighbour = 0;
							}
							else {
								octree1->maxTneighbour = 1;
							}

							if (octree1->linkS == nullptr) {
								octree1->maxSneighbour = 0;
							}
							else {
								octree1->maxSneighbour = 1;
							}
							if (octree1->linkN == nullptr) {
								octree1->maxNneighbour = 0;
							}
							else {
								octree1->maxNneighbour = 1;
							}
							if (octree1->linkW == nullptr) {
								octree1->maxWneighbour = 0;
							}
							else {
								octree1->maxWneighbour = 1;
							}
							if (octree1->linkE == nullptr) {
								octree1->maxEneighbour = 0;
							}
							else {
								octree1->maxEneighbour = 1;
							}

							//printf("atomarnaq\n");
							//system("PAUSE");
							// Дробление не вызывается.
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;

						}
						else {
							// move STACK
							my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
							top_ALICE_STACK--;
							octree1->dlist = false; // он больше никак не лист (это важно).
							integer i_76 = top_ALICE_STACK;
							integer iret64 = 0;
							// При такой инициализации GSep игнорируется.
							TOCHKA GSep;
							GSep.x = xpos[minx];
							GSep.y = ypos[miny];
							GSep.z = zpos[minz];
							droblenie_internal(octree1, minx, maxx, miny, maxy, minz, maxz, xpos, ypos, zpos, iret64,true, true, true, true,b,GSep);
							//i_76 = top_ALICE_STACK - i_76;
							if (iret64 != top_ALICE_STACK - i_76) {
#if doubleintprecision == 1
								printf("error ! invariant deleniq ne proiden %lld %lld \n", iret64, top_ALICE_STACK - i_76);
#else
								printf("error ! invariant deleniq ne proiden %d %d \n", iret64, top_ALICE_STACK - i_76);
#endif
								
								//system("PAUSE");
								system("PAUSE");
							}
							iret += top_ALICE_STACK - i_76;
#if doubleintprecision == 1
							//printf("i_76=%lld\n", top_ALICE_STACK - i_76);
#else
							//printf("i_76=%d\n", top_ALICE_STACK - i_76);
#endif
							
							//bool b54 = true;
							//for (integer i_74 = i_76; i_74 < top_ALICE_STACK; i_74++) {
							//if (my_ALICE_STACK[i_74].link->dlist  ) {
							//	printf("true\n");
							//}
							//else {
							//printf("false\n");
							//	}
							//}
							//system("PAUSE");
							bcont = true;
							//top_ALICE_STACK -= i_76;
							top_ALICE_STACK++;// компенсация.
						}
						octree1 = nullptr;
						my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
						top_ALICE_STACK--;
					}
					else {
						//обычный лист который ненадо дробить.
						octree1 = nullptr;
						my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
						top_ALICE_STACK--;
					}

				}
				else {
					// продолжаем добираться до листьев.
					STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
					STACK_ALICE* buf = &buf1;
					top_ALICE_STACK--;
					if (buf->link->link0 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link1 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link2 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link3 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link4 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link5 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link6 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
						top_ALICE_STACK++;
					}
					if (buf->link->link7 != nullptr) {
						my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
						my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
						my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
						my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
						my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
						my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
						my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
						top_ALICE_STACK++;
					}
				}
			}
		}
		
		//system("PAUSE");
	}
} // balance_octree3



void droblenie_list_octree2(octree* &oc, doublereal* xpos, doublereal* ypos, doublereal* zpos, integer &iret,
	int inx, int iny, int inz, BLOCK* &b, int lb, int lw, WALL* &w, SOURCE* &s, int &ls,
	doublereal epsToolx, doublereal epsTooly, doublereal epsToolz, bool bsimpledefine) {

#ifdef _OPENMP
	//int i_my_num_core_parallelesation = omp_get_max_threads();
	//omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#endif

	srand((unsigned int)(time(0)));

	i0r = 0; 
	i1r = 0;
	i2r = 0;

	// Здесь необходимо сохранить сбалансированность построенного дерева.
	// Уровень дробления не более 2 (двойки).
	// Доразбивка или Балансировка.
	iret = 0;
	//bool bcont = true;
	//for (integer i_7 = 0; i_7 < 5000; i_7++) {
	//while (bcont) {
	//bcont = false;
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {



				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// разбиение на 8.
				int minx = my_ALICE_STACK[top_ALICE_STACK - 1].minx;
				int maxx = my_ALICE_STACK[top_ALICE_STACK - 1].maxx;
				int miny = my_ALICE_STACK[top_ALICE_STACK - 1].miny;
				int maxy = my_ALICE_STACK[top_ALICE_STACK - 1].maxy;
				int minz = my_ALICE_STACK[top_ALICE_STACK - 1].minz;
				int maxz = my_ALICE_STACK[top_ALICE_STACK - 1].maxz;

				// Дробление  вызывается.
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;

				bool tr1 = octree1->b4N;
				integer i_76 = top_ALICE_STACK;

				iret += droblenie(xpos, ypos, zpos,
					inx, iny, inz, octree1,
					minx, maxx, miny, maxy, minz, maxz, b, lb, lw, w, s, ls, epsToolx, epsTooly, epsToolz, bsimpledefine);
				if (tr1) {
					if (DEBUG_ALICE_MESH) {
						printf("b4N situation found\n");
					}
					/*
					if (octree1->b4N) {
						printf("true true\n"); // Все впорядке проверка пройдена.
					}
					else {
						printf("true stalo false\n ");
					}
					system("PAUSE");
					*/
				}
				if (DEBUG_ALICE_MESH) {
#if doubleintprecision == 1
					printf("incoming iret=%lld\n", iret);
#else
					printf("incoming iret=%d\n", iret);
#endif
					
					//	system("PAUSE");
				}
				for (integer i_27 = i_76; i_27 < top_ALICE_STACK; i_27++) {
					my_ALICE_STACK[i_27].link = nullptr;
				}
				//top_ALICE_STACK -= top_ALICE_STACK - i_76;
				top_ALICE_STACK = i_76;

				//i_76 = top_ALICE_STACK - i_76;
#if doubleintprecision == 1
				//printf("i_76=%lld\n", top_ALICE_STACK - i_76);
#else
				//printf("i_76=%d\n", top_ALICE_STACK - i_76);
#endif
				
				//bool b54 = true;
				//for (integer i_74 = i_76; i_74 < top_ALICE_STACK; i_74++) {
				//if (my_ALICE_STACK[i_74].link->dlist  ) {
				//printf("true\n");
				//}
				//else {
				//printf("false\n");
				//}
				//}
				//system("PAUSE");
				//bcont = true;
				//top_ALICE_STACK -= i_76;
				//top_ALICE_STACK++;// компенсация.

				//top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}


	printf("%lld %lld %lld", i0r, i1r, i2r );

#ifdef _OPENMP
	//omp_set_num_threads(i_my_num_core_parallelesation); // Возвращаем количество потоков которое было изначально.
#endif
	//system("pause");
} // droblenie_list_octree2



// визуализация.
// визуализация в tecplot 360 с учётом hollow блоков в программной модели.
void expt(octree* &oc, int inx, int iny, int inz, integer maxelm,
	doublereal* &xpos, doublereal* &ypos, doublereal* &zpos) {

	// Вычисление допуска.
	doublereal epsTolx = 1.0e36;
	doublereal epsToly = 1.0e36;
	doublereal epsTolz = 1.0e36;
	for (int i = 0; i < inx; ++i) {
		if (fabs(xpos[i + 1] - xpos[i]) < epsTolx) {
			epsTolx = 0.5*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (int i = 0; i < iny; ++i) {
		if (fabs(ypos[i + 1] - ypos[i]) < epsToly) {
			epsToly = 0.5*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (int i = 0; i < inz; ++i) {
		if (fabs(zpos[i + 1] - zpos[i]) < epsTolz) {
			epsTolz = 0.5*fabs(zpos[i + 1] - zpos[i]);
		}
	}



	// сформировать pa.
	// заодно посчитать количество узловых точек.
	// сформировать nvtx которые ссылаются на pa.
	// визуализировать сетку.
	// Память под pa_alice выделяется после вычисления точного необходимого её объема, т.к.
	// на больших объектах мы можем не вылететь по недостатку памяти.
	int marker_pa = 0;
	
	
	bool *flag23=new bool[(inx + 1) * (iny + 1) * (inz + 1)];

	
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); ++i_1) {
		flag23[i_1] = false;
	}
	
	// модификация 25 марта 2017. Сначала просто посчитаем сколько же надо памяти в действительности.

	integer marker_pa_shadow = 0;
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}



	while (top_ALICE_STACK > 0) {

		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {

				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				//integer i0, i1, i2, i3, i4, i5, i6, i7;


				bool bfound = false;
				integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];

				if (!bfound) {
					//i0 = marker_pa_shadow;
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {
					
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {
					
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {
					
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {				
					
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {				
					
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {
										
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
				bfound = flag23[key_now];
				if (!bfound) {					
					
					flag23[key_now] = true;
					marker_pa_shadow++;
				}
				

				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;

			}
			else {
				// продолжаем добираться до листьев.

				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] flag23;

	// конец модификации 25 марта 2017.


	// сформировать pa.
	// заодно посчитать количество узловых точек.
	// сформировать nvtx которые ссылаются на pa.
	// визуализировать сетку.
	TOCHKA* pa_alice = nullptr;
	pa_alice = new TOCHKA[marker_pa_shadow+2]; // 2 - запас.
	// Оператор new не требует проверки.
	//if (pa_alice == nullptr) {
		// недостаточно памяти на данном оборудовании.
		//printf("Problem: not enough memory on your equipment for pa_alice in adaptive_local_refinement_mesh generator...\n");
		//printf("Please any key to exit...\n");
		//exit(1);
	//}

	// И тут же сразу формируем nvtx:
	int** nvtx = nullptr;
	nvtx = new int*[8];
	// Оператор new не требует проверки.
	//if (nvtx == nullptr) {
		// недостаточно памяти на данном оборудовании.
		//printf("Problem: not enough memory on your equipment for nvtx in adaptive_local_refinement_mesh generator...\n");
		//printf("Please any key to exit...\n");
		//exit(1);
	//}
	for (char k_1 = 0; k_1 < 8; k_1++) {
		nvtx[k_1] = nullptr;
		//nvtx[k_1] = new integer[maxelm + 1];
		// Это существенно экономит память т.к. число призм не может быть больше чем число вершин призм.
		nvtx[k_1] = new int[marker_pa_shadow + 2];
		// Оператор new не требует проверки.
		//if (nvtx[k_1] == nullptr) {
			// недостаточно памяти на данном оборудовании.
//#if doubleintprecision == 1
	//		printf("Problem: not enough memory on your equipment for nvtx[%lld] in adaptive_local_refinement_mesh generator...\n", k_1);
//#else
	//		printf("Problem: not enough memory on your equipment for nvtx[%d] in adaptive_local_refinement_mesh generator...\n", k_1);
//#endif
			
			//printf("Please any key to exit...\n");
		//	exit(1);
	//	}
	}
	integer imarker_nvtx = 1;

	HASH_POLE* hash_table_export = new HASH_POLE[(inx + 1)*(iny + 1)*(inz + 1)];
	for (integer i_1 = 0; i_1 < (inx + 1)*(iny + 1)*(inz + 1); ++i_1) {
		hash_table_export[i_1].flag = false;
		hash_table_export[i_1].inum = -1;
	}


	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}

	
	
	while (top_ALICE_STACK > 0) {

		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {

				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				// это лист update pa.
				int i0, i1, i2, i3, i4, i5, i6, i7;
				

				bool bfound = false;
				integer key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p0, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;

				if (!bfound) {
					i0 = marker_pa;
					pa_alice[marker_pa] = octree1->p0;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i0 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p1, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i1 = marker_pa;
					pa_alice[marker_pa] = octree1->p1;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i1 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p2, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i2 = marker_pa;
					pa_alice[marker_pa] = octree1->p2;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i2 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p3, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i3 = marker_pa;
					pa_alice[marker_pa] = octree1->p3;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i3 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p4, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i4 = marker_pa;
					pa_alice[marker_pa] = octree1->p4;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i4 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p5, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i5 = marker_pa;
					pa_alice[marker_pa] = octree1->p5;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i5 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p6, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i6 = marker_pa;
					pa_alice[marker_pa] = octree1->p6;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i6 = hash_table_export[key_now].inum;
				}
				bfound = false;
				key_now = hash_key_alice33(inx, iny, inz, xpos, ypos, zpos, octree1->p7, epsTolx, epsToly, epsTolz);
				bfound = hash_table_export[key_now].flag;
				if (!bfound) {
					i7 = marker_pa;
					pa_alice[marker_pa] = octree1->p7;
					hash_table_export[key_now].flag = true;
					hash_table_export[key_now].inum = marker_pa;
					marker_pa++;
				}
				else {
					i7 = hash_table_export[key_now].inum;
				}

				nvtx[0][imarker_nvtx] = i0 + 1;
				nvtx[1][imarker_nvtx] = i1 + 1;
				nvtx[2][imarker_nvtx] = i2 + 1;
				nvtx[3][imarker_nvtx] = i3 + 1;
				nvtx[4][imarker_nvtx] = i4 + 1;
				nvtx[5][imarker_nvtx] = i5 + 1;
				nvtx[6][imarker_nvtx] = i6 + 1;
				nvtx[7][imarker_nvtx] = i7 + 1;
				imarker_nvtx++;

				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;

			}
			else {
				// продолжаем добираться до листьев.

				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}

			}
		}

	}
	delete[] hash_table_export;

	// nvtx && pa сформированы, можно экспортировать в tecplot360
	FILE *fp_4 = nullptr;
	
#ifdef MINGW_COMPILLER
	int err_4 = 0;
	fp_4= fopen64("ALICEFLOW0_24ALICEMESH.PLT", "w");
	if (fp_4 == NULL) {
		err_4 = 1;
	}
#else
	errno_t err_4 = 0;
	err_4 = fopen_s(&fp_4, "ALICEFLOW0_24ALICEMESH.PLT", "w");
#endif

	if ((err_4) != 0) {
		printf("Create File temp Error\n");
		//system("PAUSE");
		system("pause");

	}
	else {
		if (fp_4 != nullptr) {

			fprintf(fp_4, "TITLE = \"ALICEFLOW0_24\"\n");
			fprintf(fp_4, "VARIABLES = x, y, z\n");
#if doubleintprecision == 1
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%lld, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx - 1);
#else
			fprintf(fp_4, "ZONE T=\"Rampant\", N=%d, E=%d, ET=BRICK, F=FEBLOCK\n\n", marker_pa, imarker_nvtx - 1);
#endif
			
			// запись x
			for (integer i = 0; i < marker_pa; ++i) {
				fprintf(fp_4, "%+.16f ", pa_alice[i].x);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись y
			for (integer i = 0; i < marker_pa; ++i) {
				fprintf(fp_4, "%+.16f ", pa_alice[i].y);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			// запись z
			for (integer i = 0; i < marker_pa; ++i) {
				fprintf(fp_4, "%+.16f ", pa_alice[i].z);
				if (i % 10 == 0) fprintf(fp_4, "\n");
			}
			fprintf(fp_4, "\n");
			for (integer i = 1; i <= imarker_nvtx - 1; ++i) {
#if doubleintprecision == 1
				fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#else
				fprintf(fp_4, "%d %d %d %d %d %d %d %d \n", nvtx[0][i], nvtx[1][i], nvtx[2][i], nvtx[3][i], nvtx[4][i], nvtx[5][i], nvtx[6][i], nvtx[7][i]);
#endif
			}
			fclose(fp_4);
			//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe ALICEFLOW0_24ALICEMESH.PLT", SW_NORMAL);
		}
	}

	delete[] pa_alice;
	for (integer i_1 = 0; i_1 <= 7; ++i_1) {
		delete[] nvtx[i_1];
	}
	delete[] nvtx;
} // expt




void shutdown_visit(octree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				// Гасим информацию о посещениях.
				my_ALICE_STACK[top_ALICE_STACK - 1].link->b_the_geometric_fragmentation = false;
				my_ALICE_STACK[top_ALICE_STACK - 1].link->bcrushing_when_balancing = false;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // shutdown_visit

// Выключает дисбаланс (сброс).
void shutdown_disbalance(octree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				// Гасим информацию о посещениях.
				my_ALICE_STACK[top_ALICE_STACK - 1].link->disbalance_now = false;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // shutdown_disbalance

// Для полного контроля линковки.
void log_message(octree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				// Гасим информацию о посещениях.
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
#if doubleintprecision == 1
				if (octree1->parent != nullptr) {
					printf("parent root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%lld %lld %d %d %d %d %d %d %lld %lld %lld %lld %lld %lld\n", octree1->parent->root, octree1->root, octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
				else {
					printf("root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%lld %d %d %d %d %d %d %lld %lld %lld %lld %lld %lld\n", octree1->root, octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
#else
				if (octree1->parent != nullptr) {
					printf("parent root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", octree1->parent->root, octree1->root, octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
				else {
					printf("root csW csE csS csN csB csT linkW linkE linkS linkN linkB linkT\n");
					printf("%d %d %d %d %d %d %d %d %d %d %d %d %d\n", octree1->root, octree1->maxWneighbour, octree1->maxEneighbour, octree1->maxSneighbour, octree1->maxNneighbour, octree1->maxBneighbour, octree1->maxTneighbour, print_link(octree1->linkW), print_link(octree1->linkE), print_link(octree1->linkS), print_link(octree1->linkN), print_link(octree1->linkB), print_link(octree1->linkT));
				}
#endif
				
				//system("PAUSE");
				system("PAUSE");
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // log_message

  // Для полного контроля линковки.
void if_disbalnce_marker(octree* &oc)
{
	printf("if disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != nullptr) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							printf("disbalance N is found...\n");
							//system("PAUSE");
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != nullptr) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							printf("disbalance S is found...\n");
							//system("PAUSE");
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != nullptr) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							printf("disbalance E is found...\n");
							//system("PAUSE");
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != nullptr) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							printf("disbalance W is found...\n");
							//system("PAUSE");
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != nullptr) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							printf("disbalance T is found...\n");
							//system("PAUSE");
							system("PAUSE");
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != nullptr) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							printf("disbalance B is found...\n");
							//system("PAUSE");
							system("PAUSE");
						}
					}
				}
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}

}

// Для полного контроля линковки.
integer if_disbalnce(octree* &oc, integer inx, integer iny, integer inz, 
	integer maxelm, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos,
	doublereal* &xposadd, doublereal* &yposadd, doublereal* &zposadd,
	int &inxadd, int &inyadd, int &inzadd, BLOCK* b, int lb,
	WALL* &w, int &lw, SOURCE* &s, int &ls) {

	printf("if disbalance control.\n"); 
	integer iS = 0, iN = 0, iT = 0, iB = 0, iE = 0, iW = 0;// счетчики дисбаланса.
	integer iOk = 0;
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != nullptr) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkN->ilevel) {
								doublereal y_1 = 0.5 * (ypos[octree1->miny] + ypos[octree1->maxy]);
								if ((y_1 >= b[0].g.yS) && (y_1 <= b[0].g.yE)) {
									// дробим octree1
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
									addboundary(yposadd, inyadd, y_1, XZ_PLANE,b,lb,w,lw,s,ls);
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
								}
							}
							else {
								doublereal y_1 = 0.5 * (ypos[octree1->linkN->miny] + ypos[octree1->linkN->maxy]);
								// дробим octree1->linkN
								if ((y_1 >= b[0].g.yS) && (y_1 <= b[0].g.yE)) {
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkN->minx] + xpos[octree1->linkN->maxx]));
									addboundary(yposadd, inyadd, y_1, XZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkN->minz] + zpos[octree1->linkN->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->linkN->minx, octree1->linkN->maxx, octree1->linkN->miny, octree1->linkN->maxy, octree1->linkN->minz, octree1->linkN->maxz);
								}
							}
							iN++;
							//printf("disbalance N is found...\n");
							//system("PAUSE");
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != nullptr) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkS->ilevel) {
								doublereal y_1 = 0.5 * (ypos[octree1->miny] + ypos[octree1->maxy]);
								if ((y_1 >= b[0].g.yS) && (y_1 <= b[0].g.yE)) {
									// дробим octree1
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
									addboundary(yposadd, inyadd, y_1,XZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
								}
							}
							else {
								doublereal y_1 = 0.5 * (ypos[octree1->linkS->miny] + ypos[octree1->linkS->maxy]);
								if ((y_1 >= b[0].g.yS) && (y_1 <= b[0].g.yE)) {
									// дробим octree1->linkN
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkS->minx] + xpos[octree1->linkS->maxx]));
									addboundary(yposadd, inyadd, y_1,XZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkS->minz] + zpos[octree1->linkS->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->linkS->minx, octree1->linkS->maxx, octree1->linkS->miny, octree1->linkS->maxy, octree1->linkS->minz, octree1->linkS->maxz);
								}
							}
							//printf("disbalance S is found...\n");
							iS++;
							//system("PAUSE");
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != nullptr) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkE->ilevel) {
								doublereal x_1 = 0.5 * (xpos[octree1->minx] + xpos[octree1->maxx]);
								if ((x_1 >= b[0].g.xS) && (x_1 <= b[0].g.xE)) {
									// дробим octree1
									// Можно оставить только одно добавление.
									addboundary(xposadd, inxadd, x_1,YZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
								}
							}
							else {
								doublereal x_1 = 0.5 * (xpos[octree1->linkE->minx] + xpos[octree1->linkE->maxx]);
								if ((x_1 >= b[0].g.xS) && (x_1 <= b[0].g.xE)) {
									// дробим octree1->linkN
									// Можно оставить только одно добавление.
									addboundary(xposadd, inxadd,x_1,YZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkE->miny] + ypos[octree1->linkE->maxy]));
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkE->minz] + zpos[octree1->linkE->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->linkE->minx, octree1->linkE->maxx, octree1->linkE->miny, octree1->linkE->maxy, octree1->linkE->minz, octree1->linkE->maxz);
								}
							}
							//printf("disbalance E is found...\n");
							iE++;
							//system("PAUSE");
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != nullptr) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkW->ilevel) {
								doublereal x_1 = 0.5 * (xpos[octree1->minx] + xpos[octree1->maxx]);
								if ((x_1 >= b[0].g.xS) && (x_1 <= b[0].g.xE)) {
									// дробим octree1
									// Можно оставить только одно добавление.
									addboundary(xposadd, inxadd, x_1,YZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->minz] + zpos[octree1->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
								}
							}
							else {
								doublereal x_1 = 0.5 * (xpos[octree1->linkW->minx] + xpos[octree1->linkW->maxx]);
								if ((x_1 >= b[0].g.xS) && (x_1 <= b[0].g.xE)) {
									// дробим octree1->linkN
									// Можно оставить только одно добавление.
									addboundary(xposadd, inxadd, x_1,YZ_PLANE, b, lb, w, lw, s, ls);
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkW->miny] + ypos[octree1->linkW->maxy]));
									//addboundary(zposadd, inzadd, 0.5*(zpos[octree1->linkW->minz] + zpos[octree1->linkW->maxz]));
									//printf("%d %d %d %d %d %d\n", octree1->linkW->minx, octree1->linkW->maxx, octree1->linkW->miny, octree1->linkW->maxy, octree1->linkW->minz, octree1->linkW->maxz);
								}
							}
							//printf("disbalance W is found...\n");
							iW++;
							//system("PAUSE");
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != nullptr) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkT->ilevel) {
								doublereal z_1 = 0.5 * (zpos[octree1->minz] + zpos[octree1->maxz]);
								if ((z_1 >= b[0].g.zS) && (z_1 <= b[0].g.zE)) {
									// дробим octree1
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
									addboundary(zposadd, inzadd, z_1, XY_PLANE, b, lb, w, lw, s, ls);
									//printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
								}
							}
							else {
								doublereal z_1 = 0.5 * (zpos[octree1->linkT->minz] + zpos[octree1->linkT->maxz]);
								if ((z_1 >= b[0].g.zS) && (z_1 <= b[0].g.zE)) {
									// дробим octree1->linkN
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkT->minx] + xpos[octree1->linkT->maxx]));
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkT->miny] + ypos[octree1->linkT->maxy]));
									addboundary(zposadd, inzadd, z_1, XY_PLANE, b, lb, w, lw, s, ls);
									//printf("%d %d %d %d %d %d\n", octree1->linkT->minx, octree1->linkT->maxx, octree1->linkT->miny, octree1->linkT->maxy, octree1->linkT->minz, octree1->linkT->maxz);
								}
							}
							//printf("disbalance T is found...\n");
							iT++;
							//system("PAUSE");
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != nullptr) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							iOk++;
							if (octree1->ilevel < octree1->linkB->ilevel) {
								doublereal z_1 = 0.5 * (zpos[octree1->minz] + zpos[octree1->maxz]);
								if ((z_1 >= b[0].g.zS) && (z_1 <= b[0].g.zE)) {
									// дробим octree1
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->minx] + xpos[octree1->maxx]));
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->miny] + ypos[octree1->maxy]));
									addboundary(zposadd, inzadd, z_1, XY_PLANE, b, lb, w, lw, s, ls);
									//printf("%d %d %d %d %d %d\n", octree1->minx, octree1->maxx, octree1->miny, octree1->maxy, octree1->minz, octree1->maxz);
								}
							}
							else {
								doublereal z_1 = 0.5 * (zpos[octree1->linkB->minz] + zpos[octree1->linkB->maxz]);
								if ((z_1 >= b[0].g.zS) && (z_1 <= b[0].g.zE)) {
									// дробим octree1->linkN
									// Можно оставить только одно добавление.
									//addboundary(xposadd, inxadd, 0.5*(xpos[octree1->linkB->minx] + xpos[octree1->linkB->maxx]));
									//addboundary(yposadd, inyadd, 0.5*(ypos[octree1->linkB->miny] + ypos[octree1->linkB->maxy]));
									addboundary(zposadd, inzadd, z_1, XY_PLANE, b, lb, w, lw, s, ls);
									//printf("%d %d %d %d %d %d\n", octree1->linkB->minx, octree1->linkB->maxx, octree1->linkB->miny, octree1->linkB->maxy, octree1->linkB->minz, octree1->linkB->maxz);
								}
							}
							//printf("disbalance B is found...\n");
							iB++;
							//system("PAUSE");
							//system("PAUSE");
						}
					}
				}
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}

	// 30.09.2018
	printf("add boundary x: E=%lld, W=%lld: %lld. inx=%lld iny=%lld inz=%lld\n", iE, iW,iE+iW, inx, iny, inz);
	printf("add boundary y: N=%lld, S=%lld: %lld. inx=%lld iny=%lld inz=%lld\n", iN, iS,iN+iS, inx, iny, inz);
	printf("add boundary z: T=%lld, B=%lld: %lld. inx=%lld iny=%lld inz=%lld\n", iT, iB,iB+iT, inx, iny, inz);

	return iOk;
} // if_disbalance.




// Для полного контроля линковки.
void marker_disbalnce_year2016(octree* &oc) {
	printf("marker disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != nullptr) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance N is found...\n");
							}
							if (octree1->ilevel > octree1->linkN->ilevel) {
								octree1->linkN->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != nullptr) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance S is found...\n");
							}
							if (octree1->ilevel > octree1->linkS->ilevel) {
								octree1->linkS->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != nullptr) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance E is found...\n");
							}
							if (octree1->ilevel > octree1->linkE->ilevel) {
								octree1->linkE->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != nullptr) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance W is found...\n");
							}
							if (octree1->ilevel > octree1->linkW->ilevel) {
								octree1->linkW->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != nullptr) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance T is found...\n");
							}
							if (octree1->ilevel > octree1->linkT->ilevel) {
								octree1->linkT->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != nullptr) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance B is found...\n");
							}
							if (octree1->ilevel > octree1->linkB->ilevel) {
								octree1->linkB->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
					}
				}
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // marker_disbalance_year2016.

  // Для полного контроля линковки.
void marker_disbalnce_year2017_2(octree* &oc, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos) {
	const doublereal critical_volume_ratio = 36.0;

	printf("marker disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != nullptr) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance N is found...\n");
							}
							if (octree1->ilevel > octree1->linkN->ilevel) {
								octree1->linkN->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkN->ilevel) == 1) {
							integer iml = octree1->ilevel;
							//bool biml = true; // octree1 иммет максимальный уровень.
							doublereal viml = fabs(xpos[octree1->maxx]-xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							if (octree1->linkN->ilevel > iml) {
								iml = octree1->linkN->ilevel;
								//biml = false;
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);
							}
							if (fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]) > viml) {
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);
							}
							octree* oc2 = octree1->linkN;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkN->maxx] - xpos[octree1->linkN->minx])*fabs(ypos[octree1->linkN->maxy] - ypos[octree1->linkN->miny])*fabs(zpos[octree1->linkN->maxz] - zpos[octree1->linkN->minz]);

												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != nullptr) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance S is found...\n");
							}
							if (octree1->ilevel > octree1->linkS->ilevel) {
								octree1->linkS->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkS->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							//bool biml = true;
							if (octree1->linkS->ilevel > iml) {
								iml = octree1->linkS->ilevel;
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);
								//biml = false;
							}
							if (fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz])>viml) {
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);
							}

							octree* oc2 = octree1->linkS;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal 	viml2 = fabs(xpos[octree1->linkS->maxx] - xpos[octree1->linkS->minx])*fabs(ypos[octree1->linkS->maxy] - ypos[octree1->linkS->miny])*fabs(zpos[octree1->linkS->maxz] - zpos[octree1->linkS->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != nullptr) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance E is found...\n");
							}
							if (octree1->ilevel > octree1->linkE->ilevel) {
								octree1->linkE->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkE->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							//bool biml = true;
							if (octree1->linkE->ilevel > iml) {
								iml = octree1->linkE->ilevel;
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);
								//biml = false;
							}
							if (fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz])>viml) {
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);
							}
							octree* oc2 = octree1->linkE;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
                                                doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkE->maxx] - xpos[octree1->linkE->minx])*fabs(ypos[octree1->linkE->maxy] - ypos[octree1->linkE->miny])*fabs(zpos[octree1->linkE->maxz] - zpos[octree1->linkE->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != nullptr) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance W is found...\n");
							}
							if (octree1->ilevel > octree1->linkW->ilevel) {
								octree1->linkW->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkW->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							//bool biml = true;
							if (octree1->linkW->ilevel > iml) {
								iml = octree1->linkW->ilevel;
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);
								//biml = false;
							}
							if (fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz])>viml) {
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);
							}
							octree* oc2 = octree1->linkW;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkW->maxx] - xpos[octree1->linkW->minx])*fabs(ypos[octree1->linkW->maxy] - ypos[octree1->linkW->miny])*fabs(zpos[octree1->linkW->maxz] - zpos[octree1->linkW->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != nullptr) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance T is found...\n");
							}
							if (octree1->ilevel > octree1->linkT->ilevel) {
								octree1->linkT->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkT->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							//bool biml = true;
							if (octree1->linkT->ilevel > iml) {
								iml = octree1->linkT->ilevel;
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);
								//biml = false;
							}
							if (fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz])>viml) {
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);
							}

							octree* oc2 = octree1->linkT;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkT->maxx] - xpos[octree1->linkT->minx])*fabs(ypos[octree1->linkT->maxy] - ypos[octree1->linkT->miny])*fabs(zpos[octree1->linkT->maxz] - zpos[octree1->linkT->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != nullptr) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance B is found...\n");
							}
							if (octree1->ilevel > octree1->linkB->ilevel) {
								octree1->linkB->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkB->ilevel) == 1) {
							integer iml = octree1->ilevel;
							doublereal viml = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
							//bool biml = true;
							if (octree1->linkB->ilevel > iml) {
								iml = octree1->linkB->ilevel;
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);
								//biml = false;
							}
							if (fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz])>viml) {
								// объём наибольшей ячейки.
								viml = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);
							}

							octree* oc2 = octree1->linkB;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkN->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkN->maxx] - xpos[oc2->linkN->minx])*fabs(ypos[oc2->linkN->maxy] - ypos[oc2->linkN->miny])*fabs(zpos[oc2->linkN->maxz] - zpos[oc2->linkN->minz]);

										if (iml > oc2->linkN->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkN->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkS->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkS->maxx] - xpos[oc2->linkS->minx])*fabs(ypos[oc2->linkS->maxy] - ypos[oc2->linkS->miny])*fabs(zpos[oc2->linkS->maxz] - zpos[oc2->linkS->minz]);

										if (iml > oc2->linkS->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkS->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkE->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkE->maxx] - xpos[oc2->linkE->minx])*fabs(ypos[oc2->linkE->maxy] - ypos[oc2->linkE->miny])*fabs(zpos[oc2->linkE->maxz] - zpos[oc2->linkE->minz]);

										if (iml > oc2->linkE->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkE->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkW->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkW->maxx] - xpos[oc2->linkW->minx])*fabs(ypos[oc2->linkW->maxy] - ypos[oc2->linkW->miny])*fabs(zpos[oc2->linkW->maxz] - zpos[oc2->linkW->minz]);

										if (iml > oc2->linkW->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkW->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {

											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkT->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkT->maxx] - xpos[oc2->linkT->minx])*fabs(ypos[oc2->linkT->maxy] - ypos[oc2->linkT->miny])*fabs(zpos[oc2->linkT->maxz] - zpos[oc2->linkT->minz]);

										if (iml > oc2->linkT->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkT->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
											doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


											if ((viml1>viml2)) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
									else if (abs(iml - oc2->linkB->ilevel) == 1) {
										doublereal viml2 = fabs(xpos[oc2->linkB->maxx] - xpos[oc2->linkB->minx])*fabs(ypos[oc2->linkB->maxy] - ypos[oc2->linkB->miny])*fabs(zpos[oc2->linkB->maxz] - zpos[oc2->linkB->minz]);

										if (iml > oc2->linkB->ilevel) {
											if ((viml2 / viml) > critical_volume_ratio) {
												oc2->linkB->disbalance_now = true;
											}
										}
										else {
											if ((viml / viml2) > critical_volume_ratio) {
												doublereal viml1 = fabs(xpos[octree1->maxx] - xpos[octree1->minx])*fabs(ypos[octree1->maxy] - ypos[octree1->miny])*fabs(zpos[octree1->maxz] - zpos[octree1->minz]);
												doublereal viml2 = fabs(xpos[octree1->linkB->maxx] - xpos[octree1->linkB->minx])*fabs(ypos[octree1->linkB->maxy] - ypos[octree1->linkB->miny])*fabs(zpos[octree1->linkB->maxz] - zpos[octree1->linkB->minz]);


												if ((viml1>viml2)) {
													octree1->disbalance_now = true;
												}
												else {
													oc2->disbalance_now = true;
												}
											}
										}
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // marker_disbalance_year2017_2.

  // Для полного контроля линковки.
void marker_disbalnce_year2017(octree* &oc) {
	printf("marker disbalance control.\n");
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (!octree1->b4N) {
					if (octree1->linkN != nullptr) {
						if (abs(octree1->ilevel - octree1->linkN->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance N is found...\n");
							}
							if (octree1->ilevel > octree1->linkN->ilevel) {
								octree1->linkN->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkN->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkN->ilevel > iml) {
								iml = octree1->linkN->ilevel;
								biml = false;
							}
							octree* oc2 = octree1->linkN;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4S) {
					if (octree1->linkS != nullptr) {
						if (abs(octree1->ilevel - octree1->linkS->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance S is found...\n");
							}
							if (octree1->ilevel > octree1->linkS->ilevel) {
								octree1->linkS->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkS->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkS->ilevel > iml) {
								iml = octree1->linkS->ilevel;
								biml = false;
							}
							octree* oc2 = octree1->linkS;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4E) {
					if (octree1->linkE != nullptr) {
						if (abs(octree1->ilevel - octree1->linkE->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance E is found...\n");
							}
							if (octree1->ilevel > octree1->linkE->ilevel) {
								octree1->linkE->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkE->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkE->ilevel > iml) {
								iml = octree1->linkE->ilevel;
								biml = false;
							}
							octree* oc2 = octree1->linkE;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4W) {
					if (octree1->linkW != nullptr) {
						if (abs(octree1->ilevel - octree1->linkW->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance W is found...\n");
							}
							if (octree1->ilevel > octree1->linkW->ilevel) {
								octree1->linkW->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkW->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkW->ilevel > iml) {
								iml = octree1->linkW->ilevel;
								biml = false;
							}
							octree* oc2 = octree1->linkW;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4T) {
					if (octree1->linkT != nullptr) {
						if (abs(octree1->ilevel - octree1->linkT->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance T is found...\n");
							}
							if (octree1->ilevel > octree1->linkT->ilevel) {
								octree1->linkT->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkT->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkT->ilevel > iml) {
								iml = octree1->linkT->ilevel;
								biml = false;
							}
							octree* oc2 = octree1->linkT;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				if (!octree1->b4B) {
					if (octree1->linkB != nullptr) {
						if (abs(octree1->ilevel - octree1->linkB->ilevel) > 1) {
							if (DEBUG_ALICE_MESH) {
								printf("disbalance B is found...\n");
							}
							if (octree1->ilevel > octree1->linkB->ilevel) {
								octree1->linkB->disbalance_now = true;
							}
							else {
								octree1->disbalance_now = true;
							}
							//system("PAUSE");
						}
						else if (abs(octree1->ilevel - octree1->linkB->ilevel) == 1) {
							integer iml = octree1->ilevel;
							bool biml = true;
							if (octree1->linkB->ilevel > iml) {
								iml = octree1->linkB->ilevel;
								biml = false;
							}
							octree* oc2 = octree1->linkB;
							if (!oc2->b4N) {
								if (oc2->linkN != nullptr) {
									if (abs(iml - oc2->linkN->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance N is found oc2!!! ...\n");
										}
										if (iml > oc2->linkN->ilevel) {
											oc2->linkN->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4S) {
								if (oc2->linkS != nullptr) {
									if (abs(iml - oc2->linkS->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance S is found oc2!!!...\n");
										}
										if (iml > oc2->linkS->ilevel) {
											oc2->linkS->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4E) {
								if (oc2->linkE != nullptr) {
									if (abs(iml - oc2->linkE->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance E is found oc2!!!...\n");
										}
										if (iml > oc2->linkE->ilevel) {
											oc2->linkE->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4W) {
								if (oc2->linkW != nullptr) {
									if (abs(iml - oc2->linkW->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance W is found oc2!!!...\n");
										}
										if (iml > oc2->linkW->ilevel) {
											oc2->linkW->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4T) {
								if (oc2->linkT != nullptr) {
									if (abs(iml - oc2->linkT->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance T is found oc2!!!...\n");
										}
										if (iml > oc2->linkT->ilevel) {
											oc2->linkT->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							if (!oc2->b4B) {
								if (oc2->linkB != nullptr) {
									if (abs(iml - oc2->linkB->ilevel) > 1) {
										if (DEBUG_ALICE_MESH) {
											printf("disbalance B is found oc2!!!...\n");
										}
										if (iml > oc2->linkB->ilevel) {
											oc2->linkB->disbalance_now = true;
										}
										else {
											if (biml) {
												octree1->disbalance_now = true;
											}
											else {
												oc2->disbalance_now = true;
											}
										}
										//system("PAUSE");
									}
								}
							}
							oc2 = nullptr;
						}
					}
				}
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // marker_disbalance_year2017.




  // Для полного контроля линковки.
  // Если соседние ячейки имеют разницу уровней больше единицы,
  // то происходит дробление наибольшей по размеру ячейки.
void marker_disbalnce(octree* &oc, doublereal* &xpos, doublereal* &ypos, doublereal* &zpos) {
	// Первоначальная базовая версия.
	// написана в 2016 году.
	if (itype_ALICE_Mesh == TYPE_ALICE_MESH::MULTI_PASS_MEDIUM_ALICE_MESH/*1*/) {
		// проблемы построения. Данный метод работает не всегда.
		// Качество сетки, получаемое алгоритмом 2016 года не является удовлетворительным
		// по ряду причин. В частности он допускает ячейки соседствующие по вершине, разность уровней у которых равна 2.
		// Эту ситуацию исправляет версия той-же функции, но 2017 года. Теперь нет ячеек соседствующих по вершине разница уровней у
		// которых достигает 2.
		//marker_disbalnce_year2017(oc); //17 august 2017.
		marker_disbalnce_year2017_2(oc, xpos, ypos, zpos); //17 august 2017.
	}
	else {		
		// Рабочий вариант 2016 года.
		marker_disbalnce_year2016(oc);
	}
}

// Для полного контроля линковки.
void is_b4N_found(octree* &oc) {
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist  ) {
				// Гасим информацию о посещениях.
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				if (octree1->b4N) {
					printf("b4N is found now in list");
					if (octree1->brootSituationY) {
						printf(" sitY=1");
					}
					else {
						printf(" sitY=0");
					}
					if (octree1->brootSituationX) {
						printf(" sitX=1");
					}
					else {
						printf(" sitX=0");
					}
					if (octree1->brootSituationZ) {
						printf(" sitZ=1");
					}
					else {
						printf(" sitZ=0");
					}
#if doubleintprecision == 1
					printf(" oc->root=%lld", octree1->root);
#else
					printf(" oc->root=%d", octree1->root);
#endif
					
					//system("PAUSE");
					system("PAUSE");
				}
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("PAUSE");
	}
} // is_b4N_found


// defa_nullptr(oc);
void defa_nullptr(octree* &oc) {
	oc->linkB = nullptr;
	oc->linkB0 = nullptr;
	oc->linkB1 = nullptr;
	oc->linkB2 = nullptr;
	oc->linkB3 = nullptr;
	oc->linkT = nullptr;
	oc->linkT4 = nullptr;
	oc->linkT5 = nullptr;
	oc->linkT6 = nullptr;
	oc->linkT7 = nullptr;
	oc->linkE = nullptr;
	oc->linkE1 = nullptr;
	oc->linkE2 = nullptr;
	oc->linkE5 = nullptr;
	oc->linkE6 = nullptr;
	oc->linkS = nullptr;
	oc->linkS0 = nullptr;
	oc->linkS1 = nullptr;
	oc->linkS4 = nullptr;
	oc->linkS5 = nullptr;
	oc->linkN = nullptr;
	oc->linkN2 = nullptr;
	oc->linkN3 = nullptr;
	oc->linkN6 = nullptr;
	oc->linkN7 = nullptr;
	oc->linkW = nullptr;
	oc->linkW0 = nullptr;
	oc->linkW3 = nullptr;
	oc->linkW4 = nullptr;
	oc->linkW7 = nullptr;
	oc->parent = nullptr;
} //defa_nullptr

// 10.08.2019
// defa_nullptr_additional(oc);
void defa_nullptr_additional(octree* &oc) {
	oc->parent = nullptr;
	oc->link0 = nullptr;
	oc->link1 = nullptr;
	oc->link2 = nullptr;
	oc->link3 = nullptr;
	oc->link4 = nullptr;
	oc->link5 = nullptr;
	oc->link6 = nullptr;
	oc->link7 = nullptr;
}

// Освобождение оперативной памяти из под octree.
// Новый метод освобождения оперативной памяти из под octree дерева 10.08.2019. 
// Проверено работает корректно в отличие от предыдущей реализации.
void free_octree(octree* &oc, integer maxelm) {
	//printf("FREE OCTREE MEMORY...Pool Size=%lld %e%%\n", icount_Length_vector_octree,100.0*icount_Length_vector_octree/ iMAX_Length_vector_octree);

	if (oc == nullptr) {
		printf("error oc==nullptr in free_octree function\n");
		system("pause");
	}
	else {
		// Ссылки на каждый узел octree дерева для его полной очистки.
		oc = nullptr;		

		rootClear_octree = head_rootClear_octree;
		while (rootClear_octree != nullptr) {
			octree_list *tmp_octree = rootClear_octree;
			defa_nullptr(tmp_octree->pnode);
			defa_nullptr_additional(tmp_octree->pnode);
			rootClear_octree = rootClear_octree->next;
			tmp_octree = nullptr;
		}

		rootClear_octree = head_rootClear_octree;
		while (rootClear_octree != nullptr) {
			octree_list *tmp_octree = rootClear_octree;
			rootClear_octree = rootClear_octree->next;
			tmp_octree->next = nullptr;
			delete tmp_octree->pnode; // освобождение оперативной памяти.
			delete tmp_octree; 
			tmp_octree = nullptr;
		}
		head_rootClear_octree = nullptr;

	}
}

// Освобождение оперативной памяти из под octree.
// alicemesh +637126 // 03.05.2019
// устарело 10.08.2019 
void free_octree_old(octree* &oc, integer maxelm) {
	if (oc == nullptr) {
		printf("error oc==nullptr in free_octree function\n");
		system("pause");
	}
	else {
		bool bpause = false;
		if (oc->link0 == nullptr) {
			printf("link0 is nullptr\n");
			bpause = true;
		}
		if (oc->link1 == nullptr) {
			printf("link1 is nullptr\n");
			bpause = true;
		}
		if (oc->link2 == nullptr) {
			printf("link2 is nullptr\n");
			bpause = true;
		}
		if (oc->link3 == nullptr) {
			printf("link3 is nullptr\n");
			bpause = true;
		}
		if (oc->link4 == nullptr) {
			printf("link4 is nullptr\n");
			bpause = true;
		}
		if (oc->link5 == nullptr) {
			printf("link5 is nullptr\n");
			bpause = true;
		}
		if (oc->link6 == nullptr) {
			printf("link6 is nullptr\n");
			bpause = true;
		}
		if (oc->link7 == nullptr) {
			printf("link7 is nullptr\n");
			bpause = true;
		}
		if (bpause) {
			system("pause");
		}
	}
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		oc->link0 = nullptr;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		oc->link1 = nullptr;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		oc->link2 = nullptr;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		oc->link3 = nullptr;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
		oc->link4 = nullptr;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
		oc->link5 = nullptr;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
		oc->link6 = nullptr;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
		oc->link7 = nullptr;
	}
	defa_nullptr(oc);


	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if ((my_ALICE_STACK[top_ALICE_STACK - 1].link->link0 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link1 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link2 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link3 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link4 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link5 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link6 == nullptr)&&
				(my_ALICE_STACK[top_ALICE_STACK - 1].link->link7 == nullptr))
			{
				// Гасим информацию о посещениях.
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;
				/*
				switch (octree1->parent->root) {
				case 0: octree1->parent->link0 = nullptr; break;
				case 1: octree1->parent->link1 = nullptr; break;
				case 2: octree1->parent->link2 = nullptr; break;
				case 3: octree1->parent->link3 = nullptr; break;
				case 4: octree1->parent->link4 = nullptr; break;
				case 5: octree1->parent->link5 = nullptr; break;
				case 6: octree1->parent->link6 = nullptr; break;
				case 7: octree1->parent->link7 = nullptr; break;
				}
				*/
				//6.01.2018
				// Ликвидируем все ссылки из всех соседних листов на конкретный данный лист.				
				for (integer i_90 = top_ALICE_STACK - 2; i_90 >= 0; i_90--) {
					if (my_ALICE_STACK[i_90].link != nullptr) {
						//if ((my_ALICE_STACK[i_90].link->link0 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link1 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link2 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link3 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link4 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link5 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link6 == nullptr) &&
						//	(my_ALICE_STACK[i_90].link->link7 == nullptr))
						{
							// Почему обязательно лист. Вообще все ссылки на octree1
							// должны быть убраны в null.
							/*
							if (my_ALICE_STACK[i_90].link->link0 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link0 == octree1) {
									my_ALICE_STACK[i_90].link->link0 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link1 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link1 == octree1) {
									my_ALICE_STACK[i_90].link->link1 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link2 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link2 == octree1) {
									my_ALICE_STACK[i_90].link->link2 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link3 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link3 == octree1) {
									my_ALICE_STACK[i_90].link->link3 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link4 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link4 == octree1) {
									my_ALICE_STACK[i_90].link->link4 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link5 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link5 == octree1) {
									my_ALICE_STACK[i_90].link->link5 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link6 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link6 == octree1) {
									my_ALICE_STACK[i_90].link->link6 = nullptr;
								}
							}

							if (my_ALICE_STACK[i_90].link->link7 != nullptr) {
								if (my_ALICE_STACK[i_90].link->link7 == octree1) {
									my_ALICE_STACK[i_90].link->link7 = nullptr;
								}
							}
							*/
							defa_nullptr(my_ALICE_STACK[i_90].link);
							
							if (my_ALICE_STACK[i_90].link->parent != nullptr) {
								if (my_ALICE_STACK[i_90].link->parent == octree1) {
									my_ALICE_STACK[i_90].link->parent = nullptr;
								}
							}
						}
					}
				}
				


				octree1->parent = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				defa_nullptr(octree1);
				
				delete octree1;
				octree1 = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					buf->link->link0 = nullptr;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					buf->link->link1 = nullptr;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
					buf->link->link2 = nullptr;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
					buf->link->link3 = nullptr;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
					buf->link->link4 = nullptr;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
					buf->link->link5 = nullptr;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
					buf->link->link6 = nullptr;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
					buf->link->link7 = nullptr;
				}
				defa_nullptr(buf->link);
			}
		}
		//}
		//system("PAUSE");
	}
} // free_octree


// Реализация данной функции см. Constr Struct.
  // проверяет принадлежит ли контрольный объём
  // тепловой модели.
  // Возвращает параметр ib равный номеру блока
  // которому принадлежит контрольный объём.
bool in_model_temp(TOCHKA p, int &ib, BLOCK* b, int lb);

// Какому блоку принадлежит точка p
// Определяет координаты блока которому принадлежит заданная точка.
// На больших моделях данная функция испытывает очень высокую нагрузку.
// По видимому надо применить ускоряющее octree дерево или двоичный поиск. 
// Проблема в том что на данном этапе сетка еще не построена и неизвестны
// xpos, ypos  и zpos двоичный поиск в которых можно использовать для ускорения 
// вычисления принадлежности точки блоку.
// Обратите внимание здесь блоки только прямоугольные параллелепипеды.
// 01.05.2019
int myisblock_id_stab(int lb, BLOCK*& b, TOCHKA p) {
	int ib = 0;
	for (int i_1 = lb - 1; i_1 >= 0; i_1--) {
		if ((b[i_1].g.xS < p.x) && (b[i_1].g.xE > p.x) && (b[i_1].g.yS < p.y) && (b[i_1].g.yE > p.y) && (b[i_1].g.zS < p.z) && (b[i_1].g.zE > p.z)) {
			ib = i_1;
			// Если блок найден то сканирование сразу прекращается.
			break;
		}
	}
	return ib;
} //myisblock_id_stab

// глобальный счётчик числа попыток
integer iOk28_number_popjtka = 0;

// Предсказания числа элементов АЛИС сетки до этапа построения самой АЛИС сетки.
// Это требуется для корректного выделения оперативной памяти, например под Alice_Stack.
// 01.11.2020
integer ALICE_maxelm_size_prediction(integer inx, integer iny, integer inz, 
	BLOCK*& b, int lb, int lw, WALL*& w,
	SOURCE*& s, int& ls) {

	// Подобрано на серии tgf задач 31.10.2020.
	//return static_cast<integer>(0.04*((inx+1)*(iny+1)*(inz+1)));

	doublereal min_dx = 1.0e30;
	doublereal min_dy = 1.0e30;
	doublereal min_dz = 1.0e30;


	for (integer i = 1; i < lb; ++i) {
		if (b[i].g.itypegeom == PRISM) {
			if (min_dx > fabs(b[i].g.xE - b[i].g.xS)) {
				min_dx = fabs(b[i].g.xE - b[i].g.xS);
			}
			if (min_dy > fabs(b[i].g.yE - b[i].g.yS)) {
				min_dy = fabs(b[i].g.yE - b[i].g.yS);
			}
			if (min_dz > fabs(b[i].g.zE - b[i].g.zS)) {
				min_dz = fabs(b[i].g.zE - b[i].g.zS);
			}
		}
		if (b[i].g.itypegeom == CYLINDER) {
			switch (b[i].g.iPlane) {
			case XY_PLANE :
				if (min_dz > fabs(b[i].g.Hcyl)) {
					min_dz = fabs(b[i].g.Hcyl);
				}
				if (min_dx > fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl)) {
					min_dx = fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl);
				}
				if (min_dy > fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl)) {
					min_dy = fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl);
				}
				break;
			case XZ_PLANE:
				if (min_dy > fabs(b[i].g.Hcyl)) {
					min_dy = fabs(b[i].g.Hcyl);
				}
				if (min_dx > fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl)) {
					min_dx = fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl);
				}
				if (min_dz > fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl)) {
					min_dz = fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl);
				}
				break;
			case YZ_PLANE:
				if (min_dx > fabs(b[i].g.Hcyl)) {
					min_dx = fabs(b[i].g.Hcyl);
				}
				if (min_dy > fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl)) {
					min_dy = fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl);
				}
				if (min_dz > fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl)) {
					min_dz = fabs(b[i].g.R_out_cyl - b[i].g.R_in_cyl);
				}
				break;
			}

		}
		if (b[i].g.itypegeom == CAD_STL) {
			doublereal dist = 0.0;
			dist = b[i].g.min_size_edge();
			if (min_dx > dist) {
				min_dx = dist;
			}
			if (min_dy > dist) {
				min_dy = dist;
			}
			if (min_dz > dist) {
				min_dz = dist;
			}
		}
		if (b[i].g.itypegeom == POLYGON) {

			integer j=0;
			doublereal dist = 0.0;
			switch (b[i].g.iPlane_obj2) {
			case XY_PLANE:
				if (min_dz > fabs(b[i].g.hi[0])) {
					min_dz = fabs(b[i].g.hi[0]);
				}
				for (j = 0; j < b[i].g.nsizei - 1; ++j) {
					dist = sqrt((b[i].g.xi[j] - b[i].g.xi[j + 1]) * (b[i].g.xi[j] - b[i].g.xi[j + 1]) + (b[i].g.yi[j] - b[i].g.yi[j + 1]) * (b[i].g.yi[j] - b[i].g.yi[j + 1]));
					if (min_dx > dist) {
						min_dx = dist;
					}
					if (min_dy > dist) {
						min_dy = dist;
					}
				}
				dist = sqrt((b[i].g.xi[0] - b[i].g.xi[b[i].g.nsizei - 1]) * (b[i].g.xi[0] - b[i].g.xi[b[i].g.nsizei - 1]) + (b[i].g.yi[0] - b[i].g.yi[b[i].g.nsizei - 1]) * (b[i].g.yi[0] - b[i].g.yi[b[i].g.nsizei - 1]));
				if (min_dx > dist) {
					min_dx = dist;
				}
				if (min_dy > dist) {
					min_dy = dist;
				}
				break;
			case XZ_PLANE:
				if (min_dy > fabs(b[i].g.hi[0])) {
					min_dy = fabs(b[i].g.hi[0]);
				}
				for (j = 0; j < b[i].g.nsizei - 1; ++j) {
					dist = sqrt((b[i].g.xi[j] - b[i].g.xi[j + 1]) * (b[i].g.xi[j] - b[i].g.xi[j + 1]) + (b[i].g.zi[j] - b[i].g.zi[j + 1]) * (b[i].g.zi[j] - b[i].g.zi[j + 1]));
					if (min_dx > dist) {
						min_dx = dist;
					}
					if (min_dz > dist) {
						min_dz = dist;
					}
				}
				dist = sqrt((b[i].g.xi[0] - b[i].g.xi[b[i].g.nsizei - 1]) * (b[i].g.xi[0] - b[i].g.xi[b[i].g.nsizei - 1]) + (b[i].g.zi[0] - b[i].g.zi[b[i].g.nsizei - 1]) * (b[i].g.zi[0] - b[i].g.zi[b[i].g.nsizei - 1]));
				if (min_dx > dist) {
					min_dx = dist;
				}
				if (min_dz > dist) {
					min_dz = dist;
				}
				break;
			case YZ_PLANE:
				if (min_dx > fabs(b[i].g.hi[0])) {
					min_dx = fabs(b[i].g.hi[0]);
				}
				for (j = 0; j < b[i].g.nsizei - 1; ++j) {
					dist = sqrt((b[i].g.zi[j] - b[i].g.zi[j + 1]) * (b[i].g.zi[j] - b[i].g.zi[j + 1]) + (b[i].g.yi[j] - b[i].g.yi[j + 1]) * (b[i].g.yi[j] - b[i].g.yi[j + 1]));
					if (min_dz > dist) {
						min_dz = dist;
					}
					if (min_dy > dist) {
						min_dy = dist;
					}
				}
				dist = sqrt((b[i].g.zi[0] - b[i].g.zi[b[i].g.nsizei - 1]) * (b[i].g.zi[0] - b[i].g.zi[b[i].g.nsizei - 1]) + (b[i].g.yi[0] - b[i].g.yi[b[i].g.nsizei - 1]) * (b[i].g.yi[0] - b[i].g.yi[b[i].g.nsizei - 1]));
				if (min_dz > dist) {
					min_dz = dist;
				}
				if (min_dy > dist) {
					min_dy = dist;
				}
				break;
			}

		}

	}

	doublereal min_div = min_dx / fabs(b[0].g.xE - b[0].g.xS);
	if (min_dy / fabs(b[0].g.yE - b[0].g.yS) < min_div) {
		min_div = min_dy / fabs(b[0].g.yE - b[0].g.yS);
	}
	if (min_dz / fabs(b[0].g.zE - b[0].g.zS) < min_div) {
		min_div = min_dz / fabs(b[0].g.zE - b[0].g.zS);
	}

	printf("min_div=%e\n",min_div);
	//system("PAUSE");

	// 01.11.2020
	doublereal K = 1.0;
	if (min_div > 0.2) {
		K = 1.0;
	}
	else if (min_div > 0.002) {
		K = 0.52;
	}
	else if (min_div > 5e-4) {
		// Пионер
		K = 0.25;
	}
	else if (min_div > 5e-5) {
		K = 0.12;
	}
	else {
		// min_div==4.428698e-6
		K = 0.04; // tgf series
	}
	return static_cast<integer>(K * ((inx + 1) * (iny + 1) * (inz + 1)));

} // ALICE_maxelm_size_prediction

// Записываем номер блока которому принадлежит ячейка АЛИС сетки, для
// каждой ячейки. 18.11.2020.
void calculate_whot_is_block(octree*& oc, BLOCK*& b, int lb) {
	top_ALICE_STACK = 0;
	if (oc->link0 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link0);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link0->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link0->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link0->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link0->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link0->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link0->minz;
		top_ALICE_STACK++;
	}
	if (oc->link1 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link1);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link1->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link1->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link1->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link1->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link1->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link1->minz;
		top_ALICE_STACK++;
	}
	if (oc->link2 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link2);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link2->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link2->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link2->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link2->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link2->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link2->minz;
		top_ALICE_STACK++;
	}
	if (oc->link3 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link3);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link3->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link3->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link3->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link3->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link3->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link3->minz;
		top_ALICE_STACK++;
	}
	if (oc->link4 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link4);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link4->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link4->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link4->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link4->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link4->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link4->minz;
		top_ALICE_STACK++;
	}
	if (oc->link5 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link5);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link5->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link5->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link5->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link5->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link5->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link5->minz;
		top_ALICE_STACK++;
	}
	if (oc->link6 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link6);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link6->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link6->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link6->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link6->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link6->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link6->minz;
		top_ALICE_STACK++;
	}
	if (oc->link7 != nullptr) {
		my_ALICE_STACK[top_ALICE_STACK].link = (oc->link7);
		my_ALICE_STACK[top_ALICE_STACK].maxx = oc->link7->maxx;
		my_ALICE_STACK[top_ALICE_STACK].minx = oc->link7->minx;
		my_ALICE_STACK[top_ALICE_STACK].maxy = oc->link7->maxy;
		my_ALICE_STACK[top_ALICE_STACK].miny = oc->link7->miny;
		my_ALICE_STACK[top_ALICE_STACK].maxz = oc->link7->maxz;
		my_ALICE_STACK[top_ALICE_STACK].minz = oc->link7->minz;
		top_ALICE_STACK++;
	}
	while (top_ALICE_STACK > 0) {
		if (my_ALICE_STACK[top_ALICE_STACK - 1].link != nullptr) {
			if (my_ALICE_STACK[top_ALICE_STACK - 1].link->dlist) {
				// Гасим информацию о посещениях.
				octree* octree1 = my_ALICE_STACK[top_ALICE_STACK - 1].link;

				bool blabeling = true;

				if ((octree1->minx == octree1->maxx-1) || (octree1->miny == octree1->maxy - 1)|| (octree1->minz == octree1->maxz - 1)) {
					// Одна клетка особый случай.
					TOCHKA p;
				    p.x = 0.125 * (octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
				    p.y = 0.125 * (octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
				    p.z = 0.125 * (octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
				    int ib;
				    //bool inDomain = false;

					// Вычисляет ib. ib используется !!!
			        //inDomain=in_model_temp(p, ib, b, lb);
					in_model_temp(p, ib, b, lb);

					// Определяем номер блока который присвоен ячейке АЛИС сетки.
				    // Все клеточки ячейки данной АЛИС сетки имеют один и тот же номер блока.
				    // Данное запоминание нужно для ускорения работы программы.
					if (/*(inDomain)&&*/(blabeling))
					{
						//if ((octree1->minx== octree1->maxx-1)&& (octree1->miny == octree1->maxy - 1)&& (octree1->minz == octree1->maxz - 1)) 
						{
							octree1->whot_is_block = ib;
							if (ib == -1) {
								std::cout << "ERROR 1 : ib == -1\n";
								system("PAUSE");
							}
						}
					}

				}
				else {

				    int ib = hash_for_droblenie_xyz[octree1->minx][octree1->miny][octree1->minz];

				    for (int i = octree1->minx; i < octree1->maxx; ++i) {
					    for (int j = octree1->miny; j < octree1->maxy; ++j) {
						    for (int k = octree1->minz; k < octree1->maxz; ++k) {
							    if (ib != hash_for_droblenie_xyz[i][j][k]) {
								   blabeling = false;
							    }
						    }
				    	}
				    }


					/*{
						// Инициируем обязательную проверку: 06,08,2021

						TOCHKA p;
						p.x = 0.125 * (octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
						p.y = 0.125 * (octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
						p.z = 0.125 * (octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
						int ib2;

						in_model_temp(p, ib2, b, lb);

						if (ib2 != ib) {
							std::cout << "Error!!! Proverka ne proidena. Istinnji number block=" << ib2 << ";  error determinate number block quick depend=" << ib << "\n";
							//system("pause");
							ib = ib2;
						}
					}*/

					if (ib == -1) {

						
						std::cout << "ERROR 2 : ib == -1\n";
						system("PAUSE");
						

						// Не удалось определить быстрым способом номер блока.
						// Применяем тяжелый с вычислительной точки зрения способ прямого вычисления.

						TOCHKA p;
						p.x = 0.125 * (octree1->p0.x + octree1->p1.x + octree1->p2.x + octree1->p3.x + octree1->p4.x + octree1->p5.x + octree1->p6.x + octree1->p7.x);
						p.y = 0.125 * (octree1->p0.y + octree1->p1.y + octree1->p2.y + octree1->p3.y + octree1->p4.y + octree1->p5.y + octree1->p6.y + octree1->p7.y);
						p.z = 0.125 * (octree1->p0.z + octree1->p1.z + octree1->p2.z + octree1->p3.z + octree1->p4.z + octree1->p5.z + octree1->p6.z + octree1->p7.z);
						int ib;
						//bool inDomain = false;

						//inDomain = in_model_temp(p, ib, b, lb);
						in_model_temp(p, ib, b, lb);

						
						std::cout << "ERROR 3 : ib == -1\n";
						system("PAUSE");
						

					}

					// Определяем номер блока который присвоен ячейке АЛИС сетки.
				    // Все клеточки ячейки данной АЛИС сетки имеют один и тот же номер блока.
				    // Данное запоминание нужно для ускорения работы программы.
					if (/*(inDomain)&&*/(blabeling))
					{
						//if ((octree1->minx== octree1->maxx-1)&& (octree1->miny == octree1->maxy - 1)&& (octree1->minz == octree1->maxz - 1)) 
						{
							octree1->whot_is_block = ib;
						}
					}
			    }
				
					

				
				
				
				octree1 = nullptr;
				my_ALICE_STACK[top_ALICE_STACK - 1].link = nullptr;
				top_ALICE_STACK--;
			}
			else {
				// продолжаем добираться до листьев.
				STACK_ALICE buf1 = my_ALICE_STACK[top_ALICE_STACK - 1];
				STACK_ALICE* buf = &buf1;
				top_ALICE_STACK--;
				if (buf->link->link0 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link0);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link0->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link0->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link0->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link0->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link0->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link0->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link1 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link1);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link1->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link1->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link1->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link1->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link1->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link1->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link2 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link2);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link2->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link2->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link2->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link2->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link2->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link2->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link3 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link3);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link3->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link3->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link3->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link3->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link3->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link3->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link4 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link4);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link4->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link4->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link4->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link4->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link4->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link4->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link5 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link5);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link5->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link5->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link5->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link5->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link5->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link5->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link6 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link6);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link6->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link6->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link6->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link6->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link6->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link6->minz;
					top_ALICE_STACK++;
				}
				if (buf->link->link7 != nullptr) {
					my_ALICE_STACK[top_ALICE_STACK].link = (buf->link->link7);
					my_ALICE_STACK[top_ALICE_STACK].maxx = buf->link->link7->maxx;
					my_ALICE_STACK[top_ALICE_STACK].minx = buf->link->link7->minx;
					my_ALICE_STACK[top_ALICE_STACK].maxy = buf->link->link7->maxy;
					my_ALICE_STACK[top_ALICE_STACK].miny = buf->link->link7->miny;
					my_ALICE_STACK[top_ALICE_STACK].maxz = buf->link->link7->maxz;
					my_ALICE_STACK[top_ALICE_STACK].minz = buf->link->link7->minz;
					top_ALICE_STACK++;
				}
			}
		}
		//}
		//system("pause");
	}
}

// Процесс построение Адаптивной Локально Измельчённой расчётной Сетки.
// АЛИС - экономит ресурсы ЭВМ и позволяет рассчитывать большие задачи на слабом оборудовании.
bool alice_mesh(doublereal* xpos, doublereal* ypos, doublereal* zpos,
	int inx, int iny, int inz,
	BLOCK* &b, int lb, int lw, WALL* &w, 
	SOURCE* &s, int &ls, integer maxelm,
	doublereal* &xposadd, doublereal* &yposadd, doublereal* &zposadd,
	int &inxadd, int &inyadd, int &inzadd) {


	bool b_resize1 = false;

	

	bool bsimpledefine = true;
	for (int i1 = 0; i1 < lb; ++i1) {
		if (b[i1].g.itypegeom != 0) {
			// есть цилиндры.
			bsimpledefine = false;
		}
	}

	++iOk28_number_popjtka;

#if doubleintprecision == 1
	/*
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inx; ++i) {
	printf("xpos[%lld]=%e\n",i,xpos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= iny; ++i) {
	printf("ypos[%lld]=%e\n", i, ypos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inz; ++i) {
	printf("zpos[%lld]=%e\n", i, zpos[i]);
	}
	system("PAUSE");
	*/
#else
	/*
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inx; ++i) {
	printf("xpos[%d]=%e\n",i,xpos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= iny; ++i) {
	printf("ypos[%d]=%e\n", i, ypos[i]);
	}
	// индексация начинается с нуля и заканчивается значением inx
	for (integer i = 0; i <= inz; ++i) {
	printf("zpos[%d]=%e\n", i, zpos[i]);
	}
	system("PAUSE");
	*/
#endif
	
	// Вычисление допуска.
	doublereal epsToolx = 1.0e36;
	doublereal epsTooly = 1.0e36;
	doublereal epsToolz = 1.0e36;
	for (int i = 0; i < inx; ++i) {
		if (fabs(xpos[i + 1] - xpos[i]) < epsToolx) {
			epsToolx = 0.5*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (int i = 0; i < iny; ++i) {
		if (fabs(ypos[i + 1] - ypos[i]) < epsTooly) {
			epsTooly = 0.5*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (int i = 0; i < inz; ++i) {
		if (fabs(zpos[i + 1] - zpos[i]) < epsToolz) {
			epsToolz = 0.5*fabs(zpos[i + 1] - zpos[i]);
		}
	}
	
	//epsToolx *= 5.0;
	//epsTooly *= 5.0;
	//epsToolz *= 5.0;
	epsToolx = -1.0e36;
	epsTooly = -1.0e36;
	epsToolz = -1.0e36;
	for (int i = 0; i < inx; ++i) {
		if (fabs(xpos[i + 1] - xpos[i]) > epsToolx) {
			epsToolx = 0.5*fabs(xpos[i + 1] - xpos[i]);
		}
	}
	for (int i = 0; i < iny; ++i) {
		if (fabs(ypos[i + 1] - ypos[i]) > epsTooly) {
			epsTooly = 0.5*fabs(ypos[i + 1] - ypos[i]);
		}
	}
	for (int i = 0; i < inz; ++i) {
		if (fabs(zpos[i + 1] - zpos[i]) > epsToolz) {
			epsToolz = 0.5*fabs(zpos[i + 1] - zpos[i]);
		}
	}
	
	hash_for_droblenie_xyz = new int**[inx];
	for (int i_54 = 0; i_54 < inx; ++i_54) {
		hash_for_droblenie_xyz[i_54] = new int*[iny];
	}
	for (int i_54 = 0; i_54 < inx; ++i_54) {
		for (int i_55 = 0; i_55 < iny; ++i_55) {
			hash_for_droblenie_xyz[i_54][i_55] = new int[inz];
		}
	}
	for (int i_54 = 0; i_54 < inx; ++i_54) {
		for (int i_55 = 0; i_55 < iny; ++i_55) {
			for (int i_56 = 0; i_56 < inz; ++i_56) {
				hash_for_droblenie_xyz[i_54][i_55][i_56] = -1;
			}
		}
	}

	if ((!CAD_GEOMETRY_OCTREE_MESHGEN)) {
		// 1 января 2018. 
		// Способ заимствован из файла constr_struct.cpp из файла 
		// enumerate_volume_improved_obobshenie.
		// Более сложный и быстродействующий вариант.

		printf("enumerate_volume_improved_obobshenie start.\n");
		Block_indexes* block_indexes = new Block_indexes[lb];
		// Оператор new не требует проверки.
		//if (block_indexes == nullptr) {
			//printf("error in allocation memory for block_indexes in enumerate_volume_improved.\n");
			//system("pause");
			//exit(1);
		//}
		// initialization 30.07.2019
		for (integer i_54 = 0; i_54 < lb; ++i_54) {
			block_indexes[i_54].iL = -1;
			block_indexes[i_54].iR = -2;
			block_indexes[i_54].jL = -1;
			block_indexes[i_54].jR = -2;
			block_indexes[i_54].kL = -1;
			block_indexes[i_54].kR = -2;
		}


		bool* bvisit = nullptr;
		bvisit = new bool[(inx+1)*(iny+1)*(inz+1)];
		// Оператор new не требует проверки.
		//if (bvisit == nullptr) {
			// недостаточно памяти на данном оборудовании.
			//printf("Problem: not enough memory on your equipment for bvisit constr struct...\n");
			//printf("Please any key to exit...\n");
			//exit(1);
		//}

		int i, j, i_1 = lb-1;
		//integer k;




		// Погрешность бывает абсолютная и относительная.
		// Вещественные числа в ЭВМ представляются с конечной точностью.
		// Лучше использовать относительную погрешность в 0.15%.
		//const doublereal otnositelnaq_tolerance_eps = 0.0015; // 0.15% 0.0015

		/*{
			i = 0;
			std::cout << b[i].name << ": ";
			printf("xS=%e xE=%e yS=%e yE=%e zS=%e zE=%e\n", b[i].g.xS, b[i].g.xE,
				b[i].g.yS, b[i].g.yE, b[i].g.zS, b[i].g.zE);
			printf("cabinet: xS=%e xE=%e yS=%e yE=%e zS=%e zE=%e\n", b[0].g.xS, b[0].g.xE,
				b[0].g.yS, b[0].g.yE, b[0].g.zS, b[0].g.zE);
			printf("ERROR: may be your geometry out of cabinet...\n");
			system("pause");

		}*/

		for (i = lb-1; i >= 0; --i) {
			//if (b[i].g.itypegeom == 0) {

			// polygon (b[i].g.itypegeom == 2)
			// Значения прямоугольной призмы xS, xE, yS, yE, zS, zE - хранят окаймляющую
			// полигон прямоугольную призму, что позволит проверять принадлежность точки полигону
			// только для ячеек сетки находящихся внутри данной прямоугольной призмы, что сильно 
			// ускоряет обработку.
			// marker 30.07.2019 исключена проверка bfound
			if ((b[i].g.itypegeom == PRISM) || (b[i].g.itypegeom == CYLINDER) ||
				(b[i].g.itypegeom == POLYGON) || (b[i].g.itypegeom == CAD_STL))
			{

				doublereal x4 = b[i].g.xS;
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XY_PLANE) || (b[i].g.iPlane == XZ_PLANE))) {
					x4 = b[i].g.xC - b[i].g.R_out_cyl;
				}
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == YZ_PLANE))) {
					if (b[i].g.Hcyl > 0.0) {
						x4 = b[i].g.xC;
					}
					else {
						x4 = b[i].g.xC + b[i].g.Hcyl;
					}
				}
				/*
				for (j = 0; j <= inx; ++j) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (xpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].iL = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(xpos[j] - x4) < shorter_length_for_simplificationX(x4)) {
							block_indexes[i_1].iL = j;
							break;
						}
					}
				}
				*/
				doublereal max_dist = 1.0e36;
				for (j = 0; j <= inx; ++j) {
					// Абсолютная погрешность.
					//if (fabs(xpos[j] - x4) < shorter_length_for_simplificationX(x4,b,lb,w,lw,s,ls)) {
						//block_indexes[i_1].iL = j;
						//break;
					//}
					if (fabs(xpos[j] - x4) < max_dist) {
						max_dist = fabs(xpos[j] - x4);
						block_indexes[i_1].iL = j;
					}
				}
				
				
				x4 = b[i].g.xE;
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XY_PLANE) || (b[i].g.iPlane == XZ_PLANE))) {
					x4 = b[i].g.xC + b[i].g.R_out_cyl;
				}
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == YZ_PLANE))) {
					if (b[i].g.Hcyl > 0.0) {
						x4 = b[i].g.xC + b[i].g.Hcyl;
					}
					else {
						x4 = b[i].g.xC;
					}
				}
				/*
				for (j = 0; j <= inx; ++j) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (xpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].iR = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(xpos[j] - x4) < shorter_length_for_simplificationX(x4)) {
							block_indexes[i_1].iR = j;
							break;
						}
					}
				}
				*/
				max_dist = 1.0e36;
				for (j = 0; j <= inx; ++j) {
					// Абсолютная погрешность.
					//if (fabs(xpos[j] - x4) < shorter_length_for_simplificationX(x4, b, lb, w, lw, s, ls)) {
						//block_indexes[i_1].iR = j;
						//break;
					//}
					if (fabs(xpos[j] - x4) < max_dist) {
						max_dist = fabs(xpos[j] - x4);
						block_indexes[i_1].iR = j;
					}
				}
				
				x4 = b[i].g.yS;
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XY_PLANE) || (b[i].g.iPlane == YZ_PLANE))) {
					x4 = b[i].g.yC - b[i].g.R_out_cyl;
				}
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XZ_PLANE))) {
					if (b[i].g.Hcyl > 0.0) {
						x4 = b[i].g.yC;
					}
					else {
						x4 = b[i].g.yC + b[i].g.Hcyl;
					}
				}
				/*
				for (j = 0; j <= iny; ++j) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (ypos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].jL = j;							
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(ypos[j] - x4) < shorter_length_for_simplificationY(x4)) {
							block_indexes[i_1].jL = j;							
							break;
						}
					}
				}
				*/
				max_dist = 1.0e36;
				for (j = 0; j <= iny; ++j) {
					// Абсолютная погрешность.
					//if (fabs(ypos[j] - x4) < shorter_length_for_simplificationY(x4, b, lb, w, lw, s, ls)) {
						//block_indexes[i_1].jL = j;
						//break;
					//}
					if (fabs(ypos[j] - x4) < max_dist) {
						max_dist = fabs(ypos[j] - x4);
						block_indexes[i_1].jL = j;
					}
				}

				x4 = b[i].g.yE;
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XY_PLANE) || (b[i].g.iPlane == YZ_PLANE))) {
					x4 = b[i].g.yC + b[i].g.R_out_cyl;
				}
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XZ_PLANE))) {
					if (b[i].g.Hcyl > 0.0) {
						x4 = b[i].g.yC + b[i].g.Hcyl;
					}
					else {
						x4 = b[i].g.yC;
					}
				}
				/*
			    for (j = 0; j <= iny; ++j) {

					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (ypos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].jR = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(ypos[j] - x4) < shorter_length_for_simplificationY(x4)) {
							block_indexes[i_1].jR = j;
							break;
						}
					}
				}
				*/
				max_dist = 1.0e36;
				for (j = 0; j <= iny; ++j) {
					// Абсолютная погрешность.
					//if (fabs(ypos[j] - x4) < shorter_length_for_simplificationY(x4, b, lb, w, lw, s, ls)) {
					//	block_indexes[i_1].jR = j;
						//break;
					//}
					if (fabs(ypos[j] - x4) < max_dist) {
						max_dist = fabs(ypos[j] - x4);
						block_indexes[i_1].jR = j;
					}
				}
				
				x4 = b[i].g.zS;
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XZ_PLANE) || (b[i].g.iPlane == YZ_PLANE))) {
					x4 = b[i].g.zC - b[i].g.R_out_cyl;
				}
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XY_PLANE))) {
					if (b[i].g.Hcyl > 0.0) {
						x4 = b[i].g.zC;
					}
					else {
						x4 = b[i].g.zC + b[i].g.Hcyl;
					}
				}
				/*
				for (j = 0; j <= inz; ++j) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (zpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].kL = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(zpos[j] - x4) < shorter_length_for_simplificationZ(x4)) {
							block_indexes[i_1].kL = j;
							break;
						}
					}
				}
				*/
				max_dist = 1.0e36;
				for (j = 0; j <= inz; ++j) {
					// Абсолютная погрешность.
					//if (fabs(zpos[j] - x4) < shorter_length_for_simplificationZ(x4, b, lb, w, lw, s, ls)) {
						//block_indexes[i_1].kL = j;
						//break;
					//}
					if (fabs(zpos[j] - x4) < max_dist) {
						max_dist = fabs(zpos[j] - x4);
						block_indexes[i_1].kL = j;
					}
				}

				x4 = b[i].g.zE;
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XZ_PLANE) || (b[i].g.iPlane == YZ_PLANE))) {
					x4 = b[i].g.zC + b[i].g.R_out_cyl;
				}
				if ((b[i].g.itypegeom == CYLINDER) && ((b[i].g.iPlane == XY_PLANE))) {
					if (b[i].g.Hcyl > 0.0) {
						x4 = b[i].g.zC + b[i].g.Hcyl;
					}
					else {
						x4 = b[i].g.zC;
					}
				}
				/*
				for (j = 0; j <= inz; ++j) {
					if (fabs(x4) > 0.0) {
						// Относительная погрешность менее 0.15%.
						if (fabs(100 * (zpos[j] - x4) / fabs(x4)) < otnositelnaq_tolerance_eps) {
							block_indexes[i_1].kR = j;
							break;
						}
					}
					else {
						// Абсолютная погрешность.
						if (fabs(zpos[j] - x4) < shorter_length_for_simplificationZ(x4)) {
							block_indexes[i_1].kR = j;
							break;
						}
					}
				}
				*/
				max_dist = 1.0e36;
				for (j = 0; j <= inz; ++j) {
					// Абсолютная погрешность.
					//if (fabs(zpos[j] - x4) < shorter_length_for_simplificationZ(x4, b, lb, w, lw, s, ls)) {
						//block_indexes[i_1].kR = j;
						//break;
					//}
					if (fabs(zpos[j] - x4) < max_dist) {
						max_dist = fabs(zpos[j] - x4);
						block_indexes[i_1].kR = j;
					}
				}

				if ((block_indexes[i_1].iL >= 0) && (block_indexes[i_1].iL <= inx) &&
					(block_indexes[i_1].iR >= 0) && (block_indexes[i_1].iR <= inx) &&
					(block_indexes[i_1].iL >= block_indexes[i_1].iR)) {
					printf("alice_mesh  function\n");
					printf("violation of the order block_indexes\n");
					//printf("i=%lld iL=%lld iR=%lld position x left=%e\n", i_1, block_indexes[i_1].iL,
						//block_indexes[i_1].iR, xpos[block_indexes[i_1].iL]);
					std::cout << "i=" << i_1 << " iL=" << block_indexes[i_1].iL << " iR=" <<
						block_indexes[i_1].iR << " position x left=" << xpos[block_indexes[i_1].iL] << std::endl;
					system("pause");
				}

				if ((block_indexes[i_1].iL >= 0) &&
					(block_indexes[i_1].iR >= 0) &&
					(block_indexes[i_1].iL + 1 == block_indexes[i_1].iR)) {
					// Всего одна клетка на блок.
					//iX_one_CELL_count_statistic++;
				}

				if ((block_indexes[i_1].jL >= 0) && (block_indexes[i_1].jL <= iny) &&
					(block_indexes[i_1].jR >= 0) && (block_indexes[i_1].jR <= iny) &&
					(block_indexes[i_1].jL >= block_indexes[i_1].jR)) {
					printf("alice_mesh  function\n");
					printf("violation of the order block_indexes\n");
					//printf("i=%lld jL=%lld jR=%lld position y left=%e\n", i_1, block_indexes[i_1].jL,
						//block_indexes[i_1].jR, ypos[block_indexes[i_1].jL] );
					std::cout << "i=" << i_1 << " jL=" << block_indexes[i_1].jL << " jR=" <<
						block_indexes[i_1].jR << "position y left=" << ypos[block_indexes[i_1].jL] << std::endl;
					system("pause");
				}


				if ((block_indexes[i_1].jL >= 0) &&
					(block_indexes[i_1].jR >= 0) &&
					(block_indexes[i_1].jL + 1 == block_indexes[i_1].jR)) {
					// Всего одна клетка на блок.
					//iY_one_CELL_count_statistic++;
				}

				if ((block_indexes[i_1].kL >= 0) && (block_indexes[i_1].kL <= inz) &&
					(block_indexes[i_1].kR >= 0) && (block_indexes[i_1].kR <= inz) &&
					(block_indexes[i_1].kL >= block_indexes[i_1].kR)) {
					printf("alice_mesh  function\n");
					printf("violation of the order block_indexes\n");
#if doubleintprecision == 1
					printf("i=%d kL=%lld kR=%lld\n", i_1, block_indexes[i_1].kL,
						block_indexes[i_1].kR);
#else
					printf("i=%d kL=%d kR=%d\n", i_1, block_indexes[i_1].kL,
						block_indexes[i_1].kR);
#endif
					system("pause");
				}


				if ((block_indexes[i_1].kL >= 0) &&
					(block_indexes[i_1].kR >= 0) &&
					(block_indexes[i_1].kL + 1 == block_indexes[i_1].kR)) {
					// Всего одна клетка на блок.
					//iZ_one_CELL_count_statistic++;
				}

				if ((block_indexes[i_1].iL < 0) || (block_indexes[i_1].iL > inx) ||
					(block_indexes[i_1].iR < 0) || (block_indexes[i_1].iR > inx) ||
					(block_indexes[i_1].jL < 0) || (block_indexes[i_1].jL > iny) ||
					(block_indexes[i_1].jR < 0) || (block_indexes[i_1].jR > iny) ||
					(block_indexes[i_1].kL < 0) || (block_indexes[i_1].kL > inz) ||
					(block_indexes[i_1].kR < 0) || (block_indexes[i_1].kR > inz)) {
					if (b[i].g.itypegeom == PRISM) {
						printf("print for PRISM object...\n");
						printf("alice_mesh function\n");
#if doubleintprecision == 1
						printf("i=%d iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", i,
							block_indexes[i_1].iL,
							block_indexes[i_1].iR, block_indexes[i_1].jL,
							block_indexes[i_1].jR, block_indexes[i_1].kL,
							block_indexes[i_1].kR);
#else
						printf("i=%d iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", i,
							block_indexes[i_1].iL,
							block_indexes[i_1].iR, block_indexes[i_1].jL,
							block_indexes[i_1].jR, block_indexes[i_1].kL,
							block_indexes[i_1].kR);
#endif
						std::cout << b[i].name << ": ";
						printf("xS=%e xE=%e yS=%e yE=%e zS=%e zE=%e\n", b[i].g.xS, b[i].g.xE,
							b[i].g.yS, b[i].g.yE, b[i].g.zS, b[i].g.zE);
						printf("cabinet: xS=%e xE=%e yS=%e yE=%e zS=%e zE=%e\n", b[0].g.xS, b[0].g.xE,
							b[0].g.yS, b[0].g.yE, b[0].g.zS, b[0].g.zE);
						printf("ERROR: may be your geometry out of cabinet...\n");
						system("pause");
					}
					if (b[i].g.itypegeom == CYLINDER) {
						printf("print for CYLINDER object...\n");
						printf("alice_mesh function\n");
#if doubleintprecision == 1
						printf("i=%d iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", i,
							block_indexes[i_1].iL, block_indexes[i_1].iR,
							block_indexes[i_1].jL, block_indexes[i_1].jR, 
							block_indexes[i_1].kL, block_indexes[i_1].kR);
#else
						printf("i=%d iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", i,
							block_indexes[i_1].iL, block_indexes[i_1].iR,
							block_indexes[i_1].jL, block_indexes[i_1].jR,
							block_indexes[i_1].kL, block_indexes[i_1].kR);
#endif
						std::cout << b[i].name << ": ";
						printf("xS=%e xE=%e yS=%e yE=%e zS=%e zE=%e\n", b[i].g.xS, b[i].g.xE,
							b[i].g.yS, b[i].g.yE, b[i].g.zS, b[i].g.zE);
						printf("iPlane=");
						switch (b[i].g.iPlane)
						{
						case XY_PLANE: printf("XY"); break;
						case XZ_PLANE: printf("XZ"); break;
						case YZ_PLANE: printf("YZ"); break;
						}
						printf(" xC=%e yC=%e zC=%e HCyl=%e Rout=%e Rin=%e\n", 
							b[i].g.xC, b[i].g.yC, b[i].g.zC, b[i].g.Hcyl, b[i].g.R_out_cyl, b[i].g.R_in_cyl);
						printf("cabinet: xS=%e xE=%e yS=%e yE=%e zS=%e zE=%e\n", b[0].g.xS, b[0].g.xE,
							b[0].g.yS, b[0].g.yE, b[0].g.zS, b[0].g.zE);
						printf("ERROR: may be your geometry out of cabinet...\n");
						printf("xpos:\n");
						for (j = 0; j <= inx; ++j) {
							printf("%e ", xpos[j]);
						}
						printf("\n");
						printf("ypos:\n");
						for (j = 0; j <= iny; ++j) {
							printf("%e ", ypos[j]);
						}
						printf("\n");
						printf("zpos:\n");
						for (j = 0; j <= inz; ++j) {
							printf("%e ",zpos[j]);
						}
						printf("\n");
						system("pause");
					}
					if (b[i].g.itypegeom == POLYGON) {
						printf("print for POLYGON object...\n");
						printf("alice_mesh function\n");
#if doubleintprecision == 1
						printf("i=%d iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", i,
							block_indexes[i_1].iL, block_indexes[i_1].iR,
							block_indexes[i_1].jL, block_indexes[i_1].jR,
							block_indexes[i_1].kL, block_indexes[i_1].kR);
#else
						printf("i=%d iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", i,
							block_indexes[i_1].iL, block_indexes[i_1].iR,
							block_indexes[i_1].jL, block_indexes[i_1].jR,
							block_indexes[i_1].kL, block_indexes[i_1].kR);
#endif
						std::cout << b[i].name << ": ";
						system("pause");
					}
					if (b[i].g.itypegeom == CAD_STL) {
						printf("print for CAD_STL object...\n");
						printf("alice_mesh function\n");
#if doubleintprecision == 1
						printf("i=%d iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", i,
							block_indexes[i_1].iL, block_indexes[i_1].iR,
							block_indexes[i_1].jL, block_indexes[i_1].jR,
							block_indexes[i_1].kL, block_indexes[i_1].kR);
#else
						printf("i=%d iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", i,
							block_indexes[i_1].iL, block_indexes[i_1].iR,
							block_indexes[i_1].jL, block_indexes[i_1].jR,
							block_indexes[i_1].kL, block_indexes[i_1].kR);
#endif
						std::cout << b[i].name << ": ";
						system("pause");
					}
				}

				i_1--;
			}

		}


	// Обязательная проверка !!!
	// Иногда предыдущий метод не срабатывает и это в случае
	// отсутствия исправления приводит к сбою.
	// Здесь приведена коррекция. Она медленней, но работает в 100% случаев.
	// 28.07.2019
		for (integer i_a = lb - 1; i_a >= 0; --i_a) {
			if ((block_indexes[i_a].iL <= -1) || (block_indexes[i_a].iR <= -1) ||
				(block_indexes[i_a].jL <= -1) || (block_indexes[i_a].jR <= -1) ||
				(block_indexes[i_a].kL <= -1) || (block_indexes[i_a].kR <= -1)) {
				// Проблема признана, теперь работаем с каждым проявлением индивидуально.
				if (block_indexes[i_a].iL == -1) {
					doublereal x4 = b[i_a].g.xS;
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XY_PLANE) || (b[i_a].g.iPlane == XZ_PLANE))) {
						x4 = b[i_a].g.xC - b[i_a].g.R_out_cyl;
					}
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == YZ_PLANE))) {
						if (b[i_a].g.Hcyl > 0.0) {
							x4 = b[i_a].g.xC;
						}
						else {
							x4 = b[i_a].g.xC + b[i_a].g.Hcyl;
						}
					}
					integer j_amin = -1;
					doublereal t_min = 1.0e30;
					for (integer j_a = 0; j_a <= inx; ++j_a) {
						// Абсолютная погрешность.
						if (fabs(xpos[j_a] - x4) < t_min) {
							t_min = fabs(xpos[j_a] - x4);
							j_amin = j_a;
						}
					}
					if (j_amin > -1) {
						block_indexes[i_a].iL = j_amin;
					}
				}
				if (block_indexes[i_a].iR == -1) {
					doublereal x4 = b[i_a].g.xE;
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XY_PLANE) || (b[i_a].g.iPlane == XZ_PLANE))) {
						x4 = b[i_a].g.xC + b[i_a].g.R_out_cyl;
					}
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == YZ_PLANE))) {
						if (b[i_a].g.Hcyl > 0.0) {
							x4 = b[i_a].g.xC + b[i_a].g.Hcyl;
						}
						else {
							x4 = b[i_a].g.xC;
						}
					}
					integer j_amin = -1;
					doublereal t_min = 1.0e30;
					for (integer j_a = 0; j_a <= inx; ++j_a) {
						// Абсолютная погрешность.
						if (fabs(xpos[j_a] - x4) < t_min) {
							t_min = fabs(xpos[j_a] - x4);
							j_amin = j_a;
						}
					}
					if (j_amin > -1) {
						block_indexes[i_a].iR = j_amin;
					}

				}
				if (block_indexes[i_a].jL == -1) {
					doublereal x4 = b[i_a].g.yS;
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XY_PLANE) || (b[i_a].g.iPlane == YZ_PLANE))) {
						x4 = b[i_a].g.yC - b[i_a].g.R_out_cyl;
					}
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XZ_PLANE))) {
						if (b[i_a].g.Hcyl > 0.0) {
							x4 = b[i_a].g.yC;
						}
						else {
							x4 = b[i_a].g.yC + b[i_a].g.Hcyl;
						}
					}
					integer j_amin = -1;
					doublereal t_min = 1.0e30;
					for (integer j_a = 0; j_a <= iny; ++j_a) {
						// Абсолютная погрешность.
						if (fabs(ypos[j_a] - x4) < t_min) {
							t_min = fabs(ypos[j_a] - x4);
							j_amin = j_a;
						}
					}
					if (j_amin > -1) {
						block_indexes[i_a].jL = j_amin;
					}
				}
				if (block_indexes[i_a].jR == -1) {
					doublereal x4 = b[i_a].g.yE;
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XY_PLANE) || (b[i_a].g.iPlane == YZ_PLANE))) {
						x4 = b[i_a].g.yC + b[i_a].g.R_out_cyl;
					}
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XZ_PLANE))) {
						if (b[i_a].g.Hcyl > 0.0) {
							x4 = b[i_a].g.yC + b[i_a].g.Hcyl;
						}
						else {
							x4 = b[i_a].g.yC;
						}
					}
					integer j_amin = -1;
					doublereal t_min = 1.0e30;
					for (integer j_a = 0; j_a <= iny; ++j_a) {
						// Абсолютная погрешность.
						if (fabs(ypos[j_a] - x4) < t_min) {
							t_min = fabs(ypos[j_a] - x4);
							j_amin = j_a;
						}
					}
					if (j_amin > -1) {
						block_indexes[i_a].jR = j_amin;
					}

				}
				if (block_indexes[i_a].kL == -1) {
					doublereal x4 = b[i_a].g.zS;
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == YZ_PLANE) || (b[i_a].g.iPlane == XZ_PLANE))) {
						x4 = b[i_a].g.zC - b[i_a].g.R_out_cyl;
					}
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XY_PLANE))) {
						if (b[i_a].g.Hcyl > 0.0) {
							x4 = b[i_a].g.zC;
						}
						else {
							x4 = b[i_a].g.zC + b[i_a].g.Hcyl;
						}
					}
					integer j_amin = -1;
					doublereal t_min = 1.0e30;
					for (integer j_a = 0; j_a <= inz; ++j_a) {
						// Абсолютная погрешность.
						if (fabs(zpos[j_a] - x4) < t_min) {
							t_min = fabs(zpos[j_a] - x4);
							j_amin = j_a;
						}
					}
					if (j_amin > -1) {
						block_indexes[i_a].kL = j_amin;
					}
				}
				if (block_indexes[i_a].kR == -1) {
					doublereal x4 = b[i_a].g.zE;
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == YZ_PLANE) || (b[i_a].g.iPlane == XZ_PLANE))) {
						x4 = b[i_a].g.zC + b[i_a].g.R_out_cyl;
					}
					if ((b[i_a].g.itypegeom == CYLINDER) && ((b[i_a].g.iPlane == XY_PLANE))) {
						if (b[i_a].g.Hcyl > 0.0) {
							x4 = b[i_a].g.zC + b[i_a].g.Hcyl;
						}
						else {
							x4 = b[i_a].g.zC;
						}
					}
					integer j_amin = -1;
					doublereal t_min = 1.0e30;
					for (integer j_a = 0; j_a <= inz; ++j_a) {
						// Абсолютная погрешность.
						if (fabs(zpos[j_a] - x4) < t_min) {
							t_min = fabs(zpos[j_a] - x4);
							j_amin = j_a;
						}
					}
					if (j_amin > -1) {
						block_indexes[i_a].kR = j_amin;
					}

				}
			}
		}

		//if (lb > 32760) {
			//printf("Error int type :  number of blocks lb > 32760\n");
			//system("PAUSE");
			//exit(1);
		//}

		// Количество проходов существенно сократилось и в итоге это приводит к существенному
		// увеличению быстродействия.
		int m7 = lb-1, m8;

//#pragma omp parallel for
		for (integer iP = 0; iP<(inx+1)*(iny+1)*(inz+1); ++iP) {
			bvisit[iP] = false;
		}		

		int i_my_num_core_parallelesation = 1;
#ifdef _OPENMP 
		i_my_num_core_parallelesation = omp_get_max_threads();
		int inum_cores = number_cores();
		omp_set_num_threads(inum_cores); // установка числа потоков
#endif
		

		for (m8 = lb-1; m8 >= 0; --m8) {
			m7 = m8;
			if (b[m8].g.itypegeom == PRISM) {

#pragma omp parallel for
				for (integer i1 = block_indexes[m7].iL; i1 < block_indexes[m7].iR; ++i1) 
					for (integer j1 = block_indexes[m7].jL; j1 < block_indexes[m7].jR; ++j1)
						for (integer k1 = block_indexes[m7].kL; k1 < block_indexes[m7].kR; ++k1) {
					integer iP = i1 + j1 * inx + k1 * inx*iny;

					if ((i1 < 0) || (i1 >= inx) || (j1 < 0) || (j1 >= iny) || (k1 < 0) || (k1 >= inz)) {
						// ERROR
						printf("ERROR PRISM\n");
						std::cout << b[m8].name << ": ";
						printf("inx=%d iny=%d inz=%d \n",inx,iny,inz);
						printf("i1=%lld j1=%lld k1=%lld \n",i1,j1,k1);
						printf("iP=%lld m8=%d",iP,m8);
						printf("iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);
						system("PAUSE");
					}

					if (bvisit[iP] == false)
					{

						bvisit[iP] = true;

						hash_for_droblenie_xyz[i1][j1][k1] = m8;
					}
				}
				//m7--;
			}
			else if (b[m8].g.itypegeom == CYLINDER) {

				// TODO как был сформирован призматический объект для цилиндра ? 
				// Надо также сократить число проверяемых точек.
				// Cylinder
				//for (integer i1 = 0; i1 < inx; i1++) for (integer j1 = 0; j1 < iny; j1++) for (integer k1 = 0; k1 < inz; k1++) {

				for (integer i1 = block_indexes[m7].iL; i1 < block_indexes[m7].iR; ++i1)
					for (integer j1 = block_indexes[m7].jL; j1 < block_indexes[m7].jR; ++j1)
						for (integer k1 = block_indexes[m7].kL; k1 < block_indexes[m7].kR; ++k1) {

					integer iP = i1 + j1 * inx + k1 * inx*iny;

					if ((i1 < 0) || (i1 >= inx) || (j1 < 0) || (j1 >= iny) || (k1 < 0) || (k1 >= inz)) {
						// ERROR
						printf("ERROR CYLINDER\n");
						std::cout << b[m8].name << ": ";
						printf("iplane=%lld",b[m8].g.iPlane);
						printf("xC=%e yC=%e zC=%e Hcyl=%e\n", b[m8].g.xC, b[m8].g.yC, b[m8].g.zC, b[m8].g.Hcyl);
						printf("Rin=%e Rout=%e\n", b[m8].g.R_in_cyl, b[m8].g.R_out_cyl);
						printf("inx=%d iny=%d inz=%d \n", inx, iny, inz);
						printf("i1=%lld j1=%lld k1=%lld \n", i1, j1, k1);
						printf("iP=%lld m8=%d", iP, m8);
						printf("iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);
						system("PAUSE");
					}

					if (bvisit[iP] == false)
					{

						TOCHKA p;
						p.x = 0.5*(xpos[i1] + xpos[i1 + 1]);
						p.y = 0.5*(ypos[j1] + ypos[j1 + 1]);
						p.z = 0.5*(zpos[k1] + zpos[k1 + 1]);

						switch (b[m8].g.iPlane) {
						case XY_PLANE:
							if (fabs(b[m8].g.R_in_cyl) < 1.0e-36) {
								if ((p.z > b[m8].g.zC) && (p.z < b[m8].g.zC + b[m8].g.Hcyl)) {
									if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.yC - p.y)*(b[m8].g.yC - p.y)) < b[m8].g.R_out_cyl) {

										bvisit[iP] = true;

										hash_for_droblenie_xyz[i1][j1][k1] = m8;

									}
								}
							}
							else {
								if ((p.z > b[m8].g.zC) && (p.z < b[m8].g.zC + b[m8].g.Hcyl)) {
									if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.yC - p.y)*(b[m8].g.yC - p.y)) < b[m8].g.R_out_cyl) {
										if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.yC - p.y)*(b[m8].g.yC - p.y)) > b[m8].g.R_in_cyl) {

											bvisit[iP] = true;

											hash_for_droblenie_xyz[i1][j1][k1] = m8;

											
										}
									}
								}
							}
							break;
						case XZ_PLANE:
							if (fabs(b[m8].g.R_in_cyl) < 1.0e-36) {
								if ((p.y > b[m8].g.yC) && (p.y < b[m8].g.yC + b[m8].g.Hcyl)) {
									if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {

										bvisit[iP] = true;

										hash_for_droblenie_xyz[i1][j1][k1] = m8;
									}
								}
							}
							else {
								if ((p.y > b[m8].g.yC) && (p.y < b[m8].g.yC + b[m8].g.Hcyl)) {
									if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {
										if (sqrt((b[m8].g.xC - p.x)*(b[m8].g.xC - p.x) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) > b[m8].g.R_in_cyl) {

											bvisit[iP] = true;

											hash_for_droblenie_xyz[i1][j1][k1] = m8;
										}
									}
								}
							}
							break;
						case YZ_PLANE:
							if (fabs(b[m8].g.R_in_cyl) < 1.0e-36) {
								if ((p.x > b[m8].g.xC) && (p.x < b[m8].g.xC + b[m8].g.Hcyl)) {
									if (sqrt((b[m8].g.yC - p.y)*(b[m8].g.yC - p.y) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {

										bvisit[iP] = true;

										hash_for_droblenie_xyz[i1][j1][k1] = m8;
									}
								}
							}
							else {
								if ((p.x > b[m8].g.xC) && (p.x < b[m8].g.xC + b[m8].g.Hcyl)) {
									if (sqrt((b[m8].g.yC - p.y)*(b[m8].g.yC - p.y) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) < b[m8].g.R_out_cyl) {
										if (sqrt((b[m8].g.yC - p.y)*(b[m8].g.yC - p.y) + (b[m8].g.zC - p.z)*(b[m8].g.zC - p.z)) > b[m8].g.R_in_cyl) {

											bvisit[iP] = true;

											hash_for_droblenie_xyz[i1][j1][k1] = m8;
										}
									}
								}
							}
							break;
						}
					}
				}
				//m7--;
			}
			else if (b[m8].g.itypegeom == POLYGON) {

				// polygon
				// Мы сокращаем число проверяемых точек 
				// рассматривая только точки внутри окаймляющей прямоугольной призмы.

#pragma omp parallel for
				for (integer i1 = block_indexes[m7].iL; i1 < block_indexes[m7].iR; ++i1)
					for (integer j1 = block_indexes[m7].jL; j1 < block_indexes[m7].jR; ++j1)
						for (integer k1 = block_indexes[m7].kL; k1 < block_indexes[m7].kR; ++k1) {

					integer iP = i1 + j1 * inx + k1 * inx*iny;

					if ((i1 < 0) || (i1 >= inx) || (j1 < 0) || (j1 >= iny) || (k1 < 0) || (k1 >= inz)) {
						// ERROR
						printf("ERROR POLYGON\n");
						if ((m8 >= 0) && (m8 < lb)) {
							std::cout << b[m8].name << ": ";
						}
						printf("inx=%d iny=%d inz=%d \n", inx, iny, inz);
						printf("i1=%lld j1=%lld k1=%lld \n", i1, j1, k1);
						printf("iP=%lld m8=%d", iP, m8);
						printf("iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);
						system("PAUSE");
					}

					if (bvisit[iP] == false)
					{

						//for (integer i1 = 0; i1 < inx; i1++) for (integer j1 = 0; j1 < iny; j1++) for (integer k1 = 0; k1 < inz; k1++) {
						TOCHKA p;
						p.x = 0.5*(xpos[i1] + xpos[i1 + 1]);
						p.y = 0.5*(ypos[j1] + ypos[j1 + 1]);
						p.z = 0.5*(zpos[k1] + zpos[k1 + 1]);

						int k74 = -1;
						if (in_polygon(p, b[m8].g.nsizei, b[m8].g.xi, b[m8].g.yi, b[m8].g.zi, b[m8].g.hi, b[m8].g.iPlane_obj2, k74, m8)) {
							//printf("i1=%d j1=%d k1=%d inx*iny*inz=%d\n",i1,j1,k1, inx*iny*inz);
							//printf("iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);

							bvisit[iP] = true;
							if ((m8 >= 0) && (m8 < lb)) {
								hash_for_droblenie_xyz[i1][j1][k1] = m8;
							}
							else {
								printf("ERROR in_polygon() function m8 corrupt\n");
								system("pause");
							}
						}
					}

				}
				
			}
			else if (b[m8].g.itypegeom == CAD_STL) {

			// CAD_STL
			// Мы сокращаем число проверяемых точек 
			// рассматривая только точки внутри окаймляющей прямоугольной призмы.

			integer icompleate = 0;

#pragma omp parallel for reduction(+: icompleate)
			for (integer i1 = block_indexes[m7].iL; i1 < block_indexes[m7].iR; ++i1) {
				for (integer j1 = block_indexes[m7].jL; j1 < block_indexes[m7].jR; ++j1)
					for (integer k1 = block_indexes[m7].kL; k1 < block_indexes[m7].kR; ++k1) {

						integer iP = i1 + j1 * inx + k1 * inx * iny;

						icompleate++;

						if (icompleate % 5000 == 0) {
							printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
							printf("%e%%", 1.0 * (icompleate) / (1.0 * ((inx*iny*inz))));
						}

						if ((i1 < 0) || (i1 >= inx) || (j1 < 0) || (j1 >= iny) || (k1 < 0) || (k1 >= inz)) {
							// ERROR
							printf("ERROR CAD_STL\n");
							if ((m8 >= 0) && (m8 < lb)) {
								std::cout << b[m8].name << ": ";
							}
							printf("inx=%d iny=%d inz=%d \n", inx, iny, inz);
							printf("i1=%lld j1=%lld k1=%lld \n", i1, j1, k1);
							printf("iP=%lld m8=%d", iP, m8);
							printf("iL=%lld iR=%lld jL=%lld jR=%lld kL=%lld kR=%lld\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);
							system("PAUSE");
						}

						if (bvisit[iP] == false)
						{

							//for (integer i1 = 0; i1 < inx; i1++) for (integer j1 = 0; j1 < iny; j1++) for (integer k1 = 0; k1 < inz; k1++) {
							TOCHKA p;
							p.x = 0.5 * (xpos[i1] + xpos[i1 + 1]);
							p.y = 0.5 * (ypos[j1] + ypos[j1 + 1]);
							p.z = 0.5 * (zpos[k1] + zpos[k1 + 1]);

							int k74 = -1;

							if (b[m8].g.in_CAD_STL_check(p, k74, m8))
							{
								//printf("i1=%d j1=%d k1=%d inx*iny*inz=%d\n",i1,j1,k1, inx*iny*inz);
								//printf("iL=%d iR=%d jL=%d jR=%d kL=%d kR=%d\n", block_indexes[m7].iL, block_indexes[m7].iR, block_indexes[m7].jL, block_indexes[m7].jR, block_indexes[m7].kL, block_indexes[m7].kR);

								bvisit[iP] = true;
								if ((m8 >= 0) && (m8 < lb)) {
									hash_for_droblenie_xyz[i1][j1][k1] = m8;
								}
								else {
									printf("ERROR in_CAD_STL_check() function m8 corrupt\n");
									system("pause");
								}
							}
						}
					}

				}

			}
			//m7--;
		}


#ifdef _OPENMP 
		omp_set_num_threads(i_my_num_core_parallelesation);
#endif

		

		if (bvisit != nullptr) {
			delete[] bvisit;
			bvisit = nullptr;
		}

		
		bool bfirst_message = true;
		integer iproblem_nodes = 0;

		for (int i_54 = 0; i_54 < inx; ++i_54) {
			for (int i_55 = 0; i_55 < iny; ++i_55) {
				for (int i_56 = 0; i_56 < inz; ++i_56) {
					if ((hash_for_droblenie_xyz[i_54][i_55][i_56] <= -1)||
						(hash_for_droblenie_xyz[i_54][i_55][i_56]>=lb)) {

						// При правильной работе сюда попадать не должно. 06,08,2021
						printf("Attantion ALICE Error 06.08.2021 function alice_mesh(). module adaptive_local_redfinement_mesh.cpp\n");
						std::cout << "incomming" << "i=" << i_54 << " j=" << i_55 << "k=" << i_56 << " inx=" << inx << " iny=" << iny << " inz=" << inz << std::endl;
						system("pause");
						for (integer i_57 = 0; i_57 < lb; ++i_57) {
							std::cout << b[i_57].name << std::endl;
							std::cout << block_indexes[i_57].iL<< "  ";
							std::cout << block_indexes[i_57].iR << "  ";
							std::cout << block_indexes[i_57].jL << "  ";
							std::cout << block_indexes[i_57].jR << "  ";
							std::cout << block_indexes[i_57].kL << "  ";
							std::cout << block_indexes[i_57].kR << "  ";
							system("pause");
						}

						if (bfirst_message) {
							
							std::cout << "Attantion!!! Increase the number of grid nodes\n";
							//system("PAUSE");
							bfirst_message = false;
						}

						iproblem_nodes++;

						// Мы что-то пропустили и из-за этого возможен сбой в дальнейшем.
						// исправляем так чтобы сбоя не было 28.07.2019
						TOCHKA p;
						p.x = 0.5 * (xpos[i_54] + xpos[i_54 + 1]);
						p.y = 0.5 * (ypos[i_55] + ypos[i_55 + 1]);
						p.z = 0.5 * (zpos[i_56] + zpos[i_56 + 1]);
						// Лобовой надежный метод, правда очень медленный.
						// Чтобы работало быстро таких аномальных точек должен быть 
						// небольшой процент от общего числа.
						int ib= myisblock_id_stab(lb, b, p);
						if ((ib >= 0) && (ib < lb)) {
							hash_for_droblenie_xyz[i_54][i_55][i_56] = ib;
						}
						else {
							printf("FATAL ERROR !!! function myisblock_id_stab(lb, b, p) bad return\n");
							system("pause");
						}
					}
				}
			}
		}

		delete[] block_indexes;

		if (iproblem_nodes > 0) {
			printf("anomal hash_for_droblenie_xyz cell count=%lld\n", iproblem_nodes);
		}

		printf("enumerate_volume_improved end.\n");

	}
	else {
		// Медленная версия, очевидное простое и медленное решение.
		// Зато оно стабильно надёжно работает. 06,08,2021
		for (int i_54 = 0; i_54 < inx; ++i_54) {
			for (int i_55 = 0; i_55 < iny; ++i_55) {
				for (int i_56 = 0; i_56 < inz; ++i_56) {
					TOCHKA p;
					p.x = 0.5*(xpos[i_54] + xpos[i_54 + 1]);
					p.y = 0.5*(ypos[i_55] + ypos[i_55 + 1]);
					p.z = 0.5*(zpos[i_56] + zpos[i_56 + 1]);
					int ib = -1;
					in_model_temp(p, ib, b, lb);
					if ((ib <= -1)||(ib>=lb)) {
						printf("object not found in function alice_mesh() in module adaptive_local_refinement_mesh.cpp. Code -1.\n");
						system("pause");
					}
					hash_for_droblenie_xyz[i_54][i_55][i_56] = ib;
				}
			}
		}
	}


	
	

	oc_global = new octree;
	// Ссылки на каждый узел octree дерева для его полной очистки.

	// Ссылки на каждый узел octree дерева для его полной очистки.
	// Мы хотим сэкономить оперативную память.
	rootClear_octree = new octree_list;
	rootClear_octree->next=nullptr;
	head_rootClear_octree = rootClear_octree;
	rootClear_octree->pnode = oc_global;
	

	oc_global->inum_TD = 0; // Не принадлежит расчётной области.
	oc_global->inum_FD = 0;// Не принадлежит расчётной области.
	// Оператор new не требует проверки.
	//if (oc_global == nullptr) {
		// недостаточно памяти на данном оборудовании.
		//printf("Problem: not enough memory on your equipment for oc in adaptive_local_refinement_mesh generator...\n");
		//printf("Please any key to exit...\n");
		//exit(1);
	//}
	oc_global->parent = nullptr;
	oc_global->ilevel = 0; // истинный root
	oc_global->root = -1000; // истинный root
	oc_global->b_the_geometric_fragmentation = false;
	oc_global->bcrushing_when_balancing = false;
	oc_global->brootSituationX = false;
	oc_global->brootSituationY = false;
	oc_global->brootSituationZ = false;
	oc_global->brootSituationX_virtual = false;
	oc_global->brootSituationY_virtual = false;
	oc_global->brootSituationZ_virtual = false;
	// вообще нет соседей.
	oc_global->maxWneighbour = 0;
	oc_global->maxEneighbour = 0;
	oc_global->maxSneighbour = 0;
	oc_global->maxNneighbour = 0;
	oc_global->maxBneighbour = 0;
	oc_global->maxTneighbour = 0;
	// пока соседей просто нету.
	oc_global->linkW = nullptr;
	oc_global->linkE = nullptr;
	oc_global->linkS = nullptr;
	oc_global->linkN = nullptr;
	oc_global->linkB = nullptr;
	oc_global->linkT = nullptr;
	oc_global->b4W = false;
	oc_global->b4E = false;
	oc_global->b4S = false;
	oc_global->b4N = false;
	oc_global->b4B = false;
	oc_global->b4T = false;
	oc_global->linkW0 = nullptr;
	oc_global->linkW3 = nullptr;
	oc_global->linkW4 = nullptr;
	oc_global->linkW7 = nullptr;
	oc_global->linkE1 = nullptr;
	oc_global->linkE2 = nullptr;
	oc_global->linkE5 = nullptr;
	oc_global->linkE6 = nullptr;
	oc_global->linkS0 = nullptr;
	oc_global->linkS1 = nullptr;
	oc_global->linkS4 = nullptr;
	oc_global->linkS5 = nullptr;
	oc_global->linkN2 = nullptr;
	oc_global->linkN3 = nullptr;
	oc_global->linkN6 = nullptr;
	oc_global->linkN7 = nullptr;
	oc_global->linkB0 = nullptr;
	oc_global->linkB1 = nullptr;
	oc_global->linkB2 = nullptr;
	oc_global->linkB3 = nullptr;
	oc_global->linkT4 = nullptr;
	oc_global->linkT5 = nullptr;
	oc_global->linkT6 = nullptr;
	oc_global->linkT7 = nullptr;
	// лист ли это.
	oc_global->dlist = true;
	oc_global->link0 = nullptr;
	oc_global->link1 = nullptr;
	oc_global->link2 = nullptr;
	oc_global->link3 = nullptr;
	oc_global->link4 = nullptr;
	oc_global->link5 = nullptr;
	oc_global->link6 = nullptr;
	oc_global->link7 = nullptr;
	my_ALICE_STACK = nullptr;
	// 0.04 импирически подобранный коэффициент запаса. 31.10.2020
	// Он подобран на серии tgf задач.
	//my_ALICE_STACK = new STACK_ALICE[static_cast<integer>(0.04*maxelm)];
	integer isize_ALICE_STACK=ALICE_maxelm_size_prediction(inx, iny, inz, b, lb, lw, w, s, ls);
	my_ALICE_STACK = new STACK_ALICE[isize_ALICE_STACK];
	// Оператор new не требует проверки.
	//if (my_ALICE_STACK == nullptr) {
		// недостаточно памяти на данном оборудовании.
		//printf("Problem: not enough memory on your equipment for my_ALICE_STACK in adaptive_local_refinement_mesh generator...\n");
		//printf("Please any key to exit...\n");
		//exit(1);
	//}
	top_ALICE_STACK = 0;
	// универсальное построение квадродерева.
	int minx = 0;
	int maxx = inx;
	int miny = 0;
	int maxy = iny;
	int minz = 0;
	int maxz = inz;
	oc_global->maxx = maxx;
	oc_global->minx = minx;
	oc_global->maxy = maxy;
	oc_global->miny = miny;
	oc_global->maxz = maxz;
	oc_global->minz = minz;
	// 1. Дробление по геометрическому признаку.
	droblenie(xpos, ypos, zpos,
		inx, iny, inz, oc_global,
		minx, maxx, miny, maxy, minz, maxz, b, lb, lw, w, s, ls, epsToolx, epsTooly, epsToolz, bsimpledefine);

	for (integer i_34 = top_ALICE_STACK - 1; i_34 >= 0; --i_34) {
		my_ALICE_STACK[i_34].link = nullptr;
	}
	top_ALICE_STACK = 0;
	// 2. (первый проход) обновление подсчёта количества соседей.
	update_max_count_neighbour(oc_global);
	top_ALICE_STACK = 0;
	// 3. Один проход дробления для балансировки (ликвидация большого числа соседей).
	// 4. (завершающий проход) обновление подсчёта количества соседей.
	// 5. Восстановление линковки.
	update_link_neighbor(oc_global);
	// 6. Гасим информацию о посещениях.
	shutdown_visit(oc_global);
	//log_message(oc_global);
	// подготовка стека не разрушает дерево.
	for (integer i_34 = top_ALICE_STACK - 1; i_34 >= 0; --i_34) {
		my_ALICE_STACK[i_34].link = nullptr;
	}
	top_ALICE_STACK = 0;
	if (!B_QUICK_MESHING) {
		printf("export paraview 5.5 geometry fragmentation.\n");
		expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
	}
	printf("export ready\n");
	if (DEBUG_ALICE_MESH) {
		//system("PAUSE");
		system("PAUSE");
	}

	printf("The begining construct...\n");
	if (DEBUG_ALICE_MESH) {
		//system("PAUSE");
		system("PAUSE");
	}
	doublereal progress_bar = 0.0;
	integer iret34 = 0;
	bool bcont34 = true;
	integer iprohod = 0;
	integer iret_one_scan = 0;
	bool biOk28_global_restart = false;
	while (bcont34) {

		
		printf("update max count neighbour is start...\n");
		update_max_count_neighbour(oc_global);
		printf("update max count neighbour is finished.\n");

		

		bcont34 = false;
		iret_one_scan = 0;
		if (top_ALICE_STACK > maxelm - 3) {
			printf("perepolnenie steka\n");
			//system("PAUSE");
			system("PAUSE");
			exit(1);
		}
		iprohod++;
		
		printf("\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b");
		integer nodes36 = (inx + 1) * (iny + 1) * (inz + 1);
#if doubleintprecision == 1		
		printf("progress bar %2.3f procent. nodes=%lld iprohod=%lld\n", (100.0*progress_bar) / (inx*iny*inz), nodes36, iprohod);
#else
		printf("progress bar %2.3f procent. nodes=%lld iprohod=%d\n", (100.0*progress_bar) / (inx*iny*inz), nodes36, iprohod);
#endif
		// 1. Дробление листьев по геометрическому признаку.
		printf("fragmentation list po geometricheskomu prisnaku. begin.\n");
		droblenie_list_octree2(oc_global, xpos, ypos, zpos, iret34, inx, iny, inz, b, lb, lw, w, s, ls, epsToolx,epsTooly,epsToolz, bsimpledefine);
		printf("fragmentation list po geometricheskomu prisnaku. end.\n");
		//system("PAUSE");
		iret_one_scan += iret34;
		
		if (DEBUG_ALICE_MESH) printf("function: shutdown_visit\n");
		shutdown_visit(oc_global);
		top_ALICE_STACK = 0;
		// 5. Восстановление линковки.
		if (DEBUG_ALICE_MESH) printf("linkovka geom.\n");
		//system("PAUSE");
		update_link_neighbor(oc_global);
		top_ALICE_STACK = 0;

		if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
		shutdown_disbalance(oc_global);
		if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
		marker_disbalnce(oc_global, xpos, ypos, zpos);
		integer iret_95 = 0;
		if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
		droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
		
		iret_one_scan += iret_95;
		//if_disbalnce_marker(oc_global);
		if (DEBUG_ALICE_MESH)  printf("function: shutdown_disbalance\n");
		shutdown_disbalance(oc_global);
		top_ALICE_STACK = 0;
#if doubleintprecision == 1
		printf("WARNING scan number=%lld\n", iprohod);
#else
		printf("WARNING scan number=%d\n", iprohod);
#endif
		
		//system("PAUSE");
		top_ALICE_STACK = 0;
		if (!B_QUICK_MESHING) {
			printf("export paraview 5.5 geometry fragmentation.\n");
			expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
		}
		printf("post geometry fragmentation neighbour count is construct.\n");
		if (DEBUG_ALICE_MESH) {
			//system("PAUSE");
			system("PAUSE");
		}
		// 2. (первый проход) обновление подсчёта количества соседей.
		//printf("whether there is a b4N front neighbour count?\n");
		//system("PAUSE");
		//is_b4N_found(oc_global); // находит , но почемуто печатает ситуацию dir Х далее.
		//integer iret_97 = 1;
		//integer iscan_balance = 0;
		if (DEBUG_ALICE_MESH) printf("function: shutdown_visit\n");
		shutdown_visit(oc_global);
		/*
		while (iret_97 > 0) {
			iret_97 = 0;
			//printf("whether there is a b4N front neighbour count is finished.\n");
			top_ALICE_STACK = 0;
			printf("update max count start\n");
			update_max_count_neighbour(oc_global);
			top_ALICE_STACK = 0;
			//printf("export tecplot geometry droblenie.");
			//expt(oc_global, inx, iny, inz, maxelm, xpos,ypos,zpos);
			//printf("post geometry droblenie neighbour count is construct.\n");
			//system("PAUSE");
			//printf("geomtric crushing is succsefull\n");
			//system("PAUSE");
			top_ALICE_STACK = 0;
			//printf("b4N start\n");
			//is_b4N_found(oc_global); // находит , но почемуто печатает ситуацию dir Х далее.
			//top_ALICE_STACK = 0;
			// 3. Один проход дробления для блансировки (ликвидация большого числа соседей).
			// Возможно это надо корректировать сразу на лету в момент генерации дробления.
			printf("balance Tree 2 start\n");
			balance_octree2(oc_global, xpos, ypos, zpos, iret_97, epsTol);
			iret34 += iret_97;
			printf("expt start\n");
			expt(oc_global, inx, iny, inz, maxelm, xpos,ypos,zpos);
			#if doubleintprecision == 1
				printf("iscan_balance=%lld", iscan_balance);
				iscan_balance++;
				printf("export tecplot post balance tree. balance number is=%lld ",iscan_balance-1);
			#else
				printf("iscan_balance=%d", iscan_balance);
				iscan_balance++;
				printf("export tecplot post balance tree. balance number is=%d ",iscan_balance-1);
			#endif
			
			system("PAUSE");
		}
		printf("completed balansing. balance crushing is succsefull\n");
		//system("PAUSE");
		iret_one_scan += iret34;
		top_ALICE_STACK = 0;
		// 4. (завершающий проход) обновление подсчёта количества соседей.
		update_max_count_neighbour(oc);
		top_ALICE_STACK = 0;
		integer iret35 = 0;
		// А может он должен работать вообще на копии дерева oc!!!.
		// Это только проверочный код который должен возвращать iret 35=0.
		//balance_octree2(oc_global, xpos, ypos, zpos, iret35, epsTol);
		if (iret35 != 0) {
			printf("error !: problem max count neighbour still very large. second scan.\n");
			system("PAUSE");
			exit(1);
		}
		*/
		if (DEBUG_ALICE_MESH) printf("function: shutdown_visit\n");
		shutdown_visit(oc_global);
		top_ALICE_STACK = 0;
		if (DEBUG_ALICE_MESH) printf("function: update_max_count_neighbour\n");
		update_max_count_neighbour(oc_global);
		top_ALICE_STACK = 0;
		// 5. Восстановление линковки.
		if (DEBUG_ALICE_MESH) printf("fragmentation linking.\n");
		if (DEBUG_ALICE_MESH) {
			//system("PAUSE");
			system("PAUSE");
		}
		if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
		update_link_neighbor(oc_global);
		top_ALICE_STACK = 0;
		// 5.5 Если с дроблением были проблемы (повторно).
		if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
		shutdown_disbalance(oc_global);
		if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
		marker_disbalnce(oc_global, xpos, ypos, zpos);
		iret_95 = 0;
		if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
		droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
		iret_one_scan += iret_95;
		//if_disbalnce_marker(oc_global);
		if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
		shutdown_disbalance(oc_global);
		integer iret_95_memo = iret_95;
		if (iret_95 > 0) {
			
			top_ALICE_STACK = 0;
			// 5. Восстановление линковки.
			printf("fragmentation 2 linking.  attempt number=%lld\n", iOk28_number_popjtka);
			//system("PAUSE");
			if (DEBUG_ALICE_MESH) {
				//system("PAUSE");
				system("PAUSE");
			}
			if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
			update_link_neighbor(oc_global);
			top_ALICE_STACK = 0;
			// 5.5 Если с дроблением были проблемы (повторно).
			if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
			shutdown_disbalance(oc_global);
			if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
			marker_disbalnce(oc_global, xpos, ypos, zpos);
			iret_95 = 0;
			if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
			droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
			iret_one_scan += iret_95;
			//if_disbalnce_marker(oc_global);
			if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
			shutdown_disbalance(oc_global);
			integer iret_95_memo1 = iret_95;
			if (iret_95 > 0) {
				
				top_ALICE_STACK = 0;
				// 5. Восстановление линковки.
				printf("fragmentation 3 linking.  attempt number=%lld\n", iOk28_number_popjtka);
				//system("PAUSE");
				if (DEBUG_ALICE_MESH) {
					//system("PAUSE");
					system("PAUSE");
				}
				if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
				update_link_neighbor(oc_global);
				top_ALICE_STACK = 0;
				// 5.5 Если с дроблением были проблемы (повторно).
				if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
				shutdown_disbalance(oc_global);
				if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
				marker_disbalnce(oc_global, xpos, ypos, zpos);
				iret_95 = 0;
				if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
				droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
				iret_one_scan += iret_95;
				//if_disbalnce_marker(oc_global);
				if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
				shutdown_disbalance(oc_global);
				integer iret_95_memo2 = iret_95;
				if (iret_95 > 0) {
					
					top_ALICE_STACK = 0;
					// 5. Восстановление линковки.
					printf("fragmentation 4 linking.  attempt number=%lld\n", iOk28_number_popjtka);
					//system("PAUSE");
					if (DEBUG_ALICE_MESH) {
						//system("PAUSE");
						system("PAUSE");
					}
					if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
					update_link_neighbor(oc_global);
					top_ALICE_STACK = 0;
					// 5.5 Если с дроблением были проблемы (повторно).
					if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
					shutdown_disbalance(oc_global);
					if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
					marker_disbalnce(oc_global, xpos, ypos, zpos);
					iret_95 = 0;
					if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
					droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
					iret_one_scan += iret_95;
					//if_disbalnce_marker(oc_global);
					if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
					shutdown_disbalance(oc_global);
					integer iret_95_memo3 = iret_95;
					if (iret_95 > 0) {
						
						top_ALICE_STACK = 0;
						// 5. Восстановление линковки.
						printf("fragmentation 5 linking.  attempt number=%lld\n", iOk28_number_popjtka);
						//system("PAUSE");
						if (DEBUG_ALICE_MESH) {
							//system("PAUSE");
							system("PAUSE");
						}
						if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
						update_link_neighbor(oc_global);
						top_ALICE_STACK = 0;
						// 5.5 Если с дроблением были проблемы (повторно).
						if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
						shutdown_disbalance(oc_global);
						if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
						marker_disbalnce(oc_global, xpos, ypos, zpos);
						iret_95 = 0;
						if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
						droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
						iret_one_scan += iret_95;
						//if_disbalnce_marker(oc_global);
						if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
						shutdown_disbalance(oc_global);

						integer iret_95_memo4 = iret_95;
						if (iret_95 > 0) {

							top_ALICE_STACK = 0;
							// 5. Восстановление линковки.
							printf("fragmentation 6 linking.  attempt number=%lld\n", iOk28_number_popjtka);
							//system("PAUSE");
							if (DEBUG_ALICE_MESH) {
								//system("PAUSE");
								system("PAUSE");
							}
							if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
							update_link_neighbor(oc_global);
							top_ALICE_STACK = 0;
							// 5.5 Если с дроблением были проблемы (повторно).
							if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
							shutdown_disbalance(oc_global);
							if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
							marker_disbalnce(oc_global, xpos, ypos, zpos);
							iret_95 = 0;
							if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
							droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
							iret_one_scan += iret_95;
							//if_disbalnce_marker(oc_global);
							if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
							shutdown_disbalance(oc_global);

							integer iret_95_memo5 = iret_95;
							if (iret_95 > 0) {

								top_ALICE_STACK = 0;
								// 5. Восстановление линковки.
								printf("fragmentation 7 linking.  attempt number=%lld\n", iOk28_number_popjtka);
								//system("PAUSE");
								if (DEBUG_ALICE_MESH) {
									//system("PAUSE");
									system("PAUSE");
								}
								if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
								update_link_neighbor(oc_global);
								top_ALICE_STACK = 0;
								// 5.5 Если с дроблением были проблемы (повторно).
								if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
								shutdown_disbalance(oc_global);
								if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
								marker_disbalnce(oc_global, xpos, ypos, zpos);
								iret_95 = 0;
								if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
								droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
								iret_one_scan += iret_95;
								//if_disbalnce_marker(oc_global);
								if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
								shutdown_disbalance(oc_global);

								integer id_sc = 1;
								while ((iret_95 > 0)&&(id_sc<1000)) {
									top_ALICE_STACK = 0;
									// 5. Восстановление линковки.
#if doubleintprecision == 1
									printf("fragmentation %lld linking.  attempt number=%lld\n", 7 + id_sc, iOk28_number_popjtka);
#else
									printf("fragmentation %d linking.  attempt number=%d\n", 7 + id_sc, iOk28_number_popjtka);
#endif
									
									//system("PAUSE");
									if (DEBUG_ALICE_MESH) {
										//system("PAUSE");
										system("PAUSE");
									}
									if (DEBUG_ALICE_MESH) printf("function: update_link_neighbor\n");
									update_link_neighbor(oc_global);
									top_ALICE_STACK = 0;
									// 5.5 Если с дроблением были проблемы (повторно).
									if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
									shutdown_disbalance(oc_global);
									if (DEBUG_ALICE_MESH) printf("function: marker_disbalnce\n");
									marker_disbalnce(oc_global, xpos, ypos, zpos);
									iret_95 = 0;
									if (DEBUG_ALICE_MESH) printf("function: droblenie_disbalance\n");
									droblenie_disbalance(oc_global, xpos, ypos, zpos, iret_95,b);
									iret_one_scan += iret_95;
									//if_disbalnce_marker(oc_global);
									if (DEBUG_ALICE_MESH) printf("\nfunction: shutdown_disbalance\n");
									shutdown_disbalance(oc_global);
									id_sc++; // увеличиваем номер прогона для вывода на консоль
								}

								if (iret_95 > 0) {
#if doubleintprecision == 1
									printf("POLNOE FATAL ERROR: 1007-time balancing NE DALO RESULTATOV iret_95 lists=%lld %lld %lld %lld %lld %lld %lld \n", iret_95, iret_95_memo5, iret_95_memo4, iret_95_memo3, iret_95_memo2, iret_95_memo1, iret_95_memo);
#else
									printf("POLNOE FATAL ERROR: 1007-time balancing NE DALO RESULTATOV iret_95 lists=%d %d %d %d %d %d %d \n", iret_95, iret_95_memo5, iret_95_memo4, iret_95_memo3, iret_95_memo2, iret_95_memo1, iret_95_memo);
#endif
									// Эта ситуация исправляется если включить еще одну дополнительную балансировку. Можно попробовать так.
									//system("PAUSE");
									//system("PAUSE");
									system("PAUSE");
									system("PAUSE");
								}
							}
						}
					}
				}

			}
			
		}
		
		

		// 6. Гасим информацию о посещениях.
		if (DEBUG_ALICE_MESH) printf("function: shutdown_visit\n");
		shutdown_visit(oc_global);
		top_ALICE_STACK = 0;
		
		if (iret_one_scan>0) bcont34 = true;
		progress_bar += iret_one_scan;
		
		printf("linking is finished.\n");

		integer nodes37 = (inx + 1) * (iny + 1) * (inz + 1);
#if doubleintprecision == 1
		printf("export ready one prohod succsefull iret=%lld.\n", iret_one_scan);
		printf("progress bar %2.3f procent. maxnod=%lld iprohod=%lld.\n", (100.0*progress_bar) / (inx*iny*inz), nodes37, iprohod);
#else
		printf("export ready one prohod succsefull iret=%d.\n", iret_one_scan);
		printf("progress bar %2.3f procent. maxnod=%lld iprohod=%d.\n", (100.0*progress_bar) / (inx*iny*inz), nodes37, iprohod);
#endif

		if (DEBUG_ALICE_MESH) {
			//system("PAUSE");
			system("PAUSE");
		}
		// Важнейший контроль дисбаланса, никаких дисбалансов быть не должно.

		integer iOk28 = 0;
		iOk28 = if_disbalnce(oc_global,inx,iny,inz,maxelm,xpos,ypos,zpos, xposadd, yposadd, zposadd, inxadd, inyadd, inzadd,b,lb,w,lw,s,ls);
		if (iOk28 > 0) {
			//std::cout << "iOk28 > 0\n";
			//system("PAUSE");
		}
		if (!B_QUICK_MESHING) {
			if (0&&(TYPE_ALICE_MESH::ONE_PASS_COARSE_ALICE_MESH == itype_ALICE_Mesh)) {

				// Если 0 то мы отказываемся от экономии памяти и hash_for_droblenie_xyz будет освобождено в конце.
				// hash_for_droblenie_xyz требуется чтобы в самом конце вычислить calculate_whot_is_block для ускорения расчётов.
				// Здесь calculate_whot_is_block вычислять нельзя, т.к. он должен быть вычислен именно в конце.

				// 18.11.2020
				calculate_whot_is_block(oc_global, b, lb);
				top_ALICE_STACK = 0;

				// Освобождение оперативной памяти из под хеш-таблицы.
				for (int i_54 = 0; i_54 < inx; i_54++) {
					for (int i_55 = 0; i_55 < iny; i_55++) {
						delete[] hash_for_droblenie_xyz[i_54][i_55];
						hash_for_droblenie_xyz[i_54][i_55] = nullptr;
					}
				}

				for (int i_54 = 0; i_54 < inx; i_54++) {
					delete[] hash_for_droblenie_xyz[i_54];
					hash_for_droblenie_xyz[i_54] = nullptr;
				}

				delete[] hash_for_droblenie_xyz;
				hash_for_droblenie_xyz = nullptr;



				b_resize1 = true;

			}


		}
		if ((TYPE_ALICE_MESH::MULTI_PASS_MEDIUM_ALICE_MESH == itype_ALICE_Mesh)&&(iOk28>99)) {
			// было (iOk28>0). Стало (iOk28>99). 26.10.2020

			// Только в том случае если мы строим многопроходовую АЛИС сетку высочайшего качества.
			// Это долгий вычислительный процесс.
#if doubleintprecision == 1
			printf("Global restart needed!!! count=%lld\n", iOk28);
#else
			printf("Global restart needed!!! count=%d\n", iOk28);
#endif
			biOk28_global_restart = true;
			
		}
		//log_message(oc);
	}
	if (biOk28_global_restart) {
		// 01.12.2018
		// Я перенес глобальный рестарт на момент окончания построения.
		// Мы накапливаем позиции недостающих сеточных линий в течении всего процесса построения,
		// а не только на текущем уровне построения.
		// Надеюсь это позволит сократить число глобальных повторных запусков и существенно уменьшить  время построения неструктурированной
		// сетки локального дробления на очень больших моделях.
		// На примере задачи построения расчётной сетки для ПТБШ Шз=20мм
		// было: 6min 30s maxelm=125779, maxp=174313.  89 прогонов, 15 глубина дробления, 12 глубина фрагментации на уровне.
		// стало: 3min 44s maxelm=143760, maxp=199424. 13 прогонов, 16 глубина дробления, 11 глубина фрагментации на уровне.
		// На примере задачи подробнейшего ПТБШ Шз=5мм
		// было: 344мин 133 прогонов, 22 глубина дробления. (3.2ггц процессор).
		// стало: 

        // 18.11.2020
		calculate_whot_is_block(oc_global, b, lb);
		top_ALICE_STACK = 0;

		// Не забываем освобождать оперативную память.
		// Освобождение оперативной памяти из под хеш-таблицы.
		for (int i_54 = 0; i_54 < inx; i_54++) {
			for (int i_55 = 0; i_55 < iny; i_55++) {
				delete[] hash_for_droblenie_xyz[i_54][i_55];
				hash_for_droblenie_xyz[i_54][i_55] = nullptr;
			}
		}

		for (int i_54 = 0; i_54 < inx; i_54++) {
			delete[] hash_for_droblenie_xyz[i_54];
			hash_for_droblenie_xyz[i_54] = nullptr;
		}

		delete[] hash_for_droblenie_xyz;
		hash_for_droblenie_xyz = nullptr;

		printf("Free memory for hash_for_droblenie_xyz. alice mesh return false\n");


		expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);

		//system("PAUSE");
		// Нужно добавить сеточных линий.
		return false;
	}
	printf("update max count neighbour is start...\n");
	update_max_count_neighbour(oc_global);
	printf("update max count neighbour is finished.\n");
	printf("FINISHING export in visualisation paraview 5.5 start now.\n");
	expt(oc_global, inx, iny, inz, maxelm, xpos, ypos, zpos);
	printf("END export paraview 5.5.\n");
	printf("\n");

	top_ALICE_STACK = 0;
	// Если нужно контролировать АЛИС сетку то надо включить паузу.
	//system("PAUSE");
	// Он нам еще очень понадобится поэтому ни в коем случае не удаляем.
	//delete[] my_ALICE_STACK;


	

	
	// 29.10.2020
	// Ужимаем в памяти хранилище для  rootClear_octree;
	// Сокращение размера сильно экономит оперативную память.

	if (!b_resize1) {

		

		// 18.11.2020
		calculate_whot_is_block(oc_global, b, lb);
		top_ALICE_STACK = 0;

		/*
		// Освобождение оперативной памяти из под хеш-таблицы.
		for (int i_54 = 0; i_54 < inx; i_54++) {
			for (int i_55 = 0; i_55 < iny; i_55++) {
				delete[] hash_for_droblenie_xyz[i_54][i_55];
				hash_for_droblenie_xyz[i_54][i_55] = nullptr;
			}
		}

		for (int i_54 = 0; i_54 < inx; i_54++) {
			delete[] hash_for_droblenie_xyz[i_54];
			hash_for_droblenie_xyz[i_54] = nullptr;
		}

		delete[] hash_for_droblenie_xyz;
		hash_for_droblenie_xyz = nullptr;
		*/
		

	}

	printf("Free memory for hash_for_droblenie_xyz. alice mesh return true\n");

	return true;

}

#endif
