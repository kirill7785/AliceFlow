
// my_cl_agl_amg_0_13.cpp: определяет точку входа для консольного приложения.
//
//
// classical aglomeration algebraic multigrid method.
// классический агломеративный алгебраический многосеточный метод.
//
// 8 января 2018 года. (см. classic_aglomerative_amg4).
// Направления дальнейшего развития: Более тонкая настройка доступная из интерфейса.
// Одна из целей: увеличение быстродействия и сильная экономия памяти в ущерб сходимости.
// Комплекс мер по увеличению быстродействия: 
// Обязательное сохранение работоспособности того что есть, доработка того что есть.
//
// 8 января 2018 года. (см. classic_aglomerative_amg4).
// Между январём 2016 и январём 2018 года была проделана работа по дальнейшему 
// развитию алгоритма и его тестированию. 
// Перечень произведённых изменений не описывается. Сделано много небольших
// модификаций. Главное это то, что алгоритм теперь мыслится 
// как предобуславливатель к Крыловскому алгоритму BiCGStab. Это плодотворно
// сказалось на его сходимости во многих случаях важных для практики.
// В основе нахождения C-F разбиения лежит АВЛ, SPLAY, BenaryHeap или Деамида.
// На будущее стоит рассмотреть фиббоначиеву кучу и поддержать работоспособность
// и улучшение ранее предложенных вариантов. В использовании сглаживателей есть 
// продвижения. Введен в эксплуатацию ilu(0) сглаживатель, алгоритм Саада при этом
//  специальным образом модифицирован (устранен линейный поиск). Положительно
// использован сглаживатель на основе метода Рунге-Кутта. Полезным оказалось 
// использование C-F порядка обхода узлов при сглаживании. Испробованы сглаживатели
// gmres и bicgstab. От них пришлось отказаться - потеря сходимости, серьёзное 
// ухудшение быстродействия. Алгоритм успешно использовался
// во многих важных для практики случаях. Есть задачи с которыми он ещё не справляется. 
// Есть проблемы с быстродействием если говорить о рекордах скорости. 
// Алгоритм потребляет много оперативной памяти.
//
// 6 января 2016. Версия 0.13.  (см. classic_aglomerative_amg2).
// АВЛ деревья во многих местах заменены на более быструю комбинацию хеш таблицы (поиск и вставка)
// и стека (стек для очистки хеш таблицы).
// Время счёта реальной тепловой задачи в 3.2М неизвестных составило 1мин 51с т.е.
// удалось догнать BiCGStab+ILU(2) из SPARSKIT2 со временем счёта 1мин 50с.
// Ю. Саада. Догнать amg1r5 с временем счёта 1мин пока не представилось возможным.
// 5 января 2016. Сделан sor сглаживатель на основе формулы  из книги Патрика Роуча
// дающий сокращение итераций на 28%,
// я исходил из того что оптимальный параметр верхней релаксации зависит только от 
// числа уравнений в СЛАУ на каждом уровне вложенности.
// Также немного доработаны процедуры интерполяции (рабочих насчитывается 4 штуки).
// Время счёта задачи с 3.2M неизвестными составляет 2мин 25с.
// что в 1.3раза медленнее чем у BiCGStab+ILU(2).
// 4 января 2016. Проблемы с ipool больше нет, он заменён на АВЛ дерево. На задаче 
// с размерностью в 3.2M неизвестных оптимальное
// значение barjer=1e-8 что дало сокращение итераций с 1003 до 213. (Время счёта с 
// 9мин до 4мин. Потребляет 2.4Гб ОЗУ). 
// У BiCGStab+ILU(2) всего 1мин 50с т.е.он в 2.2 раза быстрее.
// 3 января 2016. Версия 0.12. (см. classic_aglomerative_amg2).
// Протестированная на некоторых реальных здачах теплопередачи в программе AliceFlow&&AliceMesh.
// Для одного миллиона неизвестных время решения составляет 40с. Это время такое-же как и время 
// алгоритма BiCGStab+ILU(2). Ещё раз подчёркиваю что задача реальная. Также решалась задача 
// в 3.2М неизвестных (заняло 2Гб ОЗУ), время решения
// которой составило 8мин 27с что 4.6раза медленнее алгоритма BiCGStab+ILU(2) время которого 1мин 50с.
// В версии 0.12 произведены следующие улучшения : код очищен от устаревшего, в качестве сглаживателя
// (как пре так и пост) используется SOR с параметром omega=1.15 он чуть чуть быстрее.
// Если будут проблемы можно переключить на надежный Зейдель. см. seidelq.
// В residualq избавились от деления на элемент обратный диагональному, заменив эту операцию на более
// быстрое умножение. Добавлен W цикл, см переключатель igam, впрочем W оказался медленнее примерно 
// вдвое. 6 января 2016. W цикл запрограммирован неверно.
// Нельзя вызывать V повторно на глубоких уровнях надо делать глубину повторных вызовов не более 
// 2 или 3 тогда W цикл может ускорить вычисление до 3 раз по данным статей в интернете.
// Исправления будут в версии 0.14.Подобраны оптимальные параметры V цикла равные
// одному предсглаживанию и двум пост сглаживаниям. Есть возможность настроить количество
// пред и пост сглаживаний, в частности исследовался
// вариант когда количество сглаживаний при погружении на глубокие уровни увеличивается.
// Этот вариант не дал выигрыша в скорости.
// В данный момент разрабатывается "идеальный" алгоритм интерполяции. Помимо стандартного,
// в данный момент добавлена непрямая интерполляция, а
// также гибрид стандартной и непрямой интерполляции. От интерполяции зависит количество 
// итераций а значит и время счёта а также память. Разработка 
// интерполяции ведётся в настоящий момент. 
// Введена отсечка малых элементов в операторах Галёркина. Установлено оптимальное значение 
// в 0.0001 умноженное на максимальный элемент в строке
// быстродействие при котором наиболее велико (компромисс) по замерам на задаче в 1M неизвестных.
// Недостатком программы вданный момент является чрезвычайно большое число итераций нужных для 
// сходимости. Для 3.2М неизвестных их число составило 1000.
// Реализована сортировка с подсчётом как и намечалось ранее. АВЛ дерево сохранено и доказало 
// свою эффективность.
// 21 декабря 2015. Версия 0.11 была протестирована на реальной задаче в 3D. Размерность реальной
// задачи 1М неизвестных. Вывод состоит в том что метод 0.11 ещё не готов к реальным задачам,
// число ненулевых элементов  в матрицах грубосеточных уровней растёт катострофическим образом. 
// В ремя счёта настолько велико что ждать просто нет смысла.
// В то время как amg1r5 справился с этой реальной задачей за 17с. В следующей версии 0.12 будут
// предприняты шаги по улучшению работоспособности данного программного решения. 
// 13 декабря 2015. Версия 0.11. C-F разбиение выполнено на основе АВЛ дерева. Адельсон-Вельский 
// и Ландис 1962.
// теперь оно существенно доработано, исправлены ошибки и быстродействие алгоритма по сравнению с версией 0.10 на
// на трёхмерном уравнении Пуассона в кубе 120х120х120 1.7М неизвестных увеличилось в 11 раз!!! время решения 1мин.
// Версия 0.11 полностью переведена на быструю сортировку Ч.Хоара 1960 т.к. она обгоняет пирамидальную сортировку в 5 раз.
// В предыдущей версии кода в быстрой сортировке содержалась ошибка.См новые реализации qs, qsj.
// Сортировка Хоара не требует дополнительной памяти. Размер стека программы увеличен до 4Мб в студии. 
// Версия 0.11 полностью свободна от нумерации неизвестных в исходной матрице Это значит что версия 0.11 данного многосеточного
// метода одинаково эффективно работает с любой нумерацией неизвестных !!! Никакой головной боли с шириной ленты матрицы,
// нумеруйте как хотите, т.е. как удобно генератору сетки. 
// Мысли о том то возможно будет реализовано в слудующей версии.
// Если количество оперативной памяти не проблема для пользователя то есть возможность ускорить данную программу
// за счёт применения сортировки с подсчётом которая выполняется асимптотически за O(n) операций на одном потоке, но жрёт при этом 
// дополнительные массивы памяти.
// АВЛ дервья были изобретены более 40 лет назад, возможно их можно заменить современными более быстродействующими структурами данных.
// Алгоритм Фреда Густавсона разреженного матричного умножения по прежнему функционирует в данном коде, возможно можно улучшить и его
// характеристики быстродействия если на это укажет профилировщик.
// А да, кого интересует 2D : двмерная задача 1000х1000 1М неизвестных решается данным кодом за 18с. Подробные данные ждите в файле замеры
// времени .doc который будет приложен к проекту позднее.
// О том как использовать данное программное решение в своих проектах см. тело функции main.
// По всем вопросам о использовании данной программы писать на kirill7785@mail.ru.
//  ***---***      ***---***      ***---***
// 9 декабря 2015. Версия 0.10. Существенно ускорено построение C-F разбиения. Threshold = 0.25 
// единый и для 2D и для 3D это подтверждается анализом статей в интернете. Задача Пуассона
// в 3D кубе размерностью 120х120х120 решается теперь за 11минут вместо 25 мин.Ускорение более чем в двое в 3D.
// 6 декабря 2015. Версия 0.09. Улучшения в решении 3D задач по сравнению с версией 0.08. 
// Задача Пуассона в 3D кубе 120х120х120 решается за 25мин. Потребляет 1.86Гб оперативной пямяти.
// Это 1.7М неизвестных. Количество итераций при этом 317.
// Алгоритмически версия 0.09 отличается от версии 0.08 тем что в ней предприняты шаги по сохранению разреженности
// оператора Галёркина. Это главным образом дало возможность решать 3D задачи.
// Параметры алгоритма : nu1, nu2 (количество итераций пред и пост сглаживания), mul_tolerance, theta
// параметры отсечения малых элементов в матрице требуют подбора. Подбор пока произведен вручную на глазок. 
// Также в версии 0.09 изменён принцип поиска соседей новых F узлов : оно запрограммировано теперь на двухсвязном 
// списке без band_sizei, что дало существенное ускорение в 3D и небольшое замедление в 2D.
// Построение CF разбиения по прежнему испытывает существенные проблемы с быстродействием, поиск максимума в 3D 
// задачах занимает львиную долю времени. Матричное умножение после сохранения разреженности оператора Галёркина
// выполняется достаточно быстро и с ним всё впорядке.
// Код работает на любых размерностях влизающих в оперативную память до 300М ненулевых элементов в матрице СЛАУ.
// Работы по тестированию алгоритма на реальных задачах ведутся достаточно успешно, но показывать их пока рано.
// 15 ноября 2015. Версия 0.08 в которой исправлены ошибки версии 0.07. Ошибки были в организации двусвязного линейного
// списка.
// 8 ноября 2015. Версия 0.07 в которой выполнена работа по дальнейшему улучшению быстродействия
// алгоритма. Задача Пуассона на сетке 800х800 теперь решается за 49с. Это не предел, у аналогов
// например у amg1r5 быстродействие оценивается в 8с для данной задачи. Для трёхмерного Пуассона 
// с быстродействием в версии 0.07 лучше чем в версии 0.06 но очень плохо по сравнению с 
// комерческими аналогами. В версии 0.07 сделан прорыв в разреженном матричном умножении,алгоритм
//  Фреда Густавсона существенно ускорен. Тестиование алгоритма на реальных задачах практически 
// не было произведено по причине отсутствия реализации  Катхилла-Маки в реальном тестируемом
// приложении (AliceFlow) а данный метод my_amg_v0.07  очень чувствителен  к ширине ленты матрицы.
// 31 - октября 2015. Версия 0.06 в которой выполнена работа по дальнейшему улучшению
// быстродействия алгоритма. Исправлен ряд ошибок. Задача Пуассона на сетке 800х800 
// решается за 9мин 32с.
// Данная версия алгоритма содержит очень большое количество оптимизирующих патчей и 
// поэтому код стало очень сложно сопровождать. Надо провести реальное тестирование 
// в следующей версии кода.
// 22-23 октября 2015. Версия 0.05 в которой запрограммирована идея Писсанецки для
// разреженного матричного умножения. Реализация идеи Писсанецки ускорила код на 15%
// по сравнению с версией 0.04. Также в версии 0.05 реализован алгоритм Густавсона для
// разреженного матричного умножения gustavson sparse matrix multiplayer IBM 1978.
// Алгоритм Густавсона ускорил код по сравнению с версией 0.04 более чем вдвое.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C-F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С-F разбиения 
// учитывается уже построеннная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведеия Галёркина получена самая оптимальная по быстродествию версия,
// Основанная на алгоритме слияния отсортированных списков.
// version 0.03 15 october 2015. (Успешное построение иерархии сеток, операторов restriction
// , interpolation.) По сравнению с версией 0.01 исправлены : бинарный поиск, нахождение
// оператора Галеркина. Внесены прочие мелкие исправления.
// По сравнению с версией 0.02 код стал быстрее, продуманнее. Найдена ошибка в MergeSort
//  поэтому от неё полностью отказались в пользу HeapSort.
// Код работает на любых размерностях до 10млн ненулевых элементов но очень медленно на
// высоких размерностях.
// Код быстрее версии 0.02 на 50%.
/*    ###     ##    ###   ####
*    #  #    #  #  # ##  #
*   #####   #    #   ##  #   ##  for AliceFlowv0_22 AliceMeshv_0_34 DavisTestDelphi and anather products...
*  #    #  #         ##   ####
*    solution time 3.2M unknowns is ONE MINUTE and 51 second  in one thread 2.2GHz processor
*   (требуется 2.3Gb ОЗУ без учёта памяти которую дополнительно съест Windows).
*/

#pragma once
#ifndef MY_AGREGAT_AMG_CPP
#define MY_AGREGAT_AMG_CPP 1

//#include "cuda_runtime.h"
//#include "device_launch_parameters.h"

//#include "stdafx.h"
#include <stdio.h>
#include <math.h>
//#include <stdlib.h>
//#include <windows.h>
#include <float.h>
#include <time.h>
//#include <omp.h>
#include <windows.h>
//#pragma comment(linker, "/STACK:16777216") // увеличение размера стека для быстрой сортировки
#include <stdlib.h> // for библиотечной qsort
#include <algorithm> // sort (IntroSort)
#include "gmres.cpp" // Алгоритм Саада и Шульца GMRes [1986]


// Очередь по приоритетам на основе сортирующего дерева 
//#include "priority_queue.cpp"

// cuda primer start
/*
cudaError_t addWithCuda(integer *c, const integer *a, const integer *b, unsigned integer size);

__global__ void addKernel(integer *c, const integer *a, const integer *b)
{
	integer i = threadIdx.x;
	c[i] = a[i] + b[i];
}

integer main_test_example()
{
	const integer arraySize = 5;
	const integer a[arraySize] = { 1, 2, 3, 4, 5 };
	const integer b[arraySize] = { 10, 20, 30, 40, 50 };
	integer c[arraySize] = { 0 };

	// Add vectors in parallel.
	cudaError_t cudaStatus = addWithCuda(c, a, b, arraySize);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "addWithCuda failed!");
		return 1;
	}

	

	#if doubleintprecision == 1
		printf("{1,2,3,4,5} + {10,20,30,40,50} = {%lld,%lld,%lld,%lld,%lld}\n",
		c[0], c[1], c[2], c[3], c[4]);
	#else
		printf("{1,2,3,4,5} + {10,20,30,40,50} = {%d,%d,%d,%d,%d}\n",
		c[0], c[1], c[2], c[3], c[4]);
	#endif
	

	// cudaDeviceReset must be called before exiting in order for profiling and
	// tracing tools such as Nsight and Visual Profiler to show complete traces.
	cudaStatus = cudaDeviceReset();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceReset failed!");
		return 1;
	}

	return 0;
}

// Helper function for using CUDA to add vectors in parallel.
cudaError_t addWithCuda(integer *c, const integer *a, const integer *b, unsigned integer size)
{
	integer *dev_a = 0;
	integer *dev_b = 0;
	integer *dev_c = 0;
	cudaError_t cudaStatus;

	// Choose which GPU to run on, change this on a multi-GPU system.
	cudaStatus = cudaSetDevice(0);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaSetDevice failed!  Do you have a CUDA-capable GPU installed?");
		goto Error;
	}

	// Allocate GPU buffers for three vectors (two input, one output)    .
	cudaStatus = cudaMalloc((void**)&dev_c, size * sizeof(integer));
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		goto Error;
	}

	cudaStatus = cudaMalloc((void**)&dev_a, size * sizeof(integer));
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		goto Error;
	}

	cudaStatus = cudaMalloc((void**)&dev_b, size * sizeof(integer));
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		goto Error;
	}

	// Copy input vectors from host memory to GPU buffers.
	cudaStatus = cudaMemcpy(dev_a, a, size * sizeof(integer), cudaMemcpyHostToDevice);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		goto Error;
	}

	cudaStatus = cudaMemcpy(dev_b, b, size * sizeof(integer), cudaMemcpyHostToDevice);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		goto Error;
	}

	// Launch a kernel on the GPU with one thread for each element.
	addKernel << <1, size >> >(dev_c, dev_a, dev_b);

	// Check for any errors launching the kernel
	cudaStatus = cudaGetLastError();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "addKernel launch failed: %s\n", cudaGetErrorString(cudaStatus));
		goto Error;
	}

	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
	#if doubleintprecision == 1
		fprintf(stderr, "cudaDeviceSynchronize returned error code %lld after launching addKernel!\n", cudaStatus);
	#else
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
	#endif
		
		goto Error;
	}

	// Copy output vector from GPU buffer to host memory.
	cudaStatus = cudaMemcpy(c, dev_c, size * sizeof(integer), cudaMemcpyDeviceToHost);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		goto Error;
	}

Error:
	cudaFree(dev_c);
	cudaFree(dev_a);
	cudaFree(dev_b);

	return cudaStatus;
}
*/
// cuda primer end

// Объявление модели вещественной арифметики содержится в самом начале программы в главно модуле 
// AliceFlow_v0_27
//#define doublerealT double
//#define integer int // 32 bit
//#define integer int64_t

/*
// Объявлено в глобальном модуле:

// Управление алгебраическим многосеточным методом из интерфейса.
typedef struct TMY_AMG_MANAGER {
integer maximum_levels; // максимальное количество уровней вложенности (уровни выше редуцируются).
integer number_interpolation_procedure; // идентификатор процедуры интерполляции.
integer nFinnest, nu1, nu2; // Количества сглаживаний.
integer memory_size; // В размерах матрицы А.
} MY_AMG_MANAGER;

MY_AMG_MANAGER my_amg_manager;

// amg default settings:
// Параметры собственного многосеточного метода о умолчанию.
my_amg_manager.maximum_levels = 20; // максимальное число уровней начиная с котрго начинается усечение.
my_amg_manager.number_interpolation_procedure = 0; // номер интерполяционной процедуры.
my_amg_manager.nFinnest = 2; // число итераций на подробной сетке.
my_amg_manager.nu1 = 1; // число предсглаживаний.
my_amg_manager.nu2 = 2; // число пост сглаживаий.
my_amg_manager.memory_size = 9; // количество оперативной памяти в размерностях матрицы А.

*/

const integer QUICK_SORT_ALG = 1; // Быстрая сортировка Хоара.
// Использовать ли quicksort qs and qsj.
// Сортировка с подсчётом быстрее quickSort.
// Использовать ли сортировку подсчётом которая 
//жрёт килотонну памяти (Короче для машин у которых море оперативки).
const integer COUNTING_SORT_ALG = 0; // Сортировка с подсчётом лучший выбор.
// Сортировка с посчётом подходит потому что ключи целочисленны и 
// лежат в заданном интервале непрерывно.
const integer HEAP_SORT_ALG = 2; // пирмидальная сортировка.
// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
// В компиляторе надо увеличить размер стека до 4Мб.
// сортировка Тима Петерсона. 15-16.03.2019
const integer TIM_PETERSON_SORT_ALG = 3;

typedef struct TAk {
	integer i, j;
	doublereal aij;
	//float aij;
	//в последней версии алгоритма ind не используется.
	integer ind; // позиция в первоначальной сортировке.
} Ak;

typedef struct TAk1 {
	integer i, j;
	doublereal aij;
	//float aij;
	//в последней версии алгоритма ind не используется.
	//integer ind; // позиция в первоначальной сортировке.
} Ak1;

// 03.02.2019
// Разреженная матрица СЛАУ в CRS или COO форматах.
typedef struct TAk2 {
	// Раздельное хранение массивов.
	integer *i, *j;
	doublereal *aij;
	doublereal *abs_aij; // Для ускорения вычислений предварительно вычисляем модуль.
	//float *aij;
	//integer *row_ptr_start, *row_ptr_end;
} Ak2;


// Для генерации матрицы СЛАУ требуется в случае реализации
// на динамических массивах переупорядочивание элементов:
// сортировка. Здесь будет реализована быстрая сортировка.
// Брайан Керниган и Денис Ритчи "The C programming language".
// swap: Обмен местами v[i] и v[j]
template <typename doublerealT>
void swapnd(integer* &v, doublerealT* &dkey, integer i, integer j)
{
	integer temp;

	// change v[i] <-> v[j]
	temp = v[i];
	v[i] = v[j];
	v[j] = temp;

	doublerealT dtemp;

	// change v[i] <-> v[j]
	dtemp = dkey[i];
	dkey[i] = dkey[j];
	dkey[j] = dtemp;
} // swap

  // Вот алгоритм PivotList
template <typename doublerealT>
integer PivotListnd(integer* &list, doublerealT* &dkey, integer first, integer last) {
	// list обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	doublerealT PivotValue = dkey[first];
	integer PivotPoint = first;

	for (integer index = (first + 1); index <= last; index++) {
		if (dkey[index]<PivotValue) {
			PivotPoint++;
			swapnd<doublerealT>(list, dkey, PivotPoint, index);
		}
	}

	swapnd<doublerealT>(list, dkey, first, PivotPoint);

	return PivotPoint;
} // PivotList


  // Быстрая сортировка Хоара.
  // Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
  // стр. 106.
template <typename doublerealT>
void QuickSortnd(integer* &list, doublerealT* &dkey, integer first, integer last) {
	// list упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка

	integer pivot;

	if (first < last) {
		pivot = PivotListnd<doublerealT>(list, dkey, first, last);
		QuickSortnd<doublerealT>(list, dkey, first, pivot - 1);
		QuickSortnd<doublerealT>(list, dkey, pivot + 1, last);
	}
} // QuickSort

// Для библиотечной быстрой сортировки целочисленного массива.
integer intcompare(const void  * i, const void * j)
{
	if (*(integer*)i > *(integer*)j) return (1);
	if (*(integer*)i < *(integer*)j) return (-1);
	return (0);
} // для библиотечной функции быстрой сортировки.

/*
void handle_error(Ak1* &handle, char* ch_var, char* ch_function, integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (Ak1*)malloc((n) * sizeof(Ak1));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (Ak1*)malloc((n) * sizeof(Ak1));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}

void handle_error(Ak1* &handle, const char ch_var[], const char ch_function[], integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (Ak1*)malloc((n) * sizeof(Ak1));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (Ak1*)malloc((n) * sizeof(Ak1));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}

void handle_error(Ak* &handle, char* ch_var, char* ch_function, integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (Ak*)malloc((n) * sizeof(Ak));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (Ak*)malloc((n) * sizeof(Ak));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}


void handle_error(Ak* &handle, const char ch_var[], const char ch_function[], integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (Ak*)malloc((n) * sizeof(Ak));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (Ak*)malloc((n) * sizeof(Ak));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}
*/

template <typename doublerealT>
void handle_error(doublerealT* &handle, char* ch_var, char* ch_function, integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}


template <typename doublerealT>
void handle_error(doublerealT* &handle, const char ch_var[], const char ch_function[], integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}

template <typename doublerealT>
void handle_error(doublerealT* &handle, char* ch_var, integer id_var, char* ch_var2, char* ch_function, integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s %lld %s in %s ...\n", ch_var, id_var, ch_var2, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s %lld %s in %s ...\n", ch_var, id_var, ch_var2, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s %lld %s in %s ...\n", ch_var, id_var, ch_var2, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s %lld %s in %s.\n", ch_var, id_var, ch_var2, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s %lld %s in %s.\n", ch_var, id_var, ch_var2, ch_function);
		}
	}
}

template <typename doublerealT>
void handle_error(doublerealT* &handle, const char ch_var[], integer id_var, const char ch_var2[], const char ch_function[], integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s %lld %s in %s ...\n", ch_var, id_var, ch_var2, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s %lld %s in %s ...\n", ch_var, id_var, ch_var2, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (doublerealT*)malloc((n) * sizeof(doublerealT));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s %lld %s in %s ...\n", ch_var, id_var, ch_var2, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s %lld %s in %s.\n", ch_var, id_var, ch_var2, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s %lld %s in %s.\n", ch_var, id_var, ch_var2, ch_function);
		}
	}
}

/*
void handle_error(bool* handle, char* ch_var, char* ch_function, integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (bool*)malloc((n) * sizeof(bool));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (bool*)malloc((n) * sizeof(bool));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}


void handle_error(bool* handle, const char ch_var[], const char ch_function[], integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (bool*)malloc((n) * sizeof(bool));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (bool*)malloc((n) * sizeof(bool));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}

void handle_error(integer* handle, char* ch_var, char* ch_function, integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (integer*)malloc((n) * sizeof(integer));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (integer*)malloc((n) * sizeof(integer));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}

void handle_error(integer* handle, const char ch_var[], const char ch_function[], integer n)
{
	if (handle == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
		printf("Please any key to continue...\n");
		system("pause");
		// Здесь пользователь может закрыть другие приложения и освободить память.
		// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
		handle = (integer*)malloc((n) * sizeof(integer));
		if (handle == NULL) {
			printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
			printf("Please any key to continue...\n");
			system("pause");
			// Здесь пользователь может закрыть другие приложения и освободить память.
			// После этого память станет доступной и программа сможет в теории продолжить своё выполнение.
			handle = (integer*)malloc((n) * sizeof(integer));
			if (handle == NULL) {
				printf("Problem : not enough memory on your equipment for %s in %s ...\n", ch_var, ch_function);
				printf("Please any key to exit...\n");
				system("pause");
				exit(1);
			}
			else {
				printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
			}
		}
		else {
			printf("ok! memory allocation successfully for %s in %s.\n", ch_var, ch_function);
		}
	}
}
*/

typedef struct Taccumulqtor_list {
	integer ikey;
	Taccumulqtor_list* next;
} accumulqtor_list;

// Найти в линейном односвязном списке значение.
bool isfound(Taccumulqtor_list* &root, integer key) {
	Taccumulqtor_list* mem = root;
	while (mem != NULL) {
		if (mem->ikey == key) {
			mem = NULL;
			return true;
		}
		mem = mem->next;
	}
	return false;
}

// Быстрая вставка за O(1) операций.
// Размер структуры динамический - ровно столько сколько нужно. 
void insert_list(Taccumulqtor_list* &root, integer key) {
	if (root == NULL) {
		root = new Taccumulqtor_list;
		root->ikey = key;
		root->next = NULL;
	}
	else {
		Taccumulqtor_list* candidate = NULL;
		candidate= new Taccumulqtor_list;
		candidate->ikey = key;
		candidate->next = root->next;
		root->next = candidate;
		candidate = NULL;
	}
} // insert_list

// Полная очистка линейного списка-хранилища.
void clear_list(Taccumulqtor_list* &root) {
	Taccumulqtor_list* buf = NULL;
	while (root != NULL) {
		buf = root; // 54404 0.4%
		root = root->next;
		buf->next = NULL;
		delete buf;
		buf = NULL;
	}
} // clear_list

 

typedef struct Thashlist {
	Ak Amat;
	Thashlist* next;
	Thashlist* prev;
} hashlist;

// вставка ключа в список
void insertion_hash(hashlist* p, Ak d) {
	if (p == 0) {
		p = new hashlist;
		if (p == 0) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for p in insertion hash my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		p->prev = 0;
		p->next = 0;
		p->Amat = d;
	}
	else {
		hashlist* scanner = p;
		while (scanner->next != 0) scanner = scanner->next;
		hashlist* r = NULL;
		r=new hashlist;
		if (r == 0) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for r in insertion hash my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		r->prev = scanner;
		r->next = 0;
		r->Amat = d;
		scanner->next = r;
		r = 0;
		scanner = 0;
	}
}

// очистка списка
// Вероятно содержит ошибку потому что память не освобождается.
// TODO 17 dec 2015
void clear_hash(hashlist* p) {
	if (p != 0) {
		hashlist* head = p;
		p = 0;

		hashlist* r = head;
		while (r != 0) {
			head = head->next;
			if (head != 0)  head->prev = 0;
			r->next = 0;
			r->prev = 0;
			delete r;
			r = head;
		}
	}
}



typedef struct TList {
	integer ii, i, countsosed;
	TList* next;
	TList* prev;
} List;

// Для АВЛ дерева
// 12.12.2015
// По видимому в 3D очень большое количество соседей и простой 
// линейный двухсвязный список не справляется с таким большим 
// количеством элементов по параметру быстродействие. 
// Для сравнения в 2D при 1М неизвестных видно что линейный
// список справляется прекрасным образом со своим 2D числом соседей
// и даже по результатам 
// профайлинга не видно чтобы он испытывал сколько-нибудь ощутимую
// нагрузку. 

// АВЛ дерево это структура данных позволяющая производить все 
// операции за log_2 (number of sosed count) операций. 

// Адельсон-Вельский и Ландис 1962 (взято из интернета).
// узел с максимальным значением ключа крайний правый.

// для поля данных надо определить перегруженные операции,
// меньше, больше и равно.

// Поле данных в АВЛ дереве.
// перенесена в файл priority_queue.cpp
//struct data_BalTree
//{
	// --> high priority --> for operation <,>
	//integer ii;
	//integer  i, countsosed;
	// countsosed есть key.
//};

//отношения порядка только в insert и remove

// Узел АВЛ дерева.
struct node_AVL
{
	data_BalTree key;
	// Высота поддерева с корнем в данном узле.
	unsigned char height;
	node_AVL* left;
	node_AVL* right;
	// Конструктор.
	node_AVL(data_BalTree k) { key = k; left = right = 0; height = 1; }
};

// Работает также и с пустыми деревьями.
// Обёртка поля height
unsigned char height(node_AVL* p)
{
	return p ? p->height : 0;
};

// Вычисляет balance factor заданного узла
// работает только с ненулевыми указателями.
integer bfactor(node_AVL* p)
{
	return height(p->right) - height(p->left);
};

// Восстанавливает корректное значение поля height
// заданного узла (при условии, что значения этого поля 
// в правом и левом дочерних узлах являются корректными).
void fixheight(node_AVL* p)
{
	unsigned char hl = height(p->left);
	unsigned char hr = height(p->right);
	p->height = (hl > hr ? hl : hr) + 1;
};

// Балансировка узлов.
node_AVL* rotateright(node_AVL* p)
{
	// правый поворот вокруг p
	node_AVL* q = p->left;
	p->left = q->right;
	q->right = p;
	fixheight(p);
	fixheight(q);
	return q;
};

// Левый поворот является симметричной копией правого :
node_AVL* rotateleft(node_AVL* q)
{
	// левый поворот вокруг q
	node_AVL* p = q->right;
	q->right = p->left;
	p->left = q;
	fixheight(q);
	fixheight(p);
	return p;
};

// Код выполняющий балансировку сводится к проверке условий и выполнению поворотов
node_AVL* balance(node_AVL* p) // балансировка узла p
{
	fixheight(p);
	if (bfactor(p) == 2)
	{
		if (bfactor(p->right) < 0)
			p->right = rotateright(p->right);
		return rotateleft(p);
	}
	if (bfactor(p) == -2)
	{
		if (bfactor(p->left) > 0)
			p->left = rotateleft(p->left);
		return rotateright(p);
	}
	return p; // балансировка не нужна
}

// Вставка ключей в дерево.
// Возвращает новое значение корня АВЛ дерева.
node_AVL* insert(node_AVL* &p, data_BalTree k)
{
	// Вставка ключа k в дерево с корнем p
	if (p == NULL) {
		node_AVL* r1 = NULL;
		r1 = new node_AVL(k);
		if (r1 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for r1 in insert my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		return r1;
	}
	if (k.countsosed < p->key.countsosed)
		p->left = insert(p->left, k);
	else if (k.countsosed > p->key.countsosed)
		p->right = insert(p->right, k);
	else if (k.i < p->key.i)
		p->left = insert(p->left, k);
	//else if (k.i > p->key.i)
	else
		p->right = insert(p->right, k);
	//else if (k.ii < p->key.ii)
		//p->left = insert(p->left, k);
	//else
		//p->right = insert(p->right, k);
	return balance(p);
} // insert

  // Возвращает true если узел найден в дереве
bool isfound(node_AVL* p, data_BalTree k)
{
	if (p == 0) return false; // ненайден.
	if (k.countsosed < p->key.countsosed)
		return isfound(p->left, k);
	else if (k.countsosed > p->key.countsosed)
		return isfound(p->right, k);
	else if (k.i < p->key.i)
		return isfound(p->left, k);
	else if (k.i > p->key.i)
		return isfound(p->right, k);
	//else if (k.ii < p->key.ii)
		//return isfound(p->left, k);
	//else if (k.ii > p->key.ii)
		//return isfound(p->right, k);
	else return true; // найден.
}

// Полное удаление бинарного дерева.
void clear_AVL(node_AVL* p)
{
	if (p != 0) {
		clear_AVL(p->left);
		clear_AVL(p->right);
		// удаляем лист.
		delete p;
		p = 0;
	}
} // clear_AVL

  // Удаление узла с занными свойства с сохранением сбалансированности.
node_AVL* findmin(node_AVL* p)
{
	// поиск узла с минимальным ключём в дереве p
	//if (!p) {
	return p->left ? findmin(p->left) : p;
	//}
	//else {
	// на поиск минимума подан нулевой указатель.
	//return 0;
	//}
} // findmin

node_AVL* findmax(node_AVL* p)
{
	// поиск узла с максимальным ключём в дереве p
	if (p != 0) {
		return p->right ? findmax(p->right) : p;
		/*
		#if doubleintprecision == 1
			if (p->right == 0) {
				//printf("%lld %lld %lld\n", p->key.countsosed, p->key.i, p->key.ii);
				//system("pause");
				return p;
			}
			else {
				//printf("%lld %lld %lld\n",p->key.countsosed,p->key.i,p->key.ii);
				findmax(p->right);
			}
		#else
			if (p->right == 0) {
				//printf("%d %d %d\n", p->key.countsosed, p->key.i, p->key.ii);
				//system("pause");
				return p;
			}
			else {
				//printf("%d %d %d\n",p->key.countsosed,p->key.i,p->key.ii);
				findmax(p->right);
			}
		#endif
		
		*/
	}
	else {
		// На поиск максимума подан нулевой указатель.
		return 0;
	}
} // findmax

data_BalTree get_max_AVL(node_AVL* p)
{
	// возвращение максимального узла в дереве.
	return p->right ? get_max_AVL(p->right) : p->key;
}

node_AVL* removemin(node_AVL* p)
{
	// удаление узла с минимальным ключом из дерева p
	if (p->left == 0)
		return p->right;
	p->left = removemin(p->left);
	return balance(p);
}

// Удаление заданного элемента из AVL дерева
// с полным сохранением балансировки.
// на возвращаемое значение можно не обращать внимания.
node_AVL* remove_AVL(node_AVL* p, data_BalTree k)
{
	// Отношение порядка определено 
	// для структуры из трёх целых чисел.
	// удаление ключа k из дерева p
	if (p == 0) return 0;
	// Двоичный поиск нужного элемента.
	if (k.countsosed < p->key.countsosed)
		p->left = remove_AVL(p->left, k);
	else if (k.countsosed>p->key.countsosed)
		p->right = remove_AVL(p->right, k);
	else if (k.i < p->key.i)
		p->left = remove_AVL(p->left, k);
	else if (k.i>p->key.i)
		p->right = remove_AVL(p->right, k);
	//else if (k.ii < p->key.ii)
		//p->left = remove_AVL(p->left, k);
	//else if (k.ii>p->key.ii)
		//p->right = remove_AVL(p->right, k);
	else // k==p->key
	{
		node_AVL* q = p->left;
		node_AVL* r = p->right;
		delete p;
		p = 0;
		if (r == 0) return q;
		node_AVL* min = findmin(r);
		min->right = removemin(r);
		min->left = q;
		return balance(min);
	}

	// При выходе из рекурсии делаем балансировку.
	return balance(p);
}

// Вставка ключа К в дерево если ключа k_search
// еще нет в дереве или модификация ключа К_search на К.
// Возвращает новое значение корня АВЛ дерева.
node_AVL* insert_and_modify(node_AVL* p, data_BalTree k, data_BalTree k_search)
{
	if (isfound(p, k_search) == false) {
		//   узла в дереве нет.
		p = insert(p, k);
		return p;
	}
	else {
		// удаление k_search
		p = remove_AVL(p, k_search); // необходимое действие
									 //remove_AVL(p, k_search); // приводит к ошибке.
		p = insert(p, k);							 // вставка к.
			return p;
	}
}

// print_AVL for debug.
void print_AVL(node_AVL* p)
{
	if (p != 0) {
		print_AVL(p->left);
		for (integer i = 0; i <= p->height; i++) {
			printf(" ");
		}
#if doubleintprecision == 1
		//printf("%lld %lld %lld\n", p->key.countsosed, p->key.i, p->key.ii);
		printf("%lld %lld\n", p->key.countsosed, p->key.i);
#else
		//printf("%d %d %d\n", p->key.countsosed, p->key.i, p->key.ii);
		printf("%d %d\n", p->key.countsosed, p->key.i);
#endif
		
		print_AVL(p->right);
	}
} // print_AVL

  // тестирование АВЛ дерева
  // 12 декабря 2015 удовлетворительно.
void test_AVL()
{
	node_AVL* root = 0;
	data_BalTree d3;
	d3.countsosed = rand();
	d3.i = rand();
	//d3.ii = rand();
	root = remove_AVL(root, d3);
	for (integer i = 0; i < 10; i++)
	{
		data_BalTree d;
		d.countsosed = rand();
		d.i = rand();
		//d.ii = rand();
		root = insert_and_modify(root, d, d);
		print_AVL(root);
		if (i == 5) {

			//41 18467 6334


			data_BalTree d1;
			d1.countsosed = 41;
			d1.i = 18467;
			//d1.ii = 6334;
			data_BalTree d2;
			d2.countsosed = rand();
			d2.i = rand();
			//d2.ii = rand();
			root = insert_and_modify(root, d2, d1);
			print_AVL(root);
			printf("remove 41 18467 6334\n");
			root = remove_AVL(root, d1);
			print_AVL(root);
			printf("found max\n");
			node_AVL* emax;
			emax = findmax(root);
#if doubleintprecision == 1
			printf("maximum id %lld\n", emax->key.countsosed);
#else
			printf("maximum id %d\n", emax->key.countsosed);
#endif
			
			emax = 0;
			//clear_AVL(root);
			//root = 0;
			print_AVL(root);
		}

		system("pause");
	}
	system("pause");
}



// Конец данных и методов используемых в АВЛ дереве.

// Красночерное дерево поиска НАЧАЛО.
// ссылка
// красно-черное дерево c++ реализация в поисковике yandex.
// http://www.cyberforum.ru/cpp-beginners/thread1009501.html
// 22.06.2018.

class RBtree {
	struct node_st { node_st *p1=NULL, *p2=NULL; data_BalTree value; bool red; }; // структура узла
	node_st *tree_root=NULL;                 //!< корень
	integer nodes_count=0;                    //!< число узлов дерева
private:
	node_st * NewNode(data_BalTree value);        //!< выделение новой вешины
	void DelNode(node_st*);             //!< удаление вершины
	void Clear(node_st*);               //!< снос дерева (рекурсивная часть)
	node_st *Rotate21(node_st*);        //!< вращение влево
	node_st *Rotate12(node_st*);        //!< вращение вправо
	void BalanceInsert(node_st**);      //!< балансировка вставки
	bool BalanceRemove1(node_st**);     //!< левая балансировка удаления
	bool BalanceRemove2(node_st**);     //!< правая балансировка удаления
	bool Insert(data_BalTree, node_st**);         //!< рекурсивная часть вставки
	bool GetMin(node_st**, node_st**);   //!< найти и убрать максимальный узел поддерева
	bool Remove(node_st**, data_BalTree);         //!< рекурсивная часть удаления
public: // отладочная часть
	enum check_code { error_balance, error_struct, ok }; // код ошибки
	void Show();                        //!< вывод дерева
										//check_code Check();                 //!< проверка дерева
										//bool TreeWalk(bool*, integer);           //!< обход дерева и сверка значений с массивом
private: // отладочная часть
	void Show(node_st*, integer, char);       //!< вывод дерева, рекурсивная часть
											  //check_code Check(node_st*, integer, integer&);//!< проверка дерева (рекурсивная часть)
											  //bool TreeWalk(node_st*, bool*, integer);  //!< обход дерева и сверка значений с массивом (рекурсивная часть)
public:
	RBtree();
	~RBtree();
	void Clear();           //!< снести дерево              
	bool Find(data_BalTree);         //!< найти значение
	void Insert(data_BalTree);       //!< вставить значение
	void Remove(data_BalTree);       //!< удалить значение
	void InsertAndModify(data_BalTree, data_BalTree); //!< вставить если нет элемента, модифицировать существующий элемент если он уже есть.
	integer GetNodesCount();    //!< узнать число узлов
	data_BalTree GetMaxElm(); //!< возвращает максимальный элемент в дереве.
};

//!< возвращает максимальный элемент в дереве.
data_BalTree RBtree::GetMaxElm() {
	if (tree_root) {
		node_st *node = tree_root;
		node_st *p2_loc = tree_root->p2;
		if (p2_loc != NULL) {
			while (p2_loc != NULL) {
				node = p2_loc;
				p2_loc = p2_loc->p2;
			}
			data_BalTree ir = node->value;
			node = NULL;
			p2_loc = NULL;
			return ir;
		}
		else {
			data_BalTree ir = node->value;
			node = NULL;
			return ir;
		}
	}
	else {
		printf("Red - Black tree is empty...\n");
		//getchar();
		//exit(1);
		data_BalTree ir;
		ir.countsosed = -1;
		ir.i = -1;
		return ir;
	}

} // GetMaxElm

// Конструктор.
RBtree::RBtree()
{
	tree_root = NULL;
	nodes_count = 0;
}

// деструктор.
RBtree::~RBtree()
{
	Clear(tree_root);
}

integer RBtree::GetNodesCount()
{
	return nodes_count;
}

// выделение новой вершины
RBtree::node_st *RBtree::NewNode(data_BalTree value)
{
	nodes_count++;
	node_st *node = new node_st;
	node->value = value;
	node->p1 = node->p2 = NULL;
	node->red = true;
	return node;
}

// удаление вершины
void RBtree::DelNode(node_st *node)
{
	nodes_count--;
	delete node;
}

// снос дерева (рекурсивная часть)
void RBtree::Clear(node_st *node)
{
	if (!node) return;
	Clear(node->p1);
	Clear(node->p2);
	DelNode(node);
}

// вывод дерева, рекурсивная часть
//! \param node узел
//! \param depth глубина
//! \param dir   значёк
//! \code Show(root,0,'*'); \endcode
void RBtree::Show(node_st *node, integer depth, char dir)
{
	integer n;
	if (!node) return;
	for (n = 0; n<depth; n++) putchar(' ');
	printf("%c[%lld %lld] (%s)\n", dir, node->value.i, node->value.countsosed, node->red ? "red" : "black");
	Show(node->p1, depth + 2, '-');
	Show(node->p2, depth + 2, '+');
}


// вращение влево
//! \param index индеск вершины
//! \result новая вершина дерева
RBtree::node_st *RBtree::Rotate21(node_st *node)
{
	node_st *p2 = node->p2;
	node_st *p21 = p2->p1;
	p2->p1 = node;
	node->p2 = p21;
	return p2;
}

// вращение вправо
//! \param index индеск вершины
//! \result новая вершина дерева
RBtree::node_st *RBtree::Rotate12(node_st *node)
{
	node_st *p1 = node->p1;
	node_st *p12 = p1->p2;
	p1->p2 = node;
	node->p1 = p12;
	return p1;
}


// балансировка вершины
void RBtree::BalanceInsert(node_st **root)
{
	node_st *p1, *p2, *px1, *px2;
	node_st *node = *root;
	if (node->red) return;
	p1 = node->p1;
	p2 = node->p2;
	if ((p1 != NULL) && p1->red) {
		px2 = p1->p2;             // задача найти две рядом стоящие красные вершины
		if ((px2 != NULL) && px2->red) p1 = node->p1 = Rotate21(p1);
		px1 = p1->p1;
		if ((px1 != NULL) && px1->red) {
			node->red = true;
			p1->red = false;
			if ((p2 != NULL) && p2->red) { // отделаемся перекраской вершин
				px1->red = true;
				p2->red = false;
				return;
			}
			*root = Rotate12(node);
			return;
		}
	}
	// тоже самое в другую сторону
	if ((p2 != NULL) && p2->red) {
		px1 = p2->p1;             // задача найти две рядом стоящие красные вершины
		if ((px1 != NULL) && px1->red) p2 = node->p2 = Rotate12(p2);
		px2 = p2->p2;
		if ((px2 != NULL) && px2->red) {
			node->red = true;
			p2->red = false;
			if ((p1 != NULL) && p1->red) { // отделаемся перекраской вершин
				px2->red = true;
				p1->red = false;
				return;
			}
			*root = Rotate21(node);
			return;
		}
	}
}


bool RBtree::BalanceRemove1(node_st **root)
{
	node_st *node = *root;
	node_st *p1 = node->p1;
	node_st *p2 = node->p2;
	if ((p1!=NULL) && (p1->red)) {
		p1->red = false; return false;
	}
	if ((p2!=NULL) && (p2->red)) { // случай 1
		node->red = true;
		p2->red = false;
		node = *root = Rotate21(node);
		if (BalanceRemove1(&node->p1)) node->p1->red = false;
		return false;
	}
	unsigned int mask = 0;
	node_st *p21 = NULL;
	node_st *p22 = NULL;
	if (p2 != NULL) {
		p21 = p2->p1;
		p22 = p2->p2;
	}

	if ((p21 != NULL) && (p21->red)) mask |= 1;
	if ((p22 != NULL) && (p22->red)) mask |= 2;
	switch (mask)
	{
	case 0:     // случай 2 - if((!p21 || !p21->red) && (!p22 || !p22->red))
		p2->red = true;
		return true;
	case 1:
	case 3:     // случай 3 - if(p21 && p21->red)
		p2->red = true;
		p21->red = false;
		p2 = node->p2 = Rotate12(p2);
		p22 = p2->p2;
	case 2:     // случай 4 - if(p22 && p22->red)
		p2->red = node->red;
		p22->red = node->red = false;
		*root = Rotate21(node);
	}
	return false;
}

bool RBtree::BalanceRemove2(node_st **root)
{
	node_st *node = *root;
	node_st *p1 = node->p1;
	node_st *p2 = node->p2;
	if ((p2 != NULL) && p2->red) { p2->red = false; return false; }
	if ((p1 != NULL) && p1->red) { // случай 1
		node->red = true;
		p1->red = false;
		node = *root = Rotate12(node);
		if (BalanceRemove2(&node->p2)) node->p2->red = false;
		return false;
	}
	unsigned int mask = 0;
	node_st *p11 = NULL;
	node_st *p12 = NULL;

	if (p1 != NULL) {
		p11 = p1->p1;
		p12 = p1->p2;
	}

	if ((p11 != NULL) && p11->red) mask |= 1;
	if ((p12 != NULL) && p12->red) mask |= 2;
	switch (mask) {
	case 0:     // случай 2 - if((!p12 || !p12->red) && (!p11 || !p11->red))
		p1->red = true;
		return true;
	case 2:
	case 3:     // случай 3 - if(p12 && p12->red)
		p1->red = true;
		p12->red = false;
		p1 = node->p1 = Rotate21(p1);
		p11 = p1->p1;
	case 1:     // случай 4 - if(p11 && p11->red)
		p1->red = node->red;
		p11->red = node->red = false;
		*root = Rotate12(node);
	}
	return false;
}


bool RBtree::Find(data_BalTree value)
{
	node_st *node = tree_root;
	while (node != NULL) {
		if ((node->value.i == value.i) && (node->value.countsosed == value.countsosed)) return true;
		//node = node->value>value ? node->p1 : node->p2;
		if (value.countsosed < node->value.countsosed)
			node = node->p1;
		else if (value.countsosed >node->value.countsosed)
			node = node->p2;
		else if (value.i < node->value.i)
			node = node->p1;
		else if (value.i > node->value.i)
			node = node->p2;
	}
	return false;
}


// рекурсивная часть вставки
//! \result true если изменений небыло или балансировка в данной вершине не нужна
bool RBtree::Insert(data_BalTree value, node_st **root)
{
	node_st *node = *root;
	if (node == NULL) *root = NewNode(value);
	else {
		if ((node->value.i == value.i) && (node->value.countsosed == value.countsosed))  return true; 
		//if (Insert(value, value<node->value ? &node->p1 : &node->p2)) return true; 
		if (value.countsosed < node->value.countsosed) {
			if (Insert(value, &node->p1))  return true; 
		}
		else if (value.countsosed > node->value.countsosed) {
			if (Insert(value, &node->p2))  return true; 
		}
		else if (value.i < node->value.i) {
			if (Insert(value, &node->p1)) return true; 
		}
		else if (value.i > node->value.i) {
			if (Insert(value, &node->p2))  return true; 
		}

		BalanceInsert(root);
	}
	
	return false;
}


// найти и убрать максимальный узел поддерева
//! \param root корень дерева в котором надо найти элемент
//! \retval res эелемент который был удалён
//! \result true если нужен баланс
bool RBtree::GetMin(node_st **root, node_st **res)
{
	node_st *node = *root;
	if (node->p1 != NULL) {
		if (GetMin(&node->p1, res)) return BalanceRemove1(root);
	}
	else {
		*root = node->p2;
		*res = node;
		return !node->red;
	}
	return false;
}


// рекурсивная часть удаления
//! \result true если нужен баланс
bool RBtree::Remove(node_st **root, data_BalTree value)
{
	node_st *t, *node = *root;
	if (node==NULL) return false;
	if ((node->value.countsosed<value.countsosed) || ((node->value.countsosed == value.countsosed) && (node->value.i<value.i))) {
		if (Remove(&node->p2, value)) return BalanceRemove2(root);
	}
	else if ((node->value.countsosed>value.countsosed) || ((node->value.countsosed == value.countsosed) && (node->value.i>value.i))) {
		if (Remove(&node->p1, value)) return BalanceRemove1(root);
	}
	else {
		bool res;
		if (node->p2==NULL) {
			*root = node->p1;
			res = !node->red;
		}
		else {
			res = GetMin(&node->p2, root);
			t = *root;
			t->red = node->red;
			t->p1 = node->p1;
			t->p2 = node->p2;
			if (res) res = BalanceRemove2(root);
		}
		DelNode(node);
		return res;
	}
	return 0;
}


// вывод дерева
void RBtree::Show()
{
	printf("[tree]\n");
	Show(tree_root, 0, '*');
}

// функция вставки
void RBtree::Insert(data_BalTree value)
{
	Insert(value, &tree_root);
	if (tree_root) tree_root->red = false;
}

// удаление узла
void RBtree::Remove(data_BalTree value)
{
	Remove(&tree_root, value);
}

// снос дерева
void RBtree::Clear()
{
	Clear(tree_root);
	tree_root = 0;
}

//!< вставить если нет элемента, модифицировать существующий элемент если он уже есть.
void RBtree::InsertAndModify(data_BalTree value, data_BalTree ksearch) {

	if (Find(ksearch)) {
		// Обект уже существует
		Remove(ksearch);
		// Замена ksearch на value.
		Insert(value);
	}
	else {
		// Объекта не существует
		Insert(value);
	}
}

/*
// проверка дерева (рекурсивная часть)
//! \param tree дерево
//! \param d    текущая чёрная глубина
//! \param h    эталонная чёрная глубина
//! \result 0 или код ошибки
RBtree::check_code RBtree::Check(node_st *tree, integer d, integer &h)
{
if (!tree) {
// количество чёрных вершин на любом пути одинаковое
if (h<0) h = d;
return h == d ? ok : error_balance;
}
node_st *p1 = tree->p1;
node_st *p2 = tree->p2;
// красная вершина должна иметь чёрных потомков
if (tree->red && (p1 && p1->red || p2 && p2->red)) return error_struct;
if (p1 && tree->value<p1->value || p2 && tree->value>p2->value) return error_struct;
if (!tree->red) d++;
check_code n = Check(p1, d, h); if (n) return n;
return Check(p2, d, h);
}


// проверка дерева
RBtree::check_code RBtree::Check()
{
integer d = 0;
integer h = -1;
if (!tree_root) return ok;
if (tree_root->red) return error_struct;
return Check(tree_root, d, h);
}

// обход дерева и сверка значений с массивом (рекурсивная часть)
//! \param node  корень дерева
//! \param array массив для сверки
//! \param size  размер массива
bool RBtree::TreeWalk(node_st *node, bool *array, integer size)
{
if (!node) return false;
integer value = node->value;
if (value<0 || value >= size || !array[value]) return true;
array[value] = false;
return TreeWalk(node->p1, array, size) || TreeWalk(node->p2, array, size);
}

// обход дерева и сверка значений с массивом
//! \param array массив для сверки
//! \param size  размер массива
bool RBtree::TreeWalk(bool *array, integer size)
{
if (TreeWalk(tree_root, array, size)) return true;
for (integer n = 0; n<size; n++) if (array[n]) return true;
return false;
}
*/

//================================================================


void test_Red_Black_Tree() {
	RBtree root;
	data_BalTree d3;
	d3.countsosed = rand();
	d3.i = rand();
	root.Insert(d3);
	//root.Show();
	d3.countsosed = rand();
	d3.i = rand();
	root.Insert(d3);
	//root.Show();
	d3.countsosed = rand();
	d3.i = rand();
	root.Insert(d3);
	d3.countsosed = rand();
	d3.i = rand();
	root.Insert(d3);
	root.Show();
	d3 = (root.GetMaxElm());
	printf("i==%lld countsosed==%lld\n", d3.i, d3.countsosed);
	d3.countsosed = rand();
	d3.i = rand();
	root.Insert(d3);
	root.Show();
	d3.i = rand();
	root.Insert(d3);
	d3.i = rand();
	root.Insert(d3);
	d3.i = rand();
	root.Insert(d3);
	d3.i = rand();
	d3 = (root.GetMaxElm());
	printf("i==%lld countsosed==%lld\n", d3.i, d3.countsosed);
	root.Remove(d3);

	d3 = (root.GetMaxElm());
	printf("i==%lld countsosed==%lld\n", d3.i, d3.countsosed);
	root.Show();
	system("pause");
}

// Красночерное дерево поиска КОНЕЦ.

// Рандомизированное дерево двоичного поиска.
// Достоинства: Простота и понятность реализации при обеспечении логарифмической сложности операций.
// 24 august 2017
// По материалам статьи с хабрахабра: 7 июня 2012 в 23:43 Рандомизированные деревья поиска

//Дерамида (объединение дерева и двоичной кучи). Сидель (Siedel) и Арагон (Aragon) 1996г.
// Имеет опыт использования в качестве базовой структуры в тщательно проработанной библиотеке LEDA.
// Описание заимствовано с сайта GeeksForGeeks.
// Amat Treap Node
struct TreapNode
{
	integer  priority;
	data_BalTree key;
	TreapNode *left, *right;
};

/* T1, T2 and T3 are subtrees of the tree rooted with y
(on left side) or x (on right side)
y                               x
/ \     Right Rotation          /  \
x   T3   – – – – – – – >        T1   y
/ \       < - - - - - - -            / \
T1  T2     Left Rotation            T2  T3 */

// Amat utility function to right rotate subtree rooted with y
// See the diagram given above.
TreapNode *rightRotate(TreapNode *y)
{
	TreapNode *x = y->left, *T2 = x->right;

	// Perform rotation
	x->right = y;
	y->left = T2;

	// Return new root
	return x;
}

// Amat utility function to left rotate subtree rooted with x
// See the diagram given above.
TreapNode *leftRotate(TreapNode *x)
{
	TreapNode *y = x->right, *T2 = y->left;

	// Perform rotation
	y->left = x;
	x->right = T2;

	// Return new root
	return y;
}

/* Utility function to add a new key */
TreapNode* newNode(data_BalTree key)
{
	TreapNode* temp = new TreapNode;
	temp->key = key;
	//temp->priority = rand() % 100;
	//temp->priority = rand() % 200;
	//temp->priority = rand() % 65536;
	temp->priority = rand();
	temp->left = temp->right = NULL;
	return temp;
}

// C function to search a given key in a given BST
TreapNode* search_recursive(TreapNode* root, data_BalTree key)
{
	// Base Cases: root is null or key is present at root
	if (root == NULL || (root->key.i == key.i&&root->key.countsosed == key.countsosed))
		return root;

	// Key is greater than root's key
	if (root->key.countsosed < key.countsosed)
		return search_recursive(root->right, key);

	// Key is smaller than root's key
	if (root->key.countsosed > key.countsosed)
	return search_recursive(root->left, key);

	// Key is greater than root's key
	if (root->key.i < key.i)
		return search_recursive(root->right, key);

	// Key is smaller than root's key
	return search_recursive(root->left, key);
}

// Итеративный вариант должен бфыть быстрее.
// C function to search a given key in a given BST
TreapNode* search(TreapNode* root, data_BalTree key)
{

	TreapNode* scan = root;

	for (;;) {

		// Base Cases: root is null or key is present at root
		if (scan == NULL || (scan->key.i == key.i&&scan->key.countsosed == key.countsosed)) {
			return scan;
		}
			

		// Key is greater than root's key
		if (scan->key.countsosed < key.countsosed) {
			scan = scan->right;
		}

		// Key is smaller than root's key
		else if (scan->key.countsosed > key.countsosed)
		{
			scan = scan->left;
		}

		// Key is greater than root's key
		else if (scan->key.i < key.i) {
			scan = scan->right;
		}

		// Key is smaller than root's key
		else {
			scan = scan->left;
		}
	}
}


/* Recursive implementation of insertion in Treap */
TreapNode* insert(TreapNode* root, data_BalTree key)
{
	// If root is NULL, create a new node and return it
	if (!root)
		return newNode(key);

	// If key is smaller than root
	if (key.countsosed < root->key.countsosed)
	{
		// Insert in left subtree
		root->left = insert(root->left, key);

		// Fix Heap property if it is violated
		if (root->left->priority > root->priority)
			root = rightRotate(root);
	}
	else if (key.countsosed > root->key.countsosed) // If key is greater
	{
		// Insert in right subtree
		root->right = insert(root->right, key);

		// Fix Heap property if it is violated
		if (root->right->priority > root->priority)
			root = leftRotate(root);
	}
	else if (key.i <= root->key.i)
	{
		// Insert in left subtree
		root->left = insert(root->left, key);

		// Fix Heap property if it is violated
		if (root->left->priority > root->priority)
			root = rightRotate(root);
	}
	else  // If key is greater
	{
		// Insert in right subtree
		root->right = insert(root->right, key);

		// Fix Heap property if it is violated
		if (root->right->priority > root->priority)
			root = leftRotate(root);
	}
	return root;
}

/* Recursive implementation of Delete() */
TreapNode* deleteNode(TreapNode* root, data_BalTree key)
{
	if (root == NULL)
		return root;

	if (key.countsosed < root->key.countsosed)
		root->left = deleteNode(root->left, key);
	else if (key.countsosed > root->key.countsosed)
		root->right = deleteNode(root->right, key);
	else if (key.i < root->key.i)
		root->left = deleteNode(root->left, key);
	else if (key.i > root->key.i)
		root->right = deleteNode(root->right, key);

	// IF KEY IS AT ROOT

	// If left is NULL
	else if (root->left == NULL)
	{
		TreapNode *temp = root->right;
		delete(root);
		root = temp;  // Make right child as root
	}

	// If Right is NULL
	else if (root->right == NULL)
	{
		TreapNode *temp = root->left;
		delete(root);
		root = temp;  // Make left child as root
	}

	// If ksy is at root and both left and right are not NULL
	else if (root->left->priority < root->right->priority)
	{
		root = leftRotate(root);
		root->left = deleteNode(root->left, key);
	}
	else
	{
		root = rightRotate(root);
		root->right = deleteNode(root->right, key);
	}

	return root;
}

// Amat utility function to print tree
void inorder(TreapNode* root)
{
	if (root)
	{
		inorder(root->left);
		printf("key: i= %lld, countsosed = %lld  | priority: %lld ", root->key.i, root->key.countsosed, root->priority);
		if (root->left)
			printf(" | left child: i= %lld, countsosed = %lld ", root->left->key.i, root->key.countsosed);
		if (root->right)
			printf(" | right child: i= %lld, countsosed = %lld \n", root->right->key.i, root->key.countsosed);
		inorder(root->right);
	}
}


// Полное удаление бинарного радномизированного дерева поиска.
void clear_random_tree(TreapNode* root)
{
	if (root != NULL) {
		clear_random_tree(root->left);
		clear_random_tree(root->right);
		// удаляем лист.
		delete root;
		//free(p);
		root = NULL;
	}
} // clear_random_tree

TreapNode* findmax_random_tree(TreapNode* &p)
{
	TreapNode* p1 = p;
	// поиск узла с минимальным ключём в дереве p
	if (p1 != NULL) {
		//return p1->right ? findmax_random_tree(p1->right) : p1;
		while (p1->right != NULL) p1 = p1->right;
		TreapNode* q = new TreapNode;
		q->key = p1->key;
		p1 = NULL;
		return q;
	}
	else {
		// На поиск максимума подан нулевой указатель.
		return NULL;
	}
} // findmax

// Driver Program to test above functions
/*
int test_Treap()
{
	srand(time(NULL));

	struct TreapNode *root = NULL;
	root = insert(root, 50);
	root = insert(root, 30);
	root = insert(root, 20);
	root = insert(root, 40);
	root = insert(root, 70);
	root = insert(root, 60);
	root = insert(root, 80);

	printf("Inorder traversal of the given tree \n");
	inorder(root);

	printf("\nDelete 20\n";
	root = deleteNode(root, 20);
	printf("Inorder traversal of the modified tree \n");
	inorder(root);

	printf("\nDelete 30\n";
	root = deleteNode(root, 30);
	printf("Inorder traversal of the modified tree \n");
	inorder(root);

	printf("\nDelete 50\n");
	root = deleteNode(root, 50);
	printf("Inorder traversal of the modified tree \n");
	inorder(root);

	TreapNode *res = search(root, 50);
	(res == NULL) ? printf("\n50 Not Found "):
		printf("\n50 found");

	return 0;
}
*/

/*
struct node_random_tree // структура для представления узлов дерева
{//+
	data_BalTree key;
	integer size;
	node_random_tree* left;
	node_random_tree* right;
	node_random_tree(data_BalTree k) { key = k; left = right = 0; size = 1; }
};

//+
// Обычный двоичный поиск.
node_random_tree* find_random_tree(node_random_tree* p, data_BalTree k) // поиск ключа k в дереве p
{
					   

	node_random_tree* q = p;

	for (;;) {
		if (p == NULL) break;  // не найден.
		else if (k.countsosed < p->key.countsosed) {
			p = p->left;
		}
		else if (k.countsosed > p->key.countsosed) {
			p = p->right;
		}
		else if (k.i < p->key.i) {
			p = p->left;
		}
		else if (k.i > p->key.i) {
			p = p->right;
		}
		//else if (k.ii < p->item.ii)
		//return isfound(p->left, k);
		//else if (k.ii > p->item.ii)
		//return isfound(p->right, k);
		else break; // найден.
	}

	if (p == NULL) {
		p = q;
		q = NULL;
		return NULL;
	}
	else {
		node_random_tree* q1 = new node_random_tree(p->key);
		p = q;
		q = NULL;
		return q1;
	}

} // find_random_tree

//+
integer getsize_random_tree(node_random_tree* p) // обертка для поля size, работает с пустыми деревьями (t=NULL)
{
	if (p==NULL) return 0;
	return p->size;
}

//+
void fixsize_random_tree(node_random_tree* &p) // установление корректного размера дерева
{
	if (p!=NULL) p->size = getsize_random_tree(p->left) + getsize_random_tree(p->right) + 1;
}

//+
void insert_random_tree(node_random_tree* &p, data_BalTree k) // классическая вставка нового узла с ключом k в дерево p
{
	if (p == NULL) {
		p = new node_random_tree(k);
	}
	else {

		if (k.countsosed < p->key.countsosed)
			 insert_random_tree(p->left, k);
		else if (k.countsosed > p->key.countsosed)
			 insert_random_tree(p->right, k);
		else if (k.i < p->key.i)
			 insert_random_tree(p->left, k);
		else if (k.i > p->key.i)
			 insert_random_tree(p->right, k);

		fixsize_random_tree(p);
		
	}
} // insert_random_tree

//+
void rotateright_random_tree(node_random_tree* &p) // правый поворот вокруг узла p
{
	if (p == NULL || p->left == NULL) {
		// ничего не делаем.
	}
	else {
		node_random_tree* q = p->left;
		if (q != NULL) {
			p->left = q->right;
			q->right = p;			
			fixsize_random_tree(p);
			fixsize_random_tree(q);
		}
	}
} // rotateright_random_tree

//+
void rotateleft_random_tree(node_random_tree* &q) // левый поворот вокруг узла q
{
	if (q == NULL || q->right == NULL) {
		// ничего не делаем.
	}
	else {
		node_random_tree* p = q->right;
		if (p != NULL) {
			q->right = p->left;
			p->left = q;
			p->size = q->size;
			fixsize_random_tree(p);
			fixsize_random_tree(q);
		}
	}
} // rotateleft_random_tree

void insertroot_random_tree(node_random_tree* &p, data_BalTree k) // вставка нового узла с ключом k в корень дерева p 
{
	if (p == NULL) {
		//return new node_random_tree(k);
		p=new node_random_tree(k);
	}
	else {

		if (k.countsosed < p->key.countsosed) {
			insertroot_random_tree(p->left, k);
		    rotateright_random_tree(p);
		}
		else if (k.countsosed > p->key.countsosed) {
			insertroot_random_tree(p->right, k);
			rotateleft_random_tree(p);
		}
		else if (k.i < p->key.i) {
			insertroot_random_tree(p->left, k);
			rotateright_random_tree(p);
		}
		else if (k.i > p->key.i) {
			insertroot_random_tree(p->right, k);
			rotateleft_random_tree(p);
		}

		fixsize_random_tree(p);
	}

}// insertroot_random_tree


void insert_work_random_tree(node_random_tree* &p, data_BalTree k) // рандомизированная вставка нового узла с ключом k в дерево p
{
	if (p == NULL) { p = new node_random_tree(k);  }
	else {
		if (rand() < RAND_MAX / (p->size + 1)) {
			insertroot_random_tree(p, k);
		}
		else {

			if (k.countsosed < p->key.countsosed)
				insert_work_random_tree(p->left, k);
			else if (k.countsosed > p->key.countsosed)
				insert_work_random_tree(p->right, k);
			else if (k.i < p->key.i)
				insert_work_random_tree(p->left, k);
			else if (k.i > p->key.i)
				insert_work_random_tree(p->right, k);

		}
		fixsize_random_tree(p);
	}
} // insert_work_random_tree

node_random_tree* join_random_tree_base(node_random_tree* &p, node_random_tree* &q) // объединение двух деревьев
{
	if (p == NULL) return q;
	if (q == NULL) return p;

	insert_work_random_tree(q, p->key);
	q->left = join_random_tree_base(p->left,q->left);
	q->right= join_random_tree_base(p->right, q->right);
	p->left = NULL;
	p->right = NULL;
	delete p;
	p = NULL;
	fixsize_random_tree(q);
	return q;
}

node_random_tree* join_random_tree(node_random_tree* &p, node_random_tree* &q) // объединение двух деревьев
{
	if (p==NULL) return q;
	if (q==NULL) return p;
	if (rand() /(RAND_MAX/(p->size + q->size) +1)<p->size)
	{
		p->right = join_random_tree_base(p->right, q);
		fixsize_random_tree(p);
		return p;
	}
	else
	{
		q->left = join_random_tree_base(p, q->left);
		fixsize_random_tree(q);
		return q;
	}
} // join_random_tree
*/
/*
node_random_tree* remove_random_tree(node_random_tree* p, data_BalTree k) // удаление из дерева p первого найденного узла с ключом k 
{
	if (p==NULL) return p;

	if (k.countsosed < p->key.countsosed) {
		p->left = remove_random_tree(p->left, k);		
	}
	else if (k.countsosed > p->key.countsosed) {
		p->right = remove_random_tree(p->right, k);		
	}
	else if (k.i < p->key.i) {
		p->left = remove_random_tree(p->left, k);		
	}
	else if (k.i > p->key.i) {
		p->right = remove_random_tree(p->right, k);
	}
	else {
		// ключи равны.
		node_random_tree* q = join_random_tree(p->left, p->right);
		delete p;
		return q;
	}

	return p;
}
*/
/*
void remove_random_tree(node_random_tree* &p, data_BalTree k) //удаление из дерева p первого найденного узла с ключом k
{
	if (p != NULL) {


		node_random_tree* p1 = p;
		//node_random_tree* p1_parent = p;
		bool bleft = true;
	

		for (;;) {
			if (p1 != NULL) {
				if (k.countsosed < p1->key.countsosed) {
					bleft = true;
					//p1_parent = p1;
					 p1 = p1->left;
				}
				else if (k.countsosed > p1->key.countsosed) {
					bleft = false;
					//p1_parent = p1;
				    p1 = p1->right;
				}
				else if (k.i < p1->key.i) {
					bleft = true;
					//p1_parent = p1;
					p1 = p1->left;
				}
				else if (k.i > p1->key.i) {
					 bleft = false;
					 //p1_parent = p1;
					 p1 = p1->right;
				}
			//else if (k.ii < p->item.ii)
			//return isfound(p->left, k);
			//else if (k.ii > p->item.ii)
			//return isfound(p->right, k);
			else if ((p1->key.i == k.i) && (p1->key.countsosed == k.countsosed))  {

				/*if (p1_parent == p1) {

					if ((p1->key.i == k.i)&&(p1->key.countsosed == k.countsosed)) {
						p1 = NULL;
						p1_parent = NULL;
						delete p;
						p = NULL;
					}
				}
				else {*/
/*
					// найден.
					// ключи равны.
					node_random_tree* p1_mem = p1;
					//node_random_tree* q = join_random_tree(p1->left, p1->right);
					p1= join_random_tree(p1->left, p1->right);
					*/
					/*
					if (bleft) {
						p1_parent->left = q;
						q = NULL;
					}
					else {
						p1_parent->right = q;
						q = NULL;
					}
					p1_mem->left = NULL;
					p1_mem->right = NULL;
					delete p1_mem;
					*/
/*
					p1_mem->left = NULL;
					p1_mem->right = NULL;
					delete p1_mem;
					p1_mem = NULL;
					//p1_parent = NULL;
					//p1 = q;
					// досрочный выход из цикла for.
					break;
				//}
			}
			}
			else {
				// досрочный выход из цикла for.
				break; 
			}
		}

	}
}

// Полное удаление бинарного радномизированного дерева поиска.
void clear_random_tree(node_random_tree* &p)
{
	if (p != NULL) {
		clear_random_tree(p->left);
		clear_random_tree(p->right);
		// удаляем лист.
		delete p;
		//free(p);
		p = NULL;
	}
} // clear_random_tree

node_random_tree* findmax_random_tree(node_random_tree* &p)
{
	node_random_tree* p1 = p;
	// поиск узла с минимальным ключём в дереве p
	if (p1 != NULL) {
		//return p1->right ? findmax_random_tree(p1->right) : p1;
		while (p1->right != NULL) p1 = p1->right;
		node_random_tree* q = new node_random_tree(p1->key);
		p1 = NULL;
		return q;
	}
	else {
		// На поиск максимума подан нулевой указатель.
		return NULL;
	}
} // findmax
*/
// Конец данных рандомизированное дерево двоичного поиска.


// Двунаправленный линейный список целочисленных элементов. 
// Может сканироваться как вперёд так и назад.
typedef struct Thashlist_i {
	integer item;
	Thashlist_i* next;
	Thashlist_i* prev;
} hashlist_i;

// вставка целочисленного ключа в список
void insertion_list_i(hashlist_i* &p, integer d) {
	if (p == NULL) {
		p = new hashlist_i;
		if (p == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for p in insertion hashlist_i my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		p->prev = NULL;
		p->next = NULL;
		p->item = d;
	}
	else {
		hashlist_i* scanner = p;
		hashlist_i* r = NULL;
		r = new hashlist_i;
		if (r == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for r in insertion hashlist_i my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		r->prev = NULL;
		r->next = scanner;
		r->item = d;
		scanner->prev = r;
		p = r;
		r = NULL;
		scanner = NULL;
	}
} // insertion_list_i

  // очистка списка
  // Вероятно содержит ошибку потому что память не освобождается.
  // TODO 17 dec 2015
  // Проверено 1 января 2017.
void clear_hash_list_i(hashlist_i* &p) {
	if (p != NULL) {
		hashlist_i* head = p;
		p = NULL;

		hashlist_i* r = head;
		while (r != NULL) {
			head = head->next;
			if (head != NULL)  head->prev = NULL;
			r->next = NULL;
			r->prev = NULL;
			delete r;
			r = head;
		}
	}
} // clear_hash_list_i


// 5.01.2017
// Для нахождения множества Strong Transpose нам 
// потребуется хеш таблица АВЛ деревьев. (Лес АВЛ деревьев).
// В литературе пишут что при создании C-F разбиения используют
// именно Strong Transpose множества соседей.
// Поле данных в АВЛ дереве.
struct data_BalTreeST
{
	// --> high priority --> for operation <,>
	integer  i;
	// i есть key.
};

//отношения порядка только в insert и remove

// Узел АВЛ дерева.
struct node_AVLST
{
	data_BalTreeST key;
	// Высота поддерева с корнем в данном узле.
	unsigned char height;
	node_AVLST* left;
	node_AVLST* right;
	// Конструктор.
	node_AVLST(data_BalTreeST k) { key = k; left = right = 0; height = 1; }
};

// Работает также и с пустыми деревьями.
// Обёртка поля height
unsigned char height(node_AVLST* p)
{
	return p ? p->height : 0;
};

// Вычисляет balance factor заданного узла
// работает только с ненулевыми указателями.
integer bfactor(node_AVLST* p)
{
	return height(p->right) - height(p->left);
};

// Восстанавливает корректное значение поля height
// заданного узла (при условии, что значения этого поля 
// в правом и левом дочерних узлах являются корректными).
void fixheight(node_AVLST* p)
{
	unsigned char hl = height(p->left);
	unsigned char hr = height(p->right);
	p->height = (hl > hr ? hl : hr) + 1;
};

// Балансировка узлов.
node_AVLST* rotateright(node_AVLST* p)
{
	// правый поворот вокруг p
	node_AVLST* q = p->left;
	p->left = q->right;
	q->right = p;
	fixheight(p);
	fixheight(q);
	return q;
};

// Левый поворот является симметричной копией правого :
node_AVLST* rotateleft(node_AVLST* q)
{
	// левый поворот вокруг q
	node_AVLST* p = q->right;
	q->right = p->left;
	p->left = q;
	fixheight(q);
	fixheight(p);
	return p;
};

// Код выполняющий балансировку сводится к проверке условий и выполнению поворотов
node_AVLST* balance(node_AVLST* p) // балансировка узла p
{
	fixheight(p);
	if (bfactor(p) == 2)
	{
		if (bfactor(p->right) < 0)
			p->right = rotateright(p->right);
		return rotateleft(p);
	}
	if (bfactor(p) == -2)
	{
		if (bfactor(p->left) > 0)
			p->left = rotateleft(p->left);
		return rotateright(p);
	}
	return p; // балансировка не нужна
}

// Вставка ключей в дерево.
// Возвращает новое значение корня АВЛ дерева.
node_AVLST* insert(node_AVLST* &p, data_BalTreeST k)
{
	// Вставка ключа k в дерево с корнем p
	if (p == NULL) {
		node_AVLST* r1 = NULL;
		r1 = new node_AVLST(k);
		if (r1 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for r1 in insert my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		return r1;
	}
	if (k.i >= p->key.i)
		p->right = insert(p->right, k);
	else	
	    p->left = insert(p->left, k);
	
	return balance(p);
} // insert

  // Возвращает true если узел найден в дереве
bool isfound(node_AVLST* p, data_BalTreeST k)
{
	if (p == NULL) return false; // ненайден.
	if (k.i < p->key.i)
		return isfound(p->left, k);
	else if (k.i > p->key.i)
		return isfound(p->right, k);
	else return true; // найден.
}

// Полное удаление бинарного дерева.
void clear_AVL(node_AVLST* p)
{
	if (p != NULL) {
		clear_AVL(p->left);
		clear_AVL(p->right);
		// удаляем лист.
		delete p;
		p = NULL;
	}
} // clear_AVL

/*
// НЕ РАБОТАЕТ
// Ни в коем случае не раскоментировать. 6 июня 2017.
// Скорее всего нужна parent ссылка.
  // Полное удаление бинарного дерева.
void clear_AVL(node_AVLST* top)
{

	
	node_AVLST* stack[128];
	integer count = 0;

	while (!count == 0 || top != NULL) {
		if (!count == 0) {
			top = stack[count];
			stack[count] = NULL;
			count--;
			if (!count == 0 && top->right == stack[count]) {
				top = stack[count];
				stack[count] = NULL;
				count--;
			}
			else {
				delete top;
				top = NULL;
			}
		}

		while (top != NULL) {
			stack[count++]=top;
			if (top->right != NULL) {
				stack[count++]=(top->right);
				stack[count++] = top;
			}
			top = top->left;
		}
		*/
		/*
		if (p) {
			stack[count++] = p;
			p = p->left;
		}
		else {
			peekn = stack[count];
			if (peekn->right && lnp != peekn->right) {
				p = peekn->right;
			}
			else {

				stack[count] = NULL;
				count--;
				p = stack[count];
				#if doubleintprecision == 1
					//printf("visited %lld\n", peekn->data);
				#else
					//printf("visited %d\n", peekn->data);
				#endif
				
				delete peekn;
				peekn = NULL;
				lnp = peekn;
			}
		}
		*//*
	}

	
	
} // clear_AVL
*/

// Предварительный подсчёт размерности множества set при 
  // передачи списка Si Transpose из АВЛ дерева в множество set.
void formirate_F_SiTranspose_get_num_elements_set(node_AVLST* &p, integer &imarker75_scan)
{
	if (p != NULL) {
		formirate_F_SiTranspose_get_num_elements_set(p->left, imarker75_scan);
		formirate_F_SiTranspose_get_num_elements_set(p->right, imarker75_scan);
		imarker75_scan++;

	}
} // formirate_F_SiTranspose_get_num_elements_set

// Передача списка Si Transpose из АВЛ дерева в множество set.
void formirate_F_SiTranspose(node_AVLST* &p, integer* &set, integer &imarker75_scan)
{
	if (p != NULL) {
		formirate_F_SiTranspose(p->left, set, imarker75_scan);
		formirate_F_SiTranspose(p->right, set, imarker75_scan);
		set[imarker75_scan] = p->key.i;
		imarker75_scan++;

	}
}




  // Удаление узла с занными свойства с сохранением сбалансированности.
node_AVLST* findmin(node_AVLST* p)
{
	// поиск узла с минимальным ключём в дереве p
	//if (!p) {
	return p->left ? findmin(p->left) : p;
	//}
	//else {
	// на поиск минимума подан нулевой указатель.
	//return 0;
	//}
} // findmin

node_AVLST* findmax(node_AVLST* p)
{
	// поиск узла с минимальным ключём в дереве p
	if (p != NULL) {
		return p->right ? findmax(p->right) : p;
	}
	else {
		// На поиск максимума подан нулевой указатель.
		return NULL;
	}
} // findmax

data_BalTreeST get_max_AVL(node_AVLST* p)
{
	// возвращение максимального узла в дереве.
	return p->right ? get_max_AVL(p->right) : p->key;
}

node_AVLST* removemin(node_AVLST* p)
{
	// удаление узла с минимальным ключом из дерева p
	if (p->left == NULL)
		return p->right;
	p->left = removemin(p->left);
	return balance(p);
}

// Удаление заданного элемента из AVL дерева
// с полным сохранением балансировки.
// на возвращаемое значение можно не обращать внимания.
node_AVLST* remove_AVL(node_AVLST* p, data_BalTreeST k)
{
	// Отношение порядка определено 
	// для структуры из трёх целых чисел.
	// удаление ключа k из дерева p
	if (p == NULL) return NULL;
	// Двоичный поиск нужного элемента.
	if (k.i < p->key.i)
		p->left = remove_AVL(p->left, k);
	else if (k.i>p->key.i)
		p->right = remove_AVL(p->right, k);
	else // k==p->key
	{
		node_AVLST* q = p->left;
		node_AVLST* r = p->right;
		delete p;
		p = NULL;
		if (r == NULL) return q;
		node_AVLST* min = findmin(r);
		min->right = removemin(r);
		min->left = q;
		return balance(min);
	}

	// При выходе из рекурсии делаем балансировку.
	return balance(p);
}

// Вставка ключа К в дерево если ключа k_search
// еще нет в дереве или модификация ключа К_search на К.
// Возвращает новое значение корня АВЛ дерева.
node_AVLST* insert_and_modify(node_AVLST* p, data_BalTreeST k, data_BalTreeST k_search)
{
	if (isfound(p, k_search) == false) {
		//   узла в дереве нет.
		p = insert(p, k);
		return p;
	}
	else {
		// удаление k_search
		p = remove_AVL(p, k_search); // необходимое действие
									 //remove_AVL(p, k_search); // приводит к ошибке.
		p = insert(p, k);							 // вставка к.
		return p;
	}
}

// print_AVL for debug.
void print_AVL(node_AVLST* p)
{
	if (p != NULL) {
		print_AVL(p->left);
		for (integer i = 0; i <= p->height; i++) {
			printf(" ");
		}
#if doubleintprecision == 1
		//printf("%lld %lld %lld\n", p->key.countsosed, p->key.i, p->key.ii);
		printf("%lld\n", p->key.i);
#else
		//printf("%d %d %d\n", p->key.countsosed, p->key.i, p->key.ii);
		printf("%d\n", p->key.i);
#endif
		
		print_AVL(p->right);
	}
} // print_AVL

// Возвращает количество узлов в АВЛ дереве.
integer inumber_AVL_node_gl = 0;

// getnumber_AVL_node_local.
void getnumber_AVL_node_local(node_AVLST* p)
{
	if (p != NULL) {
		inumber_AVL_node_gl++;
		getnumber_AVL_node_local(p->left);
		getnumber_AVL_node_local(p->right);
	}
} // getnumber_AVL_node_local.

integer getnumber_AVL_node_global(node_AVLST* p)
{
	inumber_AVL_node_gl = 0;
	getnumber_AVL_node_local(p);
	integer ir = inumber_AVL_node_gl;
	inumber_AVL_node_gl = 0;
	return ir;
}


// getlist_AVL_node_local.
void getlist_AVL_node_local(node_AVLST* p, hashlist_i* &hl)
{
	if (p != NULL) {
		inumber_AVL_node_gl++;
		insertion_list_i(hl, p->key.i);
		getlist_AVL_node_local(p->left,hl);
		getlist_AVL_node_local(p->right,hl);
	}
} // getlist_AVL_node_local.

integer getlist_AVL_node_global(node_AVLST* p, hashlist_i* &hl)
{
	inumber_AVL_node_gl = 0;
	getlist_AVL_node_local(p,hl);
	integer ir = inumber_AVL_node_gl;
	inumber_AVL_node_gl = 0;
	return ir;
} // getlist_AVL_node_global

  // тестирование АВЛ дерева
  // 12 декабря 2015 удовлетворительно.
void test_AVLST()
{
	node_AVLST* root = 0;
	data_BalTreeST d3;
	d3.i = rand();
	root = remove_AVL(root, d3);
	for (integer i = 0; i < 10; i++)
	{
		data_BalTreeST d;
		d.i = rand();
		root = insert_and_modify(root, d, d);
		print_AVL(root);
		if (i == 5) {

			//41 18467 6334


			data_BalTreeST d1;
			d1.i = 18467;
			data_BalTreeST d2;
			d2.i = rand();
			root = insert_and_modify(root, d2, d1);
			print_AVL(root);
			printf("remove 41 18467 6334\n");
			root = remove_AVL(root, d1);
			print_AVL(root);
			printf("found max\n");
			node_AVLST* emax;
			emax = findmax(root);
#if doubleintprecision == 1
			printf("maximum id %lld\n", emax->key.i);
#else
			printf("maximum id %d\n", emax->key.i);
#endif
			
			emax = NULL;
			//clear_AVL(root);
			//root = NULL;
			print_AVL(root);
		}

		system("pause");
	}
	system("pause");
}
// 5.01.2017 Конец реализации леса АВЛ деревьев.

// splay tree 23 01 2016.
// start.splay tree

/*
// 
An implementation of top-down splaying
D. Sleator <sleator@cs.cmu.edu>
March 1992

"Splay trees", or "self-adjusting search trees" are a simple and
efficient data structure for storing an ordered set.  The data
structure consists of a binary tree, without parent pointers, and no
additional fields.  It allows searching, insertion, deletion,
deletemin, deletemax, splitting, joining, and many other operations,
all with amortized logarithmic performance.  Since the trees adapt to
the sequence of requests, their performance on real access patterns is
typically even better.  Splay trees are described in a number of texts
and papers [1,2,3,4,5].

The code here is adapted from simple top-down splay, at the bottom of
page 669 of [3].  It can be obtained via anonymous ftp from
spade.pc.cs.cmu.edu in directory /usr/sleator/public.

The chief modification here is that the splay operation works even if the
item being splayed is not in the tree, and even if the tree root of the
tree is NULL.  So the line:

t = splay(i, t);

causes it to search for item with key i in the tree rooted at t.  If it's
there, it is splayed to the root.  If it isn't there, then the node put
at the root is the last one before NULL that would have been reached in a
normal binary search for i.  (It's a neighbor of i in the tree.)  This
allows many other operations to be easily implemented, as shown below.

[1] "Fundamentals of data structures in C", Horowitz, Sahni,
and Anderson-Freed, Computer Science Press, pp 542-547.
[2] "Data Structures and Their Algorithms", Lewis and Denenberg,
Harper Collins, 1991, pp 243-251.
[3] "Self-adjusting Binary Search Trees" Sleator and Tarjan,
JACM Volume 32, No 3, July 1985, pp 652-686.
[4] "Data Structure and Algorithm Analysis", Mark Weiss,
Benjamin Cummins, 1992, pp 119-130.
[5] "Data Structures, Algorithms, and Performance", Derick Wood,
Addison-Wesley, 1993, pp 367-375.

The following code was written by Daniel Sleator, and is released
in the public domain.
*/

integer size_splay_Tree;  /* number of nodes in the Tree_splay */
/* Not actually needed for any of the operations */

typedef struct Tree_splay_node Tree_splay;
struct Tree_splay_node {
	Tree_splay * left, *right;
	data_BalTree item;
};

Tree_splay* findmax(Tree_splay* p)
{
	// поиск узла с минимальным ключём в дереве p
	if (p != 0) {
		return p->right ? findmax(p->right) : p;
	}
	else {
		// На поиск максимума подан нулевой указатель.
		return 0;
	}
} // findmax

// Возвращает true если узел найден в SPLAY дереве
bool isfound_recursive(Tree_splay* p, data_BalTree k)
{
	if (p == 0) return false; // ненайден.
	if (k.countsosed < p->item.countsosed)
		return isfound_recursive(p->left, k);
	else if (k.countsosed > p->item.countsosed)
		return isfound_recursive(p->right, k);
	else if (k.i < p->item.i)
		return isfound_recursive(p->left, k);
	else if (k.i > p->item.i)
		return isfound_recursive(p->right, k);
	//else if (k.ii < p->item.ii)
	//return isfound_recursive(p->left, k);
	//else if (k.ii > p->item.ii)
	//return isfound_recursive(p->right, k);
	else return true; // найден.
} // isfound_recursive in splay tree.

  // Возвращает true если узел найден в SPLAY дереве
bool isfound(Tree_splay* p1, data_BalTree k)
{
	//if (p == 0) return false; // не найден.
	
	Tree_splay* p;
	p = p1;

	for (;;) {
		if (p == 0) return false; // не найден.
		else if (k.countsosed < p->item.countsosed) {
			p = p->left;
		}
		else if (k.countsosed > p->item.countsosed) {
			p = p->right;
		}
		else if (k.i < p->item.i) {
			p = p->left;
		}
		else if (k.i > p->item.i) {
			p = p->right;
			//else if (k.ii < p->item.ii)
			//return isfound(p->left, k);
			//else if (k.ii > p->item.ii)
			//return isfound(p->right, k);
		}
		else {			
			p = 0;
			return true; // найден.
		}
	}
} // isfound in splay tree.


Tree_splay * splay(data_BalTree i, Tree_splay * t) {
	/* Simple top down splay, not requiring i to be in the Tree_splay t.  */
	/* What it does is described above.							 */
	Tree_splay Nbuf, *l, *r, *y;
	if (t == NULL) return t;
	Nbuf.left = Nbuf.right = NULL;
	l = r = &Nbuf;

	for (;;) {
		if (i.countsosed < t->item.countsosed) {
			if (t->left == NULL) break;
			if ((i.countsosed < t->left->item.countsosed) || ((i.countsosed < t->left->item.countsosed) && (i.i < t->left->item.i)))
			{
				y = t->left;						   /* rotate right */
				t->left = y->right;
				y->right = t;
				t = y;
				if (t->left == NULL) break;
			}
			r->left = t;							   /* link right */
			r = t;
			t = t->left;
		}
		else if (i.countsosed > t->item.countsosed) {
			if (t->right == NULL) break;
			if ((i.countsosed > t->right->item.countsosed) || ((i.countsosed == t->right->item.countsosed) && (i.i > t->right->item.i))) {
				y = t->right;						  /* rotate left */
				t->right = y->left;
				y->left = t;
				t = y;
				if (t->right == NULL) break;
			}
			l->right = t;							  /* link left */
			l = t;
			t = t->right;
		}
		else if (i.i < t->item.i) {
			if (t->left == NULL) break;
			if ((i.countsosed < t->left->item.countsosed) || ((i.countsosed == t->left->item.countsosed) && (i.i < t->left->item.i)))
			{
				y = t->left;						   /* rotate right */
				t->left = y->right;
				y->right = t;
				t = y;
				if (t->left == NULL) break;
			}
			r->left = t;							   /* link right */
			r = t;
			t = t->left;
		}
		else if (i.i > t->item.i) {
			if (t->right == NULL) break;
			if ((i.countsosed > t->right->item.countsosed) || ((i.countsosed == t->right->item.countsosed) && (i.i > t->right->item.i)))
			{
				y = t->right;						  /* rotate left */
				t->right = y->left;
				y->left = t;
				t = y;
				if (t->right == NULL) break;
			}
			l->right = t;							  /* link left */
			l = t;
			t = t->right;
		}
		else {
			break;
		}
	}
	l->right = t->left;								/* assemble */
	r->left = t->right;
	t->left = Nbuf.right;
	t->right = Nbuf.left;
	return t;
}

// Данный метод не используется.
/* Here is how sedgewick would have written this.					*/
/* It does the same thing.										   */
Tree_splay * sedgewickized_splay(data_BalTree i, Tree_splay * t) {
	Tree_splay Nbuf, *l, *r, *y;
	if (t == NULL) return t;
	Nbuf.left = Nbuf.right = NULL;
	l = r = &Nbuf;

	for (;;) {
		if (i.countsosed < t->item.countsosed) {
			if (t->left != NULL && i.countsosed < t->left->item.countsosed) {
				y = t->left; t->left = y->right; y->right = t; t = y;
			}
			else if (t->left != NULL && i.countsosed == t->left->item.countsosed && i.i < t->left->item.i) {
				y = t->left; t->left = y->right; y->right = t; t = y;
			}
			if (t->left == NULL) break;
			r->left = t; r = t; t = t->left;
		}
		else if (i.countsosed > t->item.countsosed) {
			if (t->right != NULL && i.countsosed > t->right->item.countsosed) {
				y = t->right; t->right = y->left; y->left = t; t = y;
			}
			else if (t->right != NULL && i.countsosed == t->right->item.countsosed && i.i > t->right->item.i) {
				y = t->right; t->right = y->left; y->left = t; t = y;
			}
			if (t->right == NULL) break;
			l->right = t; l = t; t = t->right;
		}
		else if (i.i < t->item.i) {
			if (t->left != NULL && i.countsosed < t->left->item.countsosed) {
				y = t->left; t->left = y->right; y->right = t; t = y;
			}
			else if (t->left != NULL && i.countsosed == t->left->item.countsosed && i.i < t->left->item.i) {
				y = t->left; t->left = y->right; y->right = t; t = y;
			}
			if (t->left == NULL) break;
			r->left = t; r = t; t = t->left;
		}
		else if (i.i > t->item.i) {
			if (t->right != NULL && i.countsosed > t->right->item.countsosed) {
				y = t->right; t->right = y->left; y->left = t; t = y;
			}
			else if (t->right != NULL && i.countsosed == t->right->item.countsosed && i.i > t->right->item.i) {
				y = t->right; t->right = y->left; y->left = t; t = y;
			}
			if (t->right == NULL) break;
			l->right = t; l = t; t = t->right;
		}
		else break;
	}
	l->right = t->left; r->left = t->right; t->left = Nbuf.right; t->right = Nbuf.left;
	return t;
}

Tree_splay * insert(data_BalTree i, Tree_splay * t) {
	/* Insert i into the Tree_splay t, unless it's already there.	*/
	/* Return a pointer to the resulting Tree_splay.				 */
	Tree_splay * new_splay_node=NULL;

	new_splay_node = (Tree_splay *)malloc(sizeof(Tree_splay));
	if (new_splay_node == NULL) {
		printf("Ran out of space in SPLAY tree\n");
		system("pause");
		exit(1);
	}
	new_splay_node->item = i;
	if (t == NULL) {
		new_splay_node->left = new_splay_node->right = NULL;
		size_splay_Tree = 1;
		return new_splay_node;
	}
	t = splay(i, t);
	if (i.countsosed < t->item.countsosed) {
		new_splay_node->left = t->left;
		new_splay_node->right = t;
		t->left = NULL;
		size_splay_Tree++;
		return new_splay_node;
	}
	else if (i.countsosed > t->item.countsosed) {
		new_splay_node->right = t->right;
		new_splay_node->left = t;
		t->right = NULL;
		size_splay_Tree++;
		return new_splay_node;
	}
	else if (i.i < t->item.i) {
		new_splay_node->left = t->left;
		new_splay_node->right = t;
		t->left = NULL;
		size_splay_Tree++;
		return new_splay_node;
	}
	else if (i.i > t->item.i) {
		new_splay_node->right = t->right;
		new_splay_node->left = t;
		t->right = NULL;
		size_splay_Tree++;
		return new_splay_node;
	}
	else { /* We get here if it's already in the Tree_splay */
		/* Don't add it again					  */
		free(new_splay_node);
		return t;
	}
}

Tree_splay * delete_splay_Tree(data_BalTree i, Tree_splay * t) {
	/* Deletes i from the Tree_splay if it's there.			   */
	/* Return a pointer to the resulting Tree_splay.			  */
	Tree_splay * x;
	if (t == NULL) return NULL;
	t = splay(i, t);
	if ((i.countsosed == t->item.countsosed) && (i.i == t->item.i)) {			   /* found it */
		if (t->left == NULL) {
			x = t->right;
		}
		else {
			x = splay(i, t->left);
			x->right = t->right;
		}
		size_splay_Tree--;
		free(t);
		t = NULL;
		return x;
	}
	return t;						 /* It wasn't there */
} // delete_splay_Tree 

// Вставка ключа К в дерево если ключа k_search
// еще нет в дереве или модификация ключа К_search на К.
// Возвращает новое значение корня АВЛ дерева.
Tree_splay* insert_and_modify(Tree_splay* &p, data_BalTree k, data_BalTree k_search)
{
	if (isfound(p, k_search) == false) {
		//   узла в дереве нет.
		p = insert(k, p);
		return p;
	}
	else {
		// удаление k_search
		p = delete_splay_Tree(k_search, p); // необходимое действие
		p = insert(k, p);							 // вставка к.
		return p;
	}
} // insert_and_modify splay tree

// Полное удаление бинарного splay дерева.
void clear_SPLAY(Tree_splay* p)
{
	if (p != 0) {
		clear_SPLAY(p->left);
		clear_SPLAY(p->right);
		// удаляем лист.
		// delete p;
		free(p);
		p = 0;
	}
} // clear_SPLAY

/*
// Для целочисленного item.
void test_splay_tree() {
	// Amat sample use of these functions.  Start with the empty Tree_splay,		 
	// insert some stuff into it, and then delete it						
	Tree_splay * root;
	integer i;
	root = NULL;			 // the empty Tree_splay 
	size_splay_Tree_splay = 0;
	for (i = 0; i < 1024; i++) {
		root = insert((541 * i) & (1023), root);
	}
	for (i = 0; i < 1024; i++) {
		root = delete_splay_Tree((541 * i) & (1023), root);
	}
	#if doubleintprecision == 1
		printf("size_splay_Tree_splay = %d\n", size_splay_Tree_splay);
	#else
		printf("size_splay_Tree_splay = %d\n", size_splay_Tree_splay);
	#endif
	
}
*/

// end splay tree


// Для АВЛ дерева
// Данное АВЛ дерево с целочисленным ключом 
// используется в разреженном матричном умножении 
// Фреда Густавсона для организации бинарного поиска.

// АВЛ дерево это структура данных позволяющая производить все 
// операции за log_2 (number of sosed count) операций. 

// Адельсон-Вельский и Ландис 1962 (взято из интернета).
// узел с максимальным значением ключа крайний правый.


// Gus - Фред Густавсон IBM 1978.


//отношения порядка только в insert и remove

// Узел АВЛ дерева.
struct node_AVL_Gus
{
	integer key;
	// Высота поддерева с корнем в данном узле.
	unsigned char height;
	node_AVL_Gus* left;
	node_AVL_Gus* right;
	// Конструктор.
	node_AVL_Gus(integer k) { key = k; left = right = 0; height = 1; }
};


// Работает также и с пустыми деревьями.
// Обёртка поля height
unsigned char height_Gus(node_AVL_Gus* p)
{
	return p ? p->height : 0;
};

// Вычисляет balance factor заданного узла
// работает только с ненулевыми указателями.
integer bfactor_Gus(node_AVL_Gus* p)
{
	return height_Gus(p->right) - height_Gus(p->left);
};

// Восстанавливает корректное значение поля height
// заданного узла (при условии, что значения этого поля 
// в правом и левом дочерних узлах являются корректными).
void fixheight_Gus(node_AVL_Gus* p)
{
	unsigned char hl = height_Gus(p->left);
	unsigned char hr = height_Gus(p->right);
	p->height = (hl > hr ? hl : hr) + 1;
};

// Балансировка узлов.
node_AVL_Gus* rotateright_Gus(node_AVL_Gus* p)
{
	// правый поворот вокруг p
	node_AVL_Gus* q = p->left;
	p->left = q->right;
	q->right = p;
	fixheight_Gus(p);
	fixheight_Gus(q);
	return q;
};

// Левый поворот является симметричной копией правого :
node_AVL_Gus* rotateleft_Gus(node_AVL_Gus* q)
{
	// левый поворот вокруг q
	node_AVL_Gus* p = q->right;
	q->right = p->left;
	p->left = q;
	fixheight_Gus(q);
	fixheight_Gus(p);
	return p;
};

// Код выполняющий балансировку сводится к проверке условий и выполнению поворотов
node_AVL_Gus* balance_Gus(node_AVL_Gus* p) // балансировка узла p
{
	fixheight_Gus(p);
	if (bfactor_Gus(p) == 2)
	{
		if (bfactor_Gus(p->right) < 0)
			p->right = rotateright_Gus(p->right);
		return rotateleft_Gus(p);
	}
	if (bfactor_Gus(p) == -2)
	{
		if (bfactor_Gus(p->left) > 0)
			p->left = rotateleft_Gus(p->left);
		return rotateright_Gus(p);
	}
	return p; // балансировка не нужна
}

// Вставка ключей в дерево.
// Возвращает новое значение корня АВЛ дерева.
node_AVL_Gus* insert_Gus(node_AVL_Gus* p, integer k)
{
	// Вставка ключа k в дерево с корнем p
	if (p == 0) {
		node_AVL_Gus* r1 = NULL;
		r1 = new node_AVL_Gus(k);
		if (r1 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for r1 in insert_Gus my_agregat_amg...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		return r1;
	}
	if (k < p->key)
		p->left = insert_Gus(p->left, k);
	else
		p->right = insert_Gus(p->right, k);

	return balance_Gus(p);
} // insert

  // Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
// перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_AVL_Gus(node_AVLST* &p, node_AVL_Gus* &root_Gus_set, integer &imarker75_scan)
{
	if (p != NULL) {
		formirate_F_SiTranspose_AVL_Gus(p->left, root_Gus_set, imarker75_scan);
		formirate_F_SiTranspose_AVL_Gus(p->right, root_Gus_set, imarker75_scan);
		root_Gus_set = insert_Gus(root_Gus_set, p->key.i);
		imarker75_scan++;
	}
}

// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
// перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_AVL_Gus(Taccumulqtor_list* &p, node_AVL_Gus* &root_Gus_set, integer &imarker75_scan)
{
	Taccumulqtor_list* buf = p;
	if (buf != NULL) {
		
		root_Gus_set = insert_Gus(root_Gus_set, buf->ikey);
		imarker75_scan++;

		buf = buf->next;
	}
	buf=NULL;
}


// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
// перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_AVL_Gus2(Taccumulqtor_list* &p, node_AVL_Gus* &root_Gus_set, integer &imarker75_scan,
	bool* &this_is_F_node, bool* &this_is_C_node)
{
	Taccumulqtor_list* buf = p;
	if (buf != NULL) {
		if ((this_is_F_node[buf->ikey] == false) && (this_is_C_node[buf->ikey] == false)) {
			root_Gus_set = insert_Gus(root_Gus_set, buf->ikey);
			imarker75_scan++;
		}
		buf = buf->next;
	}
} // formirate_F_SiTranspose_AVL_Gus2

// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
// перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_AVL_Gus2(node_AVLST* &p, node_AVL_Gus* &root_Gus_set, integer &imarker75_scan,
	bool* &this_is_F_node, bool* &this_is_C_node)
{
	if (p != NULL) {
		formirate_F_SiTranspose_AVL_Gus2(p->left, root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
		formirate_F_SiTranspose_AVL_Gus2(p->right, root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
		if ((this_is_F_node[p->key.i] == false) && (this_is_C_node[p->key.i] == false)) {
			root_Gus_set = insert_Gus(root_Gus_set, p->key.i);
			imarker75_scan++;
		}
	}
}

// Передача root_Gus_set в множество set.
// перекачка данных из одного дерева в массив.
void formirate_root_Gus_set__2__set(node_AVL_Gus* &root_Gus_set, integer* &set, integer &ic_986)
{
	if (root_Gus_set != NULL) {
		formirate_root_Gus_set__2__set(root_Gus_set->left, set, ic_986);
		formirate_root_Gus_set__2__set(root_Gus_set->right, set, ic_986);
		set[ic_986] = root_Gus_set->key;
		ic_986++;
	}
}



  // Возвращает true если узел найден в дереве
bool isfound_Gus(node_AVL_Gus* p, integer k)
{
	if (p == 0) return false; // ненайден.
	if (k < p->key)
		return isfound_Gus(p->left, k);
	else if (k > p->key)
		return isfound_Gus(p->right, k);
	else return true; // найден.
}

// Полное удаление бинарного дерева.
void clear_AVL_Gus(node_AVL_Gus* p)
{
	if (p != 0) {
		clear_AVL_Gus(p->left);
		clear_AVL_Gus(p->right);
		// удаляем лист.
		delete p;
		p = 0;
	}
} // clear_AVL_Gus

  // Удаление узла с занными свойства с сохранением сбалансированности.
node_AVL_Gus* findmin_Gus(node_AVL_Gus* p)
{
	return p->left ? findmin_Gus(p->left) : p;
} // findmin

node_AVL_Gus* findmax_Gus(node_AVL_Gus* p)
{
	// поиск узла с минимальным ключём в дереве p
	if (p != 0) {
		return p->right ? findmax_Gus(p->right) : p;
	}
	else {
		// На поиск максимума подан нулевой указатель.
		return 0;
	}
} // findmax

integer get_max_AVL_Gus(node_AVL_Gus* p)
{
	// возвращение максимального узла в дереве.
	return p->right ? get_max_AVL_Gus(p->right) : p->key;
}

node_AVL_Gus* removemin_Gus(node_AVL_Gus* p)
{
	// удаление узла с минимальным ключом из дерева p
	if (p->left == 0)
		return p->right;
	p->left = removemin_Gus(p->left);
	return balance_Gus(p);
}

// Удаление заданного элемента из AVL дерева
// с полным сохранением балансировки.
// на возвращаемое значение можно не обращать внимания.
node_AVL_Gus* remove_AVL_Gus(node_AVL_Gus* p, integer k)
{
	// Отношение порядка определено 
	// для структуры из трёх целых чисел.
	// удаление ключа k из дерева p
	if (p == 0) return 0;
	// Двоичный поиск нужного элемента.
	if (k < p->key)
		p->left = remove_AVL_Gus(p->left, k);
	else if (k > p->key)
		p->right = remove_AVL_Gus(p->right, k);
	else // k==p->key
	{
		node_AVL_Gus* q = p->left;
		node_AVL_Gus* r = p->right;
		delete p;
		p = 0;
		if (r == 0) return q;
		node_AVL_Gus* min = findmin_Gus(r);
		min->right = removemin_Gus(r);
		min->left = q;
		return balance_Gus(min);
	}

	// При выходе из рекурсии делаем балансировку.
	return balance_Gus(p);
}

// Вставка ключа К в дерево если ключа k_search
// еще нет в дереве или модификация ключа К_search на К.
// Возвращает новое значение корня АВЛ дерева.
node_AVL_Gus* insert_and_modify_Gus(node_AVL_Gus* p, integer k, integer k_search)
{
	if (isfound_Gus(p, k_search) == false) {
		//   узла в дереве нет.
		return insert_Gus(p, k);
	}
	else {
		// удаление k_search
		p = remove_AVL_Gus(p, k_search); // необходимое действие
										 // вставка к.
		return insert_Gus(p, k);
	}
}

// print_AVL for debug.
void print_AVL_Gus(node_AVL_Gus* p)
{
	if (p != 0) {
		print_AVL_Gus(p->left);
		for (integer i = 0; i <= p->height; i++) {
			printf(" ");
		}
#if doubleintprecision == 1
		printf("%lld\n", p->key);
#else
		printf("%d\n", p->key);
#endif
		
		print_AVL_Gus(p->right);
	}
} // print_AVL

  // тестирование АВЛ дерева
  // 12 декабря 2015 удовлетворительно.
void test_AVL_Gus()
{
	node_AVL_Gus* root = 0;
	integer d3;
	d3 = rand();
	root = remove_AVL_Gus(root, d3);
	for (integer i = 0; i < 10; i++)
	{
		integer d;
		d = rand();
		root = insert_and_modify_Gus(root, d, d);
		print_AVL_Gus(root);
		if (i == 5) {

			//41 18467 6334


			integer d1;
			d1 = 41;
			integer d2;
			d2 = rand();
			root = insert_and_modify_Gus(root, d2, d1);
			print_AVL_Gus(root);
			printf("remove 41 \n");
			root = remove_AVL_Gus(root, d1);
			print_AVL_Gus(root);
			printf("found max\n");
			node_AVL_Gus* emax;
			emax = findmax_Gus(root);
#if doubleintprecision == 1
			printf("maximum id %lld\n", emax->key);
#else
			printf("maximum id %d\n", emax->key);
#endif
			
			emax = 0;
			//clear_AVL(root);
			//root = 0;
			print_AVL_Gus(root);
		}

		system("pause");
	}
	system("pause");
}

// Конец данных и методов используемых в АВЛ дереве для разреженного матричного умножения.

// Вставка и поиск на основе быстродействующей хеш таблицы.
// начало.

bool* ihash_table_Gus_struct01 = NULL;
integer isize_hash_table_Gus_struct01 = 0;
integer* istack_pool_hash_table_Gus_struct01 = NULL;
// Внимание заполняется при инициализации, см. значение 52.5 подобранное экспериментально.
integer isize_stack_pool_hash_table_Gus_struct01 = 0; // достаточно 10000000 (10млн) для 2.1М.
integer ipointer_pool_hash_table_Gus_struct01 = 0;

// Полное освобождение оперативной памяти из под хеш таблицы.
void free_hash_table_Gus_struct01() {
	if (ihash_table_Gus_struct01 != NULL) {
		delete[] ihash_table_Gus_struct01;
		ihash_table_Gus_struct01 = NULL;
		isize_hash_table_Gus_struct01 = 0;
	}
	if (istack_pool_hash_table_Gus_struct01 != NULL) {
		delete[] istack_pool_hash_table_Gus_struct01;
		istack_pool_hash_table_Gus_struct01 = NULL;
	}
	isize_stack_pool_hash_table_Gus_struct01 = 10000000;
} // free_hash_table_Gus_struct01();

bool isfound_hash_table_Gus_struct01(integer id) {
	return ihash_table_Gus_struct01[id];
} // isfound_hash_table_Gus_struct01

// Осторожнее с операцией вставки нового элемента, модификация istack_pool_hash_table_Gus_struct01.
void insert_hash_table_Gus_struct01(integer id) {
	ihash_table_Gus_struct01[id]=true;
	if (ipointer_pool_hash_table_Gus_struct01 < isize_stack_pool_hash_table_Gus_struct01) {
		istack_pool_hash_table_Gus_struct01[ipointer_pool_hash_table_Gus_struct01++] = id;
	}
	else {
		printf("fatal error in function insert_hash_table_Gus_struct01\n");
		printf("ipointer_pool_hash_table_Gus_struct01 >= isize_stack_pool_hash_table_Gus_struct01\n");
		system("pause");
		exit(1);
	}
} // insert_hash_table_Gus_struct01

// Быстрая очистка хеш таблицы.
void clear_hash_table_Gus_struct01() {
	for (integer i_2 = 0; i_2 < ipointer_pool_hash_table_Gus_struct01; i_2++) {
		ihash_table_Gus_struct01[istack_pool_hash_table_Gus_struct01[i_2]] = false;
	}
	ipointer_pool_hash_table_Gus_struct01 = 0;
} // clear_hash_table_Gus_struct01

  // Передача списка Si Transpose из АВЛ дерева в hash_table_Gus_struct01.
  // перекачка данных из сбалансированного дерева в хеш таблицу.
void formirate_F_SiTranspose_hash_table_Gus_struct01(node_AVLST* &p, integer &imarker75_scan)
{
	if (p != NULL) {
		formirate_F_SiTranspose_hash_table_Gus_struct01(p->left, imarker75_scan);
		formirate_F_SiTranspose_hash_table_Gus_struct01(p->right, imarker75_scan);
		insert_hash_table_Gus_struct01(p->key.i);
		imarker75_scan++;
	}
} // formirate_F_SiTranspose_hash_table_Gus_struct01


  // Передача списка Si Transpose из АВЛ дерева в hash_table_Gus_struct01.
  // перекачка данных из сбалансированного дерева в хеш таблицу.
void formirate_F_SiTranspose_hash_table_Gus_struct02(Taccumulqtor_list* &p, integer &imarker75_scan)
{
	Taccumulqtor_list* buf = p;
	while (buf != NULL) {

		insert_hash_table_Gus_struct01(buf->ikey);
		imarker75_scan++;

		buf = buf->next;
	}
} // formirate_F_SiTranspose_hash_table_Gus_struct01


  // Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
  // перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_hash_table_Gus2_struct02(Taccumulqtor_list* &p, integer &imarker75_scan,
	bool* &this_is_F_node, bool* &this_is_C_node)
{

	Taccumulqtor_list* buf = p;
	while (buf != NULL) {

		if ((this_is_F_node[buf->ikey] == false) && (this_is_C_node[buf->ikey] == false)) {
			insert_hash_table_Gus_struct01(buf->ikey);
			imarker75_scan++;
		}
		buf = buf->next;
	}
} // formirate_F_SiTranspose_hash_table_Gus2_struct01

// Передача списка Si Transpose из АВЛ дерева в множество root_Gus_set.
// перекачка данных из одного дерева в другое.
void formirate_F_SiTranspose_hash_table_Gus2_struct01(node_AVLST* &p,  integer &imarker75_scan,
	bool* &this_is_F_node, bool* &this_is_C_node)
{
	if (p != NULL) {
		formirate_F_SiTranspose_hash_table_Gus2_struct01(p->left,  imarker75_scan, this_is_F_node, this_is_C_node);
		formirate_F_SiTranspose_hash_table_Gus2_struct01(p->right,  imarker75_scan, this_is_F_node, this_is_C_node);
		if ((this_is_F_node[p->key.i] == false) && (this_is_C_node[p->key.i] == false)) {
			insert_hash_table_Gus_struct01(p->key.i);
			imarker75_scan++;
		}
	}
} // formirate_F_SiTranspose_hash_table_Gus2_struct01

// Перезаливка данных из хранилища хеш таблицы в множество set.
void formirate_hash_table_Gus_struct01__2__set(integer* &set, integer &ic_986) {
	for (integer i_2 = 0; i_2 < ipointer_pool_hash_table_Gus_struct01; i_2++) {
		set[ic_986] = istack_pool_hash_table_Gus_struct01[i_2];
		ic_986++;
	}
} // formirate_hash_table_Gus_struct01__2__set

// Выделение оперативной памяти под хеш таблицу.
void construct_hash_table_Gus_struct01(integer isize) {
	// Освобождение оперативной памяти, на тот случай если 
	// память почему-то уже была выделена.
	if (ihash_table_Gus_struct01 != NULL) {
		delete[] ihash_table_Gus_struct01;
		ihash_table_Gus_struct01 = NULL;
		isize_hash_table_Gus_struct01 = 0;
	}
	if (istack_pool_hash_table_Gus_struct01 != NULL) {
		delete[] istack_pool_hash_table_Gus_struct01;
		istack_pool_hash_table_Gus_struct01 = NULL;
	}

	// Выделение оперативной памяти и инициализация.
	isize_hash_table_Gus_struct01 = isize;
	ihash_table_Gus_struct01 = new bool[isize_hash_table_Gus_struct01 + 2];
	if (ihash_table_Gus_struct01 == NULL) {
		printf("error in function construct_hash_table_Gus_struct01\n");
		printf("error memory allocate for ihash_table_Gus_struct01\n");
		system("pause");
		exit(1);
	}
	for (integer i_2 = 0; i_2 < isize_hash_table_Gus_struct01 + 2; i_2++) {
		ihash_table_Gus_struct01[i_2] = false;
	}
	ipointer_pool_hash_table_Gus_struct01 = 0;
	// Значение 52.5 найдено экспериментально, в случае нехватки памяти под пул его можно уменьшить немного,
	// только очень незначительно и очень осторожно.
	//isize_stack_pool_hash_table_Gus_struct01 = (integer)(1.0*isize / 20);
	//isize_stack_pool_hash_table_Gus_struct01 = 10000000; // 10млн.
	isize_stack_pool_hash_table_Gus_struct01 = isize + 2;
	istack_pool_hash_table_Gus_struct01 = new integer[isize_stack_pool_hash_table_Gus_struct01];
	if (istack_pool_hash_table_Gus_struct01 == NULL) {
		printf("error in function construct_hash_table_Gus_struct01\n");
		printf("error memory allocate for istack_pool_hash_table_Gus_struct01\n");
		system("pause");
		exit(1);
	}
} // construct_hash_table_Gus_struct01

// конец.


// Для генерации матрицы СЛАУ требуется в случае реализации
// на динамических массивах переупорядочивание элементов:
// сортировка. Здесь будет реализована быстрая сортировка.
// Брайан Керниган и Денис Ритчи "The C programming language".
// swap: Обмен местами Amat[i] и Amat[j]
void swap(Ak * &Amat, integer i, integer j)
{
	Ak A_temp;

	// change Amat[i] <-> Amat[j]
	A_temp = Amat[i];
	Amat[i] = Amat[j];
	Amat[j] = A_temp;

} // swap

void swap(Ak1 * &Amat, integer i, integer j)
{
	Ak1 A_temp;

	// change Amat[i] <-> Amat[j]
	A_temp = Amat[i];
	Amat[i] = Amat[j];
	Amat[j] = A_temp;

} // swap

  /*
  // Вот алгоритм PivotList
  integer PivotList(Ak * &Amat, integer n, integer first, integer last) {
  // list==jptr and altr обрабатываемый список
  // first номер первого элемента
  // last номер последнего элемента

  integer PivotValue = Amat[first].i*n+Amat[first].j;
  integer PivotPointeger = first;

  for (integer index = (first + 1); index <= last; index++) {
  if (Amat[index].i*n+Amat[index].j<PivotValue) {
  PivotPoint++;
  swap(Amat, PivotPoint, index);
  }
  }

  swap(Amat, first, PivotPoint);

  return PivotPoint;
  } // PivotListamg
  */


  // PivotList содержит ошибку.Обнаружено 12 декабря 2015.
  // Вот алгоритм PivotList
integer PivotList(Ak * &Amat, integer first, integer last) {
	// list==jptr and altr обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	integer PivotValue_j = Amat[first].j;
	integer PivotValue_i = Amat[first].i;
	integer PivotPoint = first;

	for (integer index = (first + 1); index <= last; index++) {
		if (Amat[index].i<PivotValue_i) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
		else if ((Amat[index].i == PivotValue_i) && (Amat[index].j < PivotValue_j)) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
	}

	swap(Amat, first, PivotPoint);

	return PivotPoint;
} // PivotList

// PivotList содержит ошибку.Обнаружено 12 декабря 2015.
// Вот алгоритм PivotList
integer PivotList(Ak1 * &Amat, integer first, integer last) {
	// list==jptr and altr обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	integer PivotValue_j = Amat[first].j;
	integer PivotValue_i = Amat[first].i;
	integer PivotPoint = first;

	for (integer index = (first + 1); index <= last; index++) {
		if (Amat[index].i<PivotValue_i) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
		else if ((Amat[index].i == PivotValue_i) && (Amat[index].j < PivotValue_j)) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
	}

	swap(Amat, first, PivotPoint);

	return PivotPoint;
} // PivotList

  // Вот алгоритм PivotList
integer PivotList_j(Ak * &Amat, integer first, integer last) {
	// list==jptr and altr обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	integer PivotValue_j = Amat[first].j;
	integer PivotValue_i = Amat[first].i;
	integer PivotPoint = first;

	for (integer index = (first + 1); index <= last; index++) {
		if (Amat[index].j<PivotValue_j) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
		else if ((Amat[index].j == PivotValue_j) && (Amat[index].i < PivotValue_i)) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
	}

	swap(Amat, first, PivotPoint);

	return PivotPoint;
} // PivotListamg_j

// Вот алгоритм PivotList
integer PivotList_j(Ak1 * &Amat, integer first, integer last) {
	// list==jptr and altr обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	integer PivotValue_j = Amat[first].j;
	integer PivotValue_i = Amat[first].i;
	integer PivotPoint = first;

	for (integer index = (first + 1); index <= last; index++) {
		if (Amat[index].j<PivotValue_j) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
		else if ((Amat[index].j == PivotValue_j) && (Amat[index].i < PivotValue_i)) {
			PivotPoint++;
			swap(Amat, PivotPoint, index);
		}
	}

	swap(Amat, first, PivotPoint);

	return PivotPoint;
} // PivotListamg_j

  // Пирамидальная сортировка

  // Переформировать пирамиду
void FixHeap_j(Ak* &Amat,
	integer root,
	Ak m,
	integer bound,
	/*integer n,*/ integer iadd)
{
	integer vacant;
	integer largerChild;

	// list сортируемый список пирамида
	// root номер корня пирамиды
	// m ключевое значение вставляемое в пирамиду
	// bound правая граница (номер) в пирамиде
	vacant = root;
	while (2 * vacant <= bound)
	{
		largerChild = 2 * vacant;
		integer lCadd = largerChild + iadd;
		integer lCadd1 = lCadd + 1;

		// поиск наибольшего из двух непосредственных потомков
		bool compare_result = false;
		if (Amat[lCadd1].j > Amat[lCadd].j) {
			compare_result = true;
		}
		else if (Amat[lCadd1].j == Amat[lCadd].j) {
			if (Amat[lCadd1].i > Amat[lCadd].i) {
				compare_result = true;
			}
		}
		if ((largerChild<bound) && (compare_result /*Amat[largerChild + 1+iadd].j*n+ Amat[largerChild + 1 + iadd].i> Amat[largerChild + iadd].j*n+ Amat[largerChild + iadd].i*/))
		{
			largerChild = largerChild + 1;
		}

		lCadd = largerChild + iadd;
		// находится ли ключ выше текущего потомка ?
		compare_result = false;
		if (m.j > Amat[lCadd].j) {
			compare_result = true;
		}
		else if (m.j == Amat[lCadd].j) {
			if (m.i > Amat[lCadd].i) {
				compare_result = true;
			}
		}
		if (compare_result /*m.j*n+m.i >  Amat[largerChild + iadd].j*n+ Amat[largerChild + iadd].i*/)
		{
			// да, цикл завершается
			break;
		}
		else
		{
			// нет, большего непосредственного потомка
			// следует поднять
			Amat[vacant + iadd] = Amat[lCadd];
			vacant = largerChild;
		}
	}
	Amat[vacant + iadd] = m;
} // FixHeap_j

// Переформировать пирамиду
void FixHeap_j(Ak1* &Amat,
	integer root,
	Ak1 m,
	integer bound,
	/*integer n,*/ integer iadd)
{
	integer vacant;
	integer largerChild;

	// list сортируемый список пирамида
	// root номер корня пирамиды
	// m ключевое значение вставляемое в пирамиду
	// bound правая граница (номер) в пирамиде
	vacant = root;
	while (2 * vacant <= bound)
	{
		largerChild = 2 * vacant;
		integer lCadd = largerChild + iadd;
		integer lCadd1 = lCadd + 1;

		// поиск наибольшего из двух непосредственных потомков
		bool compare_result = false;
		if (Amat[lCadd1].j > Amat[lCadd].j) {
			compare_result = true;
		}
		else if (Amat[lCadd1].j == Amat[lCadd].j) {
			if (Amat[lCadd1].i > Amat[lCadd].i) {
				compare_result = true;
			}
		}
		if ((largerChild<bound) && (compare_result /*Amat[largerChild + 1+iadd].j*n+ Amat[largerChild + 1 + iadd].i> Amat[largerChild + iadd].j*n+ Amat[largerChild + iadd].i*/))
		{
			largerChild = largerChild + 1;
		}

		lCadd = largerChild + iadd;
		// находится ли ключ выше текущего потомка ?
		compare_result = false;
		if (m.j > Amat[lCadd].j) {
			compare_result = true;
		}
		else if (m.j == Amat[lCadd].j) {
			if (m.i > Amat[lCadd].i) {
				compare_result = true;
			}
		}
		if (compare_result /*m.j*n+m.i >  Amat[largerChild + iadd].j*n+ Amat[largerChild + iadd].i*/)
		{
			// да, цикл завершается
			break;
		}
		else
		{
			// нет, большего непосредственного потомка
			// следует поднять
			Amat[vacant + iadd] = Amat[lCadd];
			vacant = largerChild;
		}
	}
	Amat[vacant + iadd] = m;
} // FixHeap_j


  // Переформировать пирамиду
void FixHeap(Ak* &Amat,
	integer root,
	Ak m,
	integer bound,
	integer iadd)
{
	integer vacant;
	integer largerChild;

	// list сортируемый список пирамида
	// root номер корня пирамиды
	// m ключевое значение вставляемое в пирамиду
	// bound правая граница (номер) в пирамиде
	vacant = root;
	while (2 * vacant <= bound)
	{
		largerChild = 2 * vacant;
		integer lCadd = largerChild + iadd;
		integer lCadd1 = lCadd + 1;

		// поиск наибольшего из двух непосредственных потомков
		//integer key1 = Amat[largerChild + 1 + iadd].i*n + Amat[largerChild + 1 + iadd].j;
		//integer key2 = Amat[largerChild + iadd].i*n + Amat[largerChild + iadd].j;
		bool compare_result = false;
		if (Amat[lCadd1].i > Amat[lCadd].i) {
			compare_result = true;
		}
		else if (Amat[lCadd1].i == Amat[lCadd].i) {
			if (Amat[lCadd1].j > Amat[lCadd].j) {
				compare_result = true;
			}
		}
		if ((largerChild<bound) && compare_result/*(key1>key2)*/)
		{
			largerChild = largerChild + 1;
		}

		lCadd = largerChild + iadd;
		// находится ли ключ выше текущего потомка ?
		//integer key5 = m.i*n + m.j;
		//integer key6 = Amat[largerChild + iadd].i*n + Amat[largerChild + iadd].j;
		compare_result = false;
		if (m.i > Amat[lCadd].i) {
			compare_result = true;
		}
		else if (m.i == Amat[lCadd].i) {
			if (m.j > Amat[lCadd].j) {
				compare_result = true;
			}
		}
		if (compare_result/*key5 > key6*/)
		{
			// да, цикл завершается
			break;
		}
		else
		{
			// нет, большего непосредственного потомка
			// следует поднять
			Amat[vacant + iadd] = Amat[lCadd];
			vacant = largerChild;
		}
	}
	Amat[vacant + iadd] = m;
} // FixHeap


// Переформировать пирамиду
void FixHeap(Ak1* &Amat,
	integer root,
	Ak1 m,
	integer bound,
	integer iadd)
{
	integer vacant;
	integer largerChild;

	// list сортируемый список пирамида
	// root номер корня пирамиды
	// m ключевое значение вставляемое в пирамиду
	// bound правая граница (номер) в пирамиде
	vacant = root;
	while (2 * vacant <= bound)
	{
		largerChild = 2 * vacant;
		integer lCadd = largerChild + iadd;
		integer lCadd1 = lCadd + 1;

		// поиск наибольшего из двух непосредственных потомков
		//integer key1 = Amat[largerChild + 1 + iadd].i*n + Amat[largerChild + 1 + iadd].j;
		//integer key2 = Amat[largerChild + iadd].i*n + Amat[largerChild + iadd].j;
		bool compare_result = false;
		if (Amat[lCadd1].i > Amat[lCadd].i) {
			compare_result = true;
		}
		else if (Amat[lCadd1].i == Amat[lCadd].i) {
			if (Amat[lCadd1].j > Amat[lCadd].j) {
				compare_result = true;
			}
		}
		if ((largerChild<bound) && compare_result/*(key1>key2)*/)
		{
			largerChild = largerChild + 1;
		}

		lCadd = largerChild + iadd;
		// находится ли ключ выше текущего потомка ?
		//integer key5 = m.i*n + m.j;
		//integer key6 = Amat[largerChild + iadd].i*n + Amat[largerChild + iadd].j;
		compare_result = false;
		if (m.i > Amat[lCadd].i) {
			compare_result = true;
		}
		else if (m.i == Amat[lCadd].i) {
			if (m.j > Amat[lCadd].j) {
				compare_result = true;
			}
		}
		if (compare_result/*key5 > key6*/)
		{
			// да, цикл завершается
			break;
		}
		else
		{
			// нет, большего непосредственного потомка
			// следует поднять
			Amat[vacant + iadd] = Amat[lCadd];
			vacant = largerChild;
		}
	}
	Amat[vacant + iadd] = m;
} // FixHeap

  // HeapSort очень быстрая только на размерностях до 10^5 а после вплоть до 10^8 она может замедляться раза в три. 

  // Пирамидальная сортировка оптимальна как
  // по памяти, так и по быстродействию, к тому же её алгоритм
  // очень интересен.
  // Ограничение состоит в том, что нумерация массива должна начинаться с 1.
void HeapSort(Ak * &Amat, integer first, integer last)
{

	Ak maxelm; // элемент с наибольшим значением ключа

			   // конструирование пирамиды
	for (integer i = ((last - first + 1) / 2); i >= 1; i--)
	{
		FixHeap(Amat, i, Amat[i + first - 1], last - first + 1, first - 1);
	}
	for (integer i = last - first + 1; i >= 2; i--)
	{
		// скопировать корень пирамиды в список
		// переформировать пирамиду
		maxelm = Amat[first];
		FixHeap(Amat, 1, Amat[i + first - 1], i - 1, first - 1);
		Amat[i + first - 1] = maxelm;
	}
} // HeapSort

// Пирамидальная сортировка оптимальна как
// по памяти, так и по быстродействию, к тому же её алгоритм
// очень интересен.
// Ограничение состоит в том, что нумерация массива должна начинаться с 1.
void HeapSort(Ak1 * &Amat, integer first, integer last)
{

	Ak1 maxelm; // элемент с наибольшим значением ключа

	// конструирование пирамиды
	for (integer i = ((last - first + 1) / 2); i >= 1; i--)
	{
		FixHeap(Amat, i, Amat[i + first - 1], last - first + 1, first - 1);
	}
	for (integer i = last - first + 1; i >= 2; i--)
	{
		// скопировать корень пирамиды в список
		// переформировать пирамиду
		maxelm = Amat[first];
		FixHeap(Amat, 1, Amat[i + first - 1], i - 1, first - 1);
		Amat[i + first - 1] = maxelm;
	}
} // HeapSort

  // Пирамидальная сортировка оптимальна как
  // по памяти, так и по быстродействию, к тому же её алгоритм
  // очень интересен.
  // Ограничение состоит в том, что нумерация массива должна начинаться с 1.
void HeapSort_j(Ak * &Amat, integer first, integer last)
{

	Ak maxelm; // элемент с наибольшим значением ключа

	integer iadd = first - 1;
	// конструирование пирамиды
	for (integer i = ((last - first + 1) / 2); i >= 1; i--)
	{
		FixHeap_j(Amat, i, Amat[i + iadd], last - first + 1, iadd);
	}
	for (integer i = last - first + 1; i >= 2; i--)
	{
		// скопировать корень пирамиды в список
		// переформировать пирамиду
		maxelm = Amat[1 + iadd];
		FixHeap_j(Amat, 1, Amat[i + iadd], i - 1, iadd);
		Amat[i + iadd] = maxelm;
	}
} // HeapSort_j

// Пирамидальная сортировка оптимальна как
// по памяти, так и по быстродействию, к тому же её алгоритм
// очень интересен.
// Ограничение состоит в том, что нумерация массива должна начинаться с 1.
void HeapSort_j(Ak1 * &Amat, integer first, integer last)
{

	Ak1 maxelm; // элемент с наибольшим значением ключа

	integer iadd = first - 1;
	// конструирование пирамиды
	for (integer i = ((last - first + 1) / 2); i >= 1; i--)
	{
		FixHeap_j(Amat, i, Amat[i + iadd], last - first + 1, iadd);
	}
	for (integer i = last - first + 1; i >= 2; i--)
	{
		// скопировать корень пирамиды в список
		// переформировать пирамиду
		maxelm = Amat[1 + iadd];
		FixHeap_j(Amat, 1, Amat[i + iadd], i - 1, iadd);
		Amat[i + iadd] = maxelm;
	}
} // HeapSort_j

  // Сортировка слиянием. 
  // Требует дополнительной пямяти.
void MergeSort(Ak * &Aorig, integer size) {
	// предполагается индексация от нуля до size-1.
	// Массив А предполагается не менее двойного размера.
	// Двойная память это недостаток данного алгоритма.
	Ak* Amat = Aorig;
	Ak* Bm = Amat + size;
	Ak* C;

	// Amat - сортируемый массив, B - вспомогательная память (справа от основных данных в А такого-же размера что и основные данные в А).
	// C - указатель для обмена.
	for (integer i = 1; i < size; i = i * 2) // размер объединяемых фрагментов
	{
		for (integer j = 0; j < size; j = j + 2 * i) // начало первого из объединяемых 
												 // фрагментов
		{
			integer r = j + i; // начало второго из объединяемых фрагментов
			integer n1 = 0, n2 = 0;
			if (i < size - j) { n1 = i; }
			else { n1 = size - j; };
			if (i < size - r) { n2 = i; }
			else { n2 = size - r; };

			if (n1 < 0) n1 = 0;
			if (n2 < 0) n2 = 0;

			// слияние упорядоченных фрагментов
			for (integer ia = 0, ib = 0, k = 0; k < n1 + n2; k++)
			{
				if (ia >= n1) Bm[j + k] = Amat[r + ib++];
				else
					if (ib >= n2) Bm[j + k] = Amat[j + ia++];
					else {
						bool compare_result = false;
						integer lCadd = j + ia;
						integer lCadd1 = r + ib;
						if (Amat[lCadd1].i > Amat[lCadd].i) {
							compare_result = true;
						}
						else if (Amat[lCadd1].i == Amat[lCadd].i) {
							if (Amat[lCadd1].j > Amat[lCadd].j) {
								compare_result = true;
							}
						}
						if (compare_result) {
							Bm[j + k] = Amat[j + ia++];
						}
						else {
							Bm[j + k] = Amat[r + ib++];
						}
					}
			}



		}
		C = Amat; Amat = Bm; Bm = C;

	}

	C = Amat; Amat = Bm; Bm = C;

	// Копирование, если результат размещен не в основном а в вспомогательном массиве
	if (Bm != Aorig)
		memcpy(Aorig, Bm, size*sizeof(Ak));

	Amat = NULL; Bm = NULL; C = NULL;
} // MergeSort


// Сортировка слиянием. 
// Требует дополнительной пямяти.
void MergeSort(Ak1 * &Aorig, integer size) {
	// предполагается индексация от нуля до size-1.
	// Массив А предполагается не менее двойного размера.
	// Двойная память это недостаток данного алгоритма.
	Ak1* Amat = Aorig;
	Ak1* Bm = Amat + size;
	Ak1* C;

	// Amat - сортируемый массив, B - вспомогательная память (справа от основных данных в А такого-же размера что и основные данные в А).
	// C - указатель для обмена.
	for (integer i = 1; i < size; i = i * 2) // размер объединяемых фрагментов
	{
		for (integer j = 0; j < size; j = j + 2 * i) // начало первого из объединяемых 
			// фрагментов
		{
			integer r = j + i; // начало второго из объединяемых фрагментов
			integer n1 = 0, n2 = 0;
			if (i < size - j) { n1 = i; }
			else { n1 = size - j; };
			if (i < size - r) { n2 = i; }
			else { n2 = size - r; };

			if (n1 < 0) n1 = 0;
			if (n2 < 0) n2 = 0;

			// слияние упорядоченных фрагментов
			for (integer ia = 0, ib = 0, k = 0; k < n1 + n2; k++)
			{
				if (ia >= n1) Bm[j + k] = Amat[r + ib++];
				else
					if (ib >= n2) Bm[j + k] = Amat[j + ia++];
					else {
						bool compare_result = false;
						integer lCadd = j + ia;
						integer lCadd1 = r + ib;
						if (Amat[lCadd1].i > Amat[lCadd].i) {
							compare_result = true;
						}
						else if (Amat[lCadd1].i == Amat[lCadd].i) {
							if (Amat[lCadd1].j > Amat[lCadd].j) {
								compare_result = true;
							}
						}
						if (compare_result) {
							Bm[j + k] = Amat[j + ia++];
						}
						else {
							Bm[j + k] = Amat[r + ib++];
						}
					}
			}



		}
		C = Amat; Amat = Bm; Bm = C;

	}

	C = Amat; Amat = Bm; Bm = C;

	// Копирование, если результат размещен не в основном а в вспомогательном массиве
	if (Bm != Aorig)
		memcpy(Aorig, Bm, size*sizeof(Ak1));

	Amat = NULL; Bm = NULL; C = NULL;
} // MergeSort


  // Сортировка слиянием. 
  // Требует дополнительной пямяти.
void MergeSort_j(Ak * &Aorig, integer size) {
	// предполагается индексация от нуля до size-1.
	// Массив А предполагается не менее двойного размера.
	// Двойная память это недостаток данного алгоритма.
	Ak* Amat = Aorig;
	Ak* Bm = Amat + size;
	Ak* C;

	// Amat - сортируемый массив, B - вспомогательная память (справа от основных данных в А такого-же размера что и основные данные в А).
	// C - указатель для обмена.
	for (integer i = 1; i < size; i = i * 2) // размер объединяемых фрагментов
	{
		for (integer j = 0; j < size; j = j + 2 * i) // начало первого из объединяемых 
												 // фрагментов
		{
			integer r = j + i; // начало второго из объединяемых фрагментов
			integer n1 = 0, n2 = 0;
			if (i < size - j) { n1 = i; }
			else { n1 = size - j; };
			if (i < size - r) { n2 = i; }
			else { n2 = size - r; };

			if (n1 < 0) n1 = 0;
			if (n2 < 0) n2 = 0;

			// слияние упорядоченных фрагментов
			for (integer ia = 0, ib = 0, k = 0; k < n1 + n2; k++)
			{
				if (ia >= n1) Bm[j + k] = Amat[r + ib++];
				else
					if (ib >= n2) Bm[j + k] = Amat[j + ia++];
					else {
						bool compare_result = false;
						integer lCadd = j + ia;
						integer lCadd1 = r + ib;
						if (Amat[lCadd1].j > Amat[lCadd].j) {
							compare_result = true;
						}
						else if (Amat[lCadd1].j == Amat[lCadd].j) {
							if (Amat[lCadd1].i > Amat[lCadd].i) {
								compare_result = true;
							}
						}
						if (compare_result) {
							Bm[j + k] = Amat[j + ia++];
						}
						else {
							Bm[j + k] = Amat[r + ib++];
						}
					}
			}



		}
		C = Amat; Amat = Bm; Bm = C;

	}

	C = Amat; Amat = Bm; Bm = C;

	// Копирование, если результат размещен не в основном а в вспомогательном массиве
	if (Bm != Aorig)
		memcpy(Aorig, Bm, size*sizeof(Ak));

	Amat = NULL; Bm = NULL; C = NULL;
} // MergeSort_j

// Сортировка слиянием. 
// Требует дополнительной пямяти.
void MergeSort_j(Ak1 * &Aorig, integer size) {
	// предполагается индексация от нуля до size-1.
	// Массив А предполагается не менее двойного размера.
	// Двойная память это недостаток данного алгоритма.
	Ak1* Amat = Aorig;
	Ak1* Bm = Amat + size;
	Ak1* C;

	// Amat - сортируемый массив, B - вспомогательная память (справа от основных данных в А такого-же размера что и основные данные в А).
	// C - указатель для обмена.
	for (integer i = 1; i < size; i = i * 2) // размер объединяемых фрагментов
	{
		for (integer j = 0; j < size; j = j + 2 * i) // начало первого из объединяемых 
			// фрагментов
		{
			integer r = j + i; // начало второго из объединяемых фрагментов
			integer n1 = 0, n2 = 0;
			if (i < size - j) { n1 = i; }
			else { n1 = size - j; };
			if (i < size - r) { n2 = i; }
			else { n2 = size - r; };

			if (n1 < 0) n1 = 0;
			if (n2 < 0) n2 = 0;

			// слияние упорядоченных фрагментов
			for (integer ia = 0, ib = 0, k = 0; k < n1 + n2; k++)
			{
				if (ia >= n1) Bm[j + k] = Amat[r + ib++];
				else
					if (ib >= n2) Bm[j + k] = Amat[j + ia++];
					else {
						bool compare_result = false;
						integer lCadd = j + ia;
						integer lCadd1 = r + ib;
						if (Amat[lCadd1].j > Amat[lCadd].j) {
							compare_result = true;
						}
						else if (Amat[lCadd1].j == Amat[lCadd].j) {
							if (Amat[lCadd1].i > Amat[lCadd].i) {
								compare_result = true;
							}
						}
						if (compare_result) {
							Bm[j + k] = Amat[j + ia++];
						}
						else {
							Bm[j + k] = Amat[r + ib++];
						}
					}
			}



		}
		C = Amat; Amat = Bm; Bm = C;

	}

	C = Amat; Amat = Bm; Bm = C;

	// Копирование, если результат размещен не в основном а в вспомогательном массиве
	if (Bm != Aorig)
		memcpy(Aorig, Bm, size*sizeof(Ak1));

	Amat = NULL; Bm = NULL; C = NULL;
} // MergeSort_j

  // Сортировка подсчётом.
  // За время O(n)
  // Томас Кормен стр. 224.
  // Внимание : Алгоритм жрёт очень много оперативной памяти.
  // Впервые предложена Севардом (H.H.Seward) в 1954 году.
void Counting_Sort(Ak* &Amat, integer first, integer last)
{
	// смена на malloc и calloc 7 января 2016.

	integer k = -1;
	for (integer j = first; j <= last; j++) {
		if (Amat[j].i > k) k = Amat[j].i;
	}
	//integer* C = new integer[k + 1];
	integer* C = (integer*)malloc((k+1)*sizeof(integer));
	char c1[2] = "C";
	char c2[14] = "Counting_Sort";
	handle_error<integer>(C, c1, c2, (k + 1));

	
	for (integer i = 0; i <= k; i++) {
		C[i] = 0; // инициализация.
	}
	for (integer j = first; j <= last; j++) {
		C[Amat[j].i]++;
	}
	// В C[i] хранится количество элементов равных i.
	for (integer i = 1; i <= k; i++) {
		C[i] += C[i - 1];
	}
	// В C[i] количество элементов не превышающих i
	//Ak* Bm = new Ak[last - first + 2];
	Ak* Bm = (Ak*)malloc((last - first + 2)*sizeof(Ak));
	char c3[3] = "Bm";
	char c4[14] = "Counting_Sort";
	handle_error<Ak>(Bm, c3, c4, (last - first + 2));
	
	integer ind;
	for (integer j = last; j >= first; j--) {
		ind = Amat[j].i;
		Bm[C[ind]] = Amat[j];
		C[ind]--;
	}
	// Обратное копирование.
	for (integer j = first, i = 1; j <= last; j++, i++) {
		//Amat[j] = B[j - first + 1];
		Amat[j] = Bm[i];
	}
	//delete[] Bm;
	free(Bm);
	//delete[] C;
	free(C);

}

// мы освобождаем память из под исходной матрицы СЛАУ,
// А потом её восстанавливаем. Для восстановления матрицы слау надо 
// запомнить первоначальный пордок следования элементов до применения сортировки.
integer* the_original_order_of_values = NULL;
integer* the_original_order_of_values_reverse = NULL;



// Сортировка подсчётом.
// За время O(n)
// Томас Кормен стр. 224.
// Внимание : Алгоритм жрёт очень много оперативной памяти.
// Впервые предложена Севардом (H.H.Seward) в 1954 году.
void Counting_Sortj(Ak* &Amat, integer first, integer last)
{

	integer k = -1;
	for (integer j = first; j <= last; j++) {
		if (Amat[j].j > k) k = Amat[j].j;
	}
	//integer* C = new integer[k + 1];
	integer* C = (integer*)malloc((k+1)*sizeof(integer));
	char c1[2] = "C";
	char c2[14] = "Counting_Sort";
	handle_error<integer>(C,  c1, c2, (k + 1));

#pragma omp parallel for
	for (integer i = 0; i <= k; i++) {
		C[i] = 0; // инициализация.
	}
	for (integer j = first; j <= last; j++) {
		C[Amat[j].j]++;
	}
	// В C[i] хранится количество элементов равных i.
//НИ в коем случае !!! #pragma omp parallel for
	for (integer i = 1; i <= k; i++) {
		C[i] += C[i - 1];
	}
	// В C[i] количество элементов не превышающих i
	//Ak* Bm = new Ak[last - first + 2];
	Ak* Bm = (Ak*)malloc((last - first + 2)*sizeof(Ak));
	char c3[3] = "Bm";
	char c4[14] = "Counting_Sort";
	handle_error<Ak>(Bm, c3, c4, (last - first + 2));
	
	integer ind;
	for (integer j = last; j >= first; j--) {
		ind = Amat[j].j;
		Bm[C[ind]] = Amat[j];
		C[ind]--;
	}
	// Обратное копирование.
	for (integer j = first, i = 1; j <= last; j++, i++) {
		//Amat[j] = B[j - first + 1];
		Amat[j] = Bm[i];
	}
	//delete[] Bm;
	free(Bm);
	//delete[] C;
	free(C);

}

// Сортировка подсчётом.
// За время O(n)
// Томас Кормен стр. 224.
// Внимание : Алгоритм жрёт очень много оперативной памяти.
// Впервые предложена Севардом (H.H.Seward) в 1954 году.
void Counting_Sort(Ak1* &Amat, integer first, integer last, bool bmemo)
{
	// смена на malloc и calloc 7 января 2016.
	//если bmemo==true то запоминаем первоначальный порядок значений.
	integer* the_original_order_of_values_buf = NULL;

	integer k = -1;
	for (integer j = first; j <= last; j++) {
		if (Amat[j].i > k) k = Amat[j].i;
	}
	//integer* C = new integer[k + 1];
	integer* C = (integer*)malloc((k + 1) * sizeof(integer));
	char c1[2] = "C";
	char c2[14] = "Counting_Sort";
	handle_error<integer>(C, c1, c2, (k + 1));

	the_original_order_of_values_buf = (integer*)malloc((last + 1) * sizeof(integer));
	char c7[34] = "the_original_order_of_values_buf";
	char c6[14] = "Counting_Sort";
	handle_error<integer>(the_original_order_of_values_buf, c7, c6, (last + 1));

	if (bmemo) {
		the_original_order_of_values = (integer*)malloc((last + 1) * sizeof(integer));
		char c5[29] = "the_original_order_of_values";

		handle_error<integer>(the_original_order_of_values, c5, c6, (last + 1));

		the_original_order_of_values_reverse = (integer*)malloc((last + 1) * sizeof(integer));
		char c8[38] = "the_original_order_of_values_reverse";
		handle_error<integer>(the_original_order_of_values_reverse, c8, c6, (last + 1));

	}

#pragma omp parallel for
	for (integer i = 0; i <= k; i++) {
		C[i] = 0; // инициализация.
	}
	for (integer j = first; j <= last; j++) {
		C[Amat[j].i]++;
	}
	// В C[i] хранится количество элементов равных i.
//НИ в коем случае !!! #pragma omp parallel for
	for (integer i = 1; i <= k; i++) {
		C[i] += C[i - 1];
	}
	// В C[i] количество элементов не превышающих i
	//Ak1* Bm = new Ak1[last - first + 2];
	Ak1* Bm = (Ak1*)malloc((last - first + 2) * sizeof(Ak1));
	char c3[3] = "Bm";
	char c4[14] = "Counting_Sort";
	handle_error<Ak1>(Bm, c3, c4, (last - first + 2));

	integer ind;
	for (integer j = last; j >= first; j--) {
		ind = Amat[j].i;
		Bm[C[ind]] = Amat[j];
		if (bmemo) {
			// j стал C[ind]
			if (the_original_order_of_values_buf != NULL) {
				the_original_order_of_values_buf[C[ind]] = j;
			}
		}
		C[ind]--;
	}
	// Обратное копирование.
	
		for (integer jnew = first, i = 1; jnew <= last; jnew++, i++) {
			//Amat[jnew] = B[jnew - first + 1];
			// i стал jnew. i ассоциируется с C[ind].
			Amat[jnew] = Bm[i];
			if (bmemo) {
				if (the_original_order_of_values_buf != NULL) {
					if (the_original_order_of_values != NULL) {
						the_original_order_of_values[the_original_order_of_values_buf[i]] = jnew;
						the_original_order_of_values_reverse[jnew] = the_original_order_of_values_buf[i];
					}
				}
			}
	    }
	//delete[] Bm;
	if (Bm != NULL) {
		free(Bm);
		Bm = NULL;
	}
	//delete[] C;
	if (C != NULL) {
		free(C);
		C = NULL;
	}

	if (the_original_order_of_values_buf != NULL) {
		free(the_original_order_of_values_buf);
		the_original_order_of_values_buf = NULL;
	}


}

// Сортировка подсчётом.
// За время O(n)
// Томас Кормен стр. 224.
// Внимание : Алгоритм жрёт очень много оперативной памяти.
// Впервые предложена Севардом (H.H.Seward) в 1954 году.
void Counting_Sortj(Ak1* &Amat, integer first, integer last)
{

	integer k = -1;
	for (integer j = first; j <= last; j++) {
		if (Amat[j].j > k) k = Amat[j].j;
	}
	//integer* C = new integer[k + 1];
	integer* C = (integer*)malloc((k + 1) * sizeof(integer));
	char c1[2] = "C";
	char c2[14] = "Counting_Sort";
	handle_error<integer>(C, c1, c2, (k + 1));

#pragma omp parallel for
	for (integer i = 0; i <= k; i++) {
		C[i] = 0; // инициализация.
	}
	for (integer j = first; j <= last; j++) {
		C[Amat[j].j]++;
	}
	// В C[i] хранится количество элементов равных i.
	for (integer i = 1; i <= k; i++) {
		C[i] += C[i - 1];
	}
	// В C[i] количество элементов не превышающих i
	//Ak1* Bm = new Ak1[last - first + 2];
	Ak1* Bm = (Ak1*)malloc((last - first + 2) * sizeof(Ak1));
	char c3[3] = "Bm";
	char c4[14] = "Counting_Sort";
	handle_error<Ak1>(Bm, c3, c4, (last - first + 2));

	integer ind;
	for (integer j = last; j >= first; j--) {
		ind = Amat[j].j;
		Bm[C[ind]] = Amat[j];
		C[ind]--;
	}
	// Обратное копирование.
	for (integer j = first, i = 1; j <= last; j++, i++) {
		//Amat[j] = B[j - first + 1];
		Amat[j] = Bm[i];
	}
	//delete[] Bm;
	free(Bm);
	//delete[] C;
	free(C);

}

// Правильная версия сортировки Чарльза Хоара которая раз в 5 быстрее чем,
// пирамидальная сортировка. Но ещё быстрее обещает быть TimSort (Futures).
void qs(Ak * &Amat, integer first, integer last) {
	integer i = first, j = last;
	Ak tmp;

	/*
	В случае явной рекурсии, как в программе выше, в стеке сохраняются не только границы подмассивов, но и ряд совершенно ненужных параметров, таких как локальные переменные. Если эмулировать стек программно, его размер можно уменьшить в несколько раз.
	Чем на более равные части будет делиться массив - тем лучше. Потому в качестве опорного целесообразно брать средний из трех, а если массив достаточно велик - то из девяти произвольных элементов.
	Пусть входные последовательности очень плохи для алгоритма. Например, их специально подбирают, чтобы средний элемент оказывался каждый раз минимумом. Как сделать QuickSort устойчивой к такому "саботажу" ? Очень просто - выбирать в качестве опорного случайный элемент входного массива. Тогда любые неприятные закономерности во входном потоке будут нейтрализованы. Другой вариант - переставить перед сортировкой элементы массива случайным образом.
	Быструю сортировку можно использовать и для двусвязных списков. Единственная проблема при этом - отсутствие непосредственного доступа к случайному элементу. Так что в качестве опорного приходится выбирать первый элемент, и либо надеяться на хорошие исходные данные, либо случайным образом переставить элементы перед сортировкой.
	*/
	integer pivot;
	if (1) {
		if (last - first < 3000) {
			pivot = Amat[(integer)((first + last) / 2)].i;
		}
		else if (last - first < 800000) {
			pivot = (integer)((Amat[first + 100].i + Amat[(first + last) / 2].i + Amat[last - 100].i) / 3.0);
		}
		else {
			pivot = 0;
			pivot = (integer)((Amat[first].i + Amat[first + 100000].i + Amat[first + 200000].i + Amat[first + 300000].i + Amat[first + 400000].i + Amat[first + 500000].i + Amat[first + 600000].i + Amat[first + 700000].i + Amat[last].i) / 9.0);
		}

	}
	else {
		pivot = Amat[(first + last) / 2].i;
	}

	// partition
	while (i <= j) {
		//while ((Amat[i].i < pivot) || ((Amat[i].i == pivot) && (Amat[i].j < pivot.j)))
		//i++;
		//while ((Amat[j].i > pivot) || ((Amat[j].i == pivot) && (Amat[j].j > pivot.j)))
		//j--;
		while (Amat[i].i < pivot)
			i++;
		while (Amat[j].i > pivot)
			j--;
		if (i <= j) {
			tmp = Amat[i];
			Amat[i] = Amat[j];
			Amat[j] = tmp;
			i++;
			j--;
		}
	}

	// recursion
	if (first < j)
		qs(Amat, first, j);
	if (i < last)
		qs(Amat, i, last);

}

integer compAi(Ak1 a, Ak1 b) {
	if (a.i > b.i) return (1);
	if (a.i < b.i) return (-1);
	return (0);
}

integer compAj(Ak1 a, Ak1 b) {
	if (a.j > b.j) return (1);
	if (a.j < b.j) return (-1);
	return (0);
}

/*
// для библиотечной std::sort
integer compAi(const void  * a, const void  * b)
{
	if ((*(Ak1*)a).i > (*(Ak1*)b).i) return (1);
	if ((*(Ak1*)a).i < (*(Ak1*)b).i) return (-1);
	return (0);
} // compAi

// для библиотечной std::sort
integer compAj(const void  * a, const void  * b)
{
	if ((*(Ak1*)a).j > (*(Ak1*)b).j) return (1);
	if ((*(Ak1*)a).j < (*(Ak1*)b).j) return (-1);
	return (0);
} // compAj
*/

// Правильная версия сортировки Чарльза Хоара которая раз в 5 быстрее чем,
// пирамидальная сортировка. Но ещё быстрее обещает быть TimSort (Futures).
void qs(Ak1 * &Amat, integer first, integer last) {
	integer i = first, j = last;
	Ak1 tmp;

	/*
	В случае явной рекурсии, как в программе выше, в стеке сохраняются не только границы подмассивов, но и ряд совершенно ненужных параметров, таких как локальные переменные. Если эмулировать стек программно, его размер можно уменьшить в несколько раз.
	Чем на более равные части будет делиться массив - тем лучше. Потому в качестве опорного целесообразно брать средний из трех, а если массив достаточно велик - то из девяти произвольных элементов.
	Пусть входные последовательности очень плохи для алгоритма. Например, их специально подбирают, чтобы средний элемент оказывался каждый раз минимумом. Как сделать QuickSort устойчивой к такому "саботажу" ? Очень просто - выбирать в качестве опорного случайный элемент входного массива. Тогда любые неприятные закономерности во входном потоке будут нейтрализованы. Другой вариант - переставить перед сортировкой элементы массива случайным образом.
	Быструю сортировку можно использовать и для двусвязных списков. Единственная проблема при этом - отсутствие непосредственного доступа к случайному элементу. Так что в качестве опорного приходится выбирать первый элемент, и либо надеяться на хорошие исходные данные, либо случайным образом переставить элементы перед сортировкой.
	*/
	integer pivot;
	if (1) {
		if (last - first < 3000) {
			pivot = Amat[(integer)((first + last) / 2)].i;
		}
		else if (last - first < 800000) {
			pivot = (integer)((Amat[first + 100].i + Amat[(first + last) / 2].i + Amat[last - 100].i) / 3.0);
		}
		else {
			//pivot = 0;
			pivot = (integer)((Amat[first].i + Amat[first + 100000].i + Amat[first + 200000].i + Amat[first + 300000].i + Amat[first + 400000].i + Amat[first + 500000].i + Amat[first + 600000].i + Amat[first + 700000].i + Amat[last].i) / 9.0);
		}

	}
	else {
		pivot = Amat[(first + last) / 2].i;
	}

	// partition
	while (i <= j) {
		//while ((Amat[i].i < pivot) || ((Amat[i].i == pivot) && (Amat[i].j < pivot.j)))
		//i++;
		//while ((Amat[j].i > pivot) || ((Amat[j].i == pivot) && (Amat[j].j > pivot.j)))
		//j--;
		while (Amat[i].i < pivot)
			i++;
		while (Amat[j].i > pivot)
			j--;
		if (i <= j) {
			tmp = Amat[i];
			Amat[i] = Amat[j];
			Amat[j] = tmp;
			i++;
			j--;
		}
	}

	// recursion
	if (first < j)
		qs(Amat, first, j);
	if (i < last)
		qs(Amat, i, last);

}

// Правильная версия сортировки Чарльза Хоара которая раз в 5 быстрее чем,
// пирамидальная сортировка. Но ещё быстрее обещает быть TimSort (Futures).
void qsj(Ak * &Amat, integer first, integer last) {
	integer i = first, j = last;
	Ak tmp;
	//Ak pivot = Amat[(first + last) / 2];
	/*
	В случае явной рекурсии, как в программе выше, в стеке сохраняются не только границы подмассивов, но и ряд совершенно ненужных параметров, таких как локальные переменные. Если эмулировать стек программно, его размер можно уменьшить в несколько раз.
	Чем на более равные части будет делиться массив - тем лучше. Потому в качестве опорного целесообразно брать средний из трех, а если массив достаточно велик - то из девяти произвольных элементов.
	Пусть входные последовательности очень плохи для алгоритма. Например, их специально подбирают, чтобы средний элемент оказывался каждый раз минимумом. Как сделать QuickSort устойчивой к такому "саботажу" ? Очень просто - выбирать в качестве опорного случайный элемент входного массива. Тогда любые неприятные закономерности во входном потоке будут нейтрализованы. Другой вариант - переставить перед сортировкой элементы массива случайным образом.
	Быструю сортировку можно использовать и для двусвязных списков. Единственная проблема при этом - отсутствие непосредственного доступа к случайному элементу. Так что в качестве опорного приходится выбирать первый элемент, и либо надеяться на хорошие исходные данные, либо случайным образом переставить элементы перед сортировкой.
	*/
	integer pivot;
	if (1) {
		if (last - first < 3000) {
			pivot = Amat[(integer)((first + last) / 2)].j;
		}
		else if (last - first < 800000) {
			pivot = (integer)((Amat[first + 100].j + Amat[(first + last) / 2].j + Amat[last - 100].j) / 3.0);
		}
		else {
			//pivot = 0;
			pivot = (integer)((Amat[first].j + Amat[first + 100000].j + Amat[first + 200000].j + Amat[first + 300000].j + Amat[first + 400000].j + Amat[first + 500000].j + Amat[first + 600000].j + Amat[first + 700000].j + Amat[last].j) / 9.0);
		}

	}
	else {
		pivot = Amat[(first + last) / 2].j;
	}



	// partition
	while (i <= j) {
		//while ((Amat[i].j < pivot.j) || ((Amat[i].j == pivot.j) && (Amat[i].i < pivot.i)))
		//i++;
		//while ((Amat[j].j > pivot.j) || ((Amat[j].j == pivot.j) && (Amat[j].i > pivot.i)))
		//j--;

		while (Amat[i].j < pivot)
			i++;
		while (Amat[j].j > pivot)
			j--;
		if (i <= j) {
			tmp = Amat[i];
			Amat[i] = Amat[j];
			Amat[j] = tmp;
			i++;
			j--;
		}
	}

	// recursion
	if (first < j)
		qsj(Amat, first, j);
	if (i < last)
		qsj(Amat, i, last);

}


// Правильная версия сортировки Чарльза Хоара которая раз в 5 быстрее чем,
// пирамидальная сортировка. Но ещё быстрее обещает быть TimSort (Futures).
void qsj(Ak1 * &Amat, integer first, integer last) {
	integer i = first, j = last;
	Ak1 tmp;
	//Ak1 pivot = Amat[(first + last) / 2];
	/*
	В случае явной рекурсии, как в программе выше, в стеке сохраняются не только границы подмассивов, но и ряд совершенно ненужных параметров, таких как локальные переменные. Если эмулировать стек программно, его размер можно уменьшить в несколько раз.
	Чем на более равные части будет делиться массив - тем лучше. Потому в качестве опорного целесообразно брать средний из трех, а если массив достаточно велик - то из девяти произвольных элементов.
	Пусть входные последовательности очень плохи для алгоритма. Например, их специально подбирают, чтобы средний элемент оказывался каждый раз минимумом. Как сделать QuickSort устойчивой к такому "саботажу" ? Очень просто - выбирать в качестве опорного случайный элемент входного массива. Тогда любые неприятные закономерности во входном потоке будут нейтрализованы. Другой вариант - переставить перед сортировкой элементы массива случайным образом.
	Быструю сортировку можно использовать и для двусвязных списков. Единственная проблема при этом - отсутствие непосредственного доступа к случайному элементу. Так что в качестве опорного приходится выбирать первый элемент, и либо надеяться на хорошие исходные данные, либо случайным образом переставить элементы перед сортировкой.
	*/
	integer pivot;
	if (1) {
		if (last - first < 3000) {
			pivot = Amat[(integer)((first + last) / 2)].j;
		}
		else if (last - first < 800000) {
			pivot = (integer)((Amat[first + 100].j + Amat[(first + last) / 2].j + Amat[last - 100].j) / 3.0);
		}
		else {
			//pivot = 0;
			pivot = (integer)((Amat[first].j + Amat[first + 100000].j + Amat[first + 200000].j + Amat[first + 300000].j + Amat[first + 400000].j + Amat[first + 500000].j + Amat[first + 600000].j + Amat[first + 700000].j + Amat[last].j) / 9.0);
		}

	}
	else {
		pivot = Amat[(first + last) / 2].j;
	}



	// partition
	while (i <= j) {
		//while ((Amat[i].j < pivot.j) || ((Amat[i].j == pivot.j) && (Amat[i].i < pivot.i)))
		//i++;
		//while ((Amat[j].j > pivot.j) || ((Amat[j].j == pivot.j) && (Amat[j].i > pivot.i)))
		//j--;

		while (Amat[i].j < pivot)
			i++;
		while (Amat[j].j > pivot)
			j--;
		if (i <= j) {
			tmp = Amat[i];
			Amat[i] = Amat[j];
			Amat[j] = tmp;
			i++;
			j--;
		}
	}

	// recursion
	if (first < j)
		qsj(Amat, first, j);
	if (i < last)
		qsj(Amat, i, last);

}




// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
void QuickSort(Ak * &Amat, integer first, integer last) {
	// list упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка

	if (0) {
		/*
		// BubbleSort
		integer numberOfPairs = last - first + 1;
		bool swappedElements = true;
		while (swappedElements) {
		numberOfPairs--;
		swappedElements = false;
		for (integer i = first; i <= first + numberOfPairs - 1; i++) {
		if (Amat[i].i*n+Amat[i].j>Amat[i + 1].i*n+Amat[i+1].j) {
		swap(Amat, i, i + 1);
		swappedElements = true;
		}
		}
		}
		*/
	}
	else
	{
		integer pivot;

		if (first < last) {
			pivot = PivotList(Amat, first, last);
			QuickSort(Amat, first, pivot - 1);
			QuickSort(Amat, pivot + 1, last);
		}
	}
} // QuickSort

// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
void QuickSort(Ak1 * &Amat, integer first, integer last) {
	// list упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка

	if (0) {
		/*
		// BubbleSort
		integer numberOfPairs = last - first + 1;
		bool swappedElements = true;
		while (swappedElements) {
		numberOfPairs--;
		swappedElements = false;
		for (integer i = first; i <= first + numberOfPairs - 1; i++) {
		if (Amat[i].i*n+Amat[i].j>Amat[i + 1].i*n+Amat[i+1].j) {
		swap(Amat, i, i + 1);
		swappedElements = true;
		}
		}
		}
		*/
	}
	else
	{
		integer pivot;

		if (first < last) {
			pivot = PivotList(Amat, first, last);
			QuickSort(Amat, first, pivot - 1);
			QuickSort(Amat, pivot + 1, last);
		}
	}
} // QuickSort

  // Быстрая сортировка Хоара.
  // Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
  // стр. 106.
void QuickSort_j(Ak * &Amat, integer first, integer last) {
	// list упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка

	if (0) {
		// BubbleSort
		integer numberOfPairs = last - first + 1;
		bool swappedElements = true;
		while (swappedElements) {
			numberOfPairs--;
			swappedElements = false;
			for (integer i = first; i <= first + numberOfPairs - 1; i++) {
				if (Amat[i].j > Amat[i + 1].j) {
					swap(Amat, i, i + 1);
					swappedElements = true;
				}
			}
		}
	}
	else
	{
		integer pivot;

		if (first < last) {
			pivot = PivotList_j(Amat, first, last);
			QuickSort_j(Amat, first, pivot - 1);
			QuickSort_j(Amat, pivot + 1, last);
		}
	}
} // QuickSort_j

// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
void QuickSort_j(Ak1 * &Amat, integer first, integer last) {
	// list упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка

	if (0) {
		// BubbleSort
		integer numberOfPairs = last - first + 1;
		bool swappedElements = true;
		while (swappedElements) {
			numberOfPairs--;
			swappedElements = false;
			for (integer i = first; i <= first + numberOfPairs - 1; i++) {
				if (Amat[i].j > Amat[i + 1].j) {
					swap(Amat, i, i + 1);
					swappedElements = true;
				}
			}
		}
	}
	else
	{
		integer pivot;

		if (first < last) {
			pivot = PivotList_j(Amat, first, last);
			QuickSort_j(Amat, first, pivot - 1);
			QuickSort_j(Amat, pivot + 1, last);
		}
	}
} // QuickSort_j


  /*
  // Это исторически первоначальный код содержащий лишь построение последовательности
  // вложенных матриц и не иодержащий построения операторов restriction и prolongation.
  // создание этого кода завершено 1 сентября 2015 года.
  template <typename doublerealT>
  integer aggregative_amg(Ak* &Amat, integer nnz, integer n, doublerealT* &x, doublerealT* &b) {


  // нумерация начинается с единицы.

  const integer maxlevel = 30;
  integer ilevel = 1;
  integer nnz_a[maxlevel];
  integer n_a[maxlevel];
  nnz_a[0] = nnz;
  n_a[0] = n;
  bool* flag = new bool[n + 1];
  integer iadd = 0;

  while ((ilevel<maxlevel-1)&&(n_a[ilevel - 1] > 50)) {
  //heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
  QuickSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);

  for (integer ii = 1+iadd; ii <= nnz_a[ilevel - 1]+iadd; ii++) {
  #if doubleintprecision == 1
  //	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #else
  //	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #endif
  
  //if (ii % 20 == 0) getchar();
  }

  for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
  flag[ii] = false;
  }
  for (integer ii = 1+iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
  Amat[ii].ind = ii-iadd;
  }



  // Copy(Amat) на nnz ячеек правее.
  for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
  Amat[ii] = Amat[ii - nnz_a[ilevel - 1]];
  }

  integer n_coarce = 1; // номер агрегата.
  const integer max_sosed = 20;
  const integer NULL_SOSED = -1;
  integer vacant = NULL_SOSED;
  for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
  if (flag[Amat[ii].i] == false) {
  // Вычисляем по немодифиуцированной матрице А (хранящейся слева).

  integer set[max_sosed]; // не более 20 узлов в одном агрегате.
  for (integer js = 0; js < max_sosed; js++) {
  set[js] = NULL_SOSED;
  }
  integer ic = 0;
  set[ic] = Amat[ii].i;
  ic++;

  // если узел j ещё не был добавлен в агрегат.
  if (flag[Amat[ii].j] == false) {
  vacant = Amat[ii].j;
  for (integer js = 0; js < ic; js++) {
  if (vacant == set[js]) {
  vacant = NULL_SOSED;
  }
  }
  if (vacant != NULL_SOSED) {
  set[ic] = vacant;
  ic++;
  }
  }
  integer iscan = ii + 1;
  while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
  // если узел j ещё не был добавлен в агрегат.
  if (flag[Amat[iscan].j] == false) {
  vacant = Amat[iscan].j;
  for (integer js = 0; js < ic; js++) {
  if (vacant == set[js]) {
  vacant = NULL_SOSED;
  }
  }
  if (vacant != NULL_SOSED) {
  set[ic] = vacant;
  ic++;

  }
  }

  iscan++;

  } // while


  // (i,j) -> (I,J)
  // модифицируем копию Amat находящуюся справа.
  for (integer k = nnz_a[ilevel - 1] + 1 + iadd; k <= 2 * nnz_a[ilevel - 1] + iadd; k++) {
  bool found = false;
  for (integer k1 = 0; k1 < ic; k1++) {
  if (Amat[k - nnz_a[ilevel - 1]].i == set[k1]) found = true;
  }
  if (found) Amat[k].i = n_coarce;
  found = false;
  for (integer k1 = 0; k1 < ic; k1++) {
  if (Amat[k - nnz_a[ilevel - 1]].j == set[k1]) found = true;
  }
  if (found) Amat[k].j = n_coarce;
  }

  // Помечаем узлы как включённые в агрегат.
  for (integer js = 0; js < ic; js++) {
  flag[set[js]] = true;
  }

  n_coarce++;

  // Один агрегат создан.



  } // узел не был ещё включён в агрегат.
  } // агрегаты созданы.

  #if doubleintprecision == 1
		//printf("%lld %lld\n",n,n_coarce-1);
  #else
		//printf("%d %d\n",n,n_coarce-1);
  #endif
  
  //getchar();
  n_a[ilevel] = n_coarce - 1;

  // сортировка по новому ключу key=i*(iglcoarce_number-1)+j;
  // в позиции ind сохранён индекс предыдущей позиции.
  //heapsort(Amat, key = i*(n_coarce - 1) + j, nnz + 1, 2 * nnz);
  QuickSort(Amat, n_coarce - 1, nnz_a[ilevel-1] + 1 + iadd, 2 * nnz_a[ilevel-1] + iadd);


  for (integer ii = 1+nnz_a[ilevel-1]+iadd; ii <= 2*nnz_a[ilevel - 1]+iadd; ii++) {
  #if doubleintprecision == 1
		 //	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #else
		//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
  #endif
  
  //if (ii % 20 == 0) getchar();
  }



  // копирование в третью часть матрицы Слау на coarce сетке.
  // инициализация.
  // запас памяти 1 nnz на fine уровне.
  for (integer ii = 2 * nnz_a[ilevel - 1]+1 + iadd; ii <= 3 * nnz_a[ilevel - 1] + iadd; ii++) {
  Amat[ii].aij = 0.0;
  Amat[ii].ind = NULL_SOSED;
  Amat[ii].i = NULL_SOSED;
  Amat[ii].j = NULL_SOSED;
  }

  for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) flag[ii] = false;


  integer ic1 = 2 * nnz_a[ilevel - 1] + 1 + iadd;
  integer im = 1;
  integer im0 = 0;
  for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
  if (flag[Amat[ii].i] == false) {
  integer istr = Amat[ii].i;
  while ((ii + im0 <= 2 * nnz_a[ilevel - 1] + iadd)&&(istr==Amat[ii+im0].i)) {

  if (ic1 <= 3 * nnz_a[ilevel - 1] + iadd) {
  Amat[ic1].i = Amat[ii + im0].i;
  Amat[ic1].j = Amat[ii + im0].j;
  Amat[ic1].aij += Amat[ii + im0].aij;
  while ((ii + im <= 2 * nnz_a[ilevel - 1] + iadd) && (Amat[ii + im0].i == Amat[ii + im].i) && (Amat[ii + im0].j == Amat[ii + im].j))
  {
  Amat[ic1].aij += Amat[ii + im].aij;
  im++;
  }
  ic1++;
  im0 = im;
  im++;
  }
  else {
  printf("error 1\n");
  getchar();
  }
  }
  flag[Amat[ii].i] = true;
  im = 1;
  im0 = 0;
  }
  }

  nnz_a[ilevel] = ic1 - 1 - 2 * nnz_a[ilevel - 1] - iadd;
  iadd += 2 * nnz_a[ilevel - 1];

  #if doubleintprecision == 1
		 printf("nnz : fine=%lld, coarse=%lld, operator complexity=%e. n : fine=%lld, coarse=%lld grid complexity=%e.\n", nnz_a[ilevel - 1], nnz_a[ilevel], (doubleT)(nnz_a[ilevel])/(doubleT)( nnz_a[ilevel - 1]), n_a[ilevel - 1], n_a[ilevel], (doubleT)(n_a[ilevel])/ (doubleT)(n_a[ilevel - 1]));
  #else
		printf("nnz : fine=%d, coarse=%d, operator complexity=%e. n : fine=%d, coarse=%d grid complexity=%e.\n", nnz_a[ilevel - 1], nnz_a[ilevel], (doubleT)(nnz_a[ilevel])/(doubleT)( nnz_a[ilevel - 1]), n_a[ilevel - 1], n_a[ilevel], (doubleT)(n_a[ilevel])/ (doubleT)(n_a[ilevel - 1]));
  #endif
   getchar();

  ilevel++;// грубосеточная матрица построена.

  } // иерархия сеток построена.

  return 0;

  } // aggregative_amg


  */

  // seidel и residual вся информация  хранится в индексах i, j поэтому вектор х обрабатывается верно в плане нумерации,
  // но для порядка обхода матрицы важно чтобы она была упорядочена по индексу i.


  // smoother.
  // 1 september 2015.
template <typename doublerealT>
void seidel1(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld",istr);
			#else
				printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidel1

// smoother.
// 1 september 2015.
template <typename doublerealT>
void seidel1(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld",istr);
			#else
				printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidel1

bool signal_omega_correct = false;
bool bproblem_amg_convergence1 = false;
bool bproblem_amg_convergence2 = false;
bool bproblem_amg_convergence3 = false;
doublereal buffers1omega, buffers2omega, buffers3omega;
doublereal gold_const = 0.2; // 0.2 default
doublereal gold_linear;

// Мысль. Омегу вычислить заранее и считывать из хеш таблицы.
template <typename doublerealT>
void optimal_omega(doublerealT rn, doublerealT &omega) {
	
	doublerealT rarg = powf((float)(rn), 0.333333f);
	doublerealT ksi = cosf(3.1415926535f / ((float)( rarg)));
	ksi *= ksi; // pow(ksi,2.0);
	if (ksi < 1.0) {
		omega = 2.0*(1.0 - sqrtf((float)(1.0 - ksi))) / ksi;// лучший выбор.
		// Для стабильности 0.2.
		if (bPhysics_PTBSH_memory) {
			// 0.2 6
			// 0.28 6
			// 0.36 6
			gold_const = 0.175;
			//if (rn<5000) gold_const = 0.08;
			//if (rn>100000) gold_const = 0.28;
		}
		//--->//omega = 1.0 + gold_const*(omega - 1.0); // optimum zero init 0.75
		//omega = 1.0 + 0.5*(omega - 1.0); // 0.7 0.5
		//omega = 1.0; // Seidel

		// 26_10_2016 gold_const передаётся пользователем из графического интерфейса.
		if (my_amg_manager.gold_const >= 0.0) {
			omega = 1.0 + my_amg_manager.gold_const*(omega - 1.0); // optimum zero init 0.75
		}
		else {
			// Если значение отрицательно то мы передаём просто omega из диапазона 0 < omega < 2:
			// При меньших 1.0 имеем нижнюю релаксацию, при больших 1.0 имеем верхнюю релаксацию.
			if ((fabs(my_amg_manager.gold_const) < 2.0) && (fabs(my_amg_manager.gold_const)>0.0)) {
				omega = fabs(my_amg_manager.gold_const);
			}
			else omega = 0.6667; //Jacobi - так рекомендует теория.
		}
	}
	else {
		printf("problem define optimum omega\n");
		omega = 1.15;
	}
	// 17 августа 2016
	if (0&&signal_omega_correct) {
		printf("omega=%e gold_const=%e\n", omega, gold_const);
		printf("please enter gold_const:\n");
		printf("0 - 0.22 1-0.24  2-0.26 3 - 0.28 4 - 0.3 5 - 0.32 6-0.34 7-0.36\n");
		char ch;// = 'd';
		ch=getchar();
		switch (ch) {
		case '0': gold_const = 0.22; break;
		case '1': gold_const = 0.24; break;
		case '2': gold_const = 0.26; break;
		case '3': gold_const = 0.28; break;
		case '4': gold_const = 0.3; break;
		case '5': gold_const = 0.32; break;
		case '6': gold_const = 0.34; break;
		case '7': gold_const = 0.36; break;
		default: gold_const = 0.2; break;
		}
		omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
		// Для стабильности.
		omega = 1.0 + gold_const*(omega - 1.0); // optimum zero init 0.75
		printf("omega=%e gold_const=%e\n", omega, gold_const);
		 ch = getchar();
		 signal_omega_correct = false;
	}
	/*
	// Seidel значительно хуже по быстродействию.
	if (bproblem_amg_convergence1) {
		if (bproblem_amg_convergence2) {
			if (bproblem_amg_convergence3) {
				// Квадратичный прогноз на основе параболы.
				doublerealT a, b, c;
				a = (buffers3omega - (gold_linear*(buffers2omega - buffers1omega) + gold_const*0.75*buffers1omega - gold_const*buffers2omega) / (gold_const*0.75 - gold_const)) / (gold_linear*(gold_linear - gold_const*0.75 - gold_const) + gold_const*gold_const*0.75);
				b = ((buffers2omega - buffers1omega) / (gold_const*0.75 - gold_const)) - a*(gold_const + gold_const*0.75);
				c = (gold_const*0.75*buffers1omega - gold_const*buffers2omega) / (gold_const*0.75 - gold_const) + a*gold_const*gold_const*0.75;
			
				doublerealT gold_const_x = 0.02;
				gold_const_x = -0.32; // TODO
				doublerealT foptimum = 1.0e40;
				//for (integer iscan = 0; iscan < 97; iscan++) {
				for (integer iscan = 0; iscan < 131; iscan++) {
					doublerealT xgold = gold_const_x + iscan*0.01;
					if ((a*xgold*xgold + b*xgold + c>1.0e-7) && (a*xgold*xgold + b*xgold + c < foptimum)) {
						foptimum = a*xgold*xgold + b*xgold + c;
						gold_const = xgold;
					}
				}

				//gold_const = 0.05; // 4 июня 2016
				omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
				omega = 1.0 + gold_const*(omega - 1.0);
				//printf("r1=%e, r2=%e, r3=%e, alpha=%e\n", buffers1omega, buffers2omega, buffers3omega, gold_const);
				//getchar();

				
				// лучше когда постоянно идёт квадратичный прогноз,
				// т.к. при вычислении оптимального коэффициента верхней
				// релаксации учитывается вся предыстория подборов оптимального параметра
				// верхней релаксации непрерывным образом.
				// но конечно-же этот подход требует проверки.
				bproblem_amg_convergence1 = false;
				bproblem_amg_convergence2 = false;
				bproblem_amg_convergence3 = false;
				// 4 июня 2016
				// Квадратичный прогноз будет идти постоянно.
				//buffers1omega = buffers2omega;
				//buffers2omega = buffers3omega;
			}
			else {
				// Линейный прогноз.
				//omega = 2.0/3.0;
				doublerealT a, b;
				a = (buffers1omega - buffers2omega) / (gold_const-0.75*gold_const);
				b = buffers2omega - a*0.75*gold_const;
				if (ksi < 1.0) {
					omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
					// Для стабильности.

					doublerealT gold_const_x = 0.02;
					gold_const_x = -0.32; // TODO
					doublerealT foptimum = 1.0e40;
					//for (integer iscan = 0; iscan < 97; iscan++) {
					for (integer iscan = 0; iscan < 131; iscan++) {
						doublerealT xgold = gold_const_x + iscan*0.01;
						if ((a*xgold+ b>1.0e-7) && (a*xgold + b < foptimum)) {
							foptimum = a*xgold + b;
							gold_linear = xgold;
						}
					}

					
					//gold_linear = 0.1;//4 июня 2016
					omega = 1.0 + (gold_linear)*(omega - 1.0); // optimum zero init 0.75
					//printf("alpha=%e\n", gold_linear);
					//getchar();
					//omega = 1.0 + 0.5*(omega - 1.0); // 0.7 0.5
					//omega = 1.0; // Seidel
					// Раскоментировать если использовать лишь линейное предсказание.
					//gold_const = (0.9 - b) / a;
					//bproblem_amg_convergence1 = false;
					//bproblem_amg_convergence2 = false;
				}
				else {
					printf("problem define optimum omega\n");
					omega = 1.15;
				}
			}
		}
		else {
			//omega = 1.0;
			if (ksi < 1.0) {
				omega = 2.0*(1.0 - sqrt(1.0 - ksi)) / ksi;// лучший выбор.
				// Для стабильности.
				// 0.15/0.2==0.75;
				omega = 1.0 + (gold_const*0.75)*(omega - 1.0); // optimum zero init 0.75
				//omega = 1.0 + 0.5*(omega - 1.0); // 0.7 0.5
				//omega = 1.0; // Seidel
			}
			else {
				printf("problem define optimum omega\n");
				omega = 1.15;
			}
		}
	}
	//omega = 1.0; // seidel
	*/
  //  omega = 1.0; // seidel

}

// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidelsor(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega); // 28.07.2016.
	//omega = 0.7;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].aij < 0.0) {
						x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else{
						ap += Amat[ic].aij; // усиление диагонали 16. 08 .2016
					}
				}
				else ap += Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld",istr);
			#else
					printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidelsor



// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidelsor(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega);//28.07.2016
	//omega = 0.7;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].aij < 0.0) {
						x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap += Amat[ic].aij;
					}
				}
				else ap += Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld",istr);
			#else
					printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				x[istr] /= ap;
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}


} // seidelsor


// smoother.
// 5 jan 2016.
// 1 september 2015.
// 9 июня 2016.
// incomplite lower upwer decomposition.
template <typename doublerealT>
void classic_ilu(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}

	// это нужне сделать единожды на фазе препроцессинга.
	doublerealT* diagonal = new doublerealT[(integer)(rn)];
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT mult=0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// линейный поиск очень медленный особенно на каждой итерации.
						for (integer ii1 = istart; ii1 <= iend; ii1++) {
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								while (Amat[ic1].i == Amat[ic].j) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			diagonal[istr] = ap - mult;
			flag[Amat[ii].i] = true;
		}
	}


	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega);
	omega = 1.0;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld",istr);
			#else
					printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				//x[istr] /= ap;
				x[istr] /= diagonal[istr];
				//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}

	delete[] diagonal;

} // classic_ilu


// smoother.
// 5 jan 2016.
// 1 september 2015.
// 9 июня 2016.
// incomplite lower upwer decomposition.
template <typename doublerealT>
void classic_ilu(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{

	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	doublerealT rn = 1.0;
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			flag[Amat[ii].i] = true;
			rn += 1.0;
		}
	}

	doublerealT omega = 1.0; // initialize.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}

	doublerealT* diagonal = new doublerealT[(integer)(rn)];
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT mult = 0.0;
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// Здесь нужно сделать хеш таблицу которая позволяет избавиться от линейного поиска.
						// линейный поиск очень медленный особенно на каждой итерации.
						for (integer ii1 = istart; ii1 <= iend; ii1++) {
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								while (Amat[ic1].i == Amat[ic].j) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			diagonal[istr] = ap - mult;
			flag[Amat[ii].i] = true;
		}
	}


	// За подробностями смотри книгу Патрика Роуча стр. 183.
	optimal_omega(rn, omega);
	omega = 1.0;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			doublerealT ap = 0.0;
			doublerealT rold = x[istr];
			x[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else ap = Amat[ic].aij;
				ic++;
			}
			/*
			if (fabs(ap) < 1.0e-30) {
			#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld",istr);
			#else
				printf("zero diagonal elements in string %d",istr);
			#endif
			
			getchar();
			exit(1);
			}
			else */ {
				//x[istr] /= ap;
				x[istr] /= diagonal[istr];
				//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			flag[Amat[ii].i] = true;
		}
	}

	delete[] diagonal;

} // classic_ilu

// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidel(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	//seidel1<doublerealT>(Amat,  istart,  iend, x, b, flag, n);
	seidelsor<doublerealT>(Amat, istart, iend, x, b, flag, n);
	// низкое быстродействие из-за линейного поиска, нужна хеш таблица.
	//classic_ilu<doublerealT>(Amat, istart, iend, x, b, flag, n);
}

// smoother.
// 5 jan 2016.
// 1 september 2015.
template <typename doublerealT>
void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
{
	//seidel1<doublerealT>(Amat,  istart,  iend, x, b, flag, n);
	seidelsor<doublerealT>(Amat, istart, iend, x, b, flag, n);
	//classic_ilu<doublerealT>(Amat, istart, iend, x, b, flag, n);
}


  /*
  integer *row_ptr_start = new integer[4 * n_a[0] + 1];
  integer *row_ptr_end = new integer[4 * n_a[0] + 1];
  // istart - начальная позиция ненулевых элементов в матрице А.
  // iend - конечная позиция ненулевых элементов в матрице А.
  for (integer i = 1; i <= n; i++) {
  flag[i] = false;
  }
  for (integer ii = 1; ii <= nnz_a[0]; ii++) {
  if (flag[Amat[ii].i] == false) {
  integer istr = Amat[ii].i;
  integer ic = ii;
  integer icdiag = ii;
  row_ptr_start[istr] = ii;
  doublerealT ap = 0.0;
  //x[istr] = b[istr];
  while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
  if (Amat[ic].j != istr) {
  //x[istr] += -Amat[ic].aij*x[Amat[ic].j];
  }
  else {
  ap = Amat[ic].aij;
  icdiag = ic;
  }
  ic++;
  }
  row_ptr_end[istr] = ic - 1;
  if (fabs(ap) < 1.0e-30) {
  #if doubleintprecision == 1
		printf("zero diagonal elements in string %lld", istr);
  #else
		printf("zero diagonal elements in string %d", istr);
  #endif
 
  getchar();
  exit(1);
  }
  else {
  //x[istr] /= ap;
  }

  flag[Amat[ii].i] = true;
  Ak temp = Amat[ii];
  Amat[ii] = Amat[icdiag];
  Amat[icdiag] = temp;
  Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
  }
  }
  */

  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelqstable(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		x[istr] = b[istr];

		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] *= Amat[row_ptr_start[ii]].aij;
	}


} // seidelq

// smoother.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqstable(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		x[istr] = b[istr];

		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] *= Amat[row_ptr_start[ii]].aij;
	}


} // seidelq

integer isorintmemo = -1;
  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelqsor(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

    // BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.15; // лучший выбор.
	bool bfirst = false;
	//if (isorintmemo == iadd) {
		// Это точно не первый раз
		//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		// Параллельность почему-то тормозит очень сильно.
//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			rsum += -Amat[ii1].aij*x[Amat[ii1].j];
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] += rsum;

		x[istr] *= Amat[row_ptr_start[ii]].aij;
		if (bfirst) {
			bfirst = false;
		}
		else {
			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}


} // seidelqsor

template <typename doublerealT>
void seidelqsor(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.15; // лучший выбор.
	bool bfirst = false;
	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		// Параллельность почему-то тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
		{
			rsum += -Amat[ii1].aij*x[Amat[ii1].j];
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
		}
		x[istr] += rsum;

		x[istr] *= Amat[row_ptr_start[ii]].aij;
		if (bfirst) {
			bfirst = false;
		}
		else {
			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}


} // seidelqsor


// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.
	
	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);
    //omega = 0.7;

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];
		// Распараллеливание почемуто тормозит очень сильно.
         //#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <=is2; ii1++)
		{
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			integer ipos = Amat[ii1].j;
			rsum += -Amat[ii1].aij*x[ipos];
		}
		x[istr] += rsum;
		x[istr] *= Amat[row_ptr_start[ii]].aij;
		
			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
	}


} // seidelqsor2


bool bfirst_jacoby_start = true;
doublereal * x_jacoby_buffer = NULL;
integer i_x_jacoby_buffer_pool_size = 0;
integer isimmetricGS_switch = 0;

// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega); //28.07.2016
	//omega = 0.7;

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	if (omega < 1.0) {
		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != NULL) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = NULL;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
			    }
			}
		}
		// copy

		if (x_jacoby_buffer == NULL) {
			printf("ERROR : x_jacoby_buffer == NULL.\n");
			system("PAUSE");
			exit(1);
		}


//#pragma loop(hint_parallel(8))
#pragma omp parallel for
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			x_jacoby_buffer[istr] = x[istr];
		}


//#pragma loop(hint_parallel(8))
#pragma omp parallel for
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x_jacoby_buffer[istr];

			// 13.07.2016
			doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				// 13.07.2016
				// игнорирование positive connections.
				//if ((Amat[ii1].aij < 0.0)) {
				rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];
				//}
				//else {
				// не рабтает.
				//	ap_now += Amat[ii1].aij;
				//}
			}
			x[istr] += rsum;
			//x[istr] *= Amat[row_ptr_start[ii]].aij;
			// 13.07.2016
			x[istr] /= ap_now;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}
	else {

		// 3 ноября 2016. Симметричный метод Гаусса-Зейделя.
		if (isimmetricGS_switch == 0) {
			// 3 ноября 2016 было экспериментально доказано на BSKDmitrii что симметричный метод Гаусса - Зейделя РАСХОДИТСЯ.
			// НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ СИММЕТРИЧНЫЙ МЕТОД ГАУССА -ЗЕЙДЕЛЯ. ИСПОЛЬЗУЙТЕ ОБЫЧНЫЙ МЕТОД ЗЕЙДЕЛЯ.


#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				doublerealT rold = x[istr];

				// 13.07.2016
				doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
				// 28.01.2017
				//ap_now = 0.0;

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					// 13.07.2016
					if (1) {
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						// Здесь всё в каше и позитив и негатив коннектионшс.
						rsum += -Amat[ii1].aij*x[ipos];
						//}
						//else {
						// не работает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					else {
						// Здесь я перемудрил. По видимому нужен Крукиер : TKM, TKM1, TKM2.

						// игнорирование positive connections.
						if ((Amat[ii1].aij < 0.0)) {
						    rsum += -Amat[ii1].aij*x[ipos];
							//ap_now += fabs(Amat[ii1].aij);
						}
						else {
						   // не работает.
							// Вероятно из-за того что так нарушен баланс.
						    //ap_now += fabs(Amat[ii1].aij);
							if (fabs(x[ipos]) > fabs(x[istr])) {
								ap_now += fabs(Amat[ii1].aij);
							}
							else rsum += -Amat[ii1].aij*x[ipos];
						}
					}
				}
				x[istr] += rsum;
				//x[istr] *= Amat[row_ptr_start[ii]].aij;
				// 13.07.2016
				x[istr] /= ap_now;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			// Ни в коем случае не переключать. 3 ноября 2016.
			//isimmetricGS_switch = 1;

		}
		else {

#pragma omp parallel for
			for (integer ii = endpos; ii >= startpos; ii--) {
				integer istr = ii - iadd;
				doublerealT rold = x[istr];

				// 13.07.2016
				doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					// 13.07.2016
					// игнорирование positive connections.
					//if ((Amat[ii1].aij < 0.0)) {
					rsum += -Amat[ii1].aij*x[ipos];
					//}
					//else {
					// не рабтает.
					//	ap_now += Amat[ii1].aij;
					//}
				}
				x[istr] += rsum;
				//x[istr] *= Amat[row_ptr_start[ii]].aij;
				// 13.07.2016
				x[istr] /= ap_now;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
			//isimmetricGS_switch = 0;
		}
	}


} // seidelqsor2

  // smoother.
  // 6 июня 2017 Трёхшаговый метод Рунге-Кутты, параметры взяты из литературы.
// Достоинство в том что оптимальные параметры известны из литературы и не надо
// ничего вручную подбирать.
// Методы Рунге-Кутты в качестве сглаживателей рекомендованы для очень плохообусловленных задач,
// что вызвано отчасти плохими сетками (например, АЛИС сетками).
  // 5 января 2016 с использованием формулы из книги Патрика Роуча.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void Runge_Kutt_3or5(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, integer iorder)
{
	// iorder == 3 or 5. Трёхшаговый или пятишаговый методы Рунге - Кутты.

	if ((iorder == 3) || (iorder == 5)) {

		// Трёхшаговый метод Рунге - Кутты.

		// Методы ускорения газодинамических расчётов на неструктурированных сетках. К.Н.Волков, под редакцией проф. В.Н.Емельянова
		// Москва ФИЗМАТЛИТ 2014.
		doublerealT m[5];
		if (iorder == 3) {
			if (1) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.2075;
				m[1] = 0.5915;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
			else {
				// Направленное огрубление.
				m[0] = 0.2239;
				m[1] = 0.5653;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
		}

		if (iorder == 5) {
			if (0) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.0962;
				m[1] = 0.2073;
				m[2] = 0.3549;
				m[3] = 0.6223;
				m[4] = 1.0;
			}
			else {
				// Направленное огрубление.
				m[0] = 0.0870;
				m[1] = 0.1892;
				m[2] = 0.3263;
				m[3] = 0.5558;
				m[4] = 1.0;
			}
		}

		// istart - начальная позиция ненулевых элементов в матрице А.
		// iend - конечная позиция ненулевых элементов в матрице А.


		doublerealT rn = (doublerealT)(iendq - istartq + 1);

		integer startpos = istartq + iadd;
		integer endpos = iendq + iadd;


		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != NULL) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = NULL;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
				}
			}
		}
		// copy

		
		if (x_jacoby_buffer == NULL) {
			printf("ERROR : x_jacoby_buffer == NULL.\n");
			system("PAUSE");
			exit(1);
		}


		for (integer inumber_step_Runge_Kutt = 0; inumber_step_Runge_Kutt < iorder-1; inumber_step_Runge_Kutt++) {

			
				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}
			

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {

				integer istr = ii - iadd;
				doublerealT rold = x_jacoby_buffer[istr];

				// 13.07.2016
				doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					// 13.07.2016
					// игнорирование positive connections.
					//if ((Amat[ii1].aij < 0.0)) {
					rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];

					//rsum += -Amat[ii1].aij*x[ipos]; // experiment
					//}
					//else {
					// не рабтает.
					//	ap_now += Amat[ii1].aij;
					//}
				}
				x[istr] += rsum;
				//x[istr] *= Amat[row_ptr_start[ii]].aij;
				// 13.07.2016
				x[istr] /= ap_now;


				x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold; // 21
				//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23
				
				//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
				//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
			}

		}

	}
	else {
		// Неправильный порядок метода Рунге - Кутты. 
		// Предусмотрены только третий и пятый порядки.
		printf("order Runge Kutt method is bad...\n ");
		system("pause");
		exit(1);
	}


} // Runge_Kutt_3or5

  // smoother.
  // 6 июня 2017 Трёхшаговый метод Рунге-Кутты, параметры взяты из литературы.
  // Достоинство в том что оптимальные параметры известны из литературы и не надо
  // ничего вручную подбирать.
  // Методы Рунге-Кутты в качестве сглаживателей рекомендованы для очень плохообусловленных задач,
  // что вызвано отчасти плохими сетками (например, АЛИС сетками).
  // 5 января 2016 с использованием формулы из книги Патрика Роуча.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void Runge_Kutt_3or5(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, 
	integer * &row_ptr_end, integer iadd, integer iorder, bool* &F_false_C_true, integer idirect)
{
	// iorder == 3 or 5. Трёхшаговый или пятишаговый методы Рунге - Кутты.

	if ((iorder == 3) || (iorder == 5)) {

		// Трёхшаговый метод Рунге - Кутты.

		// Методы ускорения газодинамических расчётов на неструктурированных сетках. К.Н.Волков, под редакцией проф. В.Н.Емельянова
		// Москва ФИЗМАТЛИТ 2014.
		doublerealT m[5];
		if (iorder == 3) {
			if (1) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.2075;
				m[1] = 0.5915;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
			else {
				// Направленное огрубление.
				m[0] = 0.2239;
				m[1] = 0.5653;
				m[2] = 1.0;
				m[3] = 0.0; // не используется в трёхшаговом методе.
				m[4] = 0.0; // не используется в трёхшаговом методе.
			}
		}

		if (iorder == 5) {
			if (0) {
				// ПИОНЕР - 1 лучший выбор.
				// Полное огрубление.
				m[0] = 0.0962;
				m[1] = 0.2073;
				m[2] = 0.3549;
				m[3] = 0.6223;
				m[4] = 1.0;
			}
			else {
				// Направленное огрубление.
				m[0] = 0.0870;
				m[1] = 0.1892;
				m[2] = 0.3263;
				m[3] = 0.5558;
				m[4] = 1.0;
			}
		}

		// istart - начальная позиция ненулевых элементов в матрице А.
		// iend - конечная позиция ненулевых элементов в матрице А.


		doublerealT rn = (doublerealT)(iendq - istartq + 1);

		integer startpos = istartq + iadd;
		integer endpos = iendq + iadd;


		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != NULL) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = NULL;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
				}
			}
		}
		// copy





		for (integer inumber_step_Runge_Kutt = 0; inumber_step_Runge_Kutt < iorder - 1; inumber_step_Runge_Kutt++) {

			if (idirect == 1) {

				// Восходящая ветвь : сначала F потом C.

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) {

						integer istr = ii - iadd;
						doublerealT rold = x_jacoby_buffer[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold; // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
					}
				}


				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == true) {

						integer istr = ii - iadd;
						doublerealT rold = x_jacoby_buffer[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold; // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];

					}
				}

			}
			else {
				// Нисходящая ветвь : сначала C потом F.

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == true) {

						integer istr = ii - iadd;
						doublerealT rold = x_jacoby_buffer[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold; // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
					}
				}


				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					integer istr = ii - iadd;
					x_jacoby_buffer[istr] = x[istr];
				}

				//#pragma loop(hint_parallel(8))
#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) {

						integer istr = ii - iadd;
						doublerealT rold = x_jacoby_buffer[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];

							//rsum += -Amat[ii1].aij*x[ipos]; // experiment
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;


						x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x[istr] + m[inumber_step_Runge_Kutt] * rold; // 21
						//x[istr] = m[inumber_step_Runge_Kutt]*x[istr] + (1.0-m[inumber_step_Runge_Kutt]) * rold; // 23

						//x[istr] = (1.0 - m[inumber_step_Runge_Kutt])*x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];
						//x[istr] = x_jacoby_buffer[istr] + m[inumber_step_Runge_Kutt] * x[istr];

					}
				}


			}

		}

	}
	else {
		// Неправильный порядок метода Рунге - Кутты. 
		// Предусмотрены только третий и пятый порядки.
		printf("order Runge Kutt method is bad...\n ");
		system("pause");
		exit(1);
	}


} // Runge_Kutt_3or5

// smoother.
// 5 июня 2017 добавлено CF-Jacobi smoothing (F - smoothing).
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, bool* &F_false_C_true, integer idirect)
{
	// F_false_C_true - нумерация начинается с 1.
	// idirect==0 douwn
	// idirect==1 up

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

							// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega); //28.07.2016
							  //omega = 0.7;

							  //if (isorintmemo == iadd) {
							  // Это точно не первый раз
							  //bfirst = false;
							  //}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	if (omega < 1.0) {
		if (bfirst_jacoby_start) {
			x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
			i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
			bfirst_jacoby_start = false;
		}
		else {
			// Перевыделение оперативной памяти в случае nu1==0.
			if (i_x_jacoby_buffer_pool_size < 3 * (endpos - startpos + 1)) {
				if (x_jacoby_buffer != NULL) {
					delete[] x_jacoby_buffer;
					x_jacoby_buffer = NULL;
					x_jacoby_buffer = new doublereal[3 * (endpos - startpos + 1)];
					i_x_jacoby_buffer_pool_size = 3 * (endpos - startpos + 1);
					bfirst_jacoby_start = false;
				}
			}
		}
		// copy

		

		if (idirect == 1) {
			// Восходящая ветвь.

			// Сначала F потом C.

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii] == false) { // F nodes

					integer istr = ii - iadd;
					doublerealT rold = x_jacoby_buffer[istr];

					// 13.07.2016
					doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
					//}
				}
			}

			// update.
			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii] == true) { // C nodes

					integer istr = ii - iadd;
					doublerealT rold = x_jacoby_buffer[istr];

					// 13.07.2016
					doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
					//}
				}
			}



		}
		else {
			// idirect==0
			// Сначала С потом F.

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii] == true) { // C nodes

					integer istr = ii - iadd;
					doublerealT rold = x_jacoby_buffer[istr];

					// 13.07.2016
					doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
					//}
				}
			}


			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				x_jacoby_buffer[istr] = x[istr];
			}

			//#pragma loop(hint_parallel(8))
#pragma omp parallel for
			for (integer ii = startpos; ii <= endpos; ii++) {
				if (F_false_C_true[ii] == false) { // F nodes

					integer istr = ii - iadd;
					doublerealT rold = x_jacoby_buffer[istr];

					// 13.07.2016
					doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

					x[istr] = b[istr];

					doublerealT rsum = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x[istr] += -Amat[ii1].aij*x_jacoby_buffer[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						// 13.07.2016
						// игнорирование positive connections.
						//if ((Amat[ii1].aij < 0.0)) {
						rsum += -Amat[ii1].aij*x_jacoby_buffer[ipos];
						//}
						//else {
						// не рабтает.
						//	ap_now += Amat[ii1].aij;
						//}
					}
					x[istr] += rsum;
					//x[istr] *= Amat[row_ptr_start[ii]].aij;
					// 13.07.2016
					x[istr] /= ap_now;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					//if (is1 <= is2) {
						// Только если это не условие Дирихле применяем релаксацию.
						x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
					//}
				}
			}

		}


	}
	else {

		// 3 ноября 2016. Симметричный метод Гаусса-Зейделя.
		if (isimmetricGS_switch == 0) {
			// 3 ноября 2016 было экспериментально доказано на BSKDmitrii что симметричный метод Гаусса - Зейделя РАСХОДИТСЯ.
			// НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ СИММЕТРИЧНЫЙ МЕТОД ГАУССА -ЗЕЙДЕЛЯ. ИСПОЛЬЗУЙТЕ ОБЫЧНЫЙ МЕТОД ЗЕЙДЕЛЯ.

			if (idirect == 1) {
				// Восходящая ветвь.

				

				// Сначала F потом C.

//----->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер : TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}

//---->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == true) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер : TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}

			}
			else {

				// idirect==0
				// Сначала С потом F.

//---->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == true) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер : TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}

//---->#pragma omp parallel for
				for (integer ii = startpos; ii <= endpos; ii++) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
						// 28.01.2017
						//ap_now = 0.0;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							if (1) {
								// игнорирование positive connections.
								//if ((Amat[ii1].aij < 0.0)) {
								// Здесь всё в каше и позитив и негатив коннектионшс.
								rsum += -Amat[ii1].aij*x[ipos];
								//}
								//else {
								// не работает.
								//	ap_now += Amat[ii1].aij;
								//}
							}
							else {
								// Здесь я перемудрил. По видимому нужен Крукиер : TKM, TKM1, TKM2.

								// игнорирование positive connections.
								if ((Amat[ii1].aij < 0.0)) {
									rsum += -Amat[ii1].aij*x[ipos];
									//ap_now += fabs(Amat[ii1].aij);
								}
								else {
									// не работает.
									// Вероятно из-за того что так нарушен баланс.
									//ap_now += fabs(Amat[ii1].aij);
									if (fabs(x[ipos]) > fabs(x[istr])) {
										ap_now += fabs(Amat[ii1].aij);
									}
									else rsum += -Amat[ii1].aij*x[ipos];
								}
							}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}

			}

			// Ни в коем случае не переключать. 3 ноября 2016.
			//isimmetricGS_switch = 1;

		}
		else {

			if (idirect == 1) {
				// Восходящая ветвь.

				// Сначала F потом C.

//---->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}


//----->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii] == true) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}



			}
			else {
				// idirect==0
				// Сначала С потом F.

//--->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii] == true) { // C nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}


//--->#pragma omp parallel for
				for (integer ii = endpos; ii >= startpos; ii--) {
					if (F_false_C_true[ii] == false) { // F nodes

						integer istr = ii - iadd;
						doublerealT rold = x[istr];

						// 13.07.2016
						doublerealT ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

						x[istr] = b[istr];

						doublerealT rsum = 0.0;
						integer is1 = row_ptr_start[ii] + 1;
						integer is2 = row_ptr_end[ii];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii1 = is1; ii1 <= is2; ii1++)
						{
							//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
							integer ipos = Amat[ii1].j;
							// 13.07.2016
							// игнорирование positive connections.
							//if ((Amat[ii1].aij < 0.0)) {
							rsum += -Amat[ii1].aij*x[ipos];
							//}
							//else {
							// не рабтает.
							//	ap_now += Amat[ii1].aij;
							//}
						}
						x[istr] += rsum;
						//x[istr] *= Amat[row_ptr_start[ii]].aij;
						// 13.07.2016
						x[istr] /= ap_now;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						//if (is1 <= is2) {
							// Только если это не условие Дирихле применяем релаксацию.
							x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
						//}
					}
				}

			}

			//isimmetricGS_switch = 0;  // смена направления.
		}
	}


} // seidelqsor2


// smoother.
// 16 января 2016 распараллеливание на центральном процессоре.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2Pcpu(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	integer inumcore_loc = 2;

	if (inumcore_loc == 1) {

		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}

	}

	if (inumcore_loc == 2) {

		// Здесь отсутствует информация о nested_desection
		// поэтому куча времени тратится на барьерную синхронизацию.

		integer middle = (startpos + endpos)/2;
		integer iadd1 = iadd;
		integer iadd2 = iadd;
		integer middle1 = middle;

#pragma omp parallel sections
		{
#pragma omp section
			{
				// работа первого потока.
				for (integer ii = startpos; ii <= middle; ii++) {
					integer istr = ii - iadd1;
					doublerealT rold = x[istr];

					doublerealT x1buf = 0.0;
					x1buf = b[istr];

					doublerealT rsum1 = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x1buf += -Amat[ii1].aij*x[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						rsum1 = rsum1 - Amat[ii1].aij*x[ipos];
					}
					x1buf = x1buf + rsum1;
					x1buf = x1buf * Amat[row_ptr_start[ii]].aij;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					x1buf = omega*x1buf + (1.0 - omega)*rold; // this is SOR
					x[istr] = x1buf;
				}
			}

#pragma omp section
			{
				// работа второго потока. 
				for (integer ii_1 = middle1 + 1; ii_1 <= endpos; ii_1++) {
					integer istr1 = ii_1 - iadd2;
					doublerealT rold1 = x[istr1];

					doublerealT x2buf = 0.0;
					x2buf = b[istr1];

					doublerealT rsum2 = 0.0;
					integer is3 = row_ptr_start[ii_1] + 1;
					integer is4 = row_ptr_end[ii_1];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii2 = is3; ii2 <= is4; ii2++)
					{
						//x[istr1] += -Amat[ii2].aij*x[Amat[ii2].j];
						integer ipos = Amat[ii2].j;
						rsum2 = rsum2 - Amat[ii2].aij*x[ipos];
					}
					x2buf = x2buf + rsum2;
					x2buf = x2buf*Amat[row_ptr_start[ii_1]].aij;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					x2buf = omega*x2buf + (1.0 - omega)*rold1; // this is SOR
					x[istr1]=x2buf;
				}
			}
		}

	}


} // seidelqsor2Pcpu


bool* bnested_desection_global_amg = NULL;

// smoother.
// 16 января 2016 распараллеливание на центральном процессоре.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor2Pcpu(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, bool* &bnested_desection, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;

	integer inumcore_loc = 1;

	if (inumcore_loc == 1) {

		// Однопоточный вариант программы.
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}

	}

	if (inumcore_loc == 2) {

		integer middle = (integer)(0.5*(startpos + endpos));
		doublerealT omega1 = omega;
		doublerealT omega2 = omega;
		integer iadd1 = iadd;
		integer iadd2 = iadd;
		integer middle1 = middle;
		doublerealT ic_all = 0.0;
		doublerealT ic_separator = 0.0;
		for (integer i_51 = startpos - iadd1; i_51 <= endpos - iadd1; i_51++) {
			bnested_desection_global_amg[i_51] = bnested_desection[i_51];
			ic_all+=1.0;
			if (!bnested_desection_global_amg[i_51]) ic_separator+=1.0;
		}
		//printf("all=%e separator=%e\n",ic_all,ic_separator);
		//system("pause");

		if (2.0*ic_separator < ic_all) {
			// параллельно только при хорошем делении.



			//#pragma omp parallel sections num_threads(4)
			//{

			//printf_s("Hello from thread %d\n", omp_get_thread_num());
			//#pragma omp section
			//	printf_s("Hello from thread %d\n", omp_get_thread_num());
			///}

			// Версия с nesteddesection избавляет от барьерных синхронизаций и мы
			// получаем линейное ускорение производительности при увеличении числа ядер.

			//default(shared)

#pragma omp parallel  shared(bnested_desection_global_amg, bnested_desection,x,row_ptr_start,row_ptr_end,b,Amat)
			{
			#pragma omp	sections
				{
			#pragma omp section
					{
//#pragma omp parallel sections num_threads(2)
	//	{

			// работа первого потока.
			for (integer ii = startpos; ii <= middle; ii++) {
				integer istr = ii - iadd1;
				if (bnested_desection_global_amg[istr]) {
					doublerealT rold = x[istr];

					doublerealT x1buf = 0.0;
					x1buf = b[istr];

					doublerealT rsum1 = 0.0;
					integer is1 = row_ptr_start[ii] + 1;
					integer is2 = row_ptr_end[ii];
					// Распараллеливание почемуто тормозит очень сильно.
					//#pragma omp parallel for reduction(+:rsum)
					for (integer ii1 = is1; ii1 <= is2; ii1++)
					{
						//x1buf += -Amat[ii1].aij*x[Amat[ii1].j];
						integer ipos = Amat[ii1].j;
						rsum1 = rsum1 - Amat[ii1].aij*x[ipos];
					}
					x1buf = x1buf + rsum1;
					x1buf = x1buf * Amat[row_ptr_start[ii]].aij;

					// Запускается только после первого раза сразу запускать нельзя
					// т.к. начальное значение не является адекватным.
					x1buf = omega1*x1buf + (1.0 - omega1)*rold; // this is SOR
					x[istr] = x1buf;
				}
			}
			}

#pragma omp section
			{
				// работа второго потока. 
				for (integer ii_1 = middle1 + 1; ii_1 <= endpos; ii_1++) {
					integer istr1 = ii_1 - iadd2;
					if (bnested_desection[istr1]) {
						doublerealT rold1 = x[istr1];

						doublerealT x2buf = 0.0;
						x2buf = b[istr1];

						doublerealT rsum2 = 0.0;
						integer is3 = row_ptr_start[ii_1] + 1;
						integer is4 = row_ptr_end[ii_1];
						// Распараллеливание почемуто тормозит очень сильно.
						//#pragma omp parallel for reduction(+:rsum)
						for (integer ii2 = is3; ii2 <= is4; ii2++)
						{
							//x[istr1] += -Amat[ii2].aij*x[Amat[ii2].j];
							integer ipos = Amat[ii2].j;
							rsum2 = rsum2 - Amat[ii2].aij*x[ipos];
						}
						x2buf = x2buf + rsum2;
						x2buf = x2buf*Amat[row_ptr_start[ii_1]].aij;

						// Запускается только после первого раза сразу запускать нельзя
						// т.к. начальное значение не является адекватным.
						x2buf = omega2*x2buf + (1.0 - omega2)*rold1; // this is SOR
						x[istr1] = x2buf;
					}
				}
			}
		}
		}

		// Однопоточный смыкающий кусок.
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			if (!bnested_desection[istr]) {
				doublerealT rold = x[istr];

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					rsum += -Amat[ii1].aij*x[ipos];
				}
				x[istr] += rsum;
				x[istr] *= Amat[row_ptr_start[ii]].aij;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
		}
		}
		else {
			// серийно
			// Однопоточный вариант программы.
			for (integer ii = startpos; ii <= endpos; ii++) {
				integer istr = ii - iadd;
				doublerealT rold = x[istr];

				x[istr] = b[istr];

				doublerealT rsum = 0.0;
				integer is1 = row_ptr_start[ii] + 1;
				integer is2 = row_ptr_end[ii];
				// Распараллеливание почемуто тормозит очень сильно.
				//#pragma omp parallel for reduction(+:rsum)
				for (integer ii1 = is1; ii1 <= is2; ii1++)
				{
					//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
					integer ipos = Amat[ii1].j;
					rsum += -Amat[ii1].aij*x[ipos];
				}
				x[istr] += rsum;
				x[istr] *= Amat[row_ptr_start[ii]].aij;

				// Запускается только после первого раза сразу запускать нельзя
				// т.к. начальное значение не является адекватным.
				x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
			}
		}

	}


} // seidelqsor2Pcpu+nested desection


bool bswitch_direct_seidelqsor3 = false;
// smoother.
// 14 января 2015 каждый раз осуществляется смена направления сканирования.
// Работает только с ноой логикой : nFinestSweeps=2, nPreSweeps=0, nPostSweeps=2.
// Смена направлений оказалась значительно хуже по быстродействию.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor3(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	if (bswitch_direct_seidelqsor3) {
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}
	else {
		// другое направление сканирования.

		for (integer ii = endpos; ii >= startpos; ii--) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}

	// смена направления сканирования на обратное.
	bswitch_direct_seidelqsor3 = !bswitch_direct_seidelqsor3;

} // seidelqsor3

// smoother.
// 14 января 2015 каждый раз осуществляется смена направления сканирования.
// Работает только с ноой логикой : nFinestSweeps=2, nPreSweeps=0, nPostSweeps=2.
// Смена направлений оказалась значительно хуже по быстродействию.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelqsor3(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	if (bswitch_direct_seidelqsor3) {
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}
	else {
		// другое направление сканирования.

		for (integer ii = endpos; ii >= startpos; ii--) {
			integer istr = ii - iadd;
			doublerealT rold = x[istr];

			x[istr] = b[istr];

			doublerealT rsum = 0.0;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			// Распараллеливание почемуто тормозит очень сильно.
			//#pragma omp parallel for reduction(+:rsum)
			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
				integer ipos = Amat[ii1].j;
				rsum += -Amat[ii1].aij*x[ipos];
			}
			x[istr] += rsum;
			x[istr] *= Amat[row_ptr_start[ii]].aij;

			// Запускается только после первого раза сразу запускать нельзя
			// т.к. начальное значение не является адекватным.
			x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
		}
	}

	// смена направления сканирования на обратное.
	bswitch_direct_seidelqsor3 = !bswitch_direct_seidelqsor3;

} // seidelqsor3


// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
// 9 июня 2016. incomplete lower upwer decomposition.
template <typename doublerealT>
void classical_ilu2(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);
	omega = 1.0;

	// это нужне сделать единожды на фазе препроцессинга.
	doublerealT* diagonal = NULL;
	diagonal = new doublerealT[(integer)(rn)+1];
	if (diagonal == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for diagonal in classical_ilu2...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	// initialization:
	for (integer i_6 = 0; i_6 < (integer)(rn)+1; i_6++) diagonal[i_6] = 1.0;

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		{
			integer istr = ii-iadd;
			integer ic = ii;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			doublerealT ap = 0.0;
			doublerealT mult = 0.0;
			for (ic = is1; ic <= is2; ic++) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// линейный поиск очень медленный особенно на каждой итерации.
						integer ii1 = iadd + Amat[ic].j;
						//for (integer ii1 = startpos; ii1 <= endpos; ii1++) {
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								integer is11 = row_ptr_start[ii1] + 1;
								integer is21 = row_ptr_end[ii1];
								for (ic1 = is11; ic1 <= is21; ic1++) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						//}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
			}
			ap = 1.0 / Amat[is1 - 1].aij;
			diagonal[istr] = ap - mult;
		}
	}

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	 startpos = istartq + iadd;
	 endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];
		// Распараллеливание почемуто тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			integer ipos = Amat[ii1].j;
			rsum += -Amat[ii1].aij*x[ipos];
		}
		x[istr] += rsum;
		//x[istr] *= Amat[row_ptr_start[ii]].aij;
		// incomplete lower upwer decomposition.
		x[istr] /= diagonal[istr];

		// Запускается только после первого раза сразу запускать нельзя
		// т.к. начальное значение не является адекватным.
		//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
	}

	delete[] diagonal;


} // classical_ilu2

// smoother.
// 5 января 2016 с использованием формулы из книги Патрика Роуча.
// 9 september 2015.
// q - quick.
// 9 июня 2016. incomplete lower upwer decomposition.
template <typename doublerealT>
void classical_ilu2(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	// sor 1.855 использовать нельзя мы имеем расходимость вычислительного процесса.
	// Попробуем нижнюю релаксацию.
	// Расходимость имеем и при нижней релаксации. 0.8

	// BSKDmitrii
	// omega   iter  time,s
	// 1.0 106 43
	// 1.1 98 42
	// 1.15 94 40 best
	// 1.2 90 40
	// 1.225 413 1min 37s
	// 1.25 divergence detected
	// 1.3 divergence detected

	doublerealT omega = 1.0; // initialize.

	// За подробностями смотри книгу Патрика Роуча стр. 183.
	doublerealT rn = (doublerealT)(iendq - istartq + 1);
	optimal_omega(rn, omega);
	omega = 1.0;

	// это нужне сделать единожды на фазе препроцессинга.
	doublerealT* diagonal = NULL;
	diagonal = new doublerealT[(integer)(rn)+1];
	if (diagonal == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for diagonal in classical_ilu2...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	// initialization:
	for (integer i_6 = 0; i_6 < (integer)(rn)+1; i_6++) diagonal[i_6] = 1.0;
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		{
			integer istr = ii - iadd;
			integer ic = ii;
			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];
			doublerealT ap = 0.0;
			doublerealT mult = 0.0;
			for (ic = is1; ic <= is2; ic++) {
				if (Amat[ic].j != istr) {
					if (Amat[ic].j < istr) {
						// aij*aji/djj;
						// найти aji;
						doublerealT aji = 0.0;
						// линейный поиск очень медленный особенно на каждой итерации.
						//for (integer ii1 = startpos; ii1 <= endpos; ii1++) {
						integer ii1 = iadd + Amat[ic].j;
							if (Amat[ii1].i == Amat[ic].j) {
								integer ic1 = ii1;
								integer is11 = row_ptr_start[ii1] + 1;
								integer is21 = row_ptr_end[ii1];
								for (ic1 = is11; ic1 <= is21; ic1++) {
									if (Amat[ic1].j != Amat[ic].j) {
										if (Amat[ic1].j == istr) {
											aji = Amat[ic1].aij;
										}
									}
								}
								break;
							}
						//}
						mult += (Amat[ic].aij*aji) / diagonal[Amat[ic].j];
					}
				}
			}
			ap = 1.0 / Amat[is1 - 1].aij;
			diagonal[istr] = ap - mult;
		}
	}

	//if (isorintmemo == iadd) {
	// Это точно не первый раз
	//bfirst = false;
	//}
	startpos = istartq + iadd;
	endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		doublerealT rold = x[istr];

		x[istr] = b[istr];

		doublerealT rsum = 0.0;
		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];
		// Распараллеливание почемуто тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			integer ipos = Amat[ii1].j;
			rsum += -Amat[ii1].aij*x[ipos];
		}
		x[istr] += rsum;
		//x[istr] *= Amat[row_ptr_start[ii]].aij;
		// incomplete lower upwer decomposition.
		x[istr] /= diagonal[istr];

		// Запускается только после первого раза сразу запускать нельзя
		// т.к. начальное значение не является адекватным.
		//x[istr] = omega*x[istr] + (1.0 - omega)*rold; // this is SOR
	}

	delete[] diagonal;

} // classical_ilu2


  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	
	//seidelqstable(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

	// SOR!!!
	// 3 jan 2016
	//seidelqsor(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// лучший выбор :
	seidelqsor2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// 14 января 2016 смена направлений сканирования.
	// оказалось значительно хуже.
	//seidelqsor3(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// incomplete lower upwer decomposition.
	//classical_ilu2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

	
} // seidelq



// smoother.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{

	//seidelqstable<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

	// SOR!!!
	// 3 jan 2016
	//seidelqsor(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// лучший выбор
	seidelqsor2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// 14 января 2016 смена направлений сканирования.
	// оказалось значительно хуже.
	//seidelqsor3(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	//seidelqsor2Pcpu(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// incomplete lower upwer decomposition.
	//classical_ilu2(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	// Экспериментальный вариант слишком медленный:
    //bool* flag = new bool[iendq - istartq + 2];
	//classic_ilu(Amat, istartq, iendq, x, b, flag, iendq - istartq + 1);
	//delete[] flag;

} // seidelq

// См. файл gmres.cpp
template <typename doublerealT>
integer  gmres(integer n, doublerealT *val, integer* col_ind, integer* row_ptr, doublerealT *dV, doublerealT* &dX0,
	integer maxit, integer &m_restart);
//integer  gmres(integer n, double *val, integer* col_ind, integer* row_ptr, double *dV, double* &dX0,
	//integer maxit, integer &m_restart);
//integer  gmres(integer n, float *val, integer* col_ind, integer* row_ptr, float *dV, float* &dX0,
	//integer maxit, integer &m_restart);
//my_linalg.cpp
void Bi_CGStabCRS_smoother(integer n, doublereal *val, integer* col_ind, integer* row_ptr, doublereal *dV, doublereal* &dX0, integer maxit);

// 13.09.2017.
template <typename doublerealT>
void gmres_smoother(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	integer n = iendq - istartq + 1;

	// Разреженная матрица СЛАУ
	// в CRS формате.

	doublerealT* val;
	integer* col_ind, *row_ptr;
	doublerealT* dX0 = new doublerealT[n];
	doublerealT* dV = new doublerealT[n];

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		dX0[ii - startpos] = x[istr];
		dV[ii - startpos] = b[istr];
	}

	integer nnz = row_ptr_end[endpos] - row_ptr_start[startpos] + 1;
	val = new doublerealT[nnz];
	col_ind = new integer[nnz];
	row_ptr = new integer[n + 1];
	for (integer i_1 = 0; i_1 <= n; i_1++) row_ptr[i_1] = nnz;

	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		integer is1 = row_ptr_start[ii];// +1;
		integer is2 = row_ptr_end[ii];


		// Распараллеливание почемуто тормозит очень сильно.
		//#pragma omp parallel for reduction(+:rsum)
		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			///printf("is1=%d is2=%d\n",is1,is2);
			if (iadd > 20) {
				//printf("i==%d j==%d\n", Amat[ii1].i, Amat[ii1].j); getchar();
				
				//printf("%d \n", ii1 - row_ptr_start[startpos]);
				//getchar();
			}
			col_ind[ii1 - row_ptr_start[startpos]] = Amat[ii1].j - 1;
			val[ii1 - row_ptr_start[startpos]] = Amat[ii1].aij;
			if (Amat[ii1].j != Amat[ii1].i) {
				val[ii1 - row_ptr_start[startpos]] *= 1.0;
			}
			else {
				val[ii1 - row_ptr_start[startpos]] = 1.0 / val[ii1 - row_ptr_start[startpos]];
			}
			row_ptr[Amat[ii1].i - 1] = min(row_ptr[Amat[ii1].i - 1], ii1 - row_ptr_start[startpos]);
		}
	}

	/*
	if (0&&(iadd < -40)) {
		// 14.07.2019 Эта ветка кода никогда не выполняется.
		if ((val != NULL) && (col_ind != NULL) && (row_ptr != NULL)) {
			for (integer i_1 = 0; i_1 < nnz; i_1++) {
				// debug message
				printf("val=%e col_ind=%lld row_ptr=\n", val[i_1], col_ind[i_1]);
				system("PAUSE");
			}
			for (integer i_1 = 0; i_1 < 400; i_1++) {
				printf("%lld \n", row_ptr[i_1]);
			}
			//system("pause");
		}
		else {
			printf("val || col_ind || row_ptr == NULL\n");
			printf("in function gmres smoother...\n");
			system("PAUSE");
		}
	}
	*/

	if (0) {
		// Матрица col_ind, row_ptr, val собрана верно!!! 14 сентября 2017.

		doublerealT omega = 1.0; // initialize.

		// За подробностями смотри книгу Патрика Роуча стр. 183.
		doublerealT rn = (doublerealT)(iendq - istartq + 1);
		optimal_omega(rn, omega);

		for (integer i_1 = 0; i_1 < n; i_1++) {
			doublerealT r = dV[i_1];
			doublerealT ap = 0.0;
			for (integer j_1 = row_ptr[i_1]; j_1 <= row_ptr[i_1 + 1] - 1; j_1++) {
				if (i_1 != col_ind[j_1]) {
					r += -val[j_1] * dX0[col_ind[j_1]];
					//printf("%e ",);
				}
				else {
					ap = val[j_1];
				}
			}
			dX0[i_1] = (1.0 - omega)*dX0[i_1] + ((omega)*(r)) / ap;
		}
	}


	// Методы GMRES и BiCGStab расходятся в качестве сглаживателей и 
	// не обеспечивают не то что сглаживания а даже дают расходимость.
	// GMRES Саад и Шульц. [1986]
	integer maxit = 20;
	integer m_restart = 20; // Так рекомендовано в статье.
	gmres(n, val, col_ind, row_ptr, dV, dX0, maxit, m_restart);
	//Bi_CGStabCRS_smoother(n, val, col_ind, row_ptr, dV, dX0, maxit);


	// Возвращение результата расчёта.
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		 x[istr]= dX0[ii - startpos];
	}

	delete[] dX0;
	delete[] dV;
	delete[] val;
	delete[] col_ind;
	delete[] row_ptr;
}


  // smoother.
  // 9 september 2015 and 4 june 2017.
  // q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, bool* &F_false_C_true, integer idirect)
{	
	if (my_amg_manager.b_gmres) {
		// gmres smoother
		gmres_smoother<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
	}
	else {
		// лучший выбор
		if (my_amg_manager.bCFJacoby == true) {
			if ((my_amg_manager.iRunge_Kutta_smoother == 3) || (my_amg_manager.iRunge_Kutta_smoother == 5)) {
				// Трёхшаговый метод Рунге-Кутты.
				integer iorder = my_amg_manager.iRunge_Kutta_smoother;
				Runge_Kutt_3or5<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd, iorder, F_false_C_true, idirect);
			}
			else {

				seidelqsor2<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd, F_false_C_true, idirect);
			}
		}
		else {
			if ((my_amg_manager.iRunge_Kutta_smoother == 3) || (my_amg_manager.iRunge_Kutta_smoother == 5)) {
				// Трёхшаговый метод Рунге-Кутты.
				integer iorder = my_amg_manager.iRunge_Kutta_smoother;
				Runge_Kutt_3or5<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd, iorder);
			}
			else {

				seidelqsor2<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);
			}

		}
	}

} // seidelq


// smoother.
// 16 jan 2016.  Seidel q -quick SOR + parallel
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, bool* &bnested_desection, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
{
	seidelqsor2Pcpu<doublerealT>(Amat, istartq, iendq, x, b, bnested_desection,  row_ptr_start, row_ptr_end, iadd);
	//seidelqsor2Pcpu(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

} // seidelq

  // smoother.
  // 16 jan 2016.  Seidel q -quick SOR + parallel
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, bool* &bnested_desection, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, bool* &F_false_C_true, integer idirect)
{
	// , bool* &F_false_C_true, integer idirect Заглушка, параметры не используются.
	// Внимание обратная совместимость.

	seidelqsor2Pcpu<doublerealT>(Amat, istartq, iendq, x, b, bnested_desection, row_ptr_start, row_ptr_end, iadd);
	//seidelqsor2Pcpu<doublerealT>(Amat, istartq, iendq, x, b, row_ptr_start, row_ptr_end, iadd);

} // seidelq


  /*
  // smoother.
  // 9 september 2015.
  // q - quick.
  // Якоби расходится.
  template <typename doublerealT>
  void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
  {
  // istart - начальная позиция ненулевых элементов в матрице А.
  // iend - конечная позиция ненулевых элементов в матрице А.
  integer startpos = istartq + iadd;
  integer endpos = iendq + iadd;

  //doublerealT *sum=new doublerealT[endpos-startpos+1];

  #pragma omp parallel for
  for (integer ii = startpos; ii <= endpos; ii++) {
  integer istr = ii - iadd;
  x[istr] = b[istr];
  //	doublerealT sum = 0.0;
  //#pragma omp parallel for reduction(+:sum)
  for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
  {
  x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
  //sum = sum - Amat[ii1].aij*x[Amat[ii1].j];
  }
  //x[istr] += sum;
  x[istr] *= Amat[row_ptr_start[ii]].aij;
  }


  //for (integer ii = startpos; ii <= endpos; ii++) {
  //	integer istr = ii - iadd;
  //	x[istr] = sum[istr]*Amat[row_ptr_start[ii]].aij;
  //}


  //delete[] sum;
  } // seidelq
  */


  // residual.
  // 2 september 2014
template <typename doublerealT>
void residual(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		residual[i] = 0.0;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			residual[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr)  residual[istr] += -Amat[ic].aij*x[Amat[ic].j];
				else residual[istr] += -Amat[ic].aij*x[istr];
				ic++;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // residual

// residual.
// 2 september 2014
template <typename doublerealT>
void residual(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		residual[i] = 0.0;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			residual[istr] = b[istr];
			while ((ic <= iend) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr)  residual[istr] += -Amat[ic].aij*x[Amat[ic].j];
				else residual[istr] += -Amat[ic].aij*x[istr];
				ic++;
			}
			flag[Amat[ii].i] = true;
		}
	}


} // residual

  // residual.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void residualq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
	}


} // residualq

// residual.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void residualq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
	}


} // residualq

  // residual.
// 3 jan 2016 ещё быстрее.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void residualq2(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT* &residual, doublerealT* &my_diag)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
		//residual[istr] -= my_diag[Amat[row_ptr_start[ii]].i] * x[istr]; // 3 jan 2016
		residual[istr] -= my_diag[istr] * x[istr]; // 3 feb 2019
	}


} // residualq2

// Эквивалентный клон функции 13.01.2018
template <typename doublerealT>
void residualq2(Ak* &Amat, integer istartq, integer iendq, doublereal* &x, doublereal* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT* &residual, doublerealT* &my_diag)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
		//residual[istr] -= my_diag[Amat[row_ptr_start[ii]].i] * x[istr]; // 3 jan 2016
		residual[istr] -= my_diag[istr] * x[istr]; // 3 feb 2019
	}


} // residualq2

// residual.
// 3 jan 2016 ещё быстрее.
// 9 september 2015.
// q - quick.
template <typename doublerealT1, typename doublerealT2>
void residualq2(Ak1* &Amat, integer istartq, integer iendq, doublerealT1* &x, doublerealT1* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT2* &residual, doublerealT2* &my_diag)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	doublerealT2 dsum = 0.0;

#pragma omp parallel for 
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) {
			if (1||(Amat[ii1].aij < 0.0)) {
				residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			}
			else {
				// 16 августа 2016.
				// не работает.
				//dsum += Amat[ii1].aij;
			}
		}
		residual[istr] -= (1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];  // 1 april 2017
		//residual[istr] -= (my_diag[Amat[row_ptr_start[ii]].i] + dsum)* x[istr]; // 3 jan 2016
	}


} // residualq2

 


  // residual.
// Анализ структуры невязки в случае проблемы с солвером.
  // 3 jan 2016 ещё быстрее.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT1, typename doublerealT2>
void residualq2_analysys(Ak1* &Amat, integer istartq, integer iendq, doublerealT1* &x, doublerealT1* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT2* &residual, doublerealT2* &my_diag)
{
	// Анализ структуры невязки.
	// Мы делим вектор невязки на 20 равных частей и смотрим где невязка наиболее велика.



	printf("residual2 analysys start:\n");
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	doublerealT2 dsum = 0.0;
	doublerealT2 statistics_sum = 0.0;
	integer icount_log = 1;
	integer i_srez = (endpos-startpos)/20;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) {
			if (1 || (Amat[ii1].aij < 0.0)) {
				residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
			}
			else {
				// 16 августа 2016.
				// не работает.
				//dsum += Amat[ii1].aij;
			}
		}
		//residual[istr] += (-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr];
		residual[istr] -= (my_diag[Amat[row_ptr_start[ii]].i] + dsum)* x[istr]; // 3 jan 2016
		statistics_sum += fabs(residual[istr]);
		if ((ii-startpos+1) % i_srez == 0) {
#if doubleintprecision == 1
			printf("%lld %e ", icount_log++, statistics_sum);
#else
			printf("%d %e ", icount_log++, statistics_sum);
#endif
			
			statistics_sum = 0.0;
		}
	}
	printf("\n");

} // residualq2_analysys

 


  // smoother.
  // 9 september 2015.
  // q - quick.
template <typename doublerealT>
void residualqspeshial(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] -=  Amat[row_ptr_start[ii]].aij*x[istr];
		// 2.0 2.441 2.543 2.546
		//residual[istr] -= 2.0*Amat[row_ptr_start[ii]].aij*x[istr];
		//doublerealT omega = 1.855; // SOR
		//residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]); // верный вариант.
		residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]) / 16.0;
		//residual[istr] *= omega;
		// 2.423
		// 1.855 4.448
		// 1.0  5.074
		// 8.713 5.706
	}


} // residualqspeshial

// smoother.
// 9 september 2015.
// q - quick.
template <typename doublerealT>
void residualqspeshial(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd, doublerealT* &residual)
{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;
	for (integer ii = startpos; ii <= endpos; ii++) {
		integer istr = ii - iadd;
		residual[istr] = b[istr];
		for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++) { residual[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; }
		//residual[istr] -=  Amat[row_ptr_start[ii]].aij*x[istr];
		// 2.0 2.441 2.543 2.546
		//residual[istr] -= 2.0*Amat[row_ptr_start[ii]].aij*x[istr];
		//doublerealT omega = 1.855; // SOR
		//residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]); // верный вариант.
		residual[istr] += ((-1.0 / Amat[row_ptr_start[ii]].aij)*x[istr]) / 16.0;
		//residual[istr] *= omega;
		// 2.423
		// 1.855 4.448
		// 1.0  5.074
		// 8.713 5.706
	}


} // residualqspeshial

  // restriction
  // 3 september 2015.
  // 6 september 2015.
  // должна быть отсортирована по i, порядок по j неважен.
template <typename doublerealT>
void restriction(Ak* &R, integer istart, integer iend, bool* &flag, doublerealT * &x_fine, doublerealT * &x_coarse, integer n_fine, integer n_coarse) {
	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
	for (integer i = 1; i <= n_coarse; i++) {
		flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[R[ii].i] == false) {
			integer istr = R[ii].i;
			integer ic = ii;
			x_coarse[istr] = 0.0;
			while ((ic <= iend) && (R[ic].i == istr)) {
				x_coarse[istr] += R[ic].aij*x_fine[R[ic].j];
				ic++;
			}
			flag[R[ii].i] = true;
		}
	}

} // restriction

// restriction
// 3 september 2015.
// 6 september 2015.
// должна быть отсортирована по i, порядок по j неважен.
template <typename doublerealT>
void restriction(Ak1* &R, integer istart, integer iend, bool* &flag, doublerealT * &x_fine, doublerealT * &x_coarse, integer n_fine, integer n_coarse) {
	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
#pragma omp parallel for
	for (integer i = 1; i <= n_coarse; i++) {
		flag[i] = false;
	}
//---->#pragma omp parallel for
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[R[ii].i] == false) {
			integer istr = R[ii].i;
			integer ic = ii;
			x_coarse[istr] = 0.0;
			while ((ic <= iend) && (R[ic].i == istr)) {
				x_coarse[istr] += R[ic].aij*x_fine[R[ic].j];
				ic++;
			}
			flag[R[ii].i] = true;
		}
	}

} // restriction


// restriction
// 3 september 2015.
// 6 september 2015.
// 10 february 2019 - нашел более компактную форму записи.
// должна быть отсортирована по i, порядок по j неважен.
template <typename doublerealT>
void restriction(Ak1* &R, integer istart, integer iend,  doublerealT * &x_fine, doublerealT * &x_coarse,  integer n_coarse) {
	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
#pragma omp parallel for
	for (integer i = 1; i <= n_coarse; i++) {
		x_coarse[i] = 0.0;
	}
	//---->#pragma omp parallel for
	for (integer ii = istart; ii <= iend; ii++) {
		x_coarse[R[ii].i] += R[ii].aij*x_fine[R[ii].j];
	}
} // restriction


  // prolongation
  // 3 september 2015.
  // 6 september 2015.
  // должна быть отсортирована по j, порядок по i неважен.
  // P=transpose(R).
template <typename doublerealT>
void prolongation(Ak* &P, integer istart, integer iend, bool* &flag, doublerealT * &x_fine, doublerealT * &x_coarse, integer n_fine, integer n_coarse) {
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];
	// P=c*transpose(R); Pij=c*Rji;
	for (integer j = 1; j <= n_fine; j++) {
		flag[j] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[P[ii].j] == false) {
			integer jstr = P[ii].j;
			integer ic = ii;
			x_fine[jstr] = 0.0;
			while ((ic <= iend) && (P[ic].j == jstr)) {
				x_fine[jstr] += P[ic].aij*x_coarse[P[ic].i];
				ic++;
			}

			flag[P[ii].j] = true;
		}
	}

} // prolongation

// prolongation
// 3 september 2015.
// 6 september 2015.
// должна быть отсортирована по j, порядок по i неважен.
// P=transpose(R).
template <typename doublerealT>
void prolongation(Ak1* &P, integer istart, integer iend, bool* &flag, doublerealT * &x_fine, doublerealT * &x_coarse, integer n_fine, integer n_coarse) {
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];
	// P=c*transpose(R); Pij=c*Rji;
#pragma omp parallel for
	for (integer j = 1; j <= n_fine; j++) {
		flag[j] = false;
	}
//---->#pragma omp parallel for
	for (integer ii = istart; ii <= iend; ii++) {
		if (flag[P[ii].j] == false) {
			integer jstr = P[ii].j;
			integer ic = ii;
			x_fine[jstr] = 0.0;
			while ((ic <= iend) && (P[ic].j == jstr)) {
				x_fine[jstr] += P[ic].aij*x_coarse[P[ic].i];
				ic++;
			}

			flag[P[ii].j] = true;
		}
	}

} // prolongation

// prolongation
// 3 september 2015.
// 6 september 2015.
// должна быть отсортирована по j, порядок по i неважен.
// P=transpose(R).
template <typename doublerealT>
void prolongation(Ak1* &P, integer istart, integer iend, doublerealT * &x_fine, doublerealT * &x_coarse, integer n_fine) {
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];
	// P=c*transpose(R); Pij=c*Rji;
#pragma omp parallel for
	for (integer j = 1; j <= n_fine; j++) {
		x_fine[j] = 0.0;
	}
//---->#pragma omp parallel for
	for (integer ii = istart; ii <= iend; ii++) {
		x_fine[P[ii].j] += P[ii].aij*x_coarse[P[ii].i];		
	}

} // prolongation

// Evklid norma of vector r in size n.
template <typename doublerealT>
doublerealT norma(doublerealT * &r, integer n) {
	doublerealT ret = 0.0;

#pragma omp parallel for  /*schedule (guided)*/ reduction (+:ret)
	for (integer ii = 1; ii <= n; ii++) {
		//ret += r[ii] * r[ii] / n;
		// 13 февраля 2016 года.
		ret += r[ii] * r[ii]; // L2 norm (classical definition).
	}

#if doubleprecision == 1
		ret = sqrt(ret);
#else	
		ret = sqrtf(ret);
#endif

	return ret;
} // L2 norm

// экспорт полевой величины u в программу tecplot 360.
template <typename doublerealT>
void exporttecplot(doublerealT* u, integer n_size) {
	FILE *fp=NULL;
	errno_t err=0;
#ifdef MINGW_COMPILLER
	fp=fopen64("fedorenko1.PLT", "w");
#else
	err = fopen_s(&fp, "fedorenko1.PLT", "w");
#endif
	// создание файла для записи.
	if ((err) != 0) {
		printf("Create File Error\n");
	}
	else {
		if (fp != NULL) {
#ifdef MINGW_COMPILLER
			// запись имён переменных
			fprintf(fp, "VARIABLES = x y u\n");
			fprintf(fp, "zone\n");
			integer m = (integer)(sqrt((double)(1.0*n_size)));
			integer n = m;
			doublerealT h = 1.0 / (m - 1);
#if doubleintprecision == 1
			fprintf(fp, "I=%lld, J=%lld, K=1, F=TOCHKA\n", m, n);
#else
			fprintf(fp, "I=%d, J=%d, K=1, F=TOCHKA\n", m, n);
#endif

			for (integer j = 0; j < n; j++) for (integer i = 0; i < m; i++)   fprintf(fp, "%e %e %e\n", i*h, j*h, u[i*m + j + 1]);

#else // MINGW_COMPILLER OFF
			// запись имён переменных
			fprintf_s(fp, "VARIABLES = x y u\n");
			fprintf_s(fp, "zone\n");
			integer m = (integer)(sqrt((double)(1.0*n_size)));
			integer n = m;
			doublerealT h = 1.0 / (m - 1);
#if doubleintprecision == 1
			fprintf_s(fp, "I=%lld, J=%lld, K=1, F=TOCHKA\n", m, n);
#else
			fprintf_s(fp, "I=%d, J=%d, K=1, F=TOCHKA\n", m, n);
#endif
			
			for (integer j = 0; j < n; j++) for (integer i = 0; i < m; i++)   fprintf_s(fp, "%e %e %e\n", i*h, j*h, u[i*m + j + 1]);
#endif		
			
			fclose(fp);
			//WinExec("C:\\Program Files\\Tecplot\\Tecplot 360 EX 2014 R1\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
			//WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
		}
		else {
			printf("Create File Error\n");
		}
	}

	system("PAUSE");

} // exporttecplot

  // Быстрая сортировка Ч. Хоара. Время n*log2(n).
void quickSort_set(integer* &ifrQ, integer left, integer right)
{
	integer i = left, j = right;
	integer tmp;
	integer pivot = ifrQ[(left + right) / 2];

	/* partition */
	while (i <= j) {
		while (ifrQ[i]<pivot)
			i++;
		while (ifrQ[j]>pivot)
			j--;
		if (i <= j) {
			tmp = ifrQ[i];
			ifrQ[i] = ifrQ[j];
			ifrQ[j] = tmp;
			i++;
			j--;
		}
	};

	/* recursion */
	if (left<j)
		quickSort_set(ifrQ, left, j);
	if (i<right)
		quickSort_set(ifrQ, i, right);


}

// Двоичный поиск.
// Массив Amat[0..n], по n включительно, отсортированный в порядке возрастания.
integer BinarySearch(integer* &Amat, integer key, integer n)
{
	integer left = 0, right = n, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid]) right = mid - 1;
		else if (key>Amat[mid]) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > 0) && (Amat[mid - 1] == Amat[mid])) {
				mid--;
			}
			return mid;
		}
	}
	return -1;
}


// Двоичный поиск.
integer BinarySearchAi(Ak* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].i) right = mid - 1;
		else if (key>Amat[mid].i) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].i == Amat[mid].i)) {
				mid--;
			}
			return mid;
		}
	}
	return -1;
}

// Двоичный поиск.
integer BinarySearchAi(Ak1* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].i) right = mid - 1;
		else if (key>Amat[mid].i) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].i == Amat[mid].i)) {
				mid--;
			}
			return mid;
		}
	}
	return -1;
}

// Двоичный поиск.
integer BinarySearchAj(Ak* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].j) right = mid - 1;
		else if (key>Amat[mid].j) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].j == Amat[mid].j)) {
				mid--;
			}
			return mid;
		};
	}
	return -1;
}

// Двоичный поиск.
integer BinarySearchAj(Ak1* &Amat, integer key, integer istart, integer iend)
{
	integer left = istart, right = iend, mid;
	while (left <= right)
	{
		mid = left + (right - left) / 2;
		if (key<Amat[mid].j) right = mid - 1;
		else if (key>Amat[mid].j) left = mid + 1;
		else {
			// надо обязательно убедиться что mid самый левый представитель.
			while ((mid > istart) && (Amat[mid - 1].j == Amat[mid].j)) {
				mid--;
			}
			return mid;
		};
	}
	return -1;
}

// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполляции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
template <typename doublerealT>
integer aggregative_amg(Ak* &Amat, integer nnz,
	integer n,
	Ak* &R, // restriction
	Ak* &P, // prolongation
	doublereal* &x, doublereal* &b) {

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	bool bquicktypesort = false;


	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	bool* flag = new bool[n + 1];
	bool* flag_ = new bool[n + 1];
	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;

	while ((ilevel<maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {


		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		if (bquicktypesort) {
			QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
			if (nnz_a[ilevel - 1] < 100000) {
				HeapSort(Amat, /*n_a[ilevel - 1],*/ 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1]);
				Aorig = NULL;
			}
		}

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
#if doubleintprecision == 1
			//	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#else
			//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#endif
			
			//if (ii % 20 == 0) getchar();
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			Amat[ii].ind = ii - iadd;
		}



		// Copy(Amat) на nnz ячеек правее.
		for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
			Amat[ii] = Amat[ii - nnz_a[ilevel - 1]];
		}

		// сделаем копию А упорядочим её по j 
		for (integer k = 1 + iadd; k <= nnz_a[ilevel - 1] + iadd; k++) {
			Amat[k + 2 * nnz_a[ilevel - 1]] = Amat[k]; // copy
			Amat[k + 2 * nnz_a[ilevel - 1]].ind = k; // запомиаем номер до сортировки.
		}
		// сортировка по j.
		if (nnz_a[ilevel - 1] < 100000) {
			HeapSort_j(Amat,/* n_a[ilevel - 1]*/ 1 + iadd + 2 * nnz_a[ilevel - 1], nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]);
		}
		else {
			Ak* Aorig = &Amat[1 + iadd + 2 * nnz_a[ilevel - 1]];
			MergeSort_j(Aorig, nnz_a[ilevel - 1]);
			Aorig = NULL;
		}


		integer n_coarce = 1; // номер агрегата.
		nnzR = 1;
		const integer max_sosed = 27850;
		const integer NULL_SOSED = -1;
		integer vacant = NULL_SOSED;
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				// Вычисляем по немодифиуцированной матрице А (хранящейся слева).

				doublerealT sum = 0.0;
				integer nnzRl = nnzR + iaddR;

				integer set[max_sosed]; // не более 20 узлов в одном агрегате.
										// инициализация убрана потомучто она не нужна и она сильно тормозит быстродействие.
										//for (integer js = 0; js < max_sosed; js++) {
										//set[js] = NULL_SOSED;
										//}
				integer ic = 0;
				set[ic] = Amat[ii].i;
				doublerealT theta = 0.25; // контроль числа сильных связей между переменными.
				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
											 // добавляем диагональный элемент.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j == set[0]) {
						sum += fabs(Amat[is0].aij);
						R[nnzRl].aij = fabs(Amat[is0].aij);
						R[nnzRl].i = n_coarce; // индекс грубой сетки
						R[nnzRl].j = set[0]; //индекс на подробной сетке.
						nnzRl++;
						break;
					}
					else {
						if (fabs(Amat[is0].aij) > max_vnediagonal) {
							max_vnediagonal = fabs(Amat[is0].aij);
						}
					}
				}

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_SOSED;
							}
						}
						if (vacant != NULL_SOSED) {
							set[ic] = vacant;
							sum += fabs(Amat[ii].aij);
							R[nnzRl].aij = fabs(Amat[ii].aij);
							R[nnzRl].i = n_coarce;
							R[nnzRl].j = vacant;
							nnzRl++;
							ic++;
						}
					}
				}
				integer iscan = ii + 1;
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_SOSED;
								}
							}
							if (vacant != NULL_SOSED) {
								set[ic] = vacant;
								sum += fabs(Amat[iscan].aij);
								R[nnzRl].aij = fabs(Amat[iscan].aij);
								R[nnzRl].i = n_coarce;
								R[nnzRl].j = vacant;
								nnzRl++;
								ic++;

							}
						}
					}

					iscan++;

				} // while

				  // R restriction.
				for (integer k1 = 0; k1 < ic; k1++) {
					R[nnzR + iaddR].aij /= sum;
					nnzR++;
				}


				//{
				//integer* Aset = new integer[ic];
				//for (integer ii3 = 0; ii3 < ic; ii3++) Aset[ii3] = set[ii3]; // copy
				// HeapSort(Aset,0,ic-1);
				//quickSort_set(Aset, 0, ic - 1);

				// bynarySearh 88.56%
				// aggregativeamg 8.89%
				// seidel 0.87%
				// (i,j) -> (I,J)
				// модифицируем копию Amat находящуюся справа.
				//for (integer k = nnz_a[ilevel - 1] + 1 + iadd; k <= 2 * nnz_a[ilevel - 1] + iadd; k++) {
				//bool found = false;

				//if (BinarySearch(Aset, Amat[k - nnz_a[ilevel - 1]].i, ic - 1) > -1) found = true;
				//for (integer k1 = 0; k1 < ic; k1++) {
				//	if (Amat[k - nnz_a[ilevel - 1]].i == set[k1]) found = true;
				//	}
				//if (found) Amat[k].i = n_coarce;
				//found = false;
				//if (BinarySearch(Aset, Amat[k - nnz_a[ilevel - 1]].j, ic - 1) > -1) found = true;

				//for (integer k1 = 0; k1 < ic; k1++) {
				//if (Amat[k - nnz_a[ilevel - 1]].j == set[k1]) found = true;
				//}

				//if (found) Amat[k].j = n_coarce;

				//}

				//delete[] Aset;
				//}


				{
					// 7 сентября 2015.
					// мы воспользовались тем что А упорядочена по i.
					for (integer k1 = 0; k1 < ic; k1++) {
						integer key = set[k1];
						integer ifound = BinarySearchAi(Amat, key, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						if (ifound > -1) {
							integer if1 = ifound;
							while ((if1 <= nnz_a[ilevel - 1] + iadd) && (Amat[if1].i == key)) {
								Amat[if1 + nnz_a[ilevel - 1]].i = n_coarce;
								if1++;
							}
							if1 = ifound - 1;
							while ((if1 >= 1 + iadd) && (Amat[if1].i == key)) {
								Amat[if1 + nnz_a[ilevel - 1]].i = n_coarce;
								if1--;
							}

						}
					}
					// копирование А на третью позицию и сортировка по j. Делается единожды в самом начале.
					// и сделаем тоже самое для j.
					// мы воспользовались тем что А упорядочена по j.
					for (integer k1 = 0; k1 < ic; k1++) {
						integer key = set[k1];
						integer ifound = BinarySearchAj(Amat, key, 1 + iadd + 2 * nnz_a[ilevel - 1], nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]);
						if (ifound > -1) {
							integer if1 = ifound;
							while ((if1 <= nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]) && (Amat[if1].j == key)) {
								Amat[Amat[if1].ind + nnz_a[ilevel - 1]].j = n_coarce;
								if1++;
							}
							if1 = ifound - 1;
							while ((if1 >= 1 + iadd + 2 * nnz_a[ilevel - 1]) && (Amat[if1].j == key)) {
								Amat[Amat[if1].ind + nnz_a[ilevel - 1]].j = n_coarce;
								if1--;
							}

						}
					}
					// Временная память в разделе 1 + iadd + 2 * nnz_a[ilevel - 1]..nnz_a[ilevel - 1] + iadd + 2 * nnz_a[ilevel - 1]
					// больше ненужна.

				}


				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}

				n_coarce++;

				// Один агрегат создан.



			} // узел не был ещё включён в агрегат.
		} // агрегаты созданы.


		  // отладочная печать в рабочей версии требуется закоментировать.
		  //for (integer ii = 1; ii <= n; ii++) {
		  //flag_[ii] = false;
		  //}
		  //for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
		  //if (flag_[R[ii].i] == false) {
		  //integer istr = R[ii].i;
		  //integer ic7 = ii;
		  //while ((ic7 <= iaddR + nnzR - 1) && (R[ic7].i == istr)) {
		  //printf("%e ", R[ic7].aij);
		  //ic7++;
		  //}
		  //printf("\n");
		  //system("pause");
		  //flag_[R[ii].i] = true;
		  //}
		  //}


		  // оператор restriction построен и он упорядочен по i.
		  // число ненулевых элементов nnzR-1.
		  // P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			P[ii] = R[ii];
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n",ii,P[ii].aij,P[ii].i,P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n",ii,P[ii].aij,P[ii].i,P[ii].j);
#endif
			
			//getchar();
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);
		if (bquicktypesort) {
			QuickSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
			HeapSort_j(P, /*n_a[ilevel-1]*/ 1 + iaddR, iaddR + nnzR - 1);
		}

		// оператор интерполяции это не просто транспонированный оператор проекции а
		// а транспонированный оператор проекции умноженный на константу. Константа 
		// определяется из следующего соображения : если сумма элементов оператора рестрикции в стоке единица,
		// то соответственно в столбце у оператора интерполяции максимальный элемент равен единица.
		// этот код обязательно должен быть включён чтобы пара рестрикция-интерполяция была верна.

		for (integer ii = 1; ii <= n; ii++) {
			flag_[ii] = false;
		}
		doublerealT mul = -1.e30;
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			if (flag_[P[ii].j] == false) {
				integer jstr = P[ii].j;
				integer ic7 = ii;
				mul = -1.e30;
				while ((ic7 <= iaddR + nnzR - 1) && (P[ic7].j == jstr)) {
					if (fabs(P[ic7].aij) > mul) {
						mul = fabs(P[ic7].aij);
					}
					ic7++;
				}
				ic7 = ii;
				while ((ic7 <= iaddR + nnzR - 1) && (P[ic7].j == jstr)) {
					P[ic7].aij /= mul; // максимальный элемент единица.
					ic7++;
				}
				flag_[P[ii].j] = true;
			}
		}

		//for (integer ii = 1; ii <= n; ii++) {
		//flag_[ii] = false;
		//}
		//for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
		//if (flag_[P[ii].j] == false) {
		//integer jstr = P[ii].j;
		//integer ic7 = ii;
		//while ((ic7 <= iaddR + nnzR - 1) && (P[ic7].j == jstr)) {
		//printf("%e ",P[ic7].aij);
		//ic7++;
		//}
		//printf("\n");
		//system("pause");
		//flag_[P[ii].j] = true;
		//}
		//}




		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;

#if doubleintprecision == 1
		//printf("%lld %lld\n",n,n_coarce-1);
#else
		//printf("%d %d\n",n,n_coarce-1);
#endif
		
		//getchar();
		n_a[ilevel] = n_coarce - 1;

		// сортировка по новому ключу key=i*(iglcoarce_number-1)+j;
		// в позиции ind сохранён индекс предыдущей позиции.
		//heapsort(Amat, key = i*(n_coarce - 1) + j, nnz + 1, 2 * nnz);
		if (bquicktypesort) {
			QuickSort(Amat, /*n_coarce - 1,*/ nnz_a[ilevel - 1] + 1 + iadd, 2 * nnz_a[ilevel - 1] + iadd);
		}
		else {
			if (nnz_a[ilevel - 1] < 100000) {
				HeapSort(Amat, /*n_coarce - 1,*/ nnz_a[ilevel - 1] + 1 + iadd, 2 * nnz_a[ilevel - 1] + iadd);
			}
			else {
				Ak* Aorig = &Amat[nnz_a[ilevel - 1] + 1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1]);
				Aorig = NULL;
			}
		}

		for (integer ii = 1 + nnz_a[ilevel - 1] + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
#if doubleintprecision == 1
			//	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#else
			//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
#endif
			
			//if (ii % 20 == 0) getchar();
		}



		// копирование в третью часть матрицы Слау на coarce сетке.
		// инициализация.
		// запас памяти 1 nnz на fine уровне.
		for (integer ii = 2 * nnz_a[ilevel - 1] + 1 + iadd; ii <= 3 * nnz_a[ilevel - 1] + iadd; ii++) {
			Amat[ii].aij = 0.0;
			Amat[ii].ind = NULL_SOSED;
			Amat[ii].i = NULL_SOSED;
			Amat[ii].j = NULL_SOSED;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) flag[ii] = false;


		integer ic1 = 2 * nnz_a[ilevel - 1] + 1 + iadd;
		integer im = 1;
		integer im0 = 0;
		for (integer ii = nnz_a[ilevel - 1] + 1 + iadd; ii <= 2 * nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				while ((ii + im0 <= 2 * nnz_a[ilevel - 1] + iadd) && (istr == Amat[ii + im0].i)) {

					if (ic1 <= 3 * nnz_a[ilevel - 1] + iadd) {
						Amat[ic1].i = Amat[ii + im0].i;
						Amat[ic1].j = Amat[ii + im0].j;
						Amat[ic1].aij += Amat[ii + im0].aij;
						while ((ii + im <= 2 * nnz_a[ilevel - 1] + iadd) && (Amat[ii + im0].i == Amat[ii + im].i) && (Amat[ii + im0].j == Amat[ii + im].j))
						{
							Amat[ic1].aij += Amat[ii + im].aij;
							im++;
						}
						ic1++;
						im0 = im;
						im++;
					}
					else {
						printf("error 1\n");
						system("PAUSE");
					}
				}
				flag[Amat[ii].i] = true;
				im = 1;
				im0 = 0;
			}
		}

		nnz_a[ilevel] = ic1 - 1 - 2 * nnz_a[ilevel - 1] - iadd;
		iadd += 2 * nnz_a[ilevel - 1];

#if doubleintprecision == 1
		printf("nnz : fine=%lld, coarse=%lld, operator complexity=%e. \n", nnz_a[ilevel - 1], nnz_a[ilevel], (doublerealT)(nnz_a[ilevel]) / (doublerealT)(nnz_a[ilevel - 1]));
		printf("n : fine=%lld, coarse=%lld grid complexity=%e.\n", n_a[ilevel - 1], n_a[ilevel], (doublerealT)(n_a[ilevel]) / (doublerealT)(n_a[ilevel - 1]));
		printf("nnz_aRP = %lld\n", nnz_aRP[ilevel - 1]);
#else
		printf("nnz : fine=%d, coarse=%d, operator complexity=%e. \n", nnz_a[ilevel - 1], nnz_a[ilevel], (doublerealT)(nnz_a[ilevel]) / (doublerealT)(nnz_a[ilevel - 1]));
		printf("n : fine=%d, coarse=%d grid complexity=%e.\n", n_a[ilevel - 1], n_a[ilevel], (doublerealT)(n_a[ilevel]) / (doublerealT)(n_a[ilevel - 1]));
		printf("nnz_aRP = %d\n", nnz_aRP[ilevel - 1]);
#endif

		
		//getchar();

		ilevel++;// грубосеточная матрица построена.
		if (ilevel >= 2) {
			if (n_a[ilevel - 2] <= n_a[ilevel - 1]) bcontinue = false;
		}

	} // иерархия сеток построена.

#if doubleintprecision == 1
	  //for (integer ii = 1; ii <= nnz_aRP[0] + nnz_aRP[1]; ii++) {
	  //printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, R[ii].aij, R[ii].i, R[ii].j);
	  //getchar();
	  //}
#else
	  //for (integer ii = 1; ii <= nnz_aRP[0] + nnz_aRP[1]; ii++) {
	  //printf("ii=%d aij=%e, i=%d j=%d\n", ii, R[ii].aij, R[ii].i, R[ii].j);
	  //getchar();
	  //}
#endif
	 


	  //exporttecplot(b,n);

	  //doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	  // restriction
	  //restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	  //for (integer ii = 1; ii <= n_a[0]; ii++) {
	  //b[ii] = 0.0;
	  //}

	  //{
	  //doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	  // restriction
	  //restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	  //for (integer ii = 1; ii <= n_a[1]; ii++) {
	  //test_coarse[ii] = 0.0;
	  //}

	  //{
	  //	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	  // restriction
	  //restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	  //for (integer ii = 1; ii <= n_a[2]; ii++) {
	  //test_coarse1[ii] = 0.0;
	  //}

	  //prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	  //}

	  //prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	  //}

	  //prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	  //exporttecplot(b, n);


	  // подготовка матрицы к cycling:

	  // smoother.
	  // 1 september 2015.
	  //void seidel(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	  //{
	  // istart - начальная позиция ненулевых элементов в матрице А.
	  // iend - конечная позиция ненулевых элементов в матрице А.
	  //for (integer i = 1; i <= n; i++) {
	  //flag[i] = false;
	  //}
	  //for (integer ii = istart; ii <= iend; ii++) {
	  //if (flag[Amat[ii].i] == false) {
	  //integer istr = Amat[ii].i;
	  //integer ic = ii;
	  //doublerealT ap = 0.0;
	  //x[istr] = b[istr];
	  //while ((ic<=iend)&&(Amat[ic].i == istr)) {
	  //if (Amat[ic].j != istr) {
	  //x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	  //}
	  //else ap = Amat[ic].aij;
	  //ic++;
	  //}
	  //if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
	  //printf("zero diagonal elements in string %lld",istr);
#else
	  //printf("zero diagonal elements in string %d",istr);
#endif
	  
	  //getchar();
	  //exit(1);
	  //}
	  //else {
	  //x[istr] /= ap;
	  //}
	  //flag[Amat[ii].i] = true;
	  //}
	  //}


	  //} // seidel


	integer *row_ptr_start = new integer[4 * n_a[0] + 1];
	integer *row_ptr_end = new integer[4 * n_a[0] + 1];
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0;
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld", istr);
#else
				printf("zero diagonal elements in string %d", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}
	// первый уровень вложенности.
	if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = 2 * nnz_a[0] + 1; ii <= 2 * nnz_a[0] + nnz_a[1]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= 2 * nnz_a[0] + nnz_a[1]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// второй уровень вложенности.

	if (ilevel > 2) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = 2 * nnz_a[0] + 2 * nnz_a[1] + 1; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// третий уровень вложенности.

	if (ilevel > 3) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 1; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// 14 сентября 2015 понедельник
	// четвёртый уровень вложенности.

	if (ilevel > 4) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 1;
		integer iend = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// пятый уровень вложенности.

	if (ilevel > 5) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 1;
		integer iend = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// шестой уровень вложенности.

	if (ilevel > 6) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 1;
		integer iend = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ic - 1;
				if (fabs(ap) < 1.0e-30) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld", istr);
#else
					printf("zero diagonal elements in string %d", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}




	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j]; 
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq



	printf("cycling: V cycle.\n");
#if doubleintprecision == 1
	printf("level=%lld\n", ilevel);
#else
	printf("level=%d\n", ilevel);
#endif
	
	printf("multigrid R.P.Fedorenko 1961.\n");
	printf("aggregative algebraic multigrid method.\n");
	//system("pause");

	// 10 11 21 multigrid tutorial Вильм Бригг.

	integer nu1 = 4;
	integer nu2 = 3;

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.

	doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = NULL;
	doublerealT* error_approx_coarse = NULL;
	doublerealT *residual_fine1 = NULL;
	doublerealT *residual_coarse1 = NULL;
	doublerealT* error_approx_coarse1 = NULL;
	doublerealT *error_approx_fine1 = NULL;
	doublerealT *residual_fine2 = NULL;
	doublerealT *residual_coarse2 = NULL;
	doublerealT* error_approx_coarse2 = NULL;
	doublerealT *error_approx_fine2 = NULL;
	doublerealT *residual_fine3 = NULL;
	doublerealT *residual_coarse3 = NULL;
	doublerealT* error_approx_coarse3 = NULL;
	doublerealT *error_approx_fine3 = NULL;
	doublerealT *residual_fine4 = NULL;
	doublerealT *residual_coarse4 = NULL;
	doublerealT *error_approx_coarse4 = NULL;
	doublerealT *error_approx_fine4 = NULL;
	doublerealT *residual_fine5 = NULL;
	doublerealT *residual_coarse5 = NULL;
	doublerealT* error_approx_coarse5 = NULL;
	doublerealT *error_approx_fine5 = NULL;
	doublerealT *residual_fine6 = NULL;
	doublerealT *residual_coarse6 = NULL;
	doublerealT* error_approx_coarse6 = NULL;
	doublerealT *error_approx_fine6 = NULL;

	if (ilevel > 1) {
		residual_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = new doublerealT[n_a[1] + 1];
		if (ilevel > 2) {
			// residual
			residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_fine1 = new doublerealT[n_a[1] + 1];
			if (ilevel > 3) {
				// residual
				residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_fine2 = new doublerealT[n_a[2] + 1];
				if (ilevel > 4) {
					// residual
					residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_fine3 = new doublerealT[n_a[3] + 1];
					if (ilevel > 5) {
						// residual
						residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_fine4 = new doublerealT[n_a[4] + 1];
						if (ilevel > 6) {
							// residual
							residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_fine5 = new doublerealT[n_a[5] + 1];
							if (ilevel > 7) {
								// residual
								residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_fine6 = new doublerealT[n_a[6] + 1];
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];


	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		// smother
		for (integer iter = 0; iter < nu1; iter++) {
			//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);

		}

		//exporttecplot(x, n);

		// residual_r
		//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
		//residual<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
		residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
		dres = norma(residual_fine, n_a[0]);

		// номер V цикла, L2 норма невязки, локальная скорость изменения невязки.
#if doubleintprecision == 1
		printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
		printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
		
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;
		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				error_approx_coarse[ii] = 0.0;
			}
			// pre smothing
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			if (ilevel > 2) {
				// residual
				//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
				//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
				//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);


				//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

				// restriction
				restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

				// Amat*e=r;
				//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
				for (integer ii = 1; ii <= n_a[2]; ii++) {
					error_approx_coarse1[ii] = 0.0;
				}
				// pre smothing
				for (integer iter = 0; iter < nu1; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}
				if (ilevel > 3) {
					// residual
					//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
					//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
					//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0]+n_a[1], residual_fine2);
					residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);

					//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
					for (integer ii = 1; ii <= n_a[3]; ii++) {
						error_approx_coarse2[ii] = 0.0;
					}
					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}
					if (ilevel > 4) {
						// residual
						//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
						//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
						//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						//speshial
						residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);



						//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
						for (integer ii = 1; ii <= n_a[4]; ii++) {
							error_approx_coarse3[ii] = 0.0;
						}
						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}
						if (ilevel > 5) {
							// residual
							//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
							//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							//speshial 14 september 2015.
							residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);


							//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
							for (integer ii = 1; ii <= n_a[5]; ii++) {
								error_approx_coarse4[ii] = 0.0;
							}
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}
							if (ilevel > 6) {
								// residual
								//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
								//if (ilevel <= 15) {
								residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}
								//else {
								// приводит к расходимости.
								//speshial 14 september 2015.
								// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
								//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}

								//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
								for (integer ii = 1; ii <= n_a[6]; ii++) {
									error_approx_coarse5[ii] = 0.0;
								}
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								if (ilevel > 7) {
									// residual
									//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
									residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);

									//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
									for (integer ii = 1; ii <= n_a[7]; ii++) {
										error_approx_coarse6[ii] = 0.0;
									}
									// pre smothing
									for (integer iter = 0; iter < nu1; iter++) {
										seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}

									if (ilevel > 8) {
										// residual
										doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
										residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);


										doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

										// restriction
										restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

										// Amat*e=r;
										doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
										for (integer ii = 1; ii <= n_a[8]; ii++) {
											error_approx_coarse7[ii] = 0.0;
										}
										// pre smothing
										for (integer iter = 0; iter < nu1; iter++) {
											seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										if (ilevel > 9) {
											// residual
											doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
											integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7];
											integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + nnz_a[8];
											residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


											doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

											// restriction
											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

											// Amat*e=r;
											doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
											for (integer ii = 1; ii <= n_a[9]; ii++) {
												error_approx_coarse8[ii] = 0.0;
											}
											// pre smothing
											for (integer iter = 0; iter < nu1; iter++) {
												integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8];
												integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}

											if (ilevel > 10) {
												// 8 сентября 2015 РИМИНИ пляж 

												// residual
												doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
												integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8];
												integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + nnz_a[9];
												residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


												doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

												// restriction
												integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

												// Amat*e=r;
												doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];
												for (integer ii = 1; ii <= n_a[10]; ii++) {
													error_approx_coarse9[ii] = 0.0;
												}
												// pre smothing
												for (integer iter = 0; iter < nu1; iter++) {
													integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9];
													integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}

												if (ilevel > 11) {
													// 8 сентября 2015 РИМИНИ пляж 

													// residual
													doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
													integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9];
													integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + nnz_a[10];
													residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


													doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

													// restriction
													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

													// Amat*e=r;
													doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];
													for (integer ii = 1; ii <= n_a[11]; ii++) {
														error_approx_coarse10[ii] = 0.0;
													}
													// pre smothing
													for (integer iter = 0; iter < nu1; iter++) {
														integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10];
														integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}

													if (ilevel > 12) {
														// 11 сентября 2015 РИМИНИ пляж 

														// residual
														doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
														integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10];
														integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + nnz_a[11];
														residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


														doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

														// restriction
														integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

														// Amat*e=r;
														doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];
														for (integer ii = 1; ii <= n_a[12]; ii++) {
															error_approx_coarse11[ii] = 0.0;
														}
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11];
															integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}

														if (ilevel > 13) {
															// 11 сентября 2015 РИМИНИ пляж 

															// residual
															doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
															integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11];
															integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + nnz_a[12];
															residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


															doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

															// Amat*e=r;
															doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];
															for (integer ii = 1; ii <= n_a[13]; ii++) {
																error_approx_coarse12[ii] = 0.0;
															}
															// pre smothing
															for (integer iter = 0; iter < nu1; iter++) {
																integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12];
																integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															if (ilevel > 14) {
																// 11 сентября 2015 РИМИНИ пляж 

																// residual
																doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12];
																integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + nnz_a[13];
																residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																// restriction
																integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																// Amat*e=r;
																doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];
																for (integer ii = 1; ii <= n_a[14]; ii++) {
																	error_approx_coarse13[ii] = 0.0;
																}
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13];
																	integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}

																if (ilevel > 15) {
																	// 14 сентября 2015 Москва на работе в пн. 

																	// residual
																	doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																	integer n1 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13];
																	integer n2 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + nnz_a[14];
																	residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																	doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																	// Amat*e=r;
																	doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																	for (integer ii = 1; ii <= n_a[15]; ii++) {
																		error_approx_coarse14[ii] = 0.0;
																	}
																	// pre smothing
																	for (integer iter = 0; iter < nu1; iter++) {
																		integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14];
																		integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}

																	// post smothing
																	for (integer iter = 0; iter < nu2; iter++) {
																		integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14];
																		integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + 2 * nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}


																	// prolongation
																	// residual_r
																	doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_fine14[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[15]; ii++) {// debug
																	//printf("error_approx_coarse14[%lld]=%e\n",ii, error_approx_coarse14[ii]);

																	//printf("residual_coarse14[%lld]=%e\n", ii, residual_coarse14[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]+2*nnz_a[14]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+2*nnz_a[14]+ nnz_a[15]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[15]; ii++) {// debug
																	//printf("error_approx_coarse14[%d]=%e\n",ii, error_approx_coarse14[ii]);

																	//printf("residual_coarse14[%d]=%e\n", ii, residual_coarse14[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]+2*nnz_a[14]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+2*nnz_a[14]+ nnz_a[15]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif
																	

																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																	// correction
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_coarse13[ii] += error_approx_fine14[ii];
																	}

																	// free
																	delete[] error_approx_fine14;
																	delete[] error_approx_coarse14;
																	delete[] residual_coarse14;
																	delete[] residual_fine14;

																}


																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13];
																	integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + 2 * nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}


																// prolongation
																// residual_r
																doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_fine13[ii] = 0.0;
																}

#if doubleintprecision == 1
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#else
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#endif
																

																integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																// correction
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_coarse12[ii] += error_approx_fine13[ii];
																}

																// free
																delete[] error_approx_fine13;
																delete[] error_approx_coarse13;
																delete[] residual_coarse13;
																delete[] residual_fine13;

															}


															// post smothing
															for (integer iter = 0; iter < nu2; iter++) {
																integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12];
																integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + 2 * nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															// prolongation
															// residual_r
															doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_fine12[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif
															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

															// correction
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_coarse11[ii] += error_approx_fine12[ii];
															}

															// free
															delete[] error_approx_fine12;
															delete[] error_approx_coarse12;
															delete[] residual_coarse12;
															delete[] residual_fine12;

														}



														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11];
															integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + 2 * nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}


														// prolongation
														// residual_r
														doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_fine11[ii] = 0.0;
														}

#if doubleintprecision == 1
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#else
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#endif
														

														integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

														// correction
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_coarse10[ii] += error_approx_fine11[ii];
														}

														// free
														delete[] error_approx_fine11;
														delete[] error_approx_coarse11;
														delete[] residual_coarse11;
														delete[] residual_fine11;

													}


													// post smothing
													for (integer iter = 0; iter < nu2; iter++) {
														integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10];
														integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + 2 * nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}


													// prolongation
													// residual_r
													doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_fine10[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif
													

													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

													// correction
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_coarse9[ii] += error_approx_fine10[ii];
													}

													// free
													delete[] error_approx_fine10;
													delete[] error_approx_coarse10;
													delete[] residual_coarse10;
													delete[] residual_fine10;

												}



												// post smothing
												for (integer iter = 0; iter < nu2; iter++) {
													integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9];
													integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + 2 * nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}


												// prolongation
												// residual_r
												doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_fine9[ii] = 0.0;
												}

#if doubleintprecision == 1
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#else
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#endif
												

												integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

												// correction
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_coarse8[ii] += error_approx_fine9[ii];
												}

												// free
												delete[] error_approx_fine9;
												delete[] error_approx_coarse9;
												delete[] residual_coarse9;
												delete[] residual_fine9;

											}

											// post smothing
											for (integer iter = 0; iter < nu2; iter++) {
												integer n5 = 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8];
												integer n6 = 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + 2 * nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}


											// prolongation
											// residual_r
											doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_fine8[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif
											

											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

											// correction
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_coarse7[ii] += error_approx_fine8[ii];
											}

											// free
											delete[] error_approx_fine8;
											delete[] error_approx_coarse8;
											delete[] residual_coarse8;
											delete[] residual_fine8;

										}

										// post smothing
										for (integer iter = 0; iter < nu2; iter++) {
											seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + 2 * nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										// prolongation
										// residual_r
										doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_fine7[ii] = 0.0;
										}

#if doubleintprecision == 1
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#else
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#endif
										

										prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

										// correction
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_coarse6[ii] += error_approx_fine7[ii];
										}

										// free
										delete[] error_approx_fine7;
										delete[] error_approx_coarse7;
										delete[] residual_coarse7;
										delete[] residual_fine7;

									}


									// post smothing
									for (integer iter = 0; iter < nu2; iter++) {
										seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + 2 * nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}


									// prolongation
									// residual_r
									//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_fine6[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif
									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

									// correction
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_coarse5[ii] += error_approx_fine6[ii];
									}

									// free
									//delete[] error_approx_fine6;
									//delete[] error_approx_coarse6;
									//delete[] residual_coarse6;
									//delete[] residual_fine6;

								}

								// post smothing
								for (integer iter = 0; iter < nu2; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								// prolongation
								// residual_r
								//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_fine5[ii] = 0.0;
								}

#if doubleintprecision == 1
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#else
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#endif
								

								prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

								// correction
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] += error_approx_fine5[ii];
								}

								// free
								//delete[] error_approx_fine5;
								//delete[] error_approx_coarse5;
								//delete[] residual_coarse5;
								//delete[] residual_fine5;

							}
							// post smothing
							for (integer iter = 0; iter < nu2; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif
							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

						}
						// post smothing
						for (integer iter = 0; iter < nu2; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif
						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

					}
					// post smothing
					for (integer iter = 0; iter < nu2; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif
					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

				}
				// post smothing
				for (integer iter = 0; iter < nu2; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif
				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

			}

			// post smothing
			for (integer iter = 0; iter < nu2; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}
		// post smother
		for (integer iter = 0; iter < nu2; iter++) {
			//seidel<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}
	}

	system("pause");

	// free
	delete[] error_approx_fine;
	if (ilevel > 1) {
		delete[] error_approx_coarse;
		delete[] residual_coarse;
		if (ilevel > 2) {
			// free
			delete[] error_approx_fine1;
			delete[] error_approx_coarse1;
			delete[] residual_coarse1;
			delete[] residual_fine1;
			if (ilevel > 3) {
				// free
				delete[] error_approx_fine2;
				delete[] error_approx_coarse2;
				delete[] residual_coarse2;
				delete[] residual_fine2;
				if (ilevel > 4) {
					// free
					delete[] error_approx_fine3;
					delete[] error_approx_coarse3;
					delete[] residual_coarse3;
					delete[] residual_fine3;
					if (ilevel > 5) {
						// free
						delete[] error_approx_fine4;
						delete[] error_approx_coarse4;
						delete[] residual_coarse4;
						delete[] residual_fine4;
						if (ilevel > 6) {
							// free
							delete[] error_approx_fine5;
							delete[] error_approx_coarse5;
							delete[] residual_coarse5;
							delete[] residual_fine5;
							if (ilevel > 7) {
								// free
								delete[] error_approx_fine6;
								delete[] error_approx_coarse6;
								delete[] residual_coarse6;
								delete[] residual_fine6;
							}
						}
					}
				}
			}
		}
	}
	delete[] residual_fine;

	delete[] row_ptr_start;
	delete[] row_ptr_end;
	delete[] flag_;
	return 0;

} // aggregative_amg

  // возвращает максимум из двух целых чисел.
integer i_my_max(integer ia, integer ib) {
	if (ia > ib) {
		return ia;
	}
	else {
		return ib;
	}
}

// возвращает минимум из двух целых чисел.
integer i_my_min(integer ia, integer ib) {
	if (ia > ib) {
		return ib;
	}
	else {
		return ia;
	}
}

// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C-F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C-F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С-F разбиения 
// учитывается уже построеннная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведеия Галёркина получена самая оптимальная по быстродествию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C-F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполляции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
template <typename doublerealT>
integer classic_aglomerative_amg1(Ak* &Amat, integer nnz,
	integer n, // dimension of vectors x and b.
	Ak* &R, // restriction
	Ak* &P, // prolongation
	Ak* &Atemp,
	Ak* &Atemp2,
	doublereal* &x, doublereal* &b,
	doublerealT theta,
	integer dim_2D
	/*,
	doublerealT mul_theta3D*/
	) {


	//const doublerealT mul_theta3D = 0.13;

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 


	bool bqs = true; // Использовать ли quicksort qs and qsj.
					 // Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая жрёт килотонну памяти (Короче для машин у которых море оперативки).
	bool blite_and_quick_version = false;
	// false даёт более качественное построение иерархии матриц, 
	// с ним количество итераций сокращается.
	const integer heapsortsizelimit = 200000000; // 200M Достаточно для 3D с размерностью 300х300х300 189М ненулевых элементов.

	const doublereal RealZERO = 1.0e-300;// 1.0e-10;
	const doublereal divisionZERO = 1.0e-300;
	const doublereal RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_sosed = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumsosedcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C-F разбиения.
	integer icandidate_shadow = -1;
	bool bmaxsosedinfoactive = false;

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	bool bquicktypesort = false;


	// x_coarse[1..n_coarse]=R n_coarse x n_fine*x_fine[1..n_fine];
	// x_fine[1..n_fine]=P n_fine x n_coarse*x_coarse[1..n_coarse];

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	bool* flag = new bool[n + 1];
	//bool* flag_ = new bool[n + 1];
	bool* flag_shadow = new bool[n + 1];
	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;
	bool* this_is_C_node = new bool[n + 1];
	bool* this_is_F_node = new bool[n + 1];

	// храним соседей новых F узлов
	const integer imaxpoolsize = 2000;
	integer pool_sosed[imaxpoolsize];
	integer imax_pool_ind;

	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {

		Maximumsosedcount = -1;
		bmaxsosedinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

#if doubleintprecision == 1
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
			printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}
#else
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
			printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}
#endif
		

		if (ilevel > 17) {
			printf("very big matrix (mesh). no programming.\n");
			system("pause");
			exit(1);
		}

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]; ii <= n; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// сортировка исходной  А  по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		if (bquicktypesort) {
			QuickSort(Amat, /*n_a[ilevel - 1],*/ 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
					else {
						// quicksort
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
				}
				else {
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}
				//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);

			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1]);
				Aorig = NULL;
			}
		}

		// Экономично вычисляет полуширину ленты матрицы.
		integer band_size = -1;
		integer band_size_i = -1;
		/*
		for (integer i_1 = 1; i_1 <= n; i_1++) {
		flag[i_1] = false;
		}
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (!flag[Amat[ii].i]) {
		flag[Amat[ii].i] = true;
		integer istart = ii;
		while ((istart <= nnz_a[ilevel - 1] + iadd) && (Amat[istart].i == Amat[ii].i) && (Amat[istart].j != Amat[ii].i)) istart++;
		if ((istart <= nnz_a[ilevel - 1] + iadd) && (Amat[istart].i == Amat[ii].i)) {
		integer ifound = istart;
		istart = ii;
		while ((istart <= nnz_a[ilevel - 1] + iadd) && (Amat[istart].i == Amat[ii].i)) {

		if (Amat[istart].j != Amat[ii].i) {
		integer ij = BinarySearchAi(Amat, Amat[istart].j, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		while ((ij <= nnz_a[ilevel - 1] + iadd) && (Amat[ij].i == Amat[istart].j) && (Amat[ij].j != Amat[istart].j)) ij++;
		if ((ij <= nnz_a[ilevel - 1] + iadd) && (Amat[ij].i == Amat[istart].j) && (Amat[ij].j == Amat[istart].j)) {
		if (abs(ij - ifound) > band_size) band_size = abs(ij - ifound);
		if (abs(Amat[ij].j - Amat[ifound].i) > band_size_i) band_size_i = abs(Amat[ij].j - Amat[ifound].i);
		}
		}
		istart++;
		}
		}
		}
		}
		#if doubleintprecision == 1
				printf("bandsize=%lld\n", band_size);
		#else
				printf("bandsize=%d\n", band_size);
		#endif
		
		*/
		// заглушка для совместимости с устаревшим кодом.
		// 13 декабря 2015.
		band_size = 100;
		band_size_i = 100;
		printf("no band_size definition\n");
		//band_size = -1; // OFF band_size acselerator.

		// Создаём копию в Atemp, копия будет отсортирована по j.
		for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
			Atemp[i_1 - iadd] = Amat[i_1];
			Atemp[i_1 - iadd].ind = i_1; // запоминаем первоначальную позицию в А.
		}
		// Сортируем копию по j.
		// Мы сортируем по j, чтобы потом быстро искать по j.
		if (bqs) {
			if (bCounting_Sort) {
				// Сортировка с подсчётом за линейное время.
				Counting_Sortj(Atemp, 1, nnz_a[ilevel - 1]);
			}
			else {
				// Быстрая сортировка Чарльза Хоара.
				qsj(Atemp, 1, nnz_a[ilevel - 1]);
			}
		}
		else {
			HeapSort_j(Atemp, 1, nnz_a[ilevel - 1]);
		}

		// Экономично вычисляет полуширину ленты матрицы.
		integer band_sizej = -1;
		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}
		/*
		for (integer ii = 1; ii <= nnz_a[ilevel - 1]; ii++) {
		if (!flag[Atemp[ii].j]) {
		flag[Atemp[ii].j] = true;
		integer istart = ii;
		while ((istart <= nnz_a[ilevel - 1]) && (Atemp[istart].j == Atemp[ii].j) && (Atemp[istart].i != Atemp[ii].j)) istart++;
		if ((istart <= nnz_a[ilevel - 1]) && (Atemp[istart].j == Atemp[ii].j)) {
		integer ifound = istart;
		istart = ii;
		while ((istart <= nnz_a[ilevel - 1]) && (Atemp[istart].j == Atemp[ii].j)) {

		if (Atemp[istart].i != Atemp[ii].j) {
		integer ij = BinarySearchAj(Atemp, Atemp[istart].i, 1, nnz_a[ilevel - 1]);
		while ((ij <= nnz_a[ilevel - 1]) && (Atemp[ij].j == Atemp[istart].i) && (Atemp[ij].i != Atemp[istart].i)) ij++;
		if ((ij <= nnz_a[ilevel - 1]) && (Atemp[ij].j == Atemp[istart].i) && (Atemp[ij].i == Atemp[istart].i)) {
		if (abs(ij - ifound) > band_sizej) band_sizej = abs(ij - ifound);
		}
		}
		istart++;
		}
		}
		}
		}
		#if doubleintprecision == 1
				printf("bandsizej=%lld\n", band_sizej);
		#else
				printf("bandsizej=%d\n", band_sizej);
		#endif
		
		if ((band_size == -1) && (band_sizej == -1)) {
		bcontinue = false;
		// Судя по всему иерархия матриц уже построена.
		// Досрочный выход из этпа конструирования по причине
		// отсутствия связей в матрице... ?
		// Возможно эта неопределённость была причиной сбоя на реальном тестировании.
		break;
		}
		*/
		// Заглушки для совместимости с устаревшим кодом.
		band_sizej = 100;
		printf("no band size use. 12 dec 2015\n");
		//getchar();
		//band_size = -1; // OFF band_size acselerator.


		//if (ilevel == 2) {
		// Матрица второго уровня составлена совершенно неверно.
		// Возможно неверно было составлено произведение Галёркина RAP.
		//for (integer ii7 = 1 + iadd; ii7 <= iadd + nnz_a[ilevel - 1]; ii7++) {
		//if (Amat[ii7].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
#if doubleintprecision == 1
		//if (Amat[ii7].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[ii7].j);
		//}
		//	printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", ii7, Amat[ii7].i, ii7, Amat[ii7].j, ii7, Amat[ii7].aij);
		//system("pause");
		//}
		//}

		//for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		//	printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
		//if (ii % 20 == 0) getchar();
		//}
#else
		//if (Amat[ii7].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[ii7].j);
		//}
		//	printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", ii7, Amat[ii7].i, ii7, Amat[ii7].j, ii7, Amat[ii7].aij);
		//system("pause");
		//}
		//}

		//for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		//	printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n",ii,Amat[ii].aij,ii,Amat[ii].i,ii,Amat[ii].j);
		//if (ii % 20 == 0) getchar();
		//}
#endif
		

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = new integer[n_a[ilevel - 1] + 1];
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_sosed = new integer[n_a[ilevel - 1] + 1];
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_sosed[ii] = 0; // нет соседей.
		}

		if (blite_and_quick_version)
		{
			// А при таком определении узел Дирихле имеет ноль соседей.
			// Соседей вычисляем на самой первой матрице А (самой левой).
			for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer ic = -1;
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
					}
					count_sosed[Amat[ii].i] = ic;
					if (ic > Maximumsosedcount) {
						Maximumsosedcount = ic;
						icandidate_shadow = ii;
						bmaxsosedinfoactive = true;
					}
					flag[Amat[ii].i] = true;
				}
			}
		}
		else {


			// При таком коде узел Дирихле тоже имеет соседа, сосед это 
			// внутренний узел который связан с этим узлом Дирихле.
			// Соседей вычисляем на самой первой матрице А (самой левой).
			for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer ic = -1;
					integer cand[max_sosed];
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
					integer len_sosed = ic;
					// Найти столбец j который равен индексу Amat[ii].i
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
					//if (Amat[ii1].i != Amat[ii].i) {
					//	if (Amat[ii1].j == Amat[ii].i) {
					// j,i
					//		bool foundsosed = false;
					//		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
					//			if (Amat[ii1].j == cand[i_1]) foundsosed = true;
					//		}
					//		if (!foundsosed) {
					//			ic++;
					//			cand[ic] = Amat[ii1].j;
					//			len_sosed++;
					//		}
					//	}
					//}
					//}
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundsosed = false;
							for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
							}
							if (!foundsosed) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_sosed++;
							}
						}
					}


					count_sosed[Amat[ii].i] = ic;
					if (ic > Maximumsosedcount) {
						Maximumsosedcount = ic;
						icandidate_shadow = ii;
						bmaxsosedinfoactive = true;
					}
					flag[Amat[ii].i] = true;
				}
			}
		}


		integer maxsosed = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				if (count_sosed[Amat[ii].i] > maxsosed) {
					maxsosed = count_sosed[Amat[ii].i];
					icandidate = ii;
					if (bmaxsosedinfoactive) {
						// организуем досрочный выход из цикла for.
						// Это должно сильно сокращать количество сканирований.
						if (maxsosed == Maximumsosedcount) break;
					}
				}
				flag[Amat[ii].i] = true;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_SOSED = -1;
		integer vacant = NULL_SOSED;
		bool bcontinue = true;

		// Построение C-F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = new bool[n + 1];
		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;

		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
			Atemp2[i_1] = Amat[i_1 + iadd]; // copy
			Atemp2[i_1].ind = i_1 + iadd;
			Amat[i_1 + iadd].ind = i_1; // запоминаем обратную связь.
									 //if (ilevel == 2) {
#if doubleintprecision == 1
									 //printf("%e %lld %lld %lld\n", Atemp2[i_1].aij, Atemp2[i_1].i, Atemp2[i_1].j, Atemp2[i_1].ind);
#else
									 //printf("%e %d %d %d\n", Atemp2[i_1].aij, Atemp2[i_1].i, Atemp2[i_1].j, Atemp2[i_1].ind);
#endif
									
									 //getchar();
									 //}
		}

		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;

		//if (bmaxsosedinfoactive == true) {
		//printf("bmaxsosedinfoactive==true\n");
		//getchar();
		//}
		List* plist = NULL;
		List* plist_current = NULL;
		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;

		integer istat_old = 0;
		integer istat_new = 0;
		integer istat_new2 = 0;


		while (bcontinue)
		{



			imax_pool_ind = 1;
#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_sosed]; // не более 20 узлов в одном агрегате.
									// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
									//for (integer js = 0; js < max_sosed; js++) {
									//set[js] = NULL_SOSED;
									//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {
				// Вычисляем по немодифицированной матрице А (хранящейся слева).
				integer nnzRl = nnzR + iaddR;


				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;


				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
											 // добавляем диагональный элемент.
											 // узел set[0]==Amat[is0].i.
											 // Нахождение значения максимального внедиагольного элемента, с 
											 // учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;
				pool_sosed[0] = ii;
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j == set[0]) {

						nnzRl++;
						break;
					}
					else {
						if (fabs(Amat[is0].aij) > max_vnediagonal) {
							max_vnediagonal = fabs(Amat[is0].aij); //i,j
						}
					}
					if (!blite_and_quick_version) {
						// Этот цикл является добавочным.
						// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
						// Медленный линейный поиск.
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
						//if (Amat[ii1].i != set[0]) {
						//if (!flag[Amat[ii1].i]) {
						//	if (Amat[ii1].j == set[0]) {
						//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
						//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
						//		}
						//	}
						//}
						//}
						//}

						// Этот цикл является добавочным.
						// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
						// Ускоренная версия на основе двоичного поиска.
						integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
						for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
						{
							if (Atemp[ii1].i != set[0]) {
								if (!flag[Atemp[ii1].i]) {
									if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
										max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
									}
								}
							}
						}

					}
				}

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						pool_sosed[imax_pool_ind] = ii;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_SOSED;
							}
						}
						if (vacant != NULL_SOSED) {
							set[ic] = vacant;
							imax_pool_ind++;
							if (imax_pool_ind > imaxpoolsize) {
								printf("pool index incorrupt: pool ind > pool_size\n");
								//getchar();
								system("pause");
							}
							nnzRl++;
							ic++;
						}
					}
				}
				integer iscan = ii + 1;
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							pool_sosed[imax_pool_ind] = iscan;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_SOSED;
								}
							}
							if (vacant != NULL_SOSED) {
								set[ic] = vacant;
								imax_pool_ind++;
								if (imax_pool_ind > imaxpoolsize) {
									printf("pool index incorrupt: pool ind > pool_size\n");
									//getchar();
									system("pause");
								}
								nnzRl++;
								ic++;

							}
						}
					}

					iscan++;

				} // while

				  // Это была учтена только связь i,j

				if (!blite_and_quick_version) {

					// Учёт свяи j,i
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
					//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
					//if (!flag[Amat[ii1].i]) {
					//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
					//	vacant = Amat[ii1].i;
					//	for (integer js = 0; js < ic; js++) {
					//		if (vacant == set[js]) {
					//			vacant = NULL_SOSED;
					//		}
					//	}
					//	if (vacant != NULL_SOSED) {
					//		set[ic] = vacant; // j,i связь.

					//		nnzRl++;
					//		ic++;
					//	}
					//	}
					//}
					//}
					//}

					// Учёт связи j,i
					// Медленная версия на основе линейного поиска.
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
					//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
					//if (!flag[Amat[ii1].i]) {
					//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
					//	vacant = Amat[ii1].i;
					//	for (integer js = 0; js < ic; js++) {
					//		if (vacant == set[js]) {
					//			vacant = NULL_SOSED;
					//		}
					//	}
					//	if (vacant != NULL_SOSED) {
					//		set[ic] = vacant; // j,i связь.

					//		nnzRl++;
					//		ic++;
					//	}
					//}
					//}
					//}
					//}

					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1]) && (Atemp[ii2].j == set[0]); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {
								vacant = Atemp[ii2].i;
								pool_sosed[imax_pool_ind] = Atemp[ii2].ind; // Позиция в А.
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant; // j,i связь.
									imax_pool_ind++;
									if (imax_pool_ind > imaxpoolsize) {
										printf("pool index incorrupt: pool ind > pool_size\n");
										//getchar();
										system("pause");
									}
									nnzRl++;
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}
				/*
				for (integer isc = 1; isc < n_a[ilevel - 1]; isc++) {
				if (flag[isc] == false) {
				// найти соседей узла isc
				integer ii1 = BinarySearchAi(Amat, isc, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//	if (Amat[ii1].i == isc) {
				integer ic2 = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer js = 1; js < ic; js++) {
				if (Amat[is0].j == set[js]) {
				ic2++;
				}
				}
				}
				count_sosed[isc] += ic2;
				//	}
				//}
				// если среди них окажется из set[1..ic-1]
				// значит увеличиваем счётчик count_sosed[isc] на единицу.
				}
				}
				*/

				//if (1) {
				if (band_size == -1) {

					// Нет никакой информации о ширине ленты.

					for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
						flag_shadow[i_1] = flag[i_1];
					}
					// Модификация счётчиков для соседей новых F узлов.
					// j есть новый F тогда i счетчик меняется. // ij связь.
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
					// Более быстрый вариант кода.
					for (integer ii_2 = ibegining_start_index_found_maximum; ii_2 <= nnz_a[ilevel - 1] + iadd; ii_2++) {
						integer ii1 = Atemp2[ii_2 - iadd].ind;
						integer isc = Amat[ii1].i;
						if ((flag_shadow[isc] == false) && ((!bmarkervisit[isc]))) {
							flag_shadow[isc] = true;
							integer ic2 = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								for (integer js = 1; js < ic; js++) {
									if (Amat[is0].j == set[js]) {
										ic2++;
									}
								}
							}
							count_sosed[isc] += ic2;
							if (bmaxsosedinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_sosed[isc] >= Maximumsosedcount) {
									Maximumsosedcount = count_sosed[isc];
									icandidate_shadow = ii1;

									if (plist == NULL) {
										plist = new List;
										plist->next = NULL;
										plist->prev = NULL;
										plist->ii = ii1;
										plist->countsosed = count_sosed[isc];
										plist->i = isc;
										plist_current = plist;
									}
									else {
										List *ptemp = new List;
										ptemp->ii = ii1;
										ptemp->i = isc;
										ptemp->countsosed = count_sosed[isc];
										ptemp->next = NULL;
										ptemp->prev = plist_current;
										plist_current->next = ptemp;
										plist_current = ptemp;
										ptemp = NULL;
									}
								}
							}
						}
					}

				}
				else {

					// Здесь в полной мере используется гипотеза локальности.
					// Она состоит в следующем : узел с порядковым номером в матрице ii 
					// имеет соседей лишь в окрестности +- band_size.


					// Ширина ленты равна band_size
					//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
					//flag_shadow[i_1] = flag[i_1];
					//}
					if (ic <= 0) {
						// Проверено ic не может быть нулём, а случай ic==1 
						// ничем не отличается от общего случая где прекрасно работает гипотеза локальности.
						// Выключим данную ветвь кода перенеся её в общий случай, т.к. данная 
						// ветвь очень медленная т.к. в ней не используется гипотеза локальности.
						// 7 ноября 2015.


						if (ic == 0) {
							printf("ic==0 iformation\n");
							//getchar();
							system("pause");
						}
						// На завершающей стадии соседей нет поэтому должен работать
						// код которому ничего неизвестно о ширине ленты.


						// Нет никакой информации о ширине ленты.

						for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
							flag_shadow[i_1] = flag[i_1];
						}
						// Модификация счётчиков для соседей новых F узлов.
						// j есть новый F тогда i счетчик меняется. // ij связь.
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
						// Более быстрый вариант кода.
						for (integer ii_2 = ibegining_start_index_found_maximum; ii_2 <= nnz_a[ilevel - 1] + iadd; ii_2++) {
							integer ii1 = Atemp2[ii_2 - iadd].ind;
							integer isc = Amat[ii1].i;
							if ((flag_shadow[isc] == false) && ((!bmarkervisit[isc]))) {
								flag_shadow[isc] = true;
								integer ic2 = 0;
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									for (integer js = 1; js < ic; js++) {
										if (Amat[is0].j == set[js]) {
											ic2++;
										}
									}
								}
								count_sosed[isc] += ic2;
								if (bmaxsosedinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_sosed[isc] >= Maximumsosedcount) {
										Maximumsosedcount = count_sosed[isc];
										icandidate_shadow = ii1;

										if (plist == NULL) {
											plist = new List;
											plist->next = NULL;
											plist->prev = NULL;
											plist->ii = ii1;
											plist->countsosed = count_sosed[isc];
											plist->i = isc;
											plist_current = plist;
										}
										else {
											List *ptemp = new List;
											ptemp->ii = ii1;
											ptemp->i = isc;
											ptemp->countsosed = count_sosed[isc];
											ptemp->next = NULL;
											ptemp->prev = plist_current;
											plist_current->next = ptemp;
											plist_current = ptemp;
											ptemp = NULL;
										}
									}
								}
							}
						}

					}
					else {

						if (0) {
							// медленный вариант кода.


							for (integer js = 1; js < ic; js++) {
								for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
									flag_shadow[i_1] = flag[i_1];
								}

								integer istart = i_my_max(1 + iadd, pool_sosed[js] - band_size - 1);
								integer iend = i_my_min(nnz_a[ilevel - 1] + iadd, pool_sosed[js] + band_size + 1);
								// Ищем только среди ближайшего окружения вновь добавленного F узла.
								for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {
									integer isc = Amat[ii_2].i;
									if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
										flag_shadow[isc] = true;
										integer ic2 = 0;
										integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_2 + band_size + 1);
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
											if (Amat[is0].j == set[js]) {
												ic2++;
											}
										}

										count_sosed[isc] += ic2;
										if (bmaxsosedinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_sosed[isc] >= Maximumsosedcount) {
												Maximumsosedcount = count_sosed[isc];
												icandidate_shadow = ii_2;

												if (plist == NULL) {
													plist = new List;
													plist->next = NULL;
													plist->prev = NULL;
													plist->ii = ii_2;
													plist->countsosed = count_sosed[isc];
													plist->i = isc;
													plist_current = plist;
												}
												else {
													List *ptemp = new List;
													ptemp->ii = ii_2;
													ptemp->i = isc;
													ptemp->countsosed = count_sosed[isc];
													ptemp->next = NULL;
													ptemp->prev = plist_current;
													plist_current->next = ptemp;
													plist_current = ptemp;
													ptemp = NULL;
												}
											}
										}
									}
								}
							}
						}
						else {

							// Алгоритм (4 декабря 2015). {Занимает 20% времени от времени алгоритма в 2D,
							// В 3D ситуация должна быть сильно хуже. }
							// 1. Сканируем все F которые соседи данного С на данном проходе.
							// 2. Для каждого фиксированного F сканируем его Bandsize_i окрестность.
							// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
							// соседства с фиксированным набором F из пункта 1.


							/*
							for (integer js = 1; js < ic; js++) {
							//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
							//flag_shadow[i_1] = flag[i_1];
							//}

							//integer istart = i_my_max(1 + iadd, pool_sosed[js] - band_size - 1);
							//integer iend = i_my_min(nnz_a[ilevel - 1] + iadd, pool_sosed[js] + band_size + 1);

							//integer i3 = 1;
							//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
							//integer i4 = n_a[ilevel - 1];
							//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;

							integer i3 = i_my_max(1, set[js] - band_size_i - 1);
							integer i4 = i_my_min(n_a[ilevel - 1], set[js] + band_size_i + 1);

							// Ищем только среди ближайшего окружения вновь добавленного F узла.
							//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

							// ищем соседа узла set[js].
							for (integer i5 = i3; i5 <= i4; i5++) {
							//integer isc = Amat[ii_2].i;
							integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer isc = i5;
							if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_2 + band_size + 1);
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
							if (Amat[is0].j == set[js]) {
							ic2++;
							}
							}

							count_sosed[isc] += ic2;
							if (bmaxsosedinfoactive) {
							// Обновляем информацию о максимальном количестве соседей.
							if (count_sosed[isc] >= Maximumsosedcount) {
							Maximumsosedcount = count_sosed[isc];
							icandidate_shadow = ii_2;

							if (plist == NULL) {
							plist = new List;
							plist->next = NULL;
							plist->prev = NULL;
							plist->ii = ii_2;
							plist->countsosed = count_sosed[isc];
							plist->i = isc;
							plist_current = plist;
							}
							else {
							List *ptemp = new List;
							ptemp->ii = ii_2;
							ptemp->i = isc;
							ptemp->countsosed = count_sosed[isc];
							ptemp->next = NULL;
							ptemp->prev = plist_current;
							plist_current->next = ptemp;
							plist_current = ptemp;
							ptemp = NULL;
							}
							}
							}
							}
							}
							}
							*/

							// Алгоритм (5 декабря 2015 revised) 
							// 1. Сканируем все F которые соседи данного С на данном проходе.
							// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
							// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
							// соседства с фиксированным набором F из пункта 1.
							// В этом коде нет очень длинных сканирований связанных с band_size, 
							// есть надежда что этот код существенно более эффективен в 3D.


							if (bAVL) {
								// 12 декабря 2015.
								// Надо удалить из АВЛ дерева C и F узлы.
								// Это удаление очищает АВЛ дерево и приводит его к
								// рабочему состоянию. Удаление несуществующих в дереве узлов
								// производится корректно. Удаление производится за логарифмическое
								// по основанию 2  время от количества элементов в дереве
								// сбалансированность дерева при этом сохраняется.
								for (integer js = 0; js < ic; js++) {
									data_BalTree ddel;
									ddel.i = set[js];
									ddel.countsosed = count_sosed[set[js]];
									//ddel.ii = row_startA[ddel.i];
									root = remove_AVL(root, ddel);
									if (bAVL_deb)
									{
										printf("remove\n");
									}
								}
							}

							for (integer js = 1; js < ic; js++) {
								//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
								//flag_shadow[i_1] = flag[i_1];
								//}

								//integer istart = i_my_max(1 + iadd, pool_sosed[js] - band_size - 1);
								//integer iend = i_my_min(nnz_a[ilevel - 1] + iadd, pool_sosed[js] + band_size + 1);

								//integer i3 = 1;
								//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
								//integer i4 = n_a[ilevel - 1];
								//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;

								//--->//	integer i3 = i_my_max(1, set[js] - band_size_i - 1);
								//---->//   integer i4 = i_my_min(n_a[ilevel - 1], set[js] + band_size_i + 1);

								// Ищем только среди ближайшего окружения вновь добавленного F узла.
								//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

								// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
								// элемент lsos_head;
								List *lsos = NULL;
								List *lsos_head = NULL;
								lsos = new List;
								lsos->prev = NULL;
								lsos_head = lsos;
								{
									integer i_11 = set[js];
									integer ii_11 = row_startA[i_11];
									//integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_11 + band_size + 1);
									integer iend2 = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_11;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
									istart2++;
									bool bvisitsos = false;
									for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
										if (flag[Amat[is0].j] == false) {
											lsos->next = NULL;
											lsos->i = Amat[is0].j;
											lsos->ii = row_startA[lsos->i];
											// lsos->countsosed // не используется.
											List *newnodesos = new List;
											newnodesos->prev = lsos;
											lsos->next = newnodesos;
											newnodesos->next = NULL;
											lsos = lsos->next;
											newnodesos = NULL;
											bvisitsos = true;
										}
									}
									if (bvisitsos) {

										List *delsos = lsos;
										lsos = lsos->prev;
										lsos->next = NULL;
										delsos->prev = NULL;
										delete delsos;
										delsos = NULL;
									}
									else {
										// Нет ни одного соседа
										lsos_head = NULL;
										delete lsos;
										lsos = NULL;
									}
								}

								lsos = lsos_head;
								// ищем соседа узла set[js].
								//for (integer i5 = i3; i5 <= i4; i5++) {
								while (lsos != NULL) {


									//integer isc = Amat[ii_2].i;
									//integer ii_2 = row_startA[i5];
									//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									//integer isc = i5;

									integer isc = lsos->i;
									integer ii_2 = lsos->ii;


									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									//integer iend2 = i_my_min(nnz_a[ilevel - 1] + iadd, ii_2 + band_size + 1);
									integer iend2 = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
										if (Amat[is0].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_sosed[isc] += ic2;
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;
									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
											icandidate_shadow = ii_2;
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.

										if (bAVL) {
											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											root = insert_and_modify(root, dadd, dsearch);
											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}
										else {
											// Добавляем элемент в список.

											if (plist == NULL) {
												plist = new List;
												plist->next = NULL;
												plist->prev = NULL;
												plist->ii = ii_2;
												plist->countsosed = count_sosed[isc];
												plist->i = isc;
												plist_current = plist;
											}
											else {
												List *ptemp = new List;
												ptemp->ii = ii_2;
												ptemp->i = isc;
												ptemp->countsosed = count_sosed[isc];
												ptemp->next = NULL;
												ptemp->prev = plist_current;
												plist_current->next = ptemp;
												plist_current = ptemp;
												ptemp = NULL;
											}
										}

									}
									//}
									lsos = lsos->next;
								}

								// Уничтожение lsos
								// Список постепенно уничтожается с головы.
								lsos = lsos_head;
								while (lsos != NULL) {
									lsos_head = lsos_head->next;
									if (lsos_head != NULL) {
										lsos_head->prev = NULL;
									}
									lsos->next = NULL;
									delete lsos;
									lsos = lsos_head;
								}


							}



						}
					}

				}




				n_coarce++; // Увеличено количество С узлов.

							// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
						   //if (maxsosed == -1) {
#if doubleintprecision == 1
						   //printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
						   //printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
						  
						   //system("pause");
						   //}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxsosed = -1;
			icandidate = 0;


			// TODO 6 november

			const integer ipool_size_limit = 128000;
			integer ipool[ipool_size_limit];
			integer isize_p = -1;
			for (integer isc = 0; isc < ic; isc++) {
				//integer ii_s = pool_sosed[isc];// позиция в А.
				integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
				integer ii_c = ii_s;
				//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
				//ii_c++;
				// Вся строка матрицы начиная с позиции ii_c должна быть помещена в Atemp2;
				while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
					integer icandidateq = ii_c;
					bool found1 = false;
					for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
						if (i_7 < ipool_size_limit) {
							if (ipool[i_7] == icandidateq) {
								found1 = true;
							}
						}
						else {
#if doubleintprecision == 1
							printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
#else
							printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
#endif
							
							system("pause");
							exit(1);
						}
					}
					// элемент в списке не обнаружен, поэтому запомним индекс.
					if (found1 == false) {
						isize_p++;
						if (isize_p < ipool_size_limit) {
							ipool[isize_p] = icandidateq;
						}
						else {
#if doubleintprecision == 1
							printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
#else
							printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
#endif
							
							system("pause");
							exit(1);
						}
					}
					ii_c++;
				}
			}
			// ipool хранит кандидатов для добавления в Atemp2.
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
				// Позиции элементов в А остаются на месте, поэтому коллизий быть недолжно.

				Ak temp = Atemp2[ibegining_start_index_found_maximum - iadd + i_7];
				Atemp2[ibegining_start_index_found_maximum - iadd + i_7] = Amat[ipool[i_7]];
				Atemp2[ibegining_start_index_found_maximum - iadd + i_7].ind = ipool[i_7];

				Atemp2[Amat[ipool[i_7]].ind] = temp;
				Amat[temp.ind].ind = Amat[ipool[i_7]].ind;
				Amat[ipool[i_7]].ind = ibegining_start_index_found_maximum - iadd + i_7;
			}
			ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxsosedinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				emax = findmax(root);
				if (emax != 0) {
					if (bAVL_deb)
					{
						print_AVL(root);
						system("pause");
					}

					// 23 jan 2016
					//icandidate = emax->key.ii;
					icandidate=BinarySearchAi(Amat, emax->key.i, 1 + iadd, iadd + nnz_a[ilevel - 1]);
					//icandidate = row_startA[emax->key.i];
					emax = 0;
					if (bAVL_deb)
					{
						printf("find max\n");
					}
				}
				else {
					root = 0;
					icandidate = 0;
					maxsosed = -1;
					bcontinue = false;

				}

			}
			else {

				// Судя по тестам в 3D этот кусок кода очень тормозит,
				// поэтому было введено АВЛ дерево чтобы существенно улучшить характеристики 
				// быстродействия.

				// Мы будем делать досрочный выход из цикла for 19 раз из 20,
				// и лишь один раз апдейтить информацию о максимальном количестве соседей.
				// Данная модификация придумана 17 октября 2015 года.
				// Эта эвристика обеспечила ускорение на 8% от суммарного времени исполнения 
				// всего алгоритма.
				if (icountprohod % 200 == 0) {



					// TODO 6november start delete code
					/*
					// Сначала пишем те узлы которые были посещены.
					integer i_2 = 1;
					for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
					if (bmarkervisit[Amat[i_1].i]) {
					Atemp2[i_2] = Amat[i_1];
					Atemp2[i_2].ind = i_1; // обязательно запоминаем первоначальный индекс.
					i_2++;
					}
					}
					// Потом пишем все другие узлы.
					for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
					if (!bmarkervisit[Amat[i_1].i]) {
					Atemp2[i_2] = Amat[i_1];
					Atemp2[i_2].ind = i_1; // обязательно запоминаем первоначальный индекс.
					i_2++;
					}
					}
					// TODO 6 november end delete code.
					*/

					/* // 7 novemver 2015.
					bool bfirst_loc = true; // нам нужно именно первое значение позиции.

					for (integer i_2 = ibegining_start_index_found_maximum; i_2 <= nnz_a[ilevel - 1] + iadd; i_2++) {
					integer  i_1 = i_2 - iadd;


					if (!bmarkervisit[Atemp2[i_1].i]) {
					// Мы запоминаем стартовую позицию начиная с которой начинаются ещё
					// непомеченные узлы.
					if (bfirst_loc) {
					ibegining_start_index_found_maximum = i_1 + iadd;
					bfirst_loc = false;
					break;
					#if doubleintprecision == 1
						//printf("diagnostic =%lld\n",i_1);
					#else
						//printf("diagnostic =%d\n",i_1);
					#endif
					
					//getchar();
					}
					}
					}
					*/


					if ((flag[Amat[icandidate_shadow].i] == false) && (count_sosed[Amat[icandidate_shadow].i] == Maximumsosedcount)) {
						// Дело в том что мы уже нашли узел с наибольшим числом соседей прямо в ходе
						// модификации счётчиков соседей новых F узлов.
						// просто сразу это было неочевидно поэтому мы организовали поиски.
						icandidate = icandidate_shadow;
						istat_new++;
					}
					else {

						istat_old++;

						for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
							flag_shadow[i_1] = flag[i_1];
						}


						for (integer i_2 = ibegining_start_index_found_maximum; i_2 <= nnz_a[ilevel - 1] + iadd; i_2++) {
							integer  i_1 = i_2 - iadd;



							if (flag_shadow[Atemp2[i_1].i] == false) {
								if (count_sosed[Atemp2[i_1].i] > maxsosed) {
									maxsosed = count_sosed[Atemp2[i_1].i];
									//icandidate = i_1;
									icandidate = Atemp2[i_1].ind;
								}
								flag_shadow[Atemp2[i_1].i] = true;
							}
						}

						Maximumsosedcount = maxsosed;
						bmaxsosedinfoactive = true;
					}

				}
				else {

					if ((flag[Amat[icandidate_shadow].i] == false) &&
						(count_sosed[Amat[icandidate_shadow].i] == Maximumsosedcount)) {
						// Дело в том что мы уже нашли узел с наибольшим числом соседей прямо в ходе
						// модификации счётчиков соседей новых F узлов.
						// просто сразу это было неочевидно поэтому мы организовали поиски.
						icandidate = icandidate_shadow;

						istat_new++;
					}
					else {

						//List* pp7=NULL;
						bool found_candidate = false;
						//while (found_candidate == false) {
						if (plist != NULL) {

							List *phvost = plist_current;
							bool bflag11 = false;
							bool bhvostready = true;

							// Сканируем короткий пулл кандидатов
							//while (plist_current != NULL) {
							while ((plist_current != NULL) && (!(((flag[Amat[plist_current->ii].i] == false) &&
								(count_sosed[Amat[plist_current->ii].i] == Maximumsosedcount))))) {
								// первый элемент удалён и на него ссылаться нельзя.

								//while (plist_current != NULL) {
								//	if (flag[Amat[plist_current->ii].i]==true) {
								// удаляем только соседей которые уже были включены в агломераты ранее.
								if (flag[Amat[plist_current->ii].i] == true) {
									if (bflag11 == false) bhvostready = false;

									List* temp;
									temp = plist_current;
									plist_current = plist_current->prev;
									if (plist_current != NULL) {
										plist_current->next = temp->next;
										if (temp->next != NULL) {
											List* temp2 = temp->next;
											temp2->prev = plist_current;
										}
									}
									temp->prev = NULL;
									temp->next = NULL;
									if (plist != temp) {
										delete temp;
									}
									else {
										plist = NULL;
										delete temp;
									}
								}
								else {
									// можно ссылаться на первый элемент.
									bflag11 = true;
									// проматываем.
									// соседа который ещё не был помечен (включён в агломерат),
									// но у которого число соседей меньше максимального.
									plist_current = plist_current->prev;
								}
							}
							//if (plist_current != NULL) {
							//pp7 = plist_current;
							//plist_current = plist_current->prev;
							//}
							//}
							//plist_current = pp7;
							if (plist != NULL) {
								if (plist_current != NULL) {
									phvost = NULL;
									icandidate_shadow = plist_current->ii;
									icandidate = icandidate_shadow;
									found_candidate = true;
									while (plist_current->next != NULL) plist_current = plist_current->next;
								}
								else {
									plist_current = plist;
									if (bhvostready) {
										plist_current = phvost;
										phvost = NULL;
										// перемотка ненужна
									}
									else {
										phvost = NULL;
										while (plist_current->next != NULL) plist_current = plist_current->next;
									}
								}
							}
							// Рабочий вариант.
							// Определение максимума (максимального числа соседей).
							// Данное сканирование ожидает быть существенно более быстрым на глубоких уровнях
							// вложенности т.к. мы сканируем не все узлы а лишь всех соседей еще не помещенных в агрегаты.
							List* pscan = plist_current;
							integer icountsosmax = -1; // Максимальное число соседей.
							integer candidatestart = -1;
							if (pscan != NULL) {
								while (pscan != NULL) {
									if (icountsosmax < pscan->countsosed) {
										icountsosmax = pscan->countsosed;
										candidatestart = pscan->ii;
									}
									pscan = pscan->prev;
								}
								if (candidatestart != -1) {
									found_candidate = true;
									icandidate = candidatestart;
								}
							}
							// Окончание экспирементального добавления.

						}
						//if (found_candidate == false) {
						//Maximumsosedcount--;
						//if (Maximumsosedcount < 3) break; // досрочный выход из прерывателя.
						//}
						//}


						/*
						// TODO 09_11_2015
						bool found_candidate = false;
						if (plist != NULL) {
						// Сканируем короткий пулл кандидатов.
						//while ((plist_current != NULL) && (!(((flag[Amat[plist_current->ii].i] == false) &&
						//	(count_sosed[Amat[plist_current->ii].i] == Maximumsosedcount))))) {
						while (plist_current != NULL) {
						if (flag[Amat[plist_current->ii].i] == true) {
						// удаляем
						List* temp;
						temp = plist_current;
						plist_current = plist_current->prev;
						if (plist_current != NULL) {
						plist_current->next = NULL;
						}
						temp->prev = NULL;
						if (plist != temp) {
						delete temp;
						}
						else {
						plist = NULL;
						delete temp;
						}
						}
						}
						if (plist_current != NULL) {
						icandidate_shadow = plist_current->ii;
						icandidate = icandidate_shadow;
						found_candidate = true;
						}
						}
						*/

						if (found_candidate == false)
						{
							istat_old++;
							for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
								flag_shadow[i_1] = flag[i_1];
							}




							// если это не так мы всегда можем запустить старый проверенный код.

							//bool bfirst_loc = true; // нам нужно именно первое значение позиции.

							integer min_stat = 10000000;
							integer max_stat = -1;

							for (integer i_2 = ibegining_start_index_found_maximum; i_2 <= nnz_a[ilevel - 1] + iadd; i_2++) {


								integer i_1 = i_2 - iadd;
								// слишком частые коректировки начала списка замедляют код вдвое.
								// мы будем коректировать начальную позицию раз в 20 раз.
								//if (!bmarkervisit[Atemp2[i_1].i]) {
								// Мы запоминаем стартовую позицию начиная с которой начинаются ещё
								// непомеченные узлы.
								//if (bfirst_loc) {
								//	ibegining_start_index_found_maximum = i_1+iadd;
								//	bfirst_loc = false;
								//}
								//}

								if (flag_shadow[Atemp2[i_1].i] == false) {

									if (count_sosed[Atemp2[i_1].i] < min_stat) {
										min_stat = count_sosed[Atemp2[i_1].i];
									}
									if (count_sosed[Atemp2[i_1].i] > max_stat) {
										max_stat = count_sosed[Atemp2[i_1].i];
									}


									if (count_sosed[Atemp2[i_1].i] > maxsosed) {
										maxsosed = count_sosed[Atemp2[i_1].i];
										//icandidate = i_1;
										// icandidate номер элемента в матрице А отвечающий за найбольшее число соседей.
										icandidate = Atemp2[i_1].ind;
										if (bmaxsosedinfoactive) {
											// Организуем досрочный выход из цикла,
											// это длжно ускорить построение C-F разбиения.
											if (maxsosed == Maximumsosedcount) break;
										}

									}
									flag_shadow[Atemp2[i_1].i] = true;
								}
							}

#if doubleintprecision == 1
							//printf("%lld %lld", Maximumsosedcount, max_stat);
#else
							//printf("%d %d", Maximumsosedcount, max_stat);
#endif
							
							//system("pause");
							Maximumsosedcount = max_stat;
#if doubleintprecision == 1
							//printf("min=%lld max=%lld M=%lld\n", min_stat, max_stat, Maximumsosedcount);
#else
							//printf("min=%d max=%d M=%d\n", min_stat, max_stat, Maximumsosedcount);
#endif
							
							//system("pause");

							// statistics
							//integer i_11 = 0;
							//for (integer i_10 = 1; i_10 <= n_a[ilevel - 1]; i_10++) {
							//if (flag[i_10] == false) i_11++;
							//}
#if doubleintprecision == 1
							//printf("%lld %lld\n", Amat[icandidate_shadow].i, icandidate); // 99%
#else
							//printf("%d %d\n", Amat[icandidate_shadow].i, icandidate); // 99%
#endif
							
							//printf("procent %f\n",(float)(100*i_11/n_a[ilevel-1]));
							//getchar();
						}
						else {
							istat_new2++;
						}

					}
				}

			}

#if doubleintprecision == 1
			//printf("maximum number of sosed=%lld\n",maxsosed);
#else
			//printf("maximum number of sosed=%d\n",maxsosed);
#endif
			
			if (maxsosed == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxsosed == -1)) {
				bcontinue = false;
			}

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C-F разбиения. создано.

		delete[] bmarkervisit;
		// Уничтожение памяти из по пула кандидатов.
		if (plist != NULL) {

			while (plist != NULL) {
				plist_current = plist;
				plist->prev = NULL;
				plist = plist->next;
				plist_current->next = NULL;
				plist->prev = NULL;
				delete plist_current;
			}
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			clear_AVL(root);
			root = 0;
		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1] == true) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);

				bool bvisit = false;
				for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j] == true) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
				}

			}

			if (bweSholdbeContinue) {
				printf(" prohod succseful\n");
			}
			else {
				printf("prohod empty\n");
			}

		}

#if doubleintprecision == 1
		printf("old=%lld, new1=%lld, new2=%lld\n", istat_old, istat_new, istat_new2);
#else
		printf("old=%d, new1=%d, new2=%d\n", istat_old, istat_new, istat_new2);
#endif
		
		//system("pause");

		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		integer* C_numerate = new integer[n_a[ilevel - 1] + 1];
		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = NULL;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C-F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");


			// C-F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполляции : 
			// coarse 2 fine.
			//P*coarse==fine

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
#if doubleintprecision == 1
			printf("countloc=%lld\n", numberofcoarcenodes);
#else
			printf("countloc=%d\n", numberofcoarcenodes);
#endif
			
			if (debug_reshime) system("pause");

			ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			if (ap_coarse == NULL) {
				printf("error cannot memory allocate.");
				system("pause");
			}
			ap_coarse[0] = 0.0;
			//integer countloc = 1;
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8] == true) {
				integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				//integer ii2 = ii1 - 1;
				//if ((ii2 >= 1 + iadd) && (Amat[ii2].i == Amat[ii1].i)) {
				//printf("koren zla\n"); // бинарный поиск должен гарантированно находить самого левого представителя.
				//getchar();
				//}
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {
						//if (countloc > icount1 - 1) { printf("system error\n"); getchar(); }
						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();

				//countloc++;
			}

			// верно 2 октября.
			//for (integer i25 = 1; i25 < icount1; i25++) {
			//if (ap_coarse[i25]>1) {
#if doubleintprecision == 1
			//printf("ap_coarse[%lld]=%e\n", i25, ap_coarse[i25]);
#else
			//printf("ap_coarse[%d]=%e\n", i25, ap_coarse[i25]);
#endif
			
			//getchar();
			//}
			//}

			ipromah = 0;
			ipromah_one = 0;
			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublerealT maxelem_threshold = -1.0;
				integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
						}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;

				doublerealT sumP = 0.0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
							icsos++;
							//}
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.



				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {


							if (fabs(sumP) < RealZERO) {
								printf("error interpolation zero diagonal sumP.\n");
								printf("Fnode all sosed is F");
								//system("pause");
								printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								//exit(1);
								// здесь нужна непрямая интерполляция.
							}
							else {

								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								P[icount1].j = i8;
								P[icount1].i = C_numerate[Amat[is0].j];
								P[icount1].aij = fabs(Amat[is0].aij) / sumP;
								icount1++;
								//}

							}

						}
					}
				}


			}

			if (bweSholdbeContinue) {
				delete[] ap_coarse;
				ap_coarse = NULL;
				printf("obratnaq svqz restart...\n");
			}

		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);
		if (bquicktypesort) {
			QuickSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
				}
				else {
					// Быстрая сортировка Хоара.
					qsj(P, 1 + iaddR, iaddR + nnzR - 1);
				}
			}
			else {
				HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}

		/*
		if (bquicktypesort) {
		QuickSort_j(R,  1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		HeapSort_j(R, n_a[ilevel - 1], 1 + iaddR, iaddR + nnzR - 1);
		}

		printf("start now\n");
		for (integer ii5 = 1 + iaddR; ii5 <= iaddR + nnzR - 1; ii5++) {
		#if doubleintprecision == 1
			printf("R[%lld].i=%lld R[%lld].j=%lld R[%lld].aij=%e\n", ii5, R[ii5].i, ii5, R[ii5].j, ii5, R[ii5].aij);
		#else
			printf("R[%d].i=%d R[%d].j=%d R[%d].aij=%e\n", ii5, R[ii5].i, ii5, R[ii5].j, ii5, R[ii5].aij);
		#endif
		
		system("pause");
		}
		*/
		// где то надо разделить на ap, т.к. 
		// R=P/ap.


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);
		if (bquicktypesort) {
			QuickSort(R, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1);
				}
				else {
					qs(R, 1 + iaddR, iaddR + nnzR - 1);
				}
			}
			else {
				HeapSort(R, 1 + iaddR, iaddR + nnzR - 1);
			}
		}

#if doubleintprecision == 1
		printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
		printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
		
		if (debug_reshime) system("pause");
		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			flag[i_1] = false; // init flag.
		}

		for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
			if (flag[R[i_1].i] == false)
			{
				for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
					if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
						printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
						printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
						
						system("pause");
					}
					if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
						printf("error division by zero\n");
						system("pause");
					}
					doublerealT delitel;
					if (ap_coarse[R[i_1].i] > 1.0) {
						// internal node
						delitel = 0.5*ap_coarse[R[i_1].i];
					}
					else {
						// Dirichlet
						delitel = ap_coarse[R[i_1].i];
					}
					R[i_2].aij = R[i_2].aij / (delitel);
				}
				flag[R[i_1].i] = true;
			}
		}


		delete[] ap_coarse;


		// debug.
		//for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
#if doubleintprecision == 1
		//printf("R[%lld].i=%lld R[%lld].j=%lld R[%lld].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#else
		//printf("R[%d].i=%d R[%d].j=%d R[%d].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#endif
		
		//system("pause");
		//}


		//for (integer i_1 = iaddR + nnzR - 1-20; i_1 <= iaddR + nnzR - 1; i_1++) {
#if doubleintprecision == 1
		//printf("R[%lld].i=%lld R[%lld].j=%lld R[%lld].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#else
		//printf("R[%d].i=%d R[%d].j=%d R[%d].aij=%e\n", i_1, R[i_1].i, i_1, R[i_1].j, i_1, R[i_1].aij);
#endif
		
		//system("pause");
		//}



		//for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
#if doubleintprecision == 1
		//printf("P[%lld].i=%lld P[%lld].j=%lld P[%lld].aij=%e\n", i_1, P[i_1].i, i_1, P[i_1].j, i_1, P[i_1].aij);
#else
		//printf("P[%d].i=%d P[%d].j=%d P[%d].aij=%e\n", i_1, P[i_1].i, i_1, P[i_1].j, i_1, P[i_1].aij);
#endif
		
		//system("pause");
		//}


		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);
		if (bquicktypesort) {
			QuickSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
					else {
						qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
				}
				else {
					HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}
			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort_j(Aorig, nnz_a[ilevel - 1]);
				Aorig = NULL;
			}
		}

		// Нахождение матрицы грубосеточного уровня :
		// Acorse=R*Afine*P;
		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		/*
		integer istartAnew = nnz_a[ilevel - 1] + 1+iadd;
		for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
		// jstr - столбец матрицы А.
		// icounter-1 - число узлов на грубом уровне.
		for (integer i = 1; i <= icounter - 1; i++) {
		flag[i] = false;
		}
		// А (на первой позиции) должна быть отсортирована по j.
		integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// это справедливо только для первого уровня.
		integer istart = 1 + iaddR;
		integer iend = nnzR - 1 + iaddR;
		for (integer ii = istart; ii <= iend; ii++) {
		if (flag[R[ii].i] == false) {
		integer istr = R[ii].i;
		integer ic = ii;
		// i-coarse, j-fine
		doublerealT sum1 = 0.0;
		while ((ic <= iend) && (R[ic].i == istr)) {
		// R[R[ii].i][R[ic].j]*Amat[R[ic].j][jstr]

		for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
		// (Amat[ii2].j == jstr) {
		if (Amat[ii2].i == R[ic].j) {
		sum1 += R[ic].aij*Amat[ii2].aij;
		}
		//}
		}
		ic++;
		}
		if (fabs(sum1) > RealZERO) {
		Amat[istartAnew].aij = sum1;
		Amat[istartAnew].i = istr;
		Amat[istartAnew].j = jstr;
		if (jstr < 0) {
		printf("fatal error");
		#if doubleintprecision == 1
			printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
		#else
			printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
		#endif
		
		system("pause");
		}
		istartAnew++;
		}
		flag[R[ii].i] = true;
		}
		}
		}
		*/

		// Идея droptolerance состоит в отсечении в матрице элементов 
		// которые меньше чем одна тысячная от диагонального
		// А если диагонального элемента нет то берётся норма Чебышева строки.
		//
		//
		//

		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		//integer istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
		//for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
		// jstr - столбец матрицы А.
		// icounter-1 - число узлов на грубом уровне.
		//if ((icounter - 1 > n) || (icounter - 1 < 0)) {
		//printf("flag incorrupt 4...\n");
		//system("pause");
		//exit(1);
		//}
		//for (integer i = 1; i <= icounter - 1; i++) {
		//flag[i] = false;
		//}
		// А (на первой позиции) должна быть отсортирована по j.
		//integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// это справедливо только для первого уровня.
		//integer istart = 1 + iaddR;
		//integer iend = nnzR - 1 + iaddR;
		//for (integer ii = istart; ii <= iend; ii++) {
		//if ((R[ii].i > n) || (R[ii].i < 0)) {
		//printf("flag incorrupt 3...\n");
		//system("pause");
		//exit(1);
		//}
		//if (flag[R[ii].i] == false) {
		//integer istr = R[ii].i;
		//integer ic = ii;
		// i-coarse, j-fine
		//doublerealT sum1 = 0.0;

		// это медленная версия кода.
		//while ((ic <= iend) && (R[ic].i == istr)) {
		// R[R[ii].i][R[ic].j]*Amat[R[ic].j][jstr]

		//for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {

		//if (Amat[ii2].i == R[ic].j) {
		//sum1 += R[ic].aij*Amat[ii2].aij;
		//}

		//}
		//ic++;
		//}

		// Это более быстрый код.
		//integer ks = ic;
		//integer ls = ii1;
		//integer kf = ic;
		//bool bvis = false;
		//doublerealT retalon = 0.0;
		//while ((kf <= iend) && (R[kf].i == istr)) {
		//if (R[kf].j == istr) {
		//	retalon = fabs(R[kf].aij);
		//	bvis = true;
		//}
		//kf++;
		//}
		//kf--;

		//if (bvis == false) {
		//kf = ic;
		//while ((kf <= iend) && (R[kf].i == istr)) {
		//	if (fabs(R[kf].aij) > retalon) retalon = fabs(R[kf].aij);
		//	kf++;
		//}
		//kf--;
		//}

		//integer lf = ii1;
		//for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
		//if (fabs(Amat[ii2].aij) > retalon) retalon = fabs(Amat[ii2].aij);
		//if (Amat[ii2].i == istr) retalon *= fabs(Amat[ii2].aij);
		//lf++;
		//}
		//lf--;

		//while ((ks <= kf) && (ls <= lf)) {
		//if (Amat[ls].i < R[ks].j) {
		//	ls++;
		//}
		//else if (Amat[ls].i > R[ks].j) {
		//	ks++;
		//}
		//else {
		//	sum1 += R[ks].aij*Amat[ls].aij;
		//	ks++;
		//	ls++;
		//}
		//}




		//if (fabs(sum1) > 0.001*retalon) {
		//if (fabs(sum1)>1.0e-30) {
		//Amat[istartAnew].aij = sum1;
		//Amat[istartAnew].i = istr;
		//Amat[istartAnew].j = jstr;
		//if (jstr < 0) {
		//	printf("fatal error");
#if doubleintprecision == 1
		//	printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
#else
		//	printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
#endif
		
		//	system("pause");
		//}
		//istartAnew++;
		//}
		//flag[R[ii].i] = true;
		//}
		//}
		//}

#if doubleintprecision == 1
	printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
	printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
		

		integer istartAnew;
		integer* kf_array;

		const integer IALGORITHM_MATRIX_MULT_1 = 2;

		if (0 == IALGORITHM_MATRIX_MULT_1) {

			// Самая быстрая версия на основе слияния упорядоченных массивов.

			//Более быстрый вариант алгоритма.
			// Быстрее этого кода на основе идеи слияния списков уже не будет.
			// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
			// часть 1 : R*Afine.
			//         xxxxxx
			//         xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//         xxxxxx
			//         xxxxxx
			//    R       Amat     [RA]
			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart1 = 1 + iaddR;
			integer iend1 = nnzR - 1 + iaddR;
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			for (integer ii = istart1; ii <= iend1; ii++) {
				if (flag[R[ii].i] == false) {
					integer istr = R[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend1) && (R[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[R[ii].i] = true;
				}
			}

			integer *start_position_i_string_in_R = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart3 = 1 + iaddR;
			integer iend3 = nnzR - 1 + iaddR;
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[R[ii].i] == false) {
					start_position_i_string_in_R[R[ii].i] = ii;
					flag[R[ii].i] = true;
				}
			}


			istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
			for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
				// jstr - столбец матрицы А.
				// icounter-1 - число узлов на грубом уровне.
				//if ((icounter - 1 > n) || (icounter - 1 < 0)) {
				//printf("flag incorrupt 4...\n");
				//system("pause");
				//exit(1);
				//}
				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				// А (на первой позиции) должна быть отсортирована по j.
				integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
					lf++;
				}
				lf--;

				// это справедливо  для любого  уровня.
				//integer istart = 1 + iaddR;
				//integer iend = nnzR - 1 + iaddR;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[R[ii].i] == false) {
				// Внимание не забыть или открыть флаг.
				//flag[R[ii].i] = true;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {
					//integer istr = R[ii].i;
					//integer ic = ii;

					integer istr = i_2;
					integer ic = start_position_i_string_in_R[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;

					// это медленная версия кода.
					//while ((ic <= iend) && (R[ic].i == istr)) {
					// R[R[ii].i][R[ic].j]*Amat[R[ic].j][jstr]

					//for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {

					//if (Amat[ii2].i == R[ic].j) {
					//sum1 += R[ic].aij*Amat[ii2].aij;
					//}

					//}
					//ic++;
					//}

					// Это более быстрый код.
					integer ks = ic;

					//integer kf = ic;

					//while ((kf <= iend) && (R[kf].i == istr)) {
					//kf++;
					//}
					//kf--;

					integer kf = kf_array[istr];

					integer ls = ii1;



					while ((ks <= kf) && (ls <= lf)) {

						if (Amat[ls].i < R[ks].j) {
							ls++;
						}
						else if (Amat[ls].i > R[ks].j) {
							ks++;
						}
						else /*if (Amat[ls].i == R[ks].j)*/ {
							sum1 += R[ks].aij*Amat[ls].aij;
							ks++;
							ls++;
						}

					}




					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew].aij = sum1;
						Amat[istartAnew].i = istr;
						Amat[istartAnew].j = jstr;
						if (jstr < 0) {
							printf("fatal error");
#if doubleintprecision == 1
							printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
#else
							printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
#endif
							
							system("pause");
						}
						istartAnew++;
					}

					//}
				}
			}


			delete[] kf_array;
			delete[] start_position_i_string_in_R;

		}
		else if (1 == IALGORITHM_MATRIX_MULT_1) {

			// Идея Писсанецки.

			//Более быстрый вариант алгоритма.
			// Быстрее этого кода на основе идеи слияния списков уже не будет.
			// 22 октября 2015. Нужно двигаться в сторону Писсанецки.
			// часть 1 : R*Afine.
			//         xxxxxx
			//         xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//  xxxxxx xxxxxx xxxxxx
			//         xxxxxx
			//         xxxxxx
			//    R       Amat     [RA]
			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart1 = 1 + iaddR;
			integer iend1 = nnzR - 1 + iaddR;
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			for (integer ii = istart1; ii <= iend1; ii++) {
				if (flag[R[ii].i] == false) {
					integer istr = R[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend1) && (R[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[R[ii].i] = true;
				}
			}

			integer *start_position_i_string_in_R = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart3 = 1 + iaddR;
			integer iend3 = nnzR - 1 + iaddR;
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[R[ii].i] == false) {
					start_position_i_string_in_R[R[ii].i] = ii;
					flag[R[ii].i] = true;
				}
			}

			integer* ind = new integer[n_a[ilevel - 1] + 1];


			istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
			for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
				// jstr - столбец матрицы А.
				// icounter-1 - число узлов на грубом уровне.
				//if ((icounter - 1 > n) || (icounter - 1 < 0)) {
				//printf("flag incorrupt 4...\n");
				//system("pause");
				//exit(1);
				//}

				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					ind[i] = -1; // инициализация.
				}

				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				// А (на первой позиции) должна быть отсортирована по j.
				integer ii1 = BinarySearchAj(Amat, jstr, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				//integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1] + iadd) && (Amat[ii2].j == jstr); ii2++) {
					ind[Amat[ii2].i] = ii2; // запоминание индекса.
										 //lf++;
				}
				//lf--;

				// это справедливо  для любого  уровня.
				//integer istart = 1 + iaddR;
				//integer iend = nnzR - 1 + iaddR;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[R[ii].i] == false) {
				// Внимание не забыть или открыть флаг.
				//flag[R[ii].i] = true;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {
					//integer istr = R[ii].i;
					//integer ic = ii;

					integer istr = i_2;
					integer ic = start_position_i_string_in_R[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;



					// Это более быстрый код.
					integer ks = ic;


					integer kf = kf_array[istr];

					//integer ls = ii1;


					while (ks <= kf) {
						if (ind[R[ks].j] != -1) {
							sum1 += R[ks].aij*Amat[ind[R[ks].j]].aij;
						}
						ks++;
					}

					/*
					while ((ks <= kf) && (ls <= lf)) {

					if (Amat[ls].i < R[ks].j) {
					ls++;
					}
					else if (Amat[ls].i > R[ks].j) {
					ks++;
					}
					else {
					sum1 += R[ks].aij*Amat[ls].aij;
					ks++;
					ls++;
					}

					}
					*/



					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew].aij = sum1;
						Amat[istartAnew].i = istr;
						Amat[istartAnew].j = jstr;
						if (jstr < 0) {
							printf("fatal error");
#if doubleintprecision == 1
							printf("i=%lld j=%lld aij=%e\n", istr, jstr, sum1);
#else
							printf("i=%d j=%d aij=%e\n", istr, jstr, sum1);
#endif
							
							system("pause");
						}
						istartAnew++;
					}

					//}
				}
			}


			delete[] kf_array;
			delete[] start_position_i_string_in_R;
			delete[] ind;
		}
		else {

			if (0) {

				// Фред Густавсон IBM 1978.
				// 23 октября 2015 года.

				// часть 1 : R*Afine.
				//         xxxxxx
				//         xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//         xxxxxx
				//         xxxxxx
				//    R       Amat     [RA]
				// Сортировка А по строкам.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
				}
				else {
					HeapSort(Amat, /*n_a[ilevel - 1],*/ 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}

				// Преобразование к формату CRS.

				integer* row_ind_SR = new integer[numberofcoarcenodes + 1];
				integer* row_ind_ER = new integer[numberofcoarcenodes + 1];
				for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					row_ind_SR[i_1] = -1;
					row_ind_ER[i_1] = -2;
				}
				integer istart1 = 1 + iaddR;
				integer iend1 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				for (integer ii = istart1; ii <= iend1; ii++) {
					if (flag[R[ii].i] == false) {
						integer istr = R[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend1) && (R[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SR[istr] = ic;
						row_ind_ER[istr] = kf;
						flag[R[ii].i] = true;
					}
				}

				// Пустые строки просто отсутствуют.
				//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
				//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
				//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
				
				//}
				//}

				integer* row_ind_SA = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_EA = new integer[n_a[ilevel - 1] + 1];
				integer istart3 = 1 + iadd;
				integer iend3 = nnz_a[ilevel - 1] + iadd;
				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					flag[i] = false;
				}
				for (integer ii = istart3; ii <= iend3; ii++) {
					if (flag[Amat[ii].i] == false) {
						integer istr = Amat[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend3) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SA[istr] = ic;
						row_ind_EA[istr] = kf;
						flag[Amat[ii].i] = true;
					}
				}

				istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

				// Данные используемые для частичного формирователя суммы.
				doublerealT* vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
				//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
				//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);

				// Сканируем первый операнд построчно.
				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Начинаем обрабатывать новую строку.
					// Сброс формирователя суммы в ноль.
					//#pragma omp parallel for
					for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
						vector_sum[i_2] = 0.0; // инициализация // 18.5
											   //b_visit_vec_sum[i_2] = false;
					}
					// Более быстрое обнуление
					// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
					//memset(vector_sum, 0,size_v );

					// Сканируем текущую i-ую строку поэлементно
					for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
						integer col_ind = R[ii].j;
						// Сканируем col_ind строку второго операнда

						for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
							doublerealT left_operand = R[ii].aij;
							doublerealT right_operand = Amat[i_1].aij;
							vector_sum[Amat[i_1].j] += left_operand*right_operand;
							//b_visit_vec_sum[Amat[i_1].j] = true;
						}
					}

					for (integer jstr = 1; jstr <= n_a[ilevel - 1]; jstr++) {
						// сначала быстрая проверка 
						//if (b_visit_vec_sum[jstr]) {
						// а потом медленная.
						if (fabs(vector_sum[jstr]) > 1.0e-30) { // 36.3
							Amat[istartAnew].aij = vector_sum[jstr];
							Amat[istartAnew].i = istr;
							Amat[istartAnew].j = jstr;
							istartAnew++;
						}
						//}
					}
				}

				delete[] row_ind_SR;
				delete[] row_ind_ER;
				delete[] row_ind_SA;
				delete[] row_ind_EA;
				delete[] vector_sum;
				//delete[] b_visit_vec_sum;

			}
			else {
				// Фред Густавсон IBM 1978.
				// 23 октября 2015 года.

				// часть 1 : R*Afine.
				//         xxxxxx
				//         xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//  xxxxxx xxxxxx xxxxxx
				//         xxxxxx
				//         xxxxxx
				//    R       Amat     [RA]
				// Сортировка А по строкам.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
				}
				else {
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}

				// Преобразование к формату CRS.

				integer* row_ind_SR = new integer[numberofcoarcenodes + 1];
				integer* row_ind_ER = new integer[numberofcoarcenodes + 1];
				for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					row_ind_SR[i_1] = -1;
					row_ind_ER[i_1] = -2;
				}
				integer istart1 = 1 + iaddR;
				integer iend1 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= icounter - 1; i++) {
					flag[i] = false;
				}
				for (integer ii = istart1; ii <= iend1; ii++) {
					if (flag[R[ii].i] == false) {
						integer istr = R[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend1) && (R[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SR[istr] = ic;
						row_ind_ER[istr] = kf;
						flag[R[ii].i] = true;
					}
				}

				// Пустые строки просто отсутствуют.
				//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
				//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
				//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
				
				//}
				//}

				integer* row_ind_SA = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_EA = new integer[n_a[ilevel - 1] + 1];
				integer istart3 = 1 + iadd;
				integer iend3 = nnz_a[ilevel - 1] + iadd;
				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					flag[i] = false;
				}
				for (integer ii = istart3; ii <= iend3; ii++) {
					if (flag[Amat[ii].i] == false) {
						integer istr = Amat[ii].i;
						integer ic = ii;
						integer kf = ic;

						while ((kf <= iend3) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_SA[istr] = ic;
						row_ind_EA[istr] = kf;
						flag[Amat[ii].i] = true;
					}
				}

				istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

				// Данные используемые для частичного формирователя суммы.
				doublerealT* vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
				//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
				//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
				// Храним индексы ненулевых элементов в отсортированном порядке.
				integer* index_visit = new integer[n_a[ilevel - 1] + 1];
				integer index_size = 0;

				// Сканируем первый операнд построчно.
				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Начинаем обрабатывать новую строку.
					// Сброс формирователя суммы в ноль.
					//#pragma omp parallel for
					//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
					//vector_sum[i_2] = 0.0; // инициализация // 18.5
					//b_visit_vec_sum[i_2] = false;
					//}
					// Более быстрое обнуление
					// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
					//memset(vector_sum, 0,size_v );

					// Сканируем текущую i-ую строку поэлементно
					for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
						integer col_ind = R[ii].j;
						// Сканируем col_ind строку второго операнда

						for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
							doublerealT left_operand = R[ii].aij;
							doublerealT right_operand = Amat[i_1].aij;
							integer iaddind = Amat[i_1].j;
							bool foundnow = false;
							integer ifoundind = -1;
							// линейный поиск позиции в массиве на добавление.
							for (integer i_6 = 1; i_6 <= index_size; i_6++) {
								if (index_visit[i_6] == iaddind) {
									foundnow = true;
									ifoundind = i_6;
									break;
								}
							}
							if (foundnow) {
								vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							}
							else {
								// Первое добавление.
								index_size++;
								index_visit[index_size] = iaddind;
								ifoundind = index_size;
								vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							}

							//vector_sum[Amat[i_1].j] += left_operand*right_operand;
							//b_visit_vec_sum[Amat[i_1].j] = true;
						}
					}

					// 5 декабря 2015 Избирательность приводящая к сохранению разреженности.
					/*
					doublerealT threshhold_maxelem_in_string = -1.0;
					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					if (jstr != istr) {
					if (fabs(vector_sum[jstr]) > threshhold_maxelem_in_string) {
					threshhold_maxelem_in_string = fabs(vector_sum[jstr]);
					}
					}
					}
					*/

					// 5 декабря 2015 
					// магический параметр отсечения mul_theta приводящий к сохранению разреженности оператора 
					// Галёркина а значит ускорению времени счёта.
					// Требуется определить оптимальное значение этого параметра.
					//doublerealT mul_theta = 0.111;
					//switch (dim_2D) {
					//case 0: // 3D
					//mul_theta = mul_theta3D;  // 0.13;
					//break;
					//case 1: // 2D
					//mul_theta = 0.008;
					//break;
					//};


					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						integer jstr = index_visit[i_6];
						if (istr != jstr) {
							// 5 декабря 2015. threshold.
							if (fabs(vector_sum[jstr]) > 1.0e-30) {
								//if (fabs(vector_sum[jstr]) > mul_theta*theta*threshhold_maxelem_in_string) {
								Amat[istartAnew].aij = vector_sum[jstr];
								Amat[istartAnew].i = istr;
								Amat[istartAnew].j = jstr;
								istartAnew++;
							}
						}
						else {
							// диагональный элемент записываем обязательно.
							Amat[istartAnew].aij = vector_sum[jstr];
							Amat[istartAnew].i = istr;
							Amat[istartAnew].j = jstr;
							istartAnew++;
						}
					}
					index_size = 0;


				}
				delete[] index_visit;
				delete[] row_ind_SR;
				delete[] row_ind_ER;
				delete[] row_ind_SA;
				delete[] row_ind_EA;
				delete[] vector_sum;
			}

		}

		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		if (bquicktypesort) {
			QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
					else {
						qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					}
				}
				else
				{
					HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}
			}
			else {
				Ak* Aorig = &Amat[1 + iadd];
				MergeSort(Aorig, nnz_a[ilevel - 1]);
				Aorig = NULL;
			}
		}

		// Проверка пройдена успешно.
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			if (Amat[i_1].j < 0) {
				printf("error : negativ j index\n");
				system("pause");
			}
#if doubleintprecision == 1
			//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);
		if (bquicktypesort) {
			QuickSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		else {
			if (nnz_a[ilevel - 1] < heapsortsizelimit) {
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
					}
					else {
						qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
					}
				}
				else {
					HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
				}
			}
			else {
				Ak* Aorig = &Amat[nnz_a[ilevel - 1] + 1 + iadd];
				MergeSort(Aorig, istartAnew - 1 - (nnz_a[ilevel - 1] + 1 + iadd) + 1);
				Aorig = NULL;
			}
		}


		// Проверка пройдена успешно.
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			if (Amat[i_1].j < 0) {
				printf("error : negativ j index\n");
				system("pause");
			}
#if doubleintprecision == 1
			//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		}

		// Самый медленный в мире BubbleSort.
		// нужен для проверки более быстрых алгоритмов сортировки.
		//integer k3 = 0;
		//for (integer k1 = nnz_a[ilevel - 1] + 1 + iadd; k1 < istartAnew - 1; k1++,k3++) {
		//for (integer k2 = nnz_a[ilevel - 1] + 1 + iadd; k2 < istartAnew - 1 - k3; k2++) {
		//if (Amat[k2].i>Amat[k2 + 1].i) {
		// change
		//Ak Temp = Amat[k2];
		//	Amat[k2] = Amat[k2 + 1];
		//Amat[k2 + 1] = Temp;
		//}
		//else if (Amat[k2].i == Amat[k2 + 1].i) {
		//if (Amat[k2].j>Amat[k2 + 1].j) {
		// change
		//Ak Temp = Amat[k2];
		//Amat[k2] = Amat[k2 + 1];
		//Amat[k2 + 1] = Temp;
		//}
		//}
		//}
		//}

		// Контроль [R*A] debug
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}

		if (bquicktypesort) {
			QuickSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
				}
				else {
					qs(P, 1 + iaddR, iaddR + nnzR - 1);
				}
			}
			else {
				HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}

		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;

		/*
		// icounter - 1; // Количество узлов на грубосеточном уровне.
		for (integer i = 1; i <= n_coarce; i++) {
		flag[i] = false;
		}
		// P должен быть упорядочен по строкам.
		// проверка диагонали в P
		for (integer ii77 = 1; ii77 <= nnzR; ii77++) {
		#if doubleintprecision == 1
			printf("i=%lld j=%lld %e\n",P[ii77].i,P[ii77].j,P[ii77].aij);
		#else
			printf("i=%d j=%d %e\n",P[ii77].i,P[ii77].j,P[ii77].aij);
		#endif
		
		getchar();
		}
		*/

		//begin medlennji
		/*
		// сканируем по столбцам
		for (integer jstr = 1; jstr <= icounter-1; jstr++) {
		for (integer i = 1; i <= n_coarce; i++) {
		flag[i] = false;
		}
		//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
		// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
		integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);
		// это справедливо только для первого уровня.
		integer istart = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend = istartAnew - 1;
		for (integer ii = istart; ii <= iend; ii++) {
		if (flag[Amat[ii].i] == false) {
		// сканируем построчно.
		integer istr = Amat[ii].i;
		integer ic = ii;
		// i-coarse, j-fine
		doublerealT sum1 = 0.0;
		while ((ic <= iend) && (Amat[ic].i == istr)) {
		// [R*A][Amat[ii].i][Amat[ic].j]*P[Amat[ic].j][jstr]
		// у матрицы P всё перепутано с точностью до транспонирования.
		// [R*A][Amat[ii].i][Amat[ic].j]*P[jstr][Amat[ic].j]
		for (integer ii2 = ii1; (ii2 <= nnzR- 1+iaddR) && (P[ii2].i == jstr); ii2++) {

		if (P[ii2].j == Amat[ic].j) {
		sum1 += Amat[ic].aij*P[ii2].aij;
		#if doubleintprecision == 1
			//printf("%e i=%lld j=%lld k=%lld\n", Amat[ic].aij*P[ii2].aij,istr,P[ii2].j,jstr);
		#else
			//printf("%e i=%d j=%d k=%d\n", Amat[ic].aij*P[ii2].aij,istr,P[ii2].j,jstr);
		#endif
		
		//getchar();
		}
		}

		ic++;
		}

		if (fabs(sum1) > RealZERO) {
		Amat[istartAnew2].aij = sum1;
		Amat[istartAnew2].i = istr;
		Amat[istartAnew2].j = jstr;
		istartAnew2++;
		}
		flag[Amat[ii].i] = true;
		}
		}
		}
		*/




		// сканируем по столбцам
		//for (integer jstr = 1; jstr <= icounter - 1; jstr++) {

		//for (integer i = 1; i <= n; i++) {
		//flag[i] = false;
		//}
		//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
		// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
		//integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);
		// это справедливо только для первого уровня.
		//integer istart = nnz_a[ilevel - 1] + 1 + iadd;
		//integer iend = istartAnew - 1;
		//for (integer ii = istart; ii <= iend; ii++) {
		//if ((Amat[ii].i > n)||(Amat[ii].i<0)) {
		//printf("flag incorrupt 1...\n");
		//system("pause");
		//exit(1);
		//}
		//if (flag[Amat[ii].i] == false) {
		// сканируем построчно.
		//integer istr = Amat[ii].i;
		//integer ic = ii;
		// i-coarse, j-fine
		//	doublerealT sum1 = 0.0;

		// Заменим медленный двойной цикл на слияние.
		//while ((ic <= iend) && (Amat[ic].i == istr)) {
		// [R*A][Amat[ii].i][Amat[ic].j]*P[Amat[ic].j][jstr]
		// у матрицы P всё перепутано с точностью до транспонирования.
		// [R*A][Amat[ii].i][Amat[ic].j]*P[jstr][Amat[ic].j]
		//for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {

		//	if (P[ii2].j == Amat[ic].j) {
		//sum1 += Amat[ic].aij*P[ii2].aij;
		//	}
		//}

		//ic++;
		//}

		// Более быстрый код на основе слияния.
		//integer ks = ic;
		//integer ls = ii1;
		//integer kf = ic;
		//doublerealT retalon = 0.0;
		//bool bvis = false;
		//while ((kf <= iend) && (Amat[kf].i == istr)) {
		//if (fabs(Amat[kf].aij) > retalon) retalon = fabs(Amat[kf].aij);
		//if (Amat[kf].j == istr) {
		//	retalon = fabs(Amat[kf].aij);
		//	bvis = true;
		//}
		///kf++;
		//}
		//kf--;
		//if (bvis == false) {
		//kf = ic;
		//while ((kf <= iend) && (Amat[kf].i == istr)) {
		//	if (fabs(Amat[kf].aij) > retalon) retalon = fabs(Amat[kf].aij);
		//	kf++;
		//}
		//kf--;
		//}
		//integer lf = ii1;
		//for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {
		//if (P[ii2].j == istr) retalon *= fabs(P[ii2].aij); // это диагональный элемент.
		//lf++;
		//}
		//lf--;
		//while ((ks <= kf) && (ls <= lf)) {
		//if (P[ls].j<Amat[ks].j) {
		//	ls++;
		//}
		//else if (P[ls].j > Amat[ks].j) {
		//	ks++;
		//}
		//else {
		//	sum1 += Amat[ks].aij*P[ls].aij;
		//	ks++;
		//	ls++;
		//}
		//}
		//if (fabs(retalon) < 1.0e-30) {
#if doubleintprecision == 1
		//printf("RAP retalon=%e string %lld is zero\n",retalon,istr);
#else
		//printf("RAP retalon=%e string %d is zero\n",retalon,istr);
#endif
		
		//getchar();
		//}

		//---//if (fabs(sum1) > 0.001*retalon) {
		//if (fabs(sum1)>1.0e-30) {
		//Amat[istartAnew2].aij = sum1;
		//Amat[istartAnew2].i = istr;
		//Amat[istartAnew2].j = jstr;
		//istartAnew2++;
		//}
		//flag[Amat[ii].i] = true;
		//}
		//}
		//}

		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
#if doubleintprecision == 1
		printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
		printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
		
		const integer IALGORITHM_MATRIX_MULT_2 = 2;

		if (0 == IALGORITHM_MATRIX_MULT_2) {

			// Код на основе слияния упорядоченных массивов.

			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend2 = istartAnew - 1;
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			for (integer ii = istart2; ii <= iend2; ii++) {
				if (flag[Amat[ii].i] == false) {
					// сканируем построчно.
					integer istr = Amat[ii].i;
					integer ic = ii;

					integer kf = ic;

					while ((kf <= iend2) && (Amat[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[Amat[ii].i] = true;

				}
			}

			// Количество строк в матрице А есть точно numberofcoarcenodes
			integer *start_position_i_string_in_RA = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart4 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend4 = istartAnew - 1;
			for (integer ii = istart4; ii <= iend4; ii++) {
				if (flag[Amat[ii].i] == false) {
					start_position_i_string_in_RA[Amat[ii].i] = ii;
					flag[Amat[ii].i] = true;
				}
			}


			// Более быстрая версия кода : 15 октября 2015
			// сканируем по столбцам
			for (integer jstr = 1; jstr <= icounter - 1; jstr++) {

				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
				// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
				integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);

				integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {
					lf++;
				}
				lf--;

				// это справедливо только для первого уровня.
				//integer istart = nnz_a[ilevel - 1] + 1 + iadd;
				//integer iend = istartAnew - 1;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[Amat[ii].i] == false) {
				// Ни в коем случае не забываем модифицировать флаг.
				//flag[Amat[ii].i] = true;
				// сканируем построчно.
				//integer istr = Amat[ii].i;
				//integer ic = ii;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {

					integer istr = i_2;
					integer ic = start_position_i_string_in_RA[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;

					// Заменим медленный двойной цикл на слияние.
					//while ((ic <= iend) && (Amat[ic].i == istr)) {
					// [R*A][Amat[ii].i][Amat[ic].j]*P[Amat[ic].j][jstr]
					// у матрицы P всё перепутано с точностью до транспонирования.
					// [R*A][Amat[ii].i][Amat[ic].j]*P[jstr][Amat[ic].j]
					//for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {

					//	if (P[ii2].j == Amat[ic].j) {
					//sum1 += Amat[ic].aij*P[ii2].aij;
					//	}
					//}

					//ic++;
					//}

					// Более быстрый код на основе слияния.
					integer ks = ic;

					//integer kf = ic;

					//while ((kf <= iend) && (Amat[kf].i == istr)) {
					//kf++;
					//}
					//kf--;
					integer kf = kf_array[istr];

					integer ls = ii1;

					while ((ks <= kf) && (ls <= lf)) {

						if (P[ls].j < Amat[ks].j) {
							ls++;
						}
						else if (P[ls].j > Amat[ks].j) {
							ks++;
						}
						else /*if (P[ls].j==Amat[ks].j)*/ {
							sum1 += Amat[ks].aij*P[ls].aij;
							ks++;
							ls++;
						}

					}

					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew2].aij = sum1;
						Amat[istartAnew2].i = istr;
						Amat[istartAnew2].j = jstr;
						istartAnew2++;
					}

					//}
				}
			}

			delete[] kf_array;
			delete[] start_position_i_string_in_RA;

		}
		else if (1 == IALGORITHM_MATRIX_MULT_2) {
			// Идея Писсанецки 22 октября 2015.

			kf_array = new integer[numberofcoarcenodes + 1];
			integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend2 = istartAnew - 1;
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			for (integer ii = istart2; ii <= iend2; ii++) {
				if (flag[Amat[ii].i] == false) {
					// сканируем построчно.
					integer istr = Amat[ii].i;
					integer ic = ii;

					integer kf = ic;

					while ((kf <= iend2) && (Amat[kf].i == istr)) {
						kf++;
					}
					kf--;
					kf_array[istr] = kf;
					flag[Amat[ii].i] = true;

				}
			}

			// Количество строк в матрице А есть точно numberofcoarcenodes
			integer *start_position_i_string_in_RA = new integer[numberofcoarcenodes + 1];
			for (integer i = 1; i <= icounter - 1; i++) {
				flag[i] = false;
			}
			integer istart4 = nnz_a[ilevel - 1] + 1 + iadd;
			integer iend4 = istartAnew - 1;
			for (integer ii = istart4; ii <= iend4; ii++) {
				if (flag[Amat[ii].i] == false) {
					start_position_i_string_in_RA[Amat[ii].i] = ii;
					flag[Amat[ii].i] = true;
				}
			}

			integer *ind = new integer[n_a[ilevel - 1] + 1];


			// Более быстрая версия кода : 15 октября 2015
			// сканируем по столбцам
			for (integer jstr = 1; jstr <= icounter - 1; jstr++) {

				for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
					ind[i] = -1; // инициализация.
				}

				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				//integer ii1 = BinarySearchAj(P, jstr, 1+iaddR, nnzR - 1+iaddR);
				// Дело в том что у матрицы P всё хранится в перепутанном (с точностью до транспонирования виде).
				integer ii1 = BinarySearchAi(P, jstr, 1 + iaddR, nnzR - 1 + iaddR);

				//integer lf = ii1;
				for (integer ii2 = ii1; (ii2 <= nnzR - 1 + iaddR) && (P[ii2].i == jstr); ii2++) {
					ind[P[ii2].j] = ii2;
					//lf++;
				}
				//lf--;

				// это справедливо только для первого уровня.
				//integer istart = nnz_a[ilevel - 1] + 1 + iadd;
				//integer iend = istartAnew - 1;
				//for (integer ii = istart; ii <= iend; ii++) {

				//if (flag[Amat[ii].i] == false) {
				// Ни в коем случае не забываем модифицировать флаг.
				//flag[Amat[ii].i] = true;
				// сканируем построчно.
				//integer istr = Amat[ii].i;
				//integer ic = ii;

				for (integer i_2 = 1; i_2 <= numberofcoarcenodes; i_2++) {

					integer istr = i_2;
					integer ic = start_position_i_string_in_RA[i_2];

					// i-coarse, j-fine
					doublerealT sum1 = 0.0;



					// Более быстрый код на основе слияния.
					integer ks = ic;


					integer kf = kf_array[istr];

					//integer ls = ii1;

					while (ks <= kf) {
						if (ind[Amat[ks].j] != -1) {
							sum1 += Amat[ks].aij*P[ind[Amat[ks].j]].aij;
						}
						ks++;
					}

					//while ((ks <= kf) && (ls <= lf)) {

					//if (P[ls].j < Amat[ks].j) {
					//ls++;
					//}
					//else if (P[ls].j > Amat[ks].j) {
					//ks++;
					//}
					//else /*if (P[ls].j==Amat[ks].j)*/ {
					//sum1 += Amat[ks].aij*P[ls].aij;
					//ks++;
					//ls++;
					//}

					//}

					if (fabs(sum1) > 1.0e-30) {
						Amat[istartAnew2].aij = sum1;
						Amat[istartAnew2].i = istr;
						Amat[istartAnew2].j = jstr;
						istartAnew2++;
					}

					//}
				}
			}

			delete[] kf_array;
			delete[] start_position_i_string_in_RA;
			delete[] ind;

		}
		else {
			// Фред Густавсон IBM 1978
			// В ядре кода Густавсона нету ни одного ветвления,
			// а мы знаем что в результате профайлинга предыдущих версий кода :
			// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
			// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно сумирование.
			// 23 октября 2015 года.

			if (0) {
				// Преобразование обоих матриц в формат CRS.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
					}
					else {
						qsj(P, 1 + iaddR, iaddR + nnzR - 1);
					}
				}
				else {
					HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
				}

				integer* row_ind_AS = new integer[numberofcoarcenodes + 1];
				integer* row_ind_AE = new integer[numberofcoarcenodes + 1];
				integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
				integer iend2 = istartAnew - 1;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart2; ii <= iend2; ii++) {
					if (flag[Amat[ii].i] == false) {
						// сканируем построчно.
						integer istr = Amat[ii].i;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend2) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_AS[istr] = ic;
						row_ind_AE[istr] = kf;
						flag[Amat[ii].i] = true;

					}
				}

				integer* row_ind_PS = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_PE = new integer[n_a[ilevel - 1] + 1];
				// Инициализация чрезвычайно важна, т.к. 
				// обязательно присутствуют пустые строки которые
				// надо корректно обрабатывать.
				for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
					row_ind_PS[ii] = -1; // инициализация.
					row_ind_PE[ii] = -2;
				}
				integer istart4 = 1 + iaddR;
				integer iend4 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart4; ii <= iend4; ii++) {
					if (flag[P[ii].j] == false) {
						// сканируем построчно.
						integer istr = P[ii].j;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend4) && (P[kf].j == istr)) {
							kf++;
						}
						kf--;
						row_ind_PS[istr] = ic;
						row_ind_PE[istr] = kf;
						flag[P[ii].j] = true;

					}
				}

				// Данный код подтверждает что обязательно присутствуют
				// пустые строки.
				//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
				//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
				//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
				//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
				
				//getchar();
				//}
				//}

				// Накопитель результата.
				doublerealT* vector_sum = new doublerealT[numberofcoarcenodes + 1];
				//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);

				// Мы будем сканировать левый операнд построчно, а
				// после окончания обработки одной строки левого операнда
				// получать готовую строку результата.

				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Переход к новой строке, сброс накопителя результата.
					//#pragma omp parallel for
					for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
						vector_sum[i_1] = 0.0; // обнуление.
					}
					// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
					// но там возникает системный вызов на который тратиться столько же времени что и раньше.
					// работа перекочевала из одного места в другое.
					// Более быстрое обнуление.
					//memset(vector_sum, 0, size_v);

					// сканируем все элементы строки левого операнда.
					for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
						integer col_ind = Amat[ii1].j;

						// Сканируем col_ind строку правого операнда накапливая сумму.
						for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
							doublerealT rleft = Amat[ii1].aij;
							doublerealT rright = P[ii2].aij;

							vector_sum[P[ii2].i] += rleft*rright;
						}
					}

					for (integer jstr = 1; jstr <= numberofcoarcenodes; jstr++) {
						if (fabs(vector_sum[jstr]) > 1.0e-30) {
							Amat[istartAnew2].aij = vector_sum[jstr];
							Amat[istartAnew2].i = istr;
							Amat[istartAnew2].j = jstr;
							istartAnew2++;
						}
					}

				}

				delete[] vector_sum;



				delete[] row_ind_AS;
				delete[] row_ind_AE;
				delete[] row_ind_PS;
				delete[] row_ind_PE;
			}
			else {

				// Рабочая версия алгоритма Фреда Густавсона.
				// IBM 1978 Sparse Matrix multiplication.

				// Преобразование обоих матриц в формат CRS.
				if (bqs) {
					if (bCounting_Sort) {
						Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
					}
					else {
						qsj(P, 1 + iaddR, iaddR + nnzR - 1);
					}
				}
				else {
					HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
				}

				integer* row_ind_AS = new integer[numberofcoarcenodes + 1];
				integer* row_ind_AE = new integer[numberofcoarcenodes + 1];
				integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
				integer iend2 = istartAnew - 1;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart2; ii <= iend2; ii++) {
					if (flag[Amat[ii].i] == false) {
						// сканируем построчно.
						integer istr = Amat[ii].i;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend2) && (Amat[kf].i == istr)) {
							kf++;
						}
						kf--;
						row_ind_AS[istr] = ic;
						row_ind_AE[istr] = kf;
						flag[Amat[ii].i] = true;

					}
				}

				integer* row_ind_PS = new integer[n_a[ilevel - 1] + 1];
				integer* row_ind_PE = new integer[n_a[ilevel - 1] + 1];
				// Инициализация чрезвычайно важна, т.к. 
				// обязательно присутствуют пустые строки которые
				// надо корректно обрабатывать.
				for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
					row_ind_PS[ii] = -1; // инициализация.
					row_ind_PE[ii] = -2;
				}
				integer istart4 = 1 + iaddR;
				integer iend4 = nnzR - 1 + iaddR;
				for (integer i = 1; i <= n; i++) {
					flag[i] = false;
				}
				for (integer ii = istart4; ii <= iend4; ii++) {
					if (flag[P[ii].j] == false) {
						// сканируем построчно.
						integer istr = P[ii].j;
						integer ic = ii;

						integer kf = ic;

						while ((kf <= iend4) && (P[kf].j == istr)) {
							kf++;
						}
						kf--;
						row_ind_PS[istr] = ic;
						row_ind_PE[istr] = kf;
						flag[P[ii].j] = true;

					}
				}

				// Данный код подтверждает что обязательно присутствуют
				// пустые строки.
				//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
				//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
				//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
				//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
				
				//getchar();
				//}
				//}

				// Накопитель результата.
				doublerealT* vector_sum = new doublerealT[numberofcoarcenodes + 1];
				//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
				// Храним индексы ненулевых элементов в отсортированном порядке.
				integer* index_visit = new integer[n_a[ilevel - 1] + 1];
				integer index_size = 0;

				// Мы будем сканировать левый операнд построчно, а
				// после окончания обработки одной строки левого операнда
				// получать готовую строку результата.

				for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

					// Переход к новой строке, сброс накопителя результата.
					//#pragma omp parallel for
					//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					//vector_sum[i_1] = 0.0; // обнуление.
					//}
					// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
					// но там возникает системный вызов на который тратиться столько же времени что и раньше.
					// работа перекочевала из одного места в другое.
					// Более быстрое обнуление.
					//memset(vector_sum, 0, size_v);

					// сканируем все элементы строки левого операнда.
					for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
						integer col_ind = Amat[ii1].j;

						// Сканируем col_ind строку правого операнда накапливая сумму.
						for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
							doublerealT left_operand = Amat[ii1].aij;
							doublerealT right_operand = P[ii2].aij;

							integer iaddind = P[ii2].i;
							bool foundnow = false;
							integer ifoundind = -1;
							// линейный поиск позиции в массиве на добавление.
							for (integer i_6 = 1; i_6 <= index_size; i_6++) {
								if (index_visit[i_6] == iaddind) {
									foundnow = true;
									ifoundind = i_6;
									break;
								}
							}
							if (foundnow) {
								vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							}
							else {
								// Первое добавление.
								index_size++;
								index_visit[index_size] = iaddind;
								ifoundind = index_size;
								vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							}



							//vector_sum[P[ii2].i] += rleft*rright;
						}
					}

					// 5 декабря 2015 Избирательность приводящая к сохранению разреженности.
					/*
					doublerealT threshhold_maxelem_in_string = -1.0;
					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					if (jstr != istr) {
					if (fabs(vector_sum[jstr]) > threshhold_maxelem_in_string) {
					threshhold_maxelem_in_string = fabs(vector_sum[jstr]);
					}
					}
					}
					*/

					//doublerealT mul_theta = 0.008;
					//switch (dim_2D) {
					//case 0: // 3D
					//mul_theta = mul_theta3D;// 0.13;
					//break;
					//case 1: // 2D
					//mul_theta = 0.008;
					//break;
					//};

					for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						integer jstr = index_visit[i_6];
						if (istr != jstr) {
							// 5 декабря 2015 года. Сохранение разреженности.
							if (fabs(vector_sum[jstr]) > 1.0e-30) {
								//if (fabs(vector_sum[jstr]) > mul_theta*theta*threshhold_maxelem_in_string) {
								Amat[istartAnew2].aij = vector_sum[jstr];
								Amat[istartAnew2].i = istr;
								Amat[istartAnew2].j = jstr;
								istartAnew2++;
							}
						}
						else {
							Amat[istartAnew2].aij = vector_sum[jstr];
							Amat[istartAnew2].i = istr;
							Amat[istartAnew2].j = jstr;
							istartAnew2++;
						}
					}
					index_size = 0;

				}

				delete[] vector_sum;
				delete[] index_visit;


				delete[] row_ind_AS;
				delete[] row_ind_AE;
				delete[] row_ind_PS;
				delete[] row_ind_PE;
			}

		}


		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*
		if (bquicktypesort) {
		QuickSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}


		printf("Prolongation is construct.\n");
#if doubleintprecision == 1
		printf("Error interpolation is count %lld\n", ipromah);
		printf("diagnostic ipromah_one=%lld\n", ipromah_one);
#else
		printf("Error interpolation is count %d\n", ipromah);
		printf("diagnostic ipromah_one=%d\n", ipromah_one);
#endif
		
		if (debug_reshime) system("pause");

		delete[] C_numerate;

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*
		if (bquicktypesort) {
		QuickSort(Amat,  1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = NULL;
		}
		}
		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		printf("one level construct OK.\n");
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.


		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}

			for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
				if (flag[Amat[ii77].i] == false) {
					integer istr77 = Amat[ii77].i;
					integer ic77 = ii77;
					//integer icdiag = ii77;
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
						if (Amat[ic77].j != istr77) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
						}
						else {
							ap = Amat[ic77].aij;
							//icdiag = ic77;
						}
						ic77++;
					}
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
#else
						printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
#endif
						
						system("PAUSE");
						//exit(1);
					}

					flag[Amat[ii77].i] = true;

				}
			}
		}


		//проверка конец

		delete[] count_sosed;
		delete[] row_startA;

	}// иерархия сеток построена.

	ilevel--;

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

#if doubleintprecision == 1
	printf("ilevel=%lld\n", ilevel);
	for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
		printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
	}
#else
	printf("ilevel=%d\n", ilevel);
	for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
		printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
	}
#endif
	
	printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);

	/*
	// отладочная печать в рабочей версии требуется закоментировать.
	for (integer ii = 1; ii <= n; ii++) {
	flag_[ii] = false;
	}
	for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
	if (flag_[R[ii].i] == false) {
	integer istr = R[ii].i;
	integer ic7 = ii;
	while ((ic7 <= iaddR + nnzR - 1) && (R[ic7].i == istr)) {
	printf("%e ", R[ic7].aij);
	ic7++;
	}
	printf("\n");
	system("pause");
	flag_[R[ii].i] = true;
	}
	}
	*/



	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel

	*/
	integer *row_ptr_start = new integer[4 * n_a[0] + 1];
	integer *row_ptr_end = new integer[4 * n_a[0] + 1];
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0;
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	bool bstop = false;
	// первый уровень вложенности.
	if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}

		for (integer ii = nnz_a[0] + 1; ii <= nnz_a[0] + nnz_a[1]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr);
#else
					printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr);
#endif
					
					system("PAUSE");
					//exit(1);
					bstop = true;
				}
				else {

					flag[Amat[ii].i] = true;
					Ak temp = Amat[ii];
					Amat[ii] = Amat[icdiag];
					Amat[icdiag] = temp;
					Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.

				}


			}
		}
	}

	if (bstop) exit(1);

	// второй уровень вложенности.

	if (ilevel > 2) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 2 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 2 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// третий уровень вложенности.

	if (ilevel > 3) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + nnz_a[2] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 3 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 3 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// 14 сентября 2015 понедельник
	// четвёртый уровень вложенности.

	if (ilevel > 4) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 4 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 4 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// пятый уровень вложенности.

	if (ilevel > 5) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 5 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 5 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// шестой уровень вложенности.

	if (ilevel > 6) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 6 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 6 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}




	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq


	delete[] this_is_C_node;
	delete[] this_is_F_node;


	printf("cycling: V cycle.\n");
#if doubleintprecision == 1
	printf("level=%lld\n", ilevel);
#else
	printf("level=%d\n", ilevel);
#endif
	
	printf("multigrid R.P.Fedorenko 1961.\n");
	printf("standart aglomerative algebraic multigrid method.\n");
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	integer nu1 = 9;  // 4 // 8
	integer nu2 = 8;  // 3 // 7

	if (dim_2D == 0) {
		// 3D
		nu1 = 9;
		nu2 = 8;
	}

#if doubleintprecision == 1
	printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
	printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
	

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.

	doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = NULL;
	doublerealT* error_approx_coarse = NULL;
	doublerealT *residual_fine1 = NULL;
	doublerealT *residual_coarse1 = NULL;
	doublerealT* error_approx_coarse1 = NULL;
	doublerealT *error_approx_fine1 = NULL;
	doublerealT *residual_fine2 = NULL;
	doublerealT *residual_coarse2 = NULL;
	doublerealT* error_approx_coarse2 = NULL;
	doublerealT *error_approx_fine2 = NULL;
	doublerealT *residual_fine3 = NULL;
	doublerealT *residual_coarse3 = NULL;
	doublerealT* error_approx_coarse3 = NULL;
	doublerealT *error_approx_fine3 = NULL;
	doublerealT *residual_fine4 = NULL;
	doublerealT *residual_coarse4 = NULL;
	doublerealT *error_approx_coarse4 = NULL;
	doublerealT *error_approx_fine4 = NULL;
	doublerealT *residual_fine5 = NULL;
	doublerealT *residual_coarse5 = NULL;
	doublerealT* error_approx_coarse5 = NULL;
	doublerealT *error_approx_fine5 = NULL;
	doublerealT *residual_fine6 = NULL;
	doublerealT *residual_coarse6 = NULL;
	doublerealT* error_approx_coarse6 = NULL;
	doublerealT *error_approx_fine6 = NULL;

	if (ilevel > 1) {
		residual_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = new doublerealT[n_a[1] + 1];
		if (ilevel > 2) {
			// residual
			residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_fine1 = new doublerealT[n_a[1] + 1];
			if (ilevel > 3) {
				// residual
				residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_fine2 = new doublerealT[n_a[2] + 1];
				if (ilevel > 4) {
					// residual
					residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_fine3 = new doublerealT[n_a[3] + 1];
					if (ilevel > 5) {
						// residual
						residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_fine4 = new doublerealT[n_a[4] + 1];
						if (ilevel > 6) {
							// residual
							residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_fine5 = new doublerealT[n_a[5] + 1];
							if (ilevel > 7) {
								// residual
								residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_fine6 = new doublerealT[n_a[6] + 1];
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];



	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;

	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		if (iter_limit > 1000) {
			printf("may be Neimann in the all boundares.\n");
			break; // досрочный выход из while цикла.
		}
		iter_limit++;


		if (dres!=dres) {
			printf("divergence AMG detected\n");
			printf("\a\a\a\a\a\a\a\a");
			system("pause");
			exit(1);
		}

		// smother
		for (integer iter = 0; iter < nu1; iter++) {
			//seidel<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);

		}

		//exporttecplot(x, n);

		// residual_r
		//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
		//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
		residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
		dres = norma(residual_fine, n_a[0]);
#if doubleintprecision == 1
		printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
		printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
		
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;
		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				error_approx_coarse[ii] = 0.0;
			}
			// pre smothing
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			if (ilevel > 2) {
				// residual
				//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
				//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
				residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);


				//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

				// restriction
				restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

				// Amat*e=r;
				//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
				for (integer ii = 1; ii <= n_a[2]; ii++) {
					error_approx_coarse1[ii] = 0.0;
				}
				// pre smothing
				for (integer iter = 0; iter < nu1; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}
				if (ilevel > 3) {
					// residual
					//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
					//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
					residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
					//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);

					//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
					for (integer ii = 1; ii <= n_a[3]; ii++) {
						error_approx_coarse2[ii] = 0.0;
					}
					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}
					if (ilevel > 4) {
						// residual
						//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
						//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
						residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						//speshial
						//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);



						//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
						for (integer ii = 1; ii <= n_a[4]; ii++) {
							error_approx_coarse3[ii] = 0.0;
						}
						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}
						if (ilevel > 5) {
							// residual
							//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
							residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							//speshial 14 september 2015.
							//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);


							//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
							for (integer ii = 1; ii <= n_a[5]; ii++) {
								error_approx_coarse4[ii] = 0.0;
							}
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}
							if (ilevel > 6) {
								// residual
								//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
								//if (ilevel <= 15) {
								residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}
								//else {
								// приводит к расходимости.
								//speshial 14 september 2015.
								// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
								//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								//}

								//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
								for (integer ii = 1; ii <= n_a[6]; ii++) {
									error_approx_coarse5[ii] = 0.0;
								}
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								if (ilevel > 7) {
									// residual
									//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
									residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);

									//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
									for (integer ii = 1; ii <= n_a[7]; ii++) {
										error_approx_coarse6[ii] = 0.0;
									}
									// pre smothing
									for (integer iter = 0; iter < nu1; iter++) {
										seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}

									if (ilevel > 8) {
										// residual
										doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
										residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);


										doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

										// restriction
										restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

										// Amat*e=r;
										doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
										for (integer ii = 1; ii <= n_a[8]; ii++) {
											error_approx_coarse7[ii] = 0.0;
										}
										// pre smothing
										for (integer iter = 0; iter < nu1; iter++) {
											seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										if (ilevel > 9) {
											// residual
											doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
											integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
											integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
											residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


											doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

											// restriction
											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

											// Amat*e=r;
											doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
											for (integer ii = 1; ii <= n_a[9]; ii++) {
												error_approx_coarse8[ii] = 0.0;
											}
											// pre smothing
											for (integer iter = 0; iter < nu1; iter++) {
												integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
												integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}

											if (ilevel > 10) {
												// 8 сентября 2015 РИМИНИ пляж 

												// residual
												doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
												integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
												integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
												residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


												doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

												// restriction
												integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

												// Amat*e=r;
												doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];
												for (integer ii = 1; ii <= n_a[10]; ii++) {
													error_approx_coarse9[ii] = 0.0;
												}
												// pre smothing
												for (integer iter = 0; iter < nu1; iter++) {
													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}

												if (ilevel > 11) {
													// 8 сентября 2015 РИМИНИ пляж 

													// residual
													doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
													integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
													integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
													residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


													doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

													// restriction
													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

													// Amat*e=r;
													doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];
													for (integer ii = 1; ii <= n_a[11]; ii++) {
														error_approx_coarse10[ii] = 0.0;
													}
													// pre smothing
													for (integer iter = 0; iter < nu1; iter++) {
														integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
														integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}

													if (ilevel > 12) {
														// 11 сентября 2015 РИМИНИ пляж 

														// residual
														doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
														integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
														integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
														residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


														doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

														// restriction
														integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

														// Amat*e=r;
														doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];
														for (integer ii = 1; ii <= n_a[12]; ii++) {
															error_approx_coarse11[ii] = 0.0;
														}
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}

														if (ilevel > 13) {
															// 11 сентября 2015 РИМИНИ пляж 

															// residual
															doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
															residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


															doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

															// Amat*e=r;
															doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];
															for (integer ii = 1; ii <= n_a[13]; ii++) {
																error_approx_coarse12[ii] = 0.0;
															}
															// pre smothing
															for (integer iter = 0; iter < nu1; iter++) {
																integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															if (ilevel > 14) {
																// 11 сентября 2015 РИМИНИ пляж 

																// residual
																doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																// restriction
																integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																// Amat*e=r;
																doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];
																for (integer ii = 1; ii <= n_a[14]; ii++) {
																	error_approx_coarse13[ii] = 0.0;
																}
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}

																if (ilevel > 15) {
																	// 14 сентября 2015 Москва на работе в пн. 

																	// residual
																	doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																	residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																	doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																	// Amat*e=r;
																	doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																	for (integer ii = 1; ii <= n_a[15]; ii++) {
																		error_approx_coarse14[ii] = 0.0;
																	}
																	// pre smothing
																	for (integer iter = 0; iter < nu1; iter++) {
																		integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																		integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}

																	if (ilevel > 16) {
																		// 10 октября 2015. 

																		// residual
																		doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																		integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																		integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																		residual(Amat, n1, n2, error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);


																		doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																		// restriction
																		integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																		integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																		restriction(R, n3, n4, flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																		// Amat*e=r;
																		doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																		for (integer ii = 1; ii <= n_a[16]; ii++) {
																			error_approx_coarse15[ii] = 0.0;
																		}
																		// pre smothing
																		for (integer iter = 0; iter < nu1; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																			seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																		}

																		if (ilevel > 17) {
																			// 10 октября 2015. 

																			// residual
																			doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																			integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																			integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																			residual(Amat, n1, n2, error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);


																			doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																			// restriction
																			integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																			integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																			restriction(R, n3, n4, flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																			// Amat*e=r;
																			doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																			for (integer ii = 1; ii <= n_a[17]; ii++) {
																				error_approx_coarse16[ii] = 0.0;
																			}
																			// pre smothing
																			for (integer iter = 0; iter < nu1; iter++) {
																				integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																				integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																				seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																			}

																			if (ilevel > 18) {
																				// 5 декабря 2015. 

																				// residual
																				doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																				integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																				integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																				residual(Amat, n1, n2, error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);


																				doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																				// restriction
																				integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																				integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																				restriction(R, n3, n4, flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);

																				// Amat*e=r;
																				doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																				for (integer ii = 1; ii <= n_a[18]; ii++) {
																					error_approx_coarse17[ii] = 0.0;
																				}
																				// pre smothing
																				for (integer iter = 0; iter < nu1; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																					seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																				}

																				// post smothing
																				for (integer iter = 0; iter < nu2; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																					seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																				}


																				// prolongation
																				// residual_r
																				doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																				for (integer ii = 1; ii <= n_a[17]; ii++) {
																					error_approx_fine17[ii] = 0.0;
																				}



																				integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																				integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																				prolongation(P, n7, n8, flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																				// correction
																				for (integer ii = 1; ii <= n_a[17]; ii++) {
																					error_approx_coarse16[ii] += error_approx_fine17[ii];
																				}

																				// free
																				delete[] error_approx_fine17;
																				delete[] error_approx_coarse17;
																				delete[] residual_coarse17;
																				delete[] residual_fine17;

																			}


																			// post smothing
																			for (integer iter = 0; iter < nu2; iter++) {
																				integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																				integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																				seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																			}


																			// prolongation
																			// residual_r
																			doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																			for (integer ii = 1; ii <= n_a[16]; ii++) {
																				error_approx_fine16[ii] = 0.0;
																			}



																			integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																			integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																			prolongation(P, n7, n8, flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																			// correction
																			for (integer ii = 1; ii <= n_a[16]; ii++) {
																				error_approx_coarse15[ii] += error_approx_fine16[ii];
																			}

																			// free
																			delete[] error_approx_fine16;
																			delete[] error_approx_coarse16;
																			delete[] residual_coarse16;
																			delete[] residual_fine16;

																		}


																		// post smothing
																		for (integer iter = 0; iter < nu2; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																			seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																		}


																		// prolongation
																		// residual_r
																		doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																		for (integer ii = 1; ii <= n_a[15]; ii++) {
																			error_approx_fine15[ii] = 0.0;
																		}



																		integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																		integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																		prolongation(P, n7, n8, flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																		// correction
																		for (integer ii = 1; ii <= n_a[15]; ii++) {
																			error_approx_coarse14[ii] += error_approx_fine15[ii];
																		}

																		// free
																		delete[] error_approx_fine15;
																		delete[] error_approx_coarse15;
																		delete[] residual_coarse15;
																		delete[] residual_fine15;

																	}

																	// post smothing
																	for (integer iter = 0; iter < nu2; iter++) {
																		integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																		integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																		seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																	}


																	// prolongation
																	// residual_r
																	doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_fine14[ii] = 0.0;
																	}



																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																	prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																	// correction
																	for (integer ii = 1; ii <= n_a[14]; ii++) {
																		error_approx_coarse13[ii] += error_approx_fine14[ii];
																	}

																	// free
																	delete[] error_approx_fine14;
																	delete[] error_approx_coarse14;
																	delete[] residual_coarse14;
																	delete[] residual_fine14;

																}


																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																	seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																}


																// prolongation
																// residual_r
																doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_fine13[ii] = 0.0;
																}

#if doubleintprecision == 1
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#else
																//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																//getchar();
																//}
																//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																//if (ii % 20 == 0) getchar();
																//}
#endif
																

																integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																// correction
																for (integer ii = 1; ii <= n_a[13]; ii++) {
																	error_approx_coarse12[ii] += error_approx_fine13[ii];
																}

																// free
																delete[] error_approx_fine13;
																delete[] error_approx_coarse13;
																delete[] residual_coarse13;
																delete[] residual_fine13;

															}


															// post smothing
															for (integer iter = 0; iter < nu2; iter++) {
																integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
															}


															// prolongation
															// residual_r
															doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_fine12[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
															//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

															//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif
															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
															prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

															// correction
															for (integer ii = 1; ii <= n_a[12]; ii++) {
																error_approx_coarse11[ii] += error_approx_fine12[ii];
															}

															// free
															delete[] error_approx_fine12;
															delete[] error_approx_coarse12;
															delete[] residual_coarse12;
															delete[] residual_fine12;

														}



														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
															seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
														}


														// prolongation
														// residual_r
														doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_fine11[ii] = 0.0;
														}

#if doubleintprecision == 1
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#else
														//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
														//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

														//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
														//getchar();
														//}
														//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
														//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
														//if (ii % 20 == 0) getchar();
														//}
#endif

													

														integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
														integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
														prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

														// correction
														for (integer ii = 1; ii <= n_a[11]; ii++) {
															error_approx_coarse10[ii] += error_approx_fine11[ii];
														}

														// free
														delete[] error_approx_fine11;
														delete[] error_approx_coarse11;
														delete[] residual_coarse11;
														delete[] residual_fine11;

													}


													// post smothing
													for (integer iter = 0; iter < nu2; iter++) {
														integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
														integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
														seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
													}


													// prolongation
													// residual_r
													doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_fine10[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
													//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

													//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif
													

													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
													prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

													// correction
													for (integer ii = 1; ii <= n_a[10]; ii++) {
														error_approx_coarse9[ii] += error_approx_fine10[ii];
													}

													// free
													delete[] error_approx_fine10;
													delete[] error_approx_coarse10;
													delete[] residual_coarse10;
													delete[] residual_fine10;

												}



												// post smothing
												for (integer iter = 0; iter < nu2; iter++) {
													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
													seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
												}


												// prolongation
												// residual_r
												doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_fine9[ii] = 0.0;
												}

#if doubleintprecision == 1
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#else
												//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
												//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

												//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
												//getchar();
												//}
												//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
												//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
												//if (ii % 20 == 0) getchar();
												//}
#endif
												

												integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
												integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
												prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

												// correction
												for (integer ii = 1; ii <= n_a[9]; ii++) {
													error_approx_coarse8[ii] += error_approx_fine9[ii];
												}

												// free
												delete[] error_approx_fine9;
												delete[] error_approx_coarse9;
												delete[] residual_coarse9;
												delete[] residual_fine9;

											}

											// post smothing
											for (integer iter = 0; iter < nu2; iter++) {
												integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
												integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
												seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
											}


											// prolongation
											// residual_r
											doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_fine8[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
											//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

											//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif
											

											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
											prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

											// correction
											for (integer ii = 1; ii <= n_a[8]; ii++) {
												error_approx_coarse7[ii] += error_approx_fine8[ii];
											}

											// free
											delete[] error_approx_fine8;
											delete[] error_approx_coarse8;
											delete[] residual_coarse8;
											delete[] residual_fine8;

										}

										// post smothing
										for (integer iter = 0; iter < nu2; iter++) {
											seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
										}


										// prolongation
										// residual_r
										doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_fine7[ii] = 0.0;
										}

#if doubleintprecision == 1
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#else
										//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
										//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

										//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
										//getchar();
										//}
										//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
										//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
										//if (ii % 20 == 0) getchar();
										//}
#endif
										

										prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

										// correction
										for (integer ii = 1; ii <= n_a[7]; ii++) {
											error_approx_coarse6[ii] += error_approx_fine7[ii];
										}

										// free
										delete[] error_approx_fine7;
										delete[] error_approx_coarse7;
										delete[] residual_coarse7;
										delete[] residual_fine7;

									}


									// post smothing
									for (integer iter = 0; iter < nu2; iter++) {
										seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7]);
									}


									// prolongation
									// residual_r
									//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_fine6[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
									//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

									//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif
									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

									// correction
									for (integer ii = 1; ii <= n_a[6]; ii++) {
										error_approx_coarse5[ii] += error_approx_fine6[ii];
									}

									// free
									//delete[] error_approx_fine6;
									//delete[] error_approx_coarse6;
									//delete[] residual_coarse6;
									//delete[] residual_fine6;

								}

								// post smothing
								for (integer iter = 0; iter < nu2; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
									seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
								}

								// prolongation
								// residual_r
								//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_fine5[ii] = 0.0;
								}

#if doubleintprecision == 1
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#else
								//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
								//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

								//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
								//getchar();
								//}
								//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
								//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
								//if (ii % 20 == 0) getchar();
								//}
#endif

								

								prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

								// correction
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] += error_approx_fine5[ii];
								}

								// free
								//delete[] error_approx_fine5;
								//delete[] error_approx_coarse5;
								//delete[] residual_coarse5;
								//delete[] residual_fine5;

							}
							// post smothing
							for (integer iter = 0; iter < nu2; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
								seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
							}

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif

							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

						}
						// post smothing
						for (integer iter = 0; iter < nu2; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
							seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
						}

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%ld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif

						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

					}
					// post smothing
					for (integer iter = 0; iter < nu2; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
						seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);

					}

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif

					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

				}
				// post smothing
				for (integer iter = 0; iter < nu2; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
					seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
				}

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif

				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

			}

			// post smothing
			for (integer iter = 0; iter < nu2; iter++) {
				//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
				seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
			}

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}
		// post smother
		for (integer iter = 0; iter < nu2; iter++) {
			//seidel<doublereal>(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
			//quick seidel
			seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}

		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");

	// free
	delete[] error_approx_fine;
	if (ilevel > 1) {
		delete[] error_approx_coarse;
		delete[] residual_coarse;
		if (ilevel > 2) {
			// free
			delete[] error_approx_fine1;
			delete[] error_approx_coarse1;
			delete[] residual_coarse1;
			delete[] residual_fine1;
			if (ilevel > 3) {
				// free
				delete[] error_approx_fine2;
				delete[] error_approx_coarse2;
				delete[] residual_coarse2;
				delete[] residual_fine2;
				if (ilevel > 4) {
					// free
					delete[] error_approx_fine3;
					delete[] error_approx_coarse3;
					delete[] residual_coarse3;
					delete[] residual_fine3;
					if (ilevel > 5) {
						// free
						delete[] error_approx_fine4;
						delete[] error_approx_coarse4;
						delete[] residual_coarse4;
						delete[] residual_fine4;
						if (ilevel > 6) {
							// free
							delete[] error_approx_fine5;
							delete[] error_approx_coarse5;
							delete[] residual_coarse5;
							delete[] residual_fine5;
							if (ilevel > 7) {
								// free
								delete[] error_approx_fine6;
								delete[] error_approx_coarse6;
								delete[] residual_coarse6;
								delete[] residual_fine6;
							}
						}
					}
				}
			}
		}
	}


	delete[] residual_fine;

	delete[] row_ptr_start;
	delete[] row_ptr_end;


	delete[] flag_shadow;
	delete[] flag;
	//delete[] flag_;
	return 0;

} // classic_aglomerative_amg1

integer iglcounter_up_and_douwn = 0;
void move_down(integer &nu1, integer& nu2) {
	//iglcounter_up_and_douwn++;
	// TODO
	//if (iglcounter_up_and_douwn % 2 == 0) {
		//nu1++;
		//nu2++;
	//}	
}

void move_up(integer &nu1, integer& nu2) {
	//iglcounter_up_and_douwn--;
	// TODO
	//if (iglcounter_up_and_douwn % 2 == 0) {
		//nu1--;
		//nu2--;
	//}
}



void nested_desection_patch(Ak1* &Amat, integer isize_na, bool* &nested_desection,
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd_now) {

	// Данный метод самописный и очень хреновый. Его не рекомендуется использовать в частности из-за граничных узлов.
	// Лучше производить разбиения по геометрическому признаку. Т.е. если есть координаты узлов, то слева выделить всё с координатами меньше
	// чем центральная координата, а справа всё что больше. Помоему так делают в Open Foam X.

	// Описание способа работы.
	// Метод требует подачи на вход матрицы в Ak1 формате.
	// Данная функция выдаёт булевый вектор nested desection [1..isize_na]:
	// Ячейки равные false относятся к границе сепаратора (разделителя двух подобластей).
	// Введем число integer middle = (integer)(0.5*(1 + isize_na));
	// Ячейки помеченные true индекс которых [1..middle] Могут выполнятся первым потоком.
	// Ячейки помеченные true индекс которых [middle+1..isize_na] Могут выполнятся вторым потоком независимо от первого.

	// Готовим nested desection
	// для двух потоков.
	// Самая подробная матрица 0.
	// nested_desection0
	bool *nested_desection1 = NULL;
	nested_desection1 = (bool*)malloc((isize_na + 1)*sizeof(bool));
	char c1[19] = "nested_desection1";
	char c2[24] = "nested_desection_patch";
	char c3[19] = "nested_desection2";
	handle_error<bool>(nested_desection1,  c1, c2, (isize_na + 1));
	bool *nested_desection2 = NULL;
	nested_desection2 = (bool*)malloc((isize_na + 1)*sizeof(bool));
	handle_error<bool>(nested_desection2, c3, c2, (isize_na + 1));

	// инициализация.
	for (integer i_73 = 1; i_73 <= isize_na; i_73++) {
		nested_desection1[i_73] = false;
		nested_desection2[i_73] = false;
		nested_desection[i_73] = true;
	}
	integer middle = (1 + isize_na)/2;
	for (integer i_72 = 1; i_72 <= middle; i_72++) {
		for (integer i_82 = row_ptr_start[i_72 + iadd_now]; i_82 <= row_ptr_end[i_72 + iadd_now]; i_82++) {
			nested_desection1[Amat[i_82].j] = true;
		}
	}
	for (integer i_72 = middle + 1; i_72 <= isize_na; i_72++) {
		for (integer i_82 = row_ptr_start[i_72 + iadd_now]; i_82 <= row_ptr_end[i_72 + iadd_now]; i_82++) {
			nested_desection2[Amat[i_82].j] = true;
		}
	}
	// На пересечении двух множеств находятся узлы сепаратора.
	for (integer i_73 = 1; i_73 <= isize_na; i_73++) {
		if ((nested_desection1[i_73]) && (nested_desection2[i_73])) {
			nested_desection[i_73] = false;
		}
	}
	// запоминаем узлов из сепаратора.
	for (integer i_73 = 1; i_73 <= isize_na; i_73++) {
		nested_desection1[i_73] = nested_desection[i_73];
	}
	// Если какой-либо сосед принадлежит сепаратору то и сам узел принадлежит сепаратору.
	for (integer i_72 = 1; i_72 <= isize_na; i_72++) {
		for (integer i_82 = row_ptr_start[i_72 + iadd_now]; i_82 <= row_ptr_end[i_72 + iadd_now]; i_82++) {
			if (!nested_desection1[Amat[i_82].j]) nested_desection[Amat[i_82].i] = false;
		}
	}

   free(nested_desection1);
   free(nested_desection2);
} // nested_desection_patch




// 22 января текущий работоспособный вариант кода.
// Планы : 1. сделать версию amg3. 
// В ней : 2. заменить все проверки на невыделение оперативной памяти на универсальную функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
  // 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
  // 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
  // построении С-F разбиения, теперь C-F разбиение строится корректно.
  // Исправлен и внедрён quicksort (qs,qsj)
  // который в рять раз быстрее пирамидальной сортировки.
  // Полный отказ от band_size!!!.
  // Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
  // 18 октября 2015. Полностью работоспособный мультигрид.
  // Тестировалось на условиях Дирихле но должно работать на любых 
  // краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
  // быстрее версии 0_03. Были ускорены как операции построения C-F разбиения, 
  // так и нахождение оператора Галёркина. При нахождении С-F разбиения 
  // учитывается уже построеннная его часть и поэтому число сканирований на
  // на поздних циклах сокращается охватывая только не построенную часть.
  // При нахождении произведеия Галёркина получена самая оптимальная по быстродествию версия,
  // Основанная на алгоритме слияния отсортированных списков.
  // 4 октября правильное построение последовательности вложенных графов.
  // 30 сентября продолжаем исправление метода. Делаем классический 
  // алгебраический многосеточный метод на основе  C-F разбиения.
  // 16 сентября 2015 года обнаружено что операции 
  // сгрубления и интерполяции сделаны совершенно неверно,
  // и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
  // Операции сгрубления и интерполляции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
  // 3 september 2015 Villa Borgese.
// Возвращает divergence detected.
template <typename doublerealT>
bool classic_aglomerative_amg2(Ak1* &Amat, 
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	doublerealT &theta
	) {

	// Параметры отвечающие за автоматическую настройку SOR.
	// По трём точкам мы построим параболу и на её основе 
	// спрогнозируем улучшенный параметр релаксации omega_optimal.
	// Парабола представляется намного лучшей чем простая линейная экстрополяция.
	bproblem_amg_convergence1 = false;
	bproblem_amg_convergence2 = false;
	bproblem_amg_convergence3 = false;
	gold_const = 0.2;

	const bool bprint_mesage_diagnostic = true;

	const integer AVL_TREE_ID = 0;
	const integer SPLAY_TREE_ID = 1;
	integer id_tree =  SPLAY_TREE_ID;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	doublerealT barjer = 1.0e-7; // 1.0e-7 
	doublerealT barjerA = 1.0e-7; // 1.0e-7

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	bool bqs = true; // Использовать ли quicksort qs and qsj.
					 // Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая жрёт килотонну памяти (Короче для машин у которых море оперативки).


	const doublerealT RealZERO = 1.0e-300;// 1.0e-10;
	const doublerealT divisionZERO = 1.0e-300;
	const doublerealT RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_sosed = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumsosedcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C-F разбиения.
	bool bmaxsosedinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = NULL;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	//bool* flag = new bool[n + 1];
	bool* flag = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_2", (n + 1));
	
	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_2", (n + 1));
	
	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = (bool*)malloc((nnz + 1)*sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_2", (nnz + 1));
	
	// Огромный размер поэтому инициализация делается лишь единожды.
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n+1; // 128000
	//integer ipool[ipool_size_limit];
	integer* istack = NULL;
		//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit)*sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_2", (istack_size_limit));

	// Для построения C-F декомпозиции нам тоже потребуется хеш таблица
	// и стек для очистки хеш таблицы.
	bool* hash_table2 = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_2", (n + 1));
	
	// Инициализация.
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш таблицы.
	integer* istack2 = NULL;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1)*sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_2", (n + 1));
	

	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_2", (n + 1));
	
	bool* this_is_F_node = (bool*)malloc((n+1)*sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_2", (n + 1));
	

	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {


		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumsosedcount = -1;
		bmaxsosedinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 10) {
			if (n_a[ilevel - 1] < 300) break;
		}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}


#if doubleintprecision == 1
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#else
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#endif

		

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]; ii <= n; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);


			// 7 января 2016. Обязательно нужна эта сортировка.
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, true);
				}
				else {
					// quicksort
					qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}
			}
			else {
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}





		if (bji) {
			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			if (bqs) {
				if (bCounting_Sort) {
					// Сортировка с подсчётом за линейное время.
					Counting_Sortj(Atemp, 1, nnz_a[ilevel - 1]);
				}
				else {
					// Быстрая сортировка Чарльза Хоара.
					qsj(Atemp, 1, nnz_a[ilevel - 1]);
				}
			}
			else {
				HeapSort_j(Atemp, 1, nnz_a[ilevel - 1]);
			}
		}

		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = NULL;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_sosed = NULL;
		//count_sosed = new integer[n_a[ilevel - 1] + 1];
		count_sosed = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(count_sosed, "count_sosed", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_sosed[ii] = 0; // нет соседей.
		}




		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				integer cand[max_sosed];
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
				}
				else {
					// 12 января 2016.
					// Учитываем только Strong соседей.
					doublerealT threshold = -1.0;
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > threshold) {
								// Определяем максимальный внедиагональный элемент.
								threshold = fabs(Amat[is0].aij);
							}
						}
					}
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > theta*threshold) {
								// Учитываем только сильно связанных соседей.
								ic++; //i,j
								cand[ic] = Amat[is0].j;
							}
						}
					}
				}
				integer len_sosed = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundsosed = false;
				//		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
				//			if (Amat[ii1].j == cand[i_1]) foundsosed = true;
				//		}
				//		if (!foundsosed) {
				//			ic++;
				//			cand[ic] = Amat[ii1].j;
				//			len_sosed++;
				//		}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundsosed = false;
							for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
							}
							if (!foundsosed) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_sosed++;
							}
						}
					}
				}


				count_sosed[Amat[ii].i] = ic;
				if (ic > Maximumsosedcount) {
					Maximumsosedcount = ic;
					bmaxsosedinfoactive = true;
				}
				flag[Amat[ii].i] = true;
			}
		}



		integer maxsosed = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				if (count_sosed[Amat[ii].i] > maxsosed) {
					maxsosed = count_sosed[Amat[ii].i];
					icandidate = ii;
					if (bmaxsosedinfoactive) {
						// организуем досрочный выход из цикла for.
						// Это должно сильно сокращать количество сканирований.
						if (maxsosed == Maximumsosedcount) break;
					}
				}
				flag[Amat[ii].i] = true;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_SOSED = -1;
		integer vacant = NULL_SOSED;
		bool bcontinue = true;

		// Построение C-F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = NULL;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n+1)*sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_2", (n + 1));
		
		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;



		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;
		Tree_splay* root_splay = 0;
		size_splay_Tree = 0;

		integer newCcount = 0;




		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_sosed]; // не более 20 узлов в одном агрегате.
									// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
									//for (integer js = 0; js < max_sosed; js++) {
									//set[js] = NULL_SOSED;
									//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;


				
				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
				// добавляем диагональный элемент.
				// узел set[0]==Amat[is0].i.
				// Нахождение значения максимального внедиагольного элемента, с 
				// учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				// 17 января 2016 правильное определение максимального внедиагонального элемента.
				// Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set[0])) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0;
				doublerealT min_vnediagonal1 = 1.0e30;
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				for (integer is0 = ii_back; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j != set[0]) {
						counter_vnediagonal = counter_vnediagonal + 1.0;
						avg_vnediagonal1 += fabs(Amat[is0].aij);
						if (fabs(Amat[is0].aij) > max_vnediagonal1) {
							max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
							// Большое количество элементов на грубых уровнях,
							// очень медленная сходимость.
							//if (Amat[is0].j == set[0]) break; 
						}
						if (fabs(Amat[is0].aij) < min_vnediagonal1) {
							min_vnediagonal1 = fabs(Amat[is0].aij); //i,j
							
						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				//max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				max_vnediagonal = -1.0;  // все связи!!!

				/*
				// Лишний код 19 января 2016.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j == set[0]) {

						// Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
						// поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
						break;
					}
					else {
						if (fabs(Amat[is0].aij) > max_vnediagonal) {
							// При стабильной версии требуется расскоментировать
							// 19 jan 2016.
							//max_vnediagonal = fabs(Amat[is0].aij); //i,j
						}
					}

					// Этот цикл является добавочным.
					// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
					// Медленный линейный поиск.
					//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
					//if (Amat[ii1].i != set[0]) {
					//if (!flag[Amat[ii1].i]) {
					//	if (Amat[ii1].j == set[0]) {
					//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
					//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
					//		}
					//	}
					//}
					//}
					//}

					if (bji) {
						// Этот цикл является добавочным.
						// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
						// Ускоренная версия на основе двоичного поиска.
						integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
						for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
						{
							if (Atemp[ii1].i != set[0]) {
								if (!flag[Atemp[ii1].i]) {
									if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
										max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
									}
								}
							}
						}
					}


				}
				*/

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_SOSED;
							}
						}
						if (vacant != NULL_SOSED) {
							set[ic] = vacant;

							ic++;
						}
					}
				}
				integer iscan = ii + 1;
				iscan = ii_back; // важная модификация 19 января 2016г.
				// TODO 19 jan 2016.
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_SOSED;
								}
							}
							if (vacant != NULL_SOSED) {
								set[ic] = vacant;

								ic++;

							}
						}
					}

					iscan++;

				} // while

				// Это была учтена только связь i,j



				  // Учёт свяи j,i
				  //for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				  //if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				  //if (!flag[Amat[ii1].i]) {
				  //if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				  //	vacant = Amat[ii1].i;
				  //	for (integer js = 0; js < ic; js++) {
				  //		if (vacant == set[js]) {
				  //			vacant = NULL_SOSED;
				  //		}
				  //	}
				  //	if (vacant != NULL_SOSED) {
				  //		set[ic] = vacant; // j,i связь.

				  //		ic++;
				  //	}
				  //	}
				  //}
				  //}
				  //}

				  // Учёт связи j,i
				  // Медленная версия на основе линейного поиска.
				  //for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				  //if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				  //if (!flag[Amat[ii1].i]) {
				  //if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				  //	vacant = Amat[ii1].i;
				  //	for (integer js = 0; js < ic; js++) {
				  //		if (vacant == set[js]) {
				  //			vacant = NULL_SOSED;
				  //		}
				  //	}
				  //	if (vacant != NULL_SOSED) {
				  //		set[ic] = vacant; // j,i связь.

				  //		ic++;
				  //	}
				  //}
				  //}
				  //}
				  //}

				if (bji) {
					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1]) && (Atemp[ii2].j == set[0]); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {
								vacant = Atemp[ii2].i;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant; // j,i связь.
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.countsosed = count_sosed[set[js]];
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						default: root = remove_AVL(root, ddel);
							break;
						}
						
						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}

				
					//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
					//flag_shadow[i_1] = flag[i_1];
					//}



					//integer i3 = 1;
					//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
					//integer i4 = n_a[ilevel - 1];
					//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


					// Ищем только среди ближайшего окружения вновь добавленного F узла.
					//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

					// Старая реализация которой присуща большая нагрузка на операторы new && delete.
				if (0) {
					for (integer js = 1; js < ic; js++) {

					// см. новый вариант от 10 января 2016.

					// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
					// элемент lsos_head;
					List *lsos = NULL;
					List *lsos_head = NULL;
					lsos = new List;
					lsos->prev = NULL;
					lsos_head = lsos;
					{
						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart2 = ii_11;
						while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
						istart2++;
						bool bvisitsos = false;
						for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {
								lsos->next = NULL;
								lsos->i = Amat[is0].j;
								lsos->ii = row_startA[lsos->i];
								// lsos->countsosed // не используется.
								List *newnodesos = new List;
								newnodesos->prev = lsos;
								lsos->next = newnodesos;
								newnodesos->next = NULL;
								lsos = lsos->next;
								newnodesos = NULL;
								bvisitsos = true;
							}
						}
						if (bvisitsos) {

							List *delsos = lsos;
							lsos = lsos->prev;
							lsos->next = NULL;
							delsos->prev = NULL;
							delete delsos;
							delsos = NULL;
						}
						else {
							// Нет ни одного соседа
							lsos_head = NULL;
							delete lsos;
							lsos = NULL;
						}
					}

					lsos = lsos_head;
					// ищем соседа узла set[js].
					//for (integer i5 = i3; i5 <= i4; i5++) {
					while (lsos != NULL) {


						//integer isc = Amat[ii_2].i;
						//integer ii_2 = row_startA[i5];
						//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						//integer isc = i5;

						integer isc = lsos->i;
						integer ii_2 = lsos->ii;


						//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
						//if (flag[isc] == false) {
						//flag_shadow[isc] = true;
						integer ic2 = 0;
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart2 = ii_2;
						while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
						istart2++;
						for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
							if (Amat[is0].j == set[js]) {
								ic2++;
							}
						}

						data_BalTree dsearch;
						dsearch.countsosed = count_sosed[isc];
						//dsearch.ii = ii_2;
						dsearch.i = isc;
						count_sosed[isc] += ic2;
						data_BalTree dadd;
						dadd.countsosed = count_sosed[isc];
						//dadd.ii = ii_2;
						dadd.i = isc;
						if (bmaxsosedinfoactive) {
							// Обновляем информацию о максимальном количестве соседей.
							if (count_sosed[isc] >= Maximumsosedcount) {
								Maximumsosedcount = count_sosed[isc];
							}

							// Добавляем соседа в любом случае
							// позволило существенным образом 
							// ускорить алгоритм. Если раньше 
							// old = 48595  | 21229
							// new = 433315 | 63031
							// new2 = 19434 | 3698
							// и основное время уходило на old
							// то теперь
							// old = 1449 | 1466
							// new = 472600 | 64525
							// new2= 56544 | 18431
							// Время решения 3D задачи с 1M неизвестными 
							// сократилось с 6мин 48с до 4мин 45с.

							if (bAVL) {

								// добавляем элемент в АВЛ дерево,
								// причём если элемент уже находился в дереве то он модифицируется.
								// 12 декабря 2015.
								// Добавление узла происходит за логарифмическое по основанию 2 время,
								// причём после добавления дерево остаётся сбалансированным.
								// Адельсон-Вельский и Ландис 1962.
								switch (id_tree) {
								case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
								case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
									break;
								default: root = insert_and_modify(root, dadd, dsearch);
									break;
								}
								
								if (bAVL_deb)
								{
									printf("insert and modify\n");
								}
							}


						}
						//}
						lsos = lsos->next;
					}

					// Уничтожение lsos
					// Список постепенно уничтожается с головы.
					lsos = lsos_head;
					while (lsos != NULL) {
						lsos_head = lsos_head->next;
						if (lsos_head != NULL) {
							lsos_head->prev = NULL;
						}
						lsos->next = NULL;
						delete lsos;
						lsos = lsos_head;
					}

				}
					}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

					// см.ниже  новый вариант от 10 января 2016.
					// 7 января 2016.
					// Новая версия в которой я избавился от лишних оператров new&&delete.
					// Никаких дублирующих линейных списков, никаких операторов new && delete.
					// Код стал намного понятнее.

					// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
					// элемент lsos_head;
					{
						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
								//if (flag[isc] == false) {
								//flag_shadow[isc] = true;
								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.countsosed = count_sosed[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_sosed[isc] += ic2;
								data_BalTree dadd;
								dadd.countsosed = count_sosed[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;
								if (bmaxsosedinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_sosed[isc] >= Maximumsosedcount) {
										Maximumsosedcount = count_sosed[isc];
									}

									// Добавляем соседа в любом случае
									// позволило существенным образом 
									// ускорить алгоритм. Если раньше 
									// old = 48595  | 21229
									// new = 433315 | 63031
									// new2 = 19434 | 3698
									// и основное время уходило на old
									// то теперь
									// old = 1449 | 1466
									// new = 472600 | 64525
									// new2= 56544 | 18431
									// Время решения 3D задачи с 1M неизвестными 
									// сократилось с 6мин 48с до 4мин 45с.

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}


								}

							}
						}

					}
				}

					}
					else if (0) {
						// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									// При таком подходе некоторые соседи инкрементируются дважды и это
									// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
									// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
									// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_sosed[isc] += ic2;
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID : root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}
									}

								}

							}
						}
					}
					else if (1) {
						// 10 января 2016. Новая логика.
						// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
						// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
						// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
						// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
						integer itop_stack2 = 0;
						
						// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;

									// Избавляемся от повторных инкрементаций.
									// В 2D на пятиточечном шаблоне повторные инкрементации составляют
									// около 33%.
									// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
									// на ряде тестовых задач при таком подходе агломерация проходила очень
									// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
									// Эта проблема проявилась на задачах :
									// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
									// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
									// Проблема не в этом месте кода.
									if (hash_table2[isc] == false) {
										hash_table2[isc] = true;
										istack2[itop_stack2] = isc;
										itop_stack2++;

										integer ii_2 = row_startA[isc];


										integer ic2 = 0;
										integer iend2loc = nnz_a[ilevel - 1] + iadd;
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											if (Amat[is01].j == set[js]) {
												ic2++;
											}
										}

										data_BalTree dsearch;
										dsearch.countsosed = count_sosed[isc];
										//dsearch.ii = ii_2;
										dsearch.i = isc;
										// Увеличиваем на количество связей с новыми F узлами.
										count_sosed[isc] += ic2;
										//if (ic2 > 0) {
											//count_sosed[isc] += 1;
										//}
										data_BalTree dadd;
										dadd.countsosed = count_sosed[isc];
										//dadd.ii = ii_2;
										dadd.i = isc;

										if (bAVL) {

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
												break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
												break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}
											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}

										if (bmaxsosedinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_sosed[isc] >= Maximumsosedcount) {
												Maximumsosedcount = count_sosed[isc];
											}
										}
									}

								}

							}
						}

						// Очистка (восстановление хеш таблицы).
						for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
							hash_table2[istack2[i_54]] = false;
						}
						itop_stack2 = 0; // стек снова готов к работе.

						
					} // the end
					else {
						// 13 января 2016. Новая логика.
						// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
						// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
						// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
						// Это было при magic=0.4
						// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
						integer itop_stack2 = 0;

						// На основе  старого варианта просто очищенного от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							doublerealT threshold9 = -1.0;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (Amat[is0].j != Amat[ii_11].i) {
									if (fabs(Amat[is0].aij) > threshold9) {
										threshold9 = fabs(Amat[is0].aij);
									}
								}
							}

							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (fabs(Amat[is0].aij) > theta*threshold9) {
									if (flag[Amat[is0].j] == false) {


										integer isc = Amat[is0].j;

										// Избавляемся от повторных инкрементаций.
										// В 2D на пятиточечном шаблоне повторные инкрементации составляют
										// около 33%.
										// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
										// на ряде тестовых задач при таком подходе агломерация проходила очень
										// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
										// Эта проблема проявилась на задачах :
										// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
										// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
										// Проблема не в этом месте кода.
										if (hash_table2[isc] == false) {
											hash_table2[isc] = true;
											istack2[itop_stack2] = isc;
											itop_stack2++;

											integer ii_2 = row_startA[isc];


											integer ic2 = 0;
											integer iend2loc = nnz_a[ilevel - 1] + iadd;
											integer istart2 = ii_2;
											while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
											istart2++;
											// Определяем модуль максимального внедиагонального элемента.
											doublerealT threshold_loc1 = -1.0; // инициализация порога.
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (fabs(Amat[is01].aij) > threshold_loc1) {
														threshold_loc1 = fabs(Amat[is01].aij);
													}
												}
											}
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (Amat[is01].j == set[js]) {
														// только Strong связи
														// по крайней мере именно так рекомендуют в литературе.
														if (fabs(Amat[is01].aij) > theta*threshold_loc1) {
															ic2++;
														}
													}
												}
											}

											if (ic2 > 0) {
												// Только если были Strong связи приводящие к инкрементации счётчика ic2.


												data_BalTree dsearch;
												dsearch.countsosed = count_sosed[isc];
												//dsearch.ii = ii_2;
												dsearch.i = isc;
												count_sosed[isc] += ic2;
												data_BalTree dadd;
												dadd.countsosed = count_sosed[isc];
												//dadd.ii = ii_2;
												dadd.i = isc;

												if (bAVL) {

													// добавляем элемент в АВЛ дерево,
													// причём если элемент уже находился в дереве то он модифицируется.
													// 12 декабря 2015.
													// Добавление узла происходит за логарифмическое по основанию 2 время,
													// причём после добавления дерево остаётся сбалансированным.
													// Адельсон-Вельский и Ландис 1962.
													switch (id_tree)
													{
													case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
														break;
													case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
														break;
													default: root = insert_and_modify(root, dadd, dsearch);
														break;
													}
													if (bAVL_deb)
													{
														printf("insert and modify\n");
													}
												}
											}

											if (bmaxsosedinfoactive) {
												// Обновляем информацию о максимальном количестве соседей.
												if (count_sosed[isc] >= Maximumsosedcount) {
													Maximumsosedcount = count_sosed[isc];
												}
											}
										}

									}
								}

							}
						}

						// Очистка (восстановление хеш таблицы).
						for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
							hash_table2[istack2[i_54]] = false;
						}
						itop_stack2 = 0; // стек снова готов к работе.


					} 

				

				n_coarce++; // Увеличено количество С узлов.

							// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
						   //if (maxsosed == -1) {
#if doubleintprecision == 1
						   //printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
						   //printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
						   
						   //system("pause");
						   //}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxsosed = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

				// На основе линейного поиска (медленный вариант на больших размерностях).

				const integer ipool_size_limit = 256000; // 128000
				//integer ipool[ipool_size_limit];
				integer* ipool = new integer[ipool_size_limit];

				for (integer isc = 0; isc < ic; isc++) {
					integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
					integer ii_c = ii_s;
					//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
					//ii_c++;
					while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
						integer icandidateq = ii_c;
						bool found1 = false;
						for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
							if (i_7 < ipool_size_limit) {
								if (ipool[i_7] == icandidateq) {
									found1 = true;
								}
							}
							else {
							#if doubleintprecision == 1
								printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
								printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								system("pause");
								exit(1);
							}
						}
						// элемент в списке не обнаружен, поэтому запомним индекс.
						if (found1 == false) {
							isize_p++;
							if (isize_p < ipool_size_limit) {
								ipool[isize_p] = icandidateq;
							}
							else {
							#if doubleintprecision == 1
									printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
									printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								system("pause");
								exit(1);
							}
						}
						ii_c++;
					}
				}
				delete[] ipool;

			}
			else if (0){

				// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

				// На основе АВЛ дерева.
				//const integer ipool_size_limit = 256000; // 128000
				//integer ipool[ipool_size_limit];
				//integer* ipool = new integer[ipool_size_limit];

				node_AVL_Gus* root_Gus = 0;

				for (integer isc = 0; isc < ic; isc++) {
					integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
					integer ii_c = ii_s;
					//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
					//ii_c++;
					while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
						integer icandidateq = ii_c;
						bool found1 = false;
						found1 = isfound_Gus(root_Gus, icandidateq);
						//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
							//if (i_7 < ipool_size_limit) {
								//if (ipool[i_7] == icandidateq) {
									//found1 = true;
								//}
							//}
							//else {
							#if doubleintprecision == 1
									//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
									//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								//system("pause");
								//exit(1);
							//}
						//}
						// элемент в списке не обнаружен, поэтому запомним индекс.
						if (found1 == false) {
							isize_p++;

							root_Gus = insert_Gus(root_Gus, icandidateq);

							//if (isize_p < ipool_size_limit) {
								//ipool[isize_p] = icandidateq;
							//}
							//else {
							#if doubleintprecision == 1
								//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
								//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
								
								//system("pause");
								//exit(1);
							//}
						}
						ii_c++;
					}
				}
				//delete[] ipool;
				clear_AVL_Gus(root_Gus);
				root_Gus = 0;

				// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

				// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

				// На основе hash таблицы.
				//const integer ipool_size_limit = 256000; // 128000
				//integer ipool[ipool_size_limit];
				//integer* ipool = new integer[ipool_size_limit];

				//node_AVL_Gus* root_Gus = 0;
				// Нельзя это вызывать это очень медленно.
				//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
				integer itop = 0; // указатель на вершину стека.

				for (integer isc = 0; isc < ic; isc++) {
					integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
					integer ii_c = ii_s;
					//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
					//ii_c++;
					while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
						integer icandidateq = ii_c;
						bool found1 = false;
						//found1 = isfound_Gus(root_Gus, icandidateq);
						found1 = hash_table[icandidateq - iadd];

						//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
						//if (i_7 < ipool_size_limit) {
						//if (ipool[i_7] == icandidateq) {
						//found1 = true;
						//}
						//}
						//else {
						#if doubleintprecision == 1
								//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
						#else
								//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
						#endif
						
						//system("pause");
						//exit(1);
						//}
						//}
						// элемент в списке не обнаружен, поэтому запомним индекс.
						if (found1 == false) {
							isize_p++;

							//root_Gus = insert_Gus(root_Gus, icandidateq);
							hash_table[icandidateq - iadd] = true;
							if (itop < istack_size_limit ) {
								istack[itop] = icandidateq - iadd;
								itop++;
							}
							else {
								printf("itop>=istack_size_limit nado uvelichit istack_size_limit");
							}

							//if (isize_p < ipool_size_limit) {
							//ipool[isize_p] = icandidateq;
							//}
							//else {
							#if doubleintprecision == 1
									//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
							#else
									//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
							#endif
							
							//system("pause");
							//exit(1);
							//}
						}
						ii_c++;
					}
				}
				//delete[] ipool;
				//clear_AVL_Gus(root_Gus);
				//root_Gus = 0;

				for (integer isc = itop - 1; isc >= 0; isc--) {
					hash_table[istack[isc]] = false;
				}
				itop = 0;

				// На основе сбалансированного АВЛ дерева поиска.
			}
			*/


		//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxsosedinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				default: emax = findmax(root);
					break;
				}

				
				switch (id_tree) {
				case AVL_TREE_ID :
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID :
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						root_splay = 0;
						size_splay_Tree = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				default :
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				}
				

				

			}

#if doubleintprecision == 1
			//printf("maximum number of sosed=%lld\n",maxsosed);
#else
			//printf("maximum number of sosed=%d\n",maxsosed);
#endif
			
			if (maxsosed == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxsosed == -1)) {
				bcontinue = false;
			}

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C-F разбиения. создано.

		//delete[] bmarkervisit;
		free(bmarkervisit);

		if (bprint_mesage_diagnostic) {
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID :
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}
			
		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		integer ipromah_oneF = 0;

		integer iadditionalCstatistic = 0;

		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1] == true) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				// старая версия до 10 января 2016.
				//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
				// 10 января 2016. на основе хеширования.
				integer i_2 = row_startA[i_1];

				bool bvisit = false;
				for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j] == true) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
					newCcount++;
				}

				// 1 января 2015 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false)&&(icsos == 1)) {
					// bvisit и так true т.к. icsos==1.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					bweSholdbeContinue = true;
				}

			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}




		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		integer* C_numerate = NULL;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(C_numerate,"C_numerate","classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = NULL;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C-F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");

			

			// C-F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполляции : 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
			
			ap_coarse[0] = 0.0;

			
			

			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8] == true) {
				// Старая версия до 10 января 2016. Время O(log2(nnz))
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// 10 января 2016 новая версия на основе хеширования. Время O(1).
				integer ii1 = row_startA[i8];
				// бинарный поиск должен гарантирует нахождение самого левого представителя.
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {
						
						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();
			}

			// верно 2 октября.
			
			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполляция.
				// К тому же чрезвычайно простая.

				if (0) {

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

				    ipromah = 0;
				    ipromah_one = 0;
				    // Построение пролонгации для узлов которые составляют F nodes.
				    // Каждый F-nodes окружён C-nodes.
				    for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					    // Нам нужен разреженный оператор Галёркина.
					    // 5 декабря 2015 года мы попробуем увеличить разреженность
					    // оператора интерполляции а значит и оператора Галёркина.
					    doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
					    //integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
					    for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						    if (Amat[is0].j != Amat[ii1].i) {
							    // Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							    //if (this_is_C_node[Amat[is0].j] == true) {
							    if (fabs(Amat[is0].aij) > maxelem_threshold) {
							    	maxelem_threshold = fabs(Amat[is0].aij);
							    }
						    	//}
					    	}
					   }
					   // Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					   // Найти соседей данного F-node которые C-node.
					   integer icsos = 0;

					   // Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					   // Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					   doublerealT sumP = 0.0;
					   for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						   if (Amat[is0].j != Amat[ii1].i) {
							   if (this_is_C_node[Amat[is0].j] == true) {
								   //	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								   if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									   sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									   icsos++;
								   }
						    	}
							    else {
								   // Подсчитываем количество соседей которые не являются С узлами.
								   ipromah++; // подсчитываем проблемы интерполяции 
							    }
						   }
					   }
					   if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					   // 1 января 2016 Один сосед это недостаточно.
					   // Поэтому в случае одного соседа делаем такой узел С узлом.
					   if ((false) && (icsos == 1)) {
						    this_is_F_node[i8] = false;
						    this_is_C_node[i8] = true;
						    bweSholdbeContinue = true;
					   }
					   else {



						    for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							    if (Amat[is0].j != Amat[ii1].i) {
								    if (this_is_C_node[Amat[is0].j] == true) {

									     if (fabs(sumP) < RealZERO) {
										     //printf("error interpolation zero diagonal sumP.\n");
										     //printf("Fnode all sosed is F");
										     //system("pause");
										     //printf("i8 is Dirichlet node\n");
										     this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										     this_is_C_node[i8] = true;
										     bweSholdbeContinue = true;
										     iadditionalCstatistic++;
										     //exit(1);
										     // здесь нужна непрямая интерполляция.
									     }
									     else {

									     	// Внедиагональный элемент из множества С узлов.

										    // Данная вставка должна существенно сохранять 
										    // разреженность оператора Галёркина на глубоких 
									    	// сеточных уровнях.
										    // Модификация 5 декабря 2015.
										    //if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										    if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											   P[icount1].j = i8;
											   P[icount1].i = C_numerate[Amat[is0].j];
											   P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											   icount1++;
										    }
                                  
									    }

			      					}
					    		}
						    }

					    }

			    	}
				}
				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполляция с элементам непрямой.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторн запускаем алгоритм построения с учётом уже добавленных С узлов.


					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


													   // 1 января 2015 Один сосед это недостаточно.
													   // Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполляция.
								bool* empty_interpol = NULL;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_2", icount_StronglyF);
								
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								bool bCinsert = false;

								// Сканируем сильных F соседей данного F узла для которого надо построить интерполляцию.
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//O(log2(nnz))
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												// O(1)
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Будем рассматривать только действительно сильных C кандидатов второго уровня.
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
															}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j] == true) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполляция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													bCinsert = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

												}

												i_38_count++;

											}
										}
									}
								}

								if (!bCinsert) {
									// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

									bool bstandart_vjzov = true;
									for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
										// 3 января. На самом деле здесь хорошо бы посмотреть вариант
										// когда с не менее чем двух сторон интерполляция сработала, здесь 
										// же срабатывание было лишь с одной из сторон как минимум.
										if (empty_interpol[i_38] == true) {
											bstandart_vjzov = false;
										}
									}
									if (bstandart_vjzov) {
										this_is_F_node[i8] = false;
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
									}
								}

								free(empty_interpol); 

							}



							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполляция с элементам непрямой. Экспериментальный вариант. TODO.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей или имеют недостаточное число С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

					// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполляцию.
					// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
					// двух  C соседей учитывая эффект непрямой интерполляции.


					ipromah = 0;
					ipromah_one = 0;
					ipromah_oneF = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}


													   // 1 января 2015 Один сосед это недостаточно.
													   // Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполляция.
								bool* empty_interpol = NULL;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_2", icount_StronglyF);
								
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Будем рассматривать только действительно сильных С кандидатов второго уровня.
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
															}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j] == true) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполляция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне вложенности.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
												}

												i_38_count++;

											}
										}
									}
								}

								bool bstandart_vjzov = true;
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									// 3 января. На самом деле здесь хорошо бы посмотреть вариант
									// когда с не менее чем двух сторон интерполляция сработала, здесь 
									// же срабатывание было лишь с одной из сторон как минимум.
									if (empty_interpol[i_38] == true) {
										bstandart_vjzov = false;
									}
								}
								if (bstandart_vjzov) {
									this_is_F_node[i8] = false;
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
								}

								free(empty_interpol);

							}
							else if ((icsos == 1)&&(icsosF!=0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполляционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


													//}
												}
										}
									}
								}
							}
							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (1) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = 0.23; // оптимальный выбор.

					// четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					    //6interpolation 0.4 6.77 11 26 28.355
						//6interpolation 0.45 6.6 10 27 28.151
						//6interpolation 0.5 6.42 12 32 28.735
						//4interpolation 0.4 3.7  52 24.736 // best
						//4interpolation 0.3 3.78 13 59 27.525
						//4interpolation 0.5 3.61 12 55 25.533
						//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij)>maxelem_threshold_theta) {
										    sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
											    SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}

							

							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									//SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												if (this_is_C_node[Amat[is0].j] == true) {

													// 20 января 2016.
													// По-моему этой ситуации вообще быть не может так как у нас 
													// заведомо один С сосед.
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													

												}
												
											}
										}
									}
								}
								else {

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (this_is_C_node[Amat[is0].j] == true) {
										if (Amat[is0].j != Amat[ii1].i) {
											

												// 20 jan 2016.
												// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


												if (fabs(sumP) < RealZERO) {
													// Это случай когда вообще нет сильных С соседей.


													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													byes_add = true; // Были добавления узлов.
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												

											}
										}
									}
								}

							}

						}

					}

					

					if (!byes_add) {

					// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
					doublerealT magic = 0.4; // 0.4 optimum
					// линейный прогноз не дает улучшений
					// ни по быстрдействию ни по числу V циклов.
					//magic = 0.5 - 0.2*ilevel / 12.0;

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						integer istr_etalon1 = Amat[ii1].i;
						integer iend_for1 = -1;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == istr_etalon1); is0++) {
							iend_for1 = is0;
							if (Amat[is0].j != istr_etalon1) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
						doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
					    //	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						for (integer is0 = ii1; is0 <= iend_for1; is0++) {
							if (Amat[is0].j != istr_etalon1) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										
										
											if (this_is_C_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}
												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
														// Рассматриваем Strong F связи.

														// Смысл :
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														integer istr_etalon = Amat[ii1_loc].i;
														integer iend_for = -1;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == istr_etalon); is0_loc++) {
															iend_for = is0_loc;
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (Amat[is0_loc].j != istr_etalon) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (Amat[is0_loc].j != istr_etalon) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

														// В общем это двойная интерполляционная сумма 
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
														    if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (Amat[is0_loc].j != istr_etalon) {
																
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																	if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
												}
										}
									
								}
							}
							else {

								// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
								// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
								// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
								// bmodify_interpol4_amg = false;
								// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
								bool bmodify_interpol4_amg = false;
								doublerealT magic2 = 0.5;

								// Подготовительный этап к усилению четвертой интерполяции 
								// Усиление интерполяции происходит без добавления новых С узлов.
								// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
								// имеется конечно.
								// Подготовительный этап заключается в определении положения is0_candidate самой сильной
								// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
								doublerealT sum1 = 0.0;
								integer is0_candidate = -1;
								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											if (this_is_C_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
												if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
													if (fabs(Amat[is0].aij) > sum1) {
														sum1 = fabs(Amat[is0].aij);
														is0_candidate = is0;
													}
												}
											}
										}
									}

									if (sum1 / sumP < magic2) {
										// Если найденный элемент слишком слабый ничего не делаем с этим С,
										// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
										sum1 = 0.0;
										is0_candidate = -1;

										// Тогда ищем среди Weakly F узлов кандидата.
										for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_F_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
													    if (fabs(Amat[is0].aij) > sum1) {
															sum1 = fabs(Amat[is0].aij);
															is0_candidate = is0;
														}
													}
												}
											}
										}

										// такой узел F должен стать новым С узлом.
										if (sum1 / sumP >= magic2) {
											this_is_F_node[i8] = false; // Этот узел  станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											byes_add = true;
											iadditionalCstatistic++;
											
										}
										// Обязательный сброс перед рестартом чтобы не было деления на ноль.
										sum1 = 0.0;
										is0_candidate = -1;

									}
								}


								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {

											

											if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
												// Мы усиливаем силу интерполяции без добавления новых узлов за
												// счёт одной дополнительной самой сильной Weakly C связи.
												// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

												 ioneStrongC_and_0_StrongF++;
												 if ( is0_candidate != -1) {
													 P[icount1].j = i8;
													 P[icount1].i = C_numerate[Amat[is0_candidate].j];
													 P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
													 icount1++;
												 }

												 //if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												 if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												     P[icount1].j = i8;
													 P[icount1].i = C_numerate[Amat[is0].j];
													 P[icount1].aij = fabs(Amat[is0].aij) / (sumP+sum1);
													 icount1++;
												 }
											}
											else {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}

										}
									}
								}
							}

						}
					}

					}
#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				if (0) {
					// пятая попытка.
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл :
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														// В общем это двойная интерполляционная сумма
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять
																	// разреженность оператора Галёркина на глубоких
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
												}
												
										
									}
								}
							}

						}

					}
				}

				if (0) {

					bool byes_add = false;
					//  быстрая проверка на добавление.
					if (1) {
						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							 {

								 if ((icsos == 1) && (icsosF != 0)) {
									 // Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									 //
									 SumPall += sumP;

									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {
											 // Нас интересуют только Strong связи.
											 if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												 if (this_is_C_node[Amat[is0].j] == true) {

													 if (fabs(sumP) < RealZERO) {
														 //printf("error interpolation zero diagonal sumP.\n");
														 //printf("Fnode all sosed is F");
														 //system("pause");
														 //	printf("i8 is Dirichlet node\n");
														 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														 this_is_C_node[i8] = true;
														 bweSholdbeContinue = true;
														 iadditionalCstatistic++;
														 byes_add = true;
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
													 }


												 }

											 }
										 }
									 }
								 }
								 else {



									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {

											 if (this_is_C_node[Amat[is0].j] == true) {

												 if (fabs(sumP) < RealZERO) {
													 //printf("error interpolation zero diagonal sumP.\n");
													 //printf("Fnode all sosed is F");
													 //system("pause");
													 //printf("i8 is Dirichlet node\n");
													 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													 this_is_C_node[i8] = true;
													 bweSholdbeContinue = true;
													 iadditionalCstatistic++;
													 byes_add = true;
													 //exit(1);
													 // здесь нужна непрямая интерполляция.
												 }


											 }



										 }
									 }



								 }

							 }

						}
					}


					// Проверка на добавление пройдена успешно, 
					// добавлений не было и можно интерполировать !!!.
					if (byes_add == false) {

						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (this_is_C_node[Amat[is0].j] == true) {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}

												}
												else
													if (this_is_F_node[Amat[is0].j] == true) {

														// Рассматриваем Strong F связи.

														// Смысл :
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполляционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
											}
										}
									}
								}
								else {

									SumPall += sumP;
									doublerealT sum_ok = 0.0;
									bool bbackreturn = false;
									integer icount1_mem = icount1;
									bool* bbackrarr = NULL;
									//bbackrarr = new bool[icount_StronglyF];
									bbackrarr = (bool*)malloc(icount_StronglyF*sizeof(bool));
									handle_error<bool>(bbackrarr, "bbackrarr", "classic_aglomerative_amg_2", icount_StronglyF);
									
									for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
										bbackrarr[i_63] = false;
									}
									integer icounter_bbackarr = -1;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {

											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														P[icount1].aij = fabs(Amat[is0].aij);
														sum_ok += fabs(Amat[is0].aij);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл :
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														icounter_bbackarr++;

														integer iFpoint = Amat[is0].j;
														//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														doublerealT mult1 = fabs(Amat[is0].aij);
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														icsos_loc = 0;
														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc1 = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
																		sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																		//	}
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														if (icsos_loc > 0) {
															// В общем это двойная интерполляционная сумма
															for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
																if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																	if (this_is_C_node[Amat[is0_loc].j] == true) {
																		// Внедиагональный элемент из множества С узлов.

																		// Данная вставка должна существенно сохранять
																		// разреженность оператора Галёркина на глубоких
																		// сеточных уровнях.
																		// Модификация 5 декабря 2015.
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																			//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																			P[icount1].j = i8;
																			P[icount1].i = C_numerate[Amat[is0_loc].j];
																			//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																			//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			icount1++;
																		}
																		//}
																	}
																}
															}
														}
														else {
															//bbackreturn = true;
															bbackrarr[icounter_bbackarr] = true;
														}


														//}
													}
												}


										}
									}


									//bbackreturn = true;
									//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
									//if (!bbackrarr[i_63]) {
									//	bbackreturn = false;
									//}
									//}

									//if (bbackreturn) {
									// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
									// варианту интерполяции.
									//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
									//P[i_95].aij = P[i_95].aij*SumPall / sumP;
									//}
									//}

									// Апосториорная корекция
									for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
										P[i_95].aij = P[i_95].aij / sum_ok;
									}

									free(bbackrarr);

								}

							}

						}
					}
				
				}

			}
			else if (true) {


				// Экспериментальная интерполляция 1 января 2016.

				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполляции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;

					doublerealT SumPall = 0.0;
					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							// Сумма вообще всех внедиагональных элементов.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij);
							}


							if (this_is_C_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									icsos++;
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


												   // 1 января 2015 Один сосед это недостаточно.
												   // Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
									//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//ipromah_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполляционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
														}
													}
												}
											}


										}
									}
							}
						}

					}


				}
			}
			else {
				// От интерполляции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполляции.
				// Эта интерполляция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.


				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполляции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					//integer icsos = 0;

					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					doublerealT sumPindicator = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								else {
									sumPindicator += fabs(Amat[is0].aij);
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															  //icsos++;
								}
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
						else {
							// Диагональный элемент.
							sumP += fabs(Amat[is0].aij);
						}
					}
					//if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					//if ((false) && (icsos == 1)) {
						//this_is_F_node[i8] = false;
						//this_is_C_node[i8] = true;
						//bweSholdbeContinue = true;
					//}
					//else
					{

						if (fabs(sumPindicator) < RealZERO) {
							//printf("error interpolation zero diagonal sumP.\n");
							//printf("Fnode all sosed is F");
							//system("pause");
							//printf("i8 is Dirichlet node\n");
							this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							//exit(1);
							// здесь нужна непрямая интерполляция.

							// Мы не будем добалять С узлы, мы будем использовать непрямую интерполляцию.



						}
						else {

							integer icount1_frozen = icount1;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connectors.

											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
										}


									}
								}
							}

							integer ilength_n = icount1 - icount1_frozen;
							integer* jposition_in_P = NULL;
							//jposition_in_P = new integer[ilength_n];
							jposition_in_P = (integer*)malloc(ilength_n*sizeof(integer));
							handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_2", ilength_n);
							
							

							integer i_97 = 0;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connections j position.
											jposition_in_P[i_97] = Amat[is0].j;
											i_97++;
										}
									}
								}
							}


							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strong F connections
											doublerealT my_mult = fabs(Amat[is0].aij);
											integer iFpoint = Amat[is0].j;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];

											// Смотрим всех соседей узла iFpoint
											// если среди них окажутся сильные С соседи 
											// первоначально рассматриваемого узла Amat[ii1].i
											// то мы будем накапливать в сумматоре sum23 
											// модули значеий матрицы.
											doublerealT sum23 = 0.0;
											bool bvisit23 = false;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														for (i_97 = 0; i_97 < ilength_n; i_97++) {
															if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																sum23 += fabs(Amat[is0_loc].aij);
																bvisit23 = true;
																break;
															}
														}
													}
												}
											}

											//if (fabs(sum23) > RealZERO) {
											if (bvisit23) {
												// мы точно не делим на ноль.

												// Сканируем всех соседей узла F.
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	//P[icount1_frozen + i_97].j = i8;
																	//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																	P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																	break;
																}
															}
														}
													}
												}
											}


										}
									}
								}
							}

							//delete[] jposition_in_P;
							free(jposition_in_P);

						}

					}


				}
			}


		
			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				free(ap_coarse);
				ap_coarse = NULL;
				if (bprint_mesage_diagnostic) {
					printf("obratnaq svqz restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes procent %3.1f", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");
		

		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				// Быстрая сортировка Хоара.
				qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);

		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1,false);
			}
			else {
				qs(R, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1);
		}


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = 0.5*ap_coarse[R[i_1].i];
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		free(ap_coarse);





		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закоментировано.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
		}
		else {
			HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Нахождение матрицы грубосеточного уровня :
		// Acorse=R*Afine*P;
		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
		}
		else {
			HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/
		// Преобразование к формату CRS.

		integer* row_ind_SR = NULL;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		integer* row_ind_ER = NULL;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		integer istart1 = 1 + iaddR;
		integer iend1 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}
		for (integer ii = istart1; ii <= iend1; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SR[istr] = ic;
				row_ind_ER[istr] = kf;
				flag[R[ii].i] = true;
			}
		}

		// Пустые строки просто отсутствуют.
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
		//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
		//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
		//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
		
		//}
		//}

		integer* row_ind_SA = NULL;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer* row_ind_EA = NULL;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer istart3 = 1 + iadd;
		integer iend3 = nnz_a[ilevel - 1] + iadd;
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}
		for (integer ii = istart3; ii <= iend3; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SA[istr] = ic;
				row_ind_EA[istr] = kf;
				flag[Amat[ii].i] = true;
			}
		}

		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

		// Данные используемые для частичного формирователя суммы.
		doublerealT* vector_sum = NULL;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		integer* index_visit = NULL;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer index_size = 0;

		


		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// Закоментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполляции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else {

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}

			
			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				if (istr != jstr) {
					// 14 января 2016.
					// Правильнее определить величину барьера только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					if (istr != jstr) {
						// 5 декабря 2015. threshold.
						//if (fabs(vector_sum[jstr]) > 1.0e-30) {
						if (fabs(vector_sum[jstr]) > barjer*maxth) {
							Amat[istartAnew].aij = vector_sum[jstr];
							Amat[istartAnew].i = istr;
							Amat[istartAnew].j = jstr;
							istartAnew++;
						}
					}
					else {
						// диагональный элемент записываем обязательно.
						Amat[istartAnew].aij = vector_sum[jstr];
						Amat[istartAnew].i = istr;
						Amat[istartAnew].j = jstr;
						istartAnew++;
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					
					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
							//Amat[istartAnew].aij = vs1;
							//Amat[istartAnew].i = istr;
							//Amat[istartAnew].j = jstr;
							//istartAnew++;

							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;
							Amat[istartAnew++] = Atemp;

						}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}



		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		free(row_ind_SR);
		free(row_ind_ER);
		free(row_ind_SA);
		free(row_ind_EA);
		free(vector_sum);


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			else {
				qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
		}
		else
		{
			HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			//if (Amat[i_1].j < 0) {
			//	printf("error : negativ j index\n");
			//	system("pause");
			//}
#if doubleintprecision == 1
			//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		if (bqs) {
			// Обязательно нужна сортировка.
			if (bCounting_Sort) {
				Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
			}
			else {
				qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
			}
		}
		else {
			HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
			//if (Amat[i_1].j < 0) {
			//	printf("error : negativ j index\n");
			//	system("pause");
			//}
#if doubleintprecision == 1
			//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
			//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
			
			//system("pause");
		//}




		/*
        // 10 января 2016. Данная сортировка не требуется.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				qs(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода :
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно сумирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		integer* row_ind_AS = NULL;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		integer* row_ind_AE = NULL;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2 = istartAnew - 1;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart2; ii <= iend2; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend2) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				flag[Amat[ii].i] = true;

			}
		}

		integer* row_ind_PS = NULL;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		integer* row_ind_PE = NULL;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));

		
		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		integer istart4 = 1 + iaddR;
		integer iend4 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_2", (numberofcoarcenodes + 1));
		
		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_2", (n_a[ilevel - 1] + 1));
		
		index_visit[0] = 0;
		index_size = 0;

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							//if (index_visit[i_6] == iaddind) {
								//foundnow = true;
								//ifoundind = i_6;
								//break;
							//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			

			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}
			
			/*
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					// 15 декабря 2015.
					// Если не принять специальных мер элементы не будут упорядочены
					// и двоичным поиском воспользоваться нельзя.
					//if (index_visit[i_6] < index_visit[i_6 - 1]) {
					//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
					//system("pause");
					//}

					integer jstr = index_visit[i_6];
					if (istr != jstr) {
						// 5 декабря 2015 года. Сохранение разреженности.
						//if (fabs(vector_sum[jstr]) > 1.0e-30) {
						if (fabs(vector_sum[jstr]) > barjerA*maxth) {
							Amat[istartAnew2].aij = vector_sum[jstr];
							Amat[istartAnew2].i = istr;
							Amat[istartAnew2].j = jstr;
							istartAnew2++;
						}
					}
					else {
						Amat[istartAnew2].aij = vector_sum[jstr];
						Amat[istartAnew2].i = istr;
						Amat[istartAnew2].j = jstr;
						istartAnew2++;
					}
				}
			}			
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;

						//Amat[istartAnew2].aij = vs1;
						//Amat[istartAnew2].i = istr;
						//Amat[istartAnew2].j = jstr;
						//istartAnew2++;

						Amat[istartAnew2++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0;
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
		}

		//delete[] vector_sum;
		//delete[] index_visit;
		free(vector_sum);
		free(index_visit);


		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		free(row_ind_AS);
		free(row_ind_AE);
		free(row_ind_PS);
		free(row_ind_PE);




		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
			// Общее количество узлов не являющихся соседемя, но не С соседями 
#if doubleintprecision == 1
			printf("Error interpolation is count %lld\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%lld iz nih kol-vo beznadechnjh %lld\n", ipromah_one, ipromah_oneF);
#else
			printf("Error interpolation is count %d\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%d iz nih kol-vo beznadechnjh %d\n", ipromah_one, ipromah_oneF);
#endif
			
			//system("pause");
		}
		if (debug_reshime) system("pause");
		

		//delete[] C_numerate;
		free(C_numerate);

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = NULL;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}

			for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
				if (flag[Amat[ii77].i] == false) {
					integer istr77 = Amat[ii77].i;
					integer ic77 = ii77;
					//integer icdiag = ii77;
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
						if (Amat[ic77].j != istr77) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
						}
						else {
							ap = Amat[ic77].aij;
							//icdiag = ic77;
						}
						ic77++;
					}
					if (fabs(ap) < RealZERO) {
					#if doubleintprecision == 1
						printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
					#else
						printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
					#endif
						
						system("PAUSE");
						//exit(1);
					}

					flag[Amat[ii77].i] = true;

				}
			}
		}
		*/

		//проверка конец

		//delete[] count_sosed;
		free(count_sosed);
		//delete[] row_startA;
		free(row_startA);

	}// иерархия сеток построена.

	ilevel--;
	if (n_a[ilevel] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f", (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0]))));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = NULL;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("ilevel=%lld\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
#else
		printf("ilevel=%d\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
#endif
		
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);





	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel
	

	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=NULL;
	if (ilevel > 1) {
		diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=NULL;
	if (ilevel > 2) {
		diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = NULL;
	if (ilevel > 3) {
		diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = NULL;
	if (ilevel > 4) {
		diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = NULL;
	if (ilevel > 5) {
		diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = NULL;
	if (ilevel > 6) {
		diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = NULL;
	if (ilevel > 7) {
		diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = NULL;
	if (ilevel > 8) {
		diag8 = new doublerealT[n_a[8] + 1];
	}
	*/

     // Т.к. деление очень медленное то мы поделим лишь один раз.
     doublerealT *diag0 = NULL;
     //diag0 = new doublerealT[n_a[0] + 1];
	 diag0 = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	 handle_error<doublerealT>(diag0, "diag0", "classic_aglomerative_amg_2", (n_a[0] + 1));
	 
     doublerealT *diag1 = NULL;
     if (ilevel > 1) {
	     //diag1 = new doublerealT[n_a[1] + 1];
		 diag1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		 handle_error<doublerealT>(diag1, "diag1", "classic_aglomerative_amg_2", (n_a[1] + 1));
     }
     doublerealT *diag2 = NULL;
     if (ilevel > 2) {
	    //diag2 = new doublerealT[n_a[2] + 1];
		diag2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag2, "diag2", "classic_aglomerative_amg_2", (n_a[2] + 1));
     }
     doublerealT *diag3 = NULL;
     if (ilevel > 3) {
	     //diag3 = new doublerealT[n_a[3] + 1];
		 diag3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
		 handle_error<doublerealT>(diag3, "diag3", "classic_aglomerative_amg_2", (n_a[3] + 1));
     }
     doublerealT *diag4 = NULL;
     if (ilevel > 4) {
	    //diag4 = new doublerealT[n_a[4] + 1];
		diag4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag4, "diag4", "classic_aglomerative_amg_2", (n_a[4] + 1));
     }
     doublerealT *diag5 = NULL;
     if (ilevel > 5) {
	    //diag5 = new doublerealT[n_a[5] + 1];
		diag5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag5, "diag5", "classic_aglomerative_amg_2", (n_a[5] + 1));
     }
     doublerealT *diag6 = NULL;
     if (ilevel > 6) {
	    //diag6 = new doublerealT[n_a[6] + 1];
		diag6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag6, "diag6", "classic_aglomerative_amg_2", (n_a[6] + 1));
     }
     doublerealT *diag7 = NULL;
     if (ilevel > 7) {
    	//diag7 = new doublerealT[n_a[7] + 1];
		diag7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag7, "diag7", "classic_aglomerative_amg_2", (n_a[7] + 1));
     }
     doublerealT *diag8 = NULL;
     if (ilevel > 8) {
	   // diag8 = new doublerealT[n_a[8] + 1];
		diag8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag8, "diag8", "classic_aglomerative_amg_2", (n_a[8] + 1));
     }

	 bnested_desection_global_amg = NULL;
	 bool *nested_desection0 = NULL;
	 bool *nested_desection1 = NULL;
	 bool *nested_desection2 = NULL;
	 bool *nested_desection3 = NULL;
	 bool *nested_desection4 = NULL;
	 bool *nested_desection5 = NULL;
	 bool *nested_desection6 = NULL;
	 bool *nested_desection7 = NULL;
	 bool *nested_desection8 = NULL;
	 if (!bonly_serial) {
		 // nested desection start
		 bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		 handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_2", (n_a[0] + 1));

		
		 nested_desection0 = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		 handle_error<bool>(nested_desection0, "nested_desection0", "classic_aglomerative_amg_2", (n_a[0] + 1));
		
		
		 if (ilevel > 1) {
			 nested_desection1 = (bool*)malloc((n_a[1] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection1, "nested_desection1", "classic_aglomerative_amg_2", (n_a[1] + 1));
		 }
		
		 if (ilevel > 2) {
			 nested_desection2 = (bool*)malloc((n_a[2] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection2, "nested_desection2", "classic_aglomerative_amg_2", (n_a[2] + 1));
		 }
		 
		 if (ilevel > 3) {
			 nested_desection3 = (bool*)malloc((n_a[3] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection3, "nested_desection3", "classic_aglomerative_amg_2", (n_a[3] + 1));
		 }
		
		 if (ilevel > 4) {
			 nested_desection4 = (bool*)malloc((n_a[4] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection4, "nested_desection4", "classic_aglomerative_amg_2", (n_a[4] + 1));
		 }
		 
		 if (ilevel > 5) {
			 nested_desection5 = (bool*)malloc((n_a[5] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection5, "nested_desection5", "classic_aglomerative_amg_2", (n_a[5] + 1));
		 }
		 
		 if (ilevel > 6) {
			 nested_desection6 = (bool*)malloc((n_a[6] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection6, "nested_desection6", "classic_aglomerative_amg_2", (n_a[6] + 1));
		 }
		 
		 if (ilevel > 7) {
			 nested_desection7 = (bool*)malloc((n_a[7] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection7, "nested_desection7", "classic_aglomerative_amg_2", (n_a[7] + 1));
		 }
		 
		 if (ilevel > 8) {
			 nested_desection8 = (bool*)malloc((n_a[8] + 1)*sizeof(bool));
			 handle_error<bool>(nested_desection8, "nested_desection8", "classic_aglomerative_amg_2", (n_a[8] + 1));
		 }
	 }
	 // nested_desection_end

	 integer *row_ptr_start = NULL;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	 row_ptr_start = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	 handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_2", (4 * n_a[0] + 1));
	
	integer *row_ptr_end = NULL;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_2", (4 * n_a[0] + 1));
	
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			diag0[Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	bool bstop = false;
	// первый уровень вложенности.
	if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}

		for (integer ii = nnz_a[0] + 1; ii <= nnz_a[0] + nnz_a[1]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr);
#else
					printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr);
#endif
					
					system("PAUSE");
					//exit(1);
					bstop = true;
				}
				else {

					flag[Amat[ii].i] = true;
					Ak1 temp = Amat[ii];
					Amat[ii] = Amat[icdiag];
					Amat[icdiag] = temp;
					diag1[Amat[ii].i] = ap; // для ускорения вычисления невязки.
					Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.

				}


			}
		}
	}

	if (bstop) exit(1);

	// второй уровень вложенности.

	if (ilevel > 2) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 2 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 2 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag2[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// третий уровень вложенности.

	if (ilevel > 3) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = nnz_a[0] + nnz_a[1] + nnz_a[2] + 1; ii <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3]) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 3 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 3 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag3[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// 14 сентября 2015 понедельник
	// четвёртый уровень вложенности.

	if (ilevel > 4) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 4 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 4 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag4[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}


	// пятый уровень вложенности.

	if (ilevel > 5) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 5 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 5 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag5[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// шестой уровень вложенности.

	if (ilevel > 6) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 6 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 6 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag6[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// седьмой уровень вложенности.

	if (ilevel > 7) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]] = ic - 1;
				if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 7 matrix", istr);
#else
					printf("zero diagonal elements in string %d in level 7 matrix", istr);
#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag7[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}

	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
		integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
		for (integer ii = ist; ii <= iend; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer icdiag = ii;
				row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
				doublerealT ap = 0.0;
				//x[istr] = b[istr];
				while ((ic <= iend) && (Amat[ic].i == istr)) {
					if (Amat[ic].j != istr) {
						//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					}
					else {
						ap = Amat[ic].aij;
						icdiag = ic;
					}
					ic++;
				}
				row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
				if (fabs(ap) < RealZERO) {
				#if doubleintprecision == 1
					printf("zero diagonal elements in string %lld in level 7 matrix", istr);
				#else
					printf("zero diagonal elements in string %d in level 7 matrix", istr);
				#endif
					
					system("PAUSE");
					exit(1);
				}
				else {
					//x[istr] /= ap;
				}

				flag[Amat[ii].i] = true;
				Ak1 temp = Amat[ii];
				Amat[ii] = Amat[icdiag];
				Amat[icdiag] = temp;
				diag8[Amat[ii].i] = ap; // для ускорения вычисления невязки.
				Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
			}
		}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection0
		nested_desection_patch(Amat, n_a[0], nested_desection0, row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection1
		nested_desection_patch(Amat, n_a[1], nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
		if (bprint_mesage_diagnostic) {
			printf("part2\n");
		}
		nested_desection_patch(Amat, n_a[2], nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
		if (bprint_mesage_diagnostic) {
			printf("part3\n");
		}
		nested_desection_patch(Amat, n_a[3], nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
		if (bprint_mesage_diagnostic) {
			printf("part4\n");
		}
		nested_desection_patch(Amat, n_a[4], nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
		if (bprint_mesage_diagnostic) {
			printf("part5\n");
		}
		nested_desection_patch(Amat, n_a[5], nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
		if (bprint_mesage_diagnostic) {
			printf("part6\n");
		}
		nested_desection_patch(Amat, n_a[6], nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
		if (bprint_mesage_diagnostic) {
			printf("part7\n");
		}
		nested_desection_patch(Amat, n_a[7], nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
		if (bprint_mesage_diagnostic) {
			printf("part8 \n");
			printf("nested desection is finish\n");
		}

	}
	

	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=NULL) {
	   free(this_is_C_node);
	   this_is_C_node=NULL;
	}
	if (this_is_F_node!=NULL) {
	   free(this_is_F_node);
       this_is_F_node=NULL;
	}
	//delete[] hash_table;
	free(hash_table);
	free(hash_table2);
	//delete[] istack;
	//delete[] istack2;
	free(istack);
	free(istack2);


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

	integer nFinestSweeps = 3;
	// для Finner Heat Sink надо усилить сглаживания.
	// Это не помогает будет перенаправление на другой алгоритм.
	//nu1 = 3;
	//nu2 = 3;
	//nFinestSweeps = 6;


	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = 0.7;
	doublerealT process_flow_alpha = 0.1;
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.


	doublerealT *residual_fine =NULL;
	//residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = NULL;
	doublerealT* error_approx_coarse = NULL;
	doublerealT *residual_fine1 = NULL;
	doublerealT *residual_coarse1 = NULL;
	doublerealT* error_approx_coarse1 = NULL;
	doublerealT *error_approx_fine1 = NULL;
	doublerealT *residual_fine2 = NULL;
	doublerealT *residual_coarse2 = NULL;
	doublerealT* error_approx_coarse2 = NULL;
	doublerealT *error_approx_fine2 = NULL;
	doublerealT *residual_fine3 = NULL;
	doublerealT *residual_coarse3 = NULL;
	doublerealT* error_approx_coarse3 = NULL;
	doublerealT *error_approx_fine3 = NULL;
	doublerealT *residual_fine4 = NULL;
	doublerealT *residual_coarse4 = NULL;
	doublerealT *error_approx_coarse4 = NULL;
	doublerealT *error_approx_fine4 = NULL;
	doublerealT *residual_fine5 = NULL;
	doublerealT *residual_coarse5 = NULL;
	doublerealT* error_approx_coarse5 = NULL;
	doublerealT *error_approx_fine5 = NULL;
	doublerealT *residual_fine6 = NULL;
	doublerealT *residual_coarse6 = NULL;
	doublerealT* error_approx_coarse6 = NULL;
	doublerealT *error_approx_fine6 = NULL;
	doublerealT *residual_fine7 = NULL;
	doublerealT *residual_coarse7 = NULL;
	doublerealT* error_approx_coarse7 = NULL;
	doublerealT *error_approx_fine7 = NULL;
	doublerealT *residual_fine8 = NULL;
	doublerealT *residual_coarse8 = NULL;
	doublerealT* error_approx_coarse8 = NULL;
	doublerealT *error_approx_fine8 = NULL;
	doublerealT *residual_fine9 = NULL;
	doublerealT *residual_coarse9 = NULL;
	doublerealT* error_approx_coarse9 = NULL;
	doublerealT *error_approx_fine9 = NULL;
	doublerealT *residual_fine10 = NULL;
	doublerealT *residual_coarse10 = NULL;
	doublerealT* error_approx_coarse10 = NULL;
	doublerealT *error_approx_fine10 = NULL;
	doublerealT *residual_fine11 = NULL;
	doublerealT *residual_coarse11 = NULL;
	doublerealT* error_approx_coarse11 = NULL;
	doublerealT *error_approx_fine11 = NULL;
	doublerealT *residual_fine12 = NULL;
	doublerealT *residual_coarse12 = NULL;
	doublerealT* error_approx_coarse12 = NULL;
	doublerealT *error_approx_fine12 = NULL;
	doublerealT *residual_fine13 = NULL;
	doublerealT *residual_coarse13 = NULL;
	doublerealT* error_approx_coarse13 = NULL;
	doublerealT *error_approx_fine13 = NULL;
	doublerealT *residual_fine14 = NULL;
	doublerealT *residual_coarse14 = NULL;
	doublerealT* error_approx_coarse14 = NULL;
	doublerealT *error_approx_fine14 = NULL;
	doublerealT *residual_fine15 = NULL;
	doublerealT *residual_coarse15 = NULL;
	doublerealT* error_approx_coarse15 = NULL;
	doublerealT *error_approx_fine15 = NULL;
	doublerealT *residual_fine16 = NULL;
	doublerealT *residual_coarse16 = NULL;
	doublerealT* error_approx_coarse16 = NULL;
	doublerealT *error_approx_fine16 = NULL;
	doublerealT *residual_fine17 = NULL;
	doublerealT *residual_coarse17 = NULL;
	doublerealT* error_approx_coarse17 = NULL;
	doublerealT *error_approx_fine17 = NULL;

	/*
	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	if (residual_fine == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for residual_fine in classic_aglomerative_amg2 my_agregat_amg...\n");
		printf("Please any key to exit...\n");
		//getchar();
		system("pause");
		exit(1);
	}
	if (ilevel > 1) {
		residual_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = new doublerealT[n_a[1] + 1];
		if (ilevel > 2) {
			// residual
			residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_fine1 = new doublerealT[n_a[1] + 1];
			if (ilevel > 3) {
				// residual
				residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_fine2 = new doublerealT[n_a[2] + 1];
				if (ilevel > 4) {
					// residual
					residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_fine3 = new doublerealT[n_a[3] + 1];
					if (ilevel > 5) {
						// residual
						residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_fine4 = new doublerealT[n_a[4] + 1];
						if (ilevel > 6) {
							// residual
							residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_fine5 = new doublerealT[n_a[5] + 1];
							if (ilevel > 7) {
								// residual
								residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_fine6 = new doublerealT[n_a[6] + 1];
								if (ilevel > 8) {
									// residual
									residual_fine7 = new doublerealT[n_a[7] + 1];
									residual_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_fine7 = new doublerealT[n_a[7] + 1];
									if (ilevel > 9) {
										// residual
										residual_fine8 = new doublerealT[n_a[8] + 1];
										residual_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_fine8 = new doublerealT[n_a[8] + 1];
										if (ilevel > 10) {
											// residual
											residual_fine9 = new doublerealT[n_a[9] + 1];
											residual_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_fine9 = new doublerealT[n_a[9] + 1];
											if (ilevel > 11) {
												// residual
												residual_fine10 = new doublerealT[n_a[10] + 1];
												residual_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_fine10 = new doublerealT[n_a[10] + 1];
												if (ilevel > 12) {
													// residual
													residual_fine11 = new doublerealT[n_a[11] + 1];
													residual_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_fine11 = new doublerealT[n_a[11] + 1];
													if (ilevel > 13) {
														// residual
														residual_fine12 = new doublerealT[n_a[12] + 1];
														residual_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_fine12 = new doublerealT[n_a[12] + 1];
														if (ilevel > 14) {
															// residual
															residual_fine13 = new doublerealT[n_a[13] + 1];
															residual_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_fine13 = new doublerealT[n_a[13] + 1];
															if (ilevel > 15) {
																// residual
																residual_fine14 = new doublerealT[n_a[14] + 1];
																residual_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_fine14 = new doublerealT[n_a[14] + 1];
																if (ilevel > 16) {
																	// residual
																	residual_fine15 = new doublerealT[n_a[15] + 1];
																	residual_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_fine15 = new doublerealT[n_a[15] + 1];
																	if (ilevel > 17) {
																		// residual
																		residual_fine16 = new doublerealT[n_a[16] + 1];
																		residual_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_fine16 = new doublerealT[n_a[16] + 1];
																		if (ilevel > 18) {
																			// residual
																			residual_fine17 = new doublerealT[n_a[17] + 1];
																			residual_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_fine17 = new doublerealT[n_a[17] + 1];

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
	*/

// лучше выделять оперативную память небольшими блоками т.к.
// оперативная память фрагментирована системными dll и
// большого свободного блока может не найтись.


residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
handle_error<doublerealT>(residual_fine, "residual_fine", "classic_aglomerative_amg_2", (n_a[0] + 1));

if (ilevel > 1) {
	//residual_coarse = new doublerealT[n_a[1] + 1];
	residual_coarse = (doublerealT*)malloc((n_a[1]+1)*sizeof(doublerealT));
	handle_error<doublerealT>(residual_coarse, "residual_coarse", "classic_aglomerative_amg_2", (n_a[1] + 1));
	
	//error_approx_coarse = new doublerealT[n_a[1] + 1];
	error_approx_coarse = (doublerealT*)malloc((n_a[1]+1)*sizeof(doublerealT));
	handle_error<doublerealT>(error_approx_coarse, "error_approx_coarse", "classic_aglomerative_amg_2", (n_a[1] + 1));
	
	if (ilevel > 2) {
		// residual
		//residual_fine1 = new doublerealT[n_a[1] + 1];
		residual_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_fine1, "residual_fine1", "classic_aglomerative_amg_2", (n_a[1] + 1));
		
		//residual_coarse1 = new doublerealT[n_a[2] + 1];
		residual_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_coarse1, "residual_coarse1", "classic_aglomerative_amg_2", (n_a[2] + 1));
		
		//error_approx_coarse1 = new doublerealT[n_a[2] + 1];
		error_approx_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_coarse1, "error_approx_coarse1", "classic_aglomerative_amg_2", (n_a[2] + 1));
		
		//error_approx_fine1 = new doublerealT[n_a[1] + 1];
		error_approx_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_fine1, "error_approx_fine1", "classic_aglomerative_amg_2", (n_a[1] + 1));
		
		if (ilevel > 3) {
			// residual
			//residual_fine2 = new doublerealT[n_a[2] + 1];
			residual_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_fine2, "residual_fine2", "classic_aglomerative_amg_2", (n_a[2] + 1));
			
			//residual_coarse2 = new doublerealT[n_a[3] + 1];
			residual_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse2, "residual_coarse2", "classic_aglomerative_amg_2", (n_a[3] + 1));
			
			//error_approx_coarse2 = new doublerealT[n_a[3] + 1];
			error_approx_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse2, "error_approx_coarse2", "classic_aglomerative_amg_2", (n_a[3] + 1));
			
			//error_approx_fine2 = new doublerealT[n_a[2] + 1];
			error_approx_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine2, "error_approx_fine2", "classic_aglomerative_amg_2", (n_a[2] + 1));
			
			if (ilevel > 4) {
				// residual
				//residual_fine3 = new doublerealT[n_a[3] + 1];
				residual_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_fine3, "residual_fine3", "classic_aglomerative_amg_2", (n_a[3] + 1));
				
				//residual_coarse3 = new doublerealT[n_a[4] + 1];
				residual_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_coarse3, "residual_coarse3", "classic_aglomerative_amg_2", (n_a[4] + 1));
				
				//error_approx_coarse3 = new doublerealT[n_a[4] + 1];
				error_approx_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_coarse3, "error_approx_coarse3", "classic_aglomerative_amg_2", (n_a[4] + 1));
				
				//error_approx_fine3 = new doublerealT[n_a[3] + 1];
				error_approx_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_fine3, "error_approx_fine3", "classic_aglomerative_amg_2", (n_a[3] + 1));
				
				if (ilevel > 5) {
					// residual
					//residual_fine4 = new doublerealT[n_a[4] + 1];
					residual_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_fine4, "residual_fine4", "classic_aglomerative_amg_2", (n_a[4] + 1));
					
					//residual_coarse4 = new doublerealT[n_a[5] + 1];
					residual_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_coarse4, "residual_coarse4", "classic_aglomerative_amg_2", (n_a[5] + 1));
					
					//error_approx_coarse4 = new doublerealT[n_a[5] + 1];
					error_approx_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_coarse4, "error_approx_coarse4", "classic_aglomerative_amg_2", (n_a[5] + 1));
					
					//error_approx_fine4 = new doublerealT[n_a[4] + 1];
					error_approx_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_fine4, "error_approx_fine4", "classic_aglomerative_amg_2", (n_a[4] + 1));
					
					if (ilevel > 6) {
						// residual
						//residual_fine5 = new doublerealT[n_a[5] + 1];
						residual_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_fine5, "residual_fine5", "classic_aglomerative_amg_2", (n_a[5] + 1));
						
						//residual_coarse5 = new doublerealT[n_a[6] + 1];
						residual_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_coarse5, "residual_coarse5", "classic_aglomerative_amg_2", (n_a[6] + 1));
						
						//error_approx_coarse5 = new doublerealT[n_a[6] + 1];
						error_approx_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_coarse5, "error_approx_coarse5", "classic_aglomerative_amg_2", (n_a[6] + 1));
						
						//error_approx_fine5 = new doublerealT[n_a[5] + 1];
						error_approx_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_fine5, "error_approx_fine5", "classic_aglomerative_amg_2", (n_a[5] + 1));
						
						if (ilevel > 7) {
							// residual
							//residual_fine6 = new doublerealT[n_a[6] + 1];
							residual_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_fine6, "residual_fine6", "classic_aglomerative_amg_2", (n_a[6] + 1));
							
							//residual_coarse6 = new doublerealT[n_a[7] + 1];
							residual_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_coarse6, "residual_coarse6", "classic_aglomerative_amg_2", (n_a[7] + 1));
							
							//error_approx_coarse6 = new doublerealT[n_a[7] + 1];
							error_approx_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_coarse6, "error_approx_coarse6", "classic_aglomerative_amg_2", (n_a[7] + 1));
							
							//error_approx_fine6 = new doublerealT[n_a[6] + 1];
							error_approx_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_fine6, "error_approx_fine6", "classic_aglomerative_amg_2", (n_a[6] + 1));
							
							if (ilevel > 8) {
								// residual
								//residual_fine7 = new doublerealT[n_a[7] + 1];
								residual_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_fine7, "residual_fine7", "classic_aglomerative_amg_2", (n_a[7] + 1));
								
								//residual_coarse7 = new doublerealT[n_a[8] + 1];
								residual_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_coarse7, "residual_coarse7", "classic_aglomerative_amg_2", (n_a[8] + 1));
								
								//error_approx_coarse7 = new doublerealT[n_a[8] + 1];
								error_approx_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_coarse7, "error_approx_coarse7", "classic_aglomerative_amg_2", (n_a[8] + 1));
								
								//error_approx_fine7 = new doublerealT[n_a[7] + 1];
								error_approx_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_fine7, "error_approx_fine7", "classic_aglomerative_amg_2", (n_a[7] + 1));
								
								if (ilevel > 9) {
									// residual
									//residual_fine8 = new doublerealT[n_a[8] + 1];
									residual_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_fine8, "residual_fine8", "classic_aglomerative_amg_2", (n_a[8] + 1));
									
									//residual_coarse8 = new doublerealT[n_a[9] + 1];
									residual_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_coarse8, "residual_coarse8", "classic_aglomerative_amg_2", (n_a[9] + 1));
									
									//error_approx_coarse8 = new doublerealT[n_a[9] + 1];
									error_approx_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_coarse8, "error_approx_coarse8", "classic_aglomerative_amg_2", (n_a[9] + 1));
									
									//error_approx_fine8 = new doublerealT[n_a[8] + 1];
									error_approx_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_fine8, "error_approx_fine8", "classic_aglomerative_amg_2", (n_a[8] + 1));
									
									if (ilevel > 10) {
										// residual
										//residual_fine9 = new doublerealT[n_a[9] + 1];
										residual_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_fine9, "residual_fine9", "classic_aglomerative_amg_2", (n_a[9] + 1));
										
										//residual_coarse9 = new doublerealT[n_a[10] + 1];
										residual_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_coarse9, "residual_coarse9", "classic_aglomerative_amg_2", (n_a[10] + 1));
										
										//error_approx_coarse9 = new doublerealT[n_a[10] + 1];
										error_approx_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_coarse9, "error_approx_coarse9", "classic_aglomerative_amg_2", (n_a[10] + 1));
										
										//error_approx_fine9 = new doublerealT[n_a[9] + 1];
										error_approx_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_fine9, "error_approx_fine9", "classic_aglomerative_amg_2", (n_a[9] + 1));
										
										if (ilevel > 11) {
											// residual
											//residual_fine10 = new doublerealT[n_a[10] + 1];
											residual_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_fine10, "residual_fine10", "classic_aglomerative_amg_2", (n_a[10] + 1));
											
											//residual_coarse10 = new doublerealT[n_a[11] + 1];
											residual_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_coarse10, "residual_coarse10", "classic_aglomerative_amg_2", (n_a[11] + 1));
											
											//error_approx_coarse10 = new doublerealT[n_a[11] + 1];
											error_approx_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_coarse10, "error_approx_coarse10", "classic_aglomerative_amg_2", (n_a[11] + 1));
											
											//error_approx_fine10 = new doublerealT[n_a[10] + 1];
											error_approx_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_fine10, "error_approx_fine10", "classic_aglomerative_amg_2", (n_a[10] + 1));
											
											if (ilevel > 12) {
												// residual
												//residual_fine11 = new doublerealT[n_a[11] + 1];
												residual_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_fine11, "residual_fine11", "classic_aglomerative_amg_2", (n_a[11] + 1));
												
												//residual_coarse11 = new doublerealT[n_a[12] + 1];
												residual_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_coarse11, "residual_coarse11", "classic_aglomerative_amg_2", (n_a[12] + 1));
												
												//error_approx_coarse11 = new doublerealT[n_a[12] + 1];
												error_approx_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_coarse11, "error_approx_coarse11", "classic_aglomerative_amg_2", (n_a[12] + 1));
												
												//error_approx_fine11 = new doublerealT[n_a[11] + 1];
												error_approx_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_fine11, "error_approx_fine11", "classic_aglomerative_amg_2", (n_a[11] + 1));
												
												if (ilevel > 13) {
													// residual
													//residual_fine12 = new doublerealT[n_a[12] + 1];
													residual_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_fine12, "residual_fine12", "classic_aglomerative_amg_2", (n_a[12] + 1));
													
													//residual_coarse12 = new doublerealT[n_a[13] + 1];
													residual_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_coarse12, "residual_coarse12", "classic_aglomerative_amg_2", (n_a[13] + 1));
													
													//error_approx_coarse12 = new doublerealT[n_a[13] + 1];
													error_approx_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_coarse12, "error_approx_coarse12", "classic_aglomerative_amg_2", (n_a[13] + 1));
													
													//error_approx_fine12 = new doublerealT[n_a[12] + 1];
													error_approx_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_fine12, "error_approx_fine12", "classic_aglomerative_amg_2", (n_a[12] + 1));
													
													if (ilevel > 14) {
														// residual
														//residual_fine13 = new doublerealT[n_a[13] + 1];
														residual_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_fine13, "residual_fine13", "classic_aglomerative_amg_2", (n_a[13] + 1));
														
														//residual_coarse13 = new doublerealT[n_a[14] + 1];
														residual_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_coarse13, "residual_coarse13", "classic_aglomerative_amg_2", (n_a[14] + 1));
														
														//error_approx_coarse13 = new doublerealT[n_a[14] + 1];
														error_approx_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_coarse13, "error_approx_coarse13", "classic_aglomerative_amg_2", (n_a[14] + 1));
														
														//error_approx_fine13 = new doublerealT[n_a[13] + 1];
														error_approx_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_fine13, "error_approx_fine13", "classic_aglomerative_amg_2", (n_a[13] + 1));
														
														if (ilevel > 15) {
															// residual
															//residual_fine14 = new doublerealT[n_a[14] + 1];
															residual_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_fine14, "residual_fine14", "classic_aglomerative_amg_2", (n_a[14] + 1));
															
															//residual_coarse14 = new doublerealT[n_a[15] + 1];
															residual_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_coarse14, "residual_coarse14", "classic_aglomerative_amg_2", (n_a[15] + 1));
															
															//error_approx_coarse14 = new doublerealT[n_a[15] + 1];
															error_approx_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_coarse14, "error_approx_coarse14", "classic_aglomerative_amg_2", (n_a[15] + 1));
															
															//error_approx_fine14 = new doublerealT[n_a[14] + 1];
															error_approx_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_fine14, "error_approx_fine14", "classic_aglomerative_amg_2", (n_a[14] + 1));
															
															if (ilevel > 16) {
																// residual
																//residual_fine15 = new doublerealT[n_a[15] + 1];
																residual_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_fine15, "residual_fine15", "classic_aglomerative_amg_2", (n_a[15] + 1));
																
																//residual_coarse15 = new doublerealT[n_a[16] + 1];
																residual_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_coarse15, "residual_coarse15", "classic_aglomerative_amg_2", (n_a[16] + 1));
																
																//error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																error_approx_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_coarse15, "error_approx_coarse15", "classic_aglomerative_amg_2", (n_a[16] + 1));
																
																//error_approx_fine15 = new doublerealT[n_a[15] + 1];
																error_approx_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_fine15, "error_approx_fine15", "classic_aglomerative_amg_2", (n_a[15] + 1));
																
																if (ilevel > 17) {
																	// residual
																	//residual_fine16 = new doublerealT[n_a[16] + 1];
																	residual_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_fine16, "residual_fine16", "classic_aglomerative_amg_2", (n_a[16] + 1));
																	
																	//residual_coarse16 = new doublerealT[n_a[17] + 1];
																	residual_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_coarse16, "residual_coarse16", "classic_aglomerative_amg_2", (n_a[17] + 1));
																
																	//error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																	error_approx_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_coarse16, "error_approx_coarse16", "classic_aglomerative_amg_2", (n_a[17] + 1));
																	
																	//error_approx_fine16 = new doublerealT[n_a[16] + 1];
																	error_approx_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_fine16, "error_approx_fine16", "classic_aglomerative_amg_2", (n_a[16] + 1));
																	
																	if (ilevel > 18) {
																		// residual
																		//residual_fine17 = new doublerealT[n_a[17] + 1];
																		residual_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_fine17, "residual_fine17", "classic_aglomerative_amg_2", (n_a[17] + 1));
																		
																		//residual_coarse17 = new doublerealT[n_a[18] + 1];
																		residual_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_coarse17, "residual_coarse17", "classic_aglomerative_amg_2", (n_a[18] + 1));
																		
																		//error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																		error_approx_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_coarse17, "error_approx_coarse17", "classic_aglomerative_amg_2", (n_a[18] + 1));
																		
																		//error_approx_fine17 = new doublerealT[n_a[17] + 1];
																		error_approx_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_fine17, "error_approx_fine17", "classic_aglomerative_amg_2", (n_a[17] + 1));
																		

																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
doublerealT *error_approx_fine = NULL;
//error_approx_fine = new doublerealT[n_a[0] + 1];
error_approx_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
handle_error<doublerealT>(error_approx_fine, "error_approx_fine", "classic_aglomerative_amg_2", (n_a[0] + 1));



	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	const integer ZERO_INIT = 0;
	const integer RANDOM_INIT = 1;// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	integer imyinit =  ZERO_INIT; // ZERO_INIT optimum

	doublerealT* x_copy = NULL;
	x_copy = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_copy, "x_copy", "classic_aglomerative_amg_2", (n_a[0] + 1));

	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_copy[i47] = x[i47];
	}

	doublerealT* x_best_search = NULL;
	x_best_search = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_best_search, "x_best_search", "classic_aglomerative_amg_2", (n_a[0] + 1));

	doublerealT res_best_search = 1e40;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
	}


	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;
	integer istop_porog_reconst = 50;

	bool ret_value = false;
	doublerealT dres_previos = 1.0e40;
	integer icount_bad_convergence_Vcycles = 0;
	integer i_count_stagnation = 0;
	doublerealT res0start = 1.0e-40;
	bool bfirst_divergence = true;

	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		if (iter_limit == 1) {
			// начальная невязка.
			res0start = fabs(dres);
		}
		
		if (fabs(dres) < res_best_search)
		{
			// Запоминаем лучшую попытку.
			res_best_search = fabs(dres);
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
			}
		}

		if (iter_limit > 2000) { // Finner Heat Sink
			if (bfirst_divergence) {
				iter_limit = 3;
				nu1 += 2;
				nu2 += 2;
				nFinestSweeps+=2;
				bfirst_divergence = false;
			}
			else {
				if ((fabs(res_best_search / res0start) < 0.23) && (fabs(res_best_search) < 1.0e-3)) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				else if ((fabs(res_best_search / res0start) <= 1.0) && (fabs(res_best_search) < 1.0e-4)) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
				// Эта ветвь кода вообще никогда не вызовется.
				printf("Fatal amg error : Strong divergence amg solver...%e \n", fabs(res_best_search / res0start));
				printf("res_best_search=%e, res0start=%e\n", fabs(res_best_search), fabs(res0start));
				printf("BiCGStab+ILU2 is start now...\n");
				printf("please wait...");
				system("pause");
				break; // досрочный выход из while цикла.
			}
		}
		iter_limit++;

		if (fabs(dres) < fabs(dres_previos)) {
			// все нормально процесс сходится.
			icount_bad_convergence_Vcycles = 0;
		}
		else {
			icount_bad_convergence_Vcycles++;
		}

		//if (_finite(dres) == 0) {
		//if (fabs(dres) > 1.0e30)
		//{
			//printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			//for (integer i47 = 1; i47 <= n_a[0]; i47++) {
			//	x[i47] = x_copy[i47];
			//}
			//if (iter_limit > 100) {
			//	ret_value = true;
			//	break;
			//}
			//else {
		    // Увеличение количества сглаживающих итераций ни коим образом не 
		    // исправляет факт расходимости. 
			//	nu1++;
			//	nu2++;
			//	nFinestSweeps++;
		    // По видимому надо действовать очень тонкой настройкой параметра верхней релаксации omega optimal.
		    // Настройка omega optimal должна быть самообучающейся (адаптированной к задаче).
			//}
		//}
		if ((icount_bad_convergence_Vcycles >= istop_porog_reconst) || (fabs(dres) > 1.0e30)) {
			// детектировано 10 шагов расходимости подряд по-видимому метод расходится.
			// Также о расходимости говорит невязка большая 1.0e30.

			//if (fabs(dres) < 1.0e-3) break; // Будем считать сходимость достигнута успешно.
			if ((fabs(res_best_search / res0start) < 1.0e-1) && (fabs(dres) < 1.0e-3)) {
				// Если невязка меньше первоначальной на два порядка.
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
			}
			i_count_stagnation++;

			printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			if (i_count_stagnation < 20) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					x[i47] = x_best_search[i47]; // лучшее найденное решение
				}
			}
			if (i_count_stagnation == 20 || i_count_stagnation == 21) gold_const = 0.2;
			if ((i_count_stagnation >= 20) && (i_count_stagnation < 30)) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					// Можно еще единократно немного улучшить nu1 и nu2.
					doublerealT signumnow = 1.0;
					if (rand() % 2 == 0) signumnow = -1.0;
					x[i47] = signumnow *1.0*(rand() % 90 + 10) / 100.0; // Случайное число в интервале от 0 до 1.
				}
			}
			if (i_count_stagnation == 30 || i_count_stagnation == 31) gold_const = 0.2;
			if (i_count_stagnation >= 30) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = 1.0;
				}
			}
			if (bproblem_amg_convergence1) {
				if (bproblem_amg_convergence2) {
					if (bproblem_amg_convergence3) {
						// выход к вызову BiCGStab+ILU2.
						ret_value = true;
						break;
					}
					else {
						// смена omega.
						bproblem_amg_convergence3 = true;
						icount_bad_convergence_Vcycles = 0;
						buffers3omega = dres / dres_previos;
						printf("buffers1omega=%1.4f, buffers2omega=%1.4f, buffers3omega=%1.4f\n", buffers1omega, buffers2omega, buffers3omega);
					}
				}
				else {
					// смена omega.
					bproblem_amg_convergence2 = true;
					icount_bad_convergence_Vcycles = 0;
					buffers2omega = dres / dres_previos;
					printf("buffers1omega=%1.4f, buffers2omega=%1.4f\n", buffers1omega, buffers2omega);
					//istop_porog_reconst += 50; // 10, 20, 30, 40
					// Увеличение количества сглаживающих итераций ничего не даёт.
					//nu1++;
					//nu2++;
					//nFinestSweeps++;
				}
			}
			else {
				
				bproblem_amg_convergence1 = true; // переход с SOR на стабильный Зейдель.
				icount_bad_convergence_Vcycles = 0;
				buffers1omega = dres / dres_previos;
			}
		}

		dres_previos = dres;


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0=0.0, Rnext_0=0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			R0_0 = norma(residual_fine, n_a[0]);
			Rprev_0 = R0_0;
			
			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
		}
		dres = norma(residual_fine, n_a[0]);
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
			printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
			
		}
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;
		
		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			if (imyinit == ZERO_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = 0.0;
				}
			}
			
			if (imyinit == RANDOM_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = (rand()/((doublerealT)RAND_MAX));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
			doublerealT R0_1 = 0.0;
			doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
			if (process_flow_logic) {
				// calculate initial residual.
				//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1,diag1);

				R0_1 = norma(residual_fine1, n_a[1]);
				Rprev_1 = R0_1;

				// smother
				integer iter = 0;
				for (iter = 0; iter < nu1; iter++) {
					//quick seidel
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}

					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1,diag1);

					Rnext_1 = norma(residual_fine1, n_a[1]);
					// this is process flow logic
					if (Rnext_1 > process_flow_beta*Rprev_1) {
						// Смысл модификации в том что мы экономим итерации на пресмутере.
						break; // досрочно опускаемся на следующий уровень если он есть конечно.
					}
					else {
						Rprev_1 = Rnext_1;
					}
				}

				if (iter == nu1) {
					printf("level 1 limit presmother iteration is reached\n");
				}

			}
			else {

				// pre smothing
				for (integer iter = 0; iter < nu1; iter++) {
					//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}
				}
			}

			move_down(nu1, nu2);

			
			if (ilevel > 2) {
				// residual
				if (!process_flow_logic) {
					//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
					//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1,diag1);
					//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
				}

				//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

				// restriction
				restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

				// Amat*e=r;
				//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
				if (imyinit == ZERO_INIT) {
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] = 0.0;
					}
				}
				if (imyinit == RANDOM_INIT) {
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] = (rand() / ((doublerealT)RAND_MAX));
					}
				}

				//for (integer i_37 = 1; i_37 <= igam; i_37++)
				{
				doublerealT R0_2 = 0.0;
				doublerealT Rprev_2 = 0.0, Rnext_2 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
					residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);

					R0_2 = norma(residual_fine2, n_a[2]);
					Rprev_2 = R0_2;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}

						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);

						Rnext_2 = norma(residual_fine2, n_a[2]);
						// this is process flow logic
						if (Rnext_2 > process_flow_beta*Rprev_2) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_2 = Rnext_2;
						}
					}

					if (iter == nu1) {
						printf("level 2 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
					}

				}

				move_down(nu1, nu2);
				
				if (ilevel > 3) {
					// residual
					if (!process_flow_logic) {
						//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
						//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);
						//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
					}

					//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
					if (imyinit == ZERO_INIT) {
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] = 0.0;
						}
					}
					if (imyinit == RANDOM_INIT) {
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] = (rand() / ((doublerealT)RAND_MAX));
						}
					}
					//for (integer i_37 = 1; i_37 <= igam; i_37++)
					{
					doublerealT R0_3 = 0.0;
					doublerealT Rprev_3 = 0.0, Rnext_3 = 0.0;
					if (process_flow_logic) {
						// calculate initial residual.
						//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);


						R0_3 = norma(residual_fine3, n_a[3]);
						Rprev_3 = R0_3;

						// smother
						integer iter = 0;
						for (iter = 0; iter < nu1; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);


							Rnext_3 = norma(residual_fine3, n_a[3]);
							// this is process flow logic
							if (Rnext_3 > process_flow_beta*Rprev_3) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_3 = Rnext_3;
							}
						}

						if (iter == nu1) {
							printf("level 3 limit presmother iteration is reached\n");
						}

					}
					else {
						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
						}
					}


					move_down(nu1, nu2);

					
					if (ilevel > 4) {
						// residual
						if (!process_flow_logic) {
							//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);

							//speshial
							//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
						}


						//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
						if (imyinit == ZERO_INIT) {
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] = 0.0;
							}
						}
						if (imyinit == RANDOM_INIT) {
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] = (rand() / ((doublerealT)RAND_MAX));
							}
						}

						//for (integer i_37 = 1; i_37 <= igam; i_37++) 
						{
						doublerealT R0_4 = 0.0;
						doublerealT Rprev_4 = 0.0, Rnext_4 = 0.0;
						if (process_flow_logic) {
							// calculate initial residual.
							//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);


							R0_4 = norma(residual_fine4, n_a[4]);
							Rprev_4 = R0_4;

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu1; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}

								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);


								Rnext_4 = norma(residual_fine4, n_a[4]);
								// this is process flow logic
								if (Rnext_4 > process_flow_beta*Rprev_4) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_4 = Rnext_4;
								}
							}

							if (iter == nu1) {
								printf("level 4 limit presmother iteration is reached\n");
							}

						}
						else {
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
							}
						}


						move_down(nu1, nu2);
						
						if (ilevel > 5) {
							// residual
							if (!process_flow_logic) {
								//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);

								//speshial 14 september 2015.
								//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
							}


							//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
							if (imyinit == ZERO_INIT) {
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] = 0.0;
								}
							}
							if (imyinit == RANDOM_INIT) {
								for (integer ii = 1; ii <= n_a[5]; ii++) {
									error_approx_coarse4[ii] = (rand() / ((doublerealT)RAND_MAX));
								}
							}

							// pre smothing
							//for (integer i_37 = 1; i_37 <= igam; i_37++)
							{
							doublerealT R0_5 = 0.0;
							doublerealT Rprev_5 = 0.0, Rnext_5 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
								residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);



								R0_5 = norma(residual_fine5, n_a[5]);
								Rprev_5 = R0_5;

								// smother
								integer iter = 0;
								for (iter = 0; iter < nu1; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}

									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);


									Rnext_5 = norma(residual_fine5, n_a[5]);
									// this is process flow logic
									if (Rnext_5 > process_flow_beta*Rprev_5) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_5 = Rnext_5;
									}
								}

								if (iter == nu1) {
									printf("level 5 limit presmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
								}
							}


							move_down(nu1, nu2);
							
								if (ilevel > 6) {
									// residual
									if (!process_flow_logic) {
										//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
										//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
										//if (ilevel <= 15) {
										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);

										//}
										//else {
										// приводит к расходимости.
										//speshial 14 september 2015.
										// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
										//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										//}
									}

									//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
									if (imyinit == ZERO_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = 0.0;
										}
									}
									if (imyinit == RANDOM_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = (rand() / ((doublerealT)RAND_MAX));
										}
									}

									//for (integer i_37 = 1; i_37 <= igam; i_37++) 
									{
										// pre smothing

										doublerealT R0_6 = 0.0;
										doublerealT Rprev_6 = 0.0, Rnext_6 = 0.0;
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
											residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);



											R0_6 = norma(residual_fine6, n_a[6]);
											Rprev_6 = R0_6;

											// smother
											integer iter = 0;
											for (iter = 0; iter < nu1; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);


												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 > process_flow_beta*Rprev_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu1) {
												printf("level 6 limit presmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu1; iter++) {
												//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}


										move_down(nu1, nu2);

										if (ilevel > 7) {
											// residual
											if (!process_flow_logic) {
												//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
												//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);
											}

											//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

											// restriction
											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

											// Amat*e=r;
											//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
											if (imyinit == ZERO_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = 0.0;
												}
											}
											if (imyinit == RANDOM_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = (rand() / ((doublerealT)RAND_MAX));
												}
											}

											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
											{

												// pre smothing


												doublerealT R0_7 = 0.0;
												doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
													residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);



													R0_7 = norma(residual_fine7, n_a[7]);
													Rprev_7 = R0_7;

													// smother
													integer iter = 0;
													for (iter = 0; iter < nu1; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 > process_flow_beta*Rprev_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu1) {
														printf("level 7 limit presmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu1; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}


												move_down(nu1, nu2);

												if (ilevel > 8) {
													// residual
													if (!process_flow_logic) {
														//doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);
														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);

													}


													//doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

													// restriction
													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

													// Amat*e=r;
													//doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
													if (imyinit == ZERO_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = 0.0;
														}
													}
													if (imyinit == RANDOM_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = (rand() / ((doublerealT)RAND_MAX));
														}
													}

													//for (integer i_37 = 1; i_37 <= igam; i_37++)
													{
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
															//nested_desection8 futures

														}


														if (ilevel > 9) {
															// residual
															//doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
															residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


															//doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

															// Amat*e=r;
															//doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
															if (imyinit == ZERO_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = 0.0;
																}
															}
															if (imyinit == RANDOM_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = (rand() / ((doublerealT)RAND_MAX));
																}
															}

															//for (integer i_37 = 1; i_37 <= igam; i_37++) 
															{
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}

																// точное решение на подробном уровне лишь замедляет время счёта и нисколько не
																// улучшает сходимость.
																


																move_down(nu1, nu2);

																if (ilevel > 10) {
																	// 8 сентября 2015 РИМИНИ пляж 

																	// residual
																	//doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


																	//doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

																	// Amat*e=r;
																	//doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];


																	if (imyinit == ZERO_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = 0.0;
																		}
																	}
																	if (imyinit == RANDOM_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = (rand() / ((doublerealT)RAND_MAX));
																		}
																	}

																	//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																	{
																		// pre smothing
																		for (integer iter = 0; iter < nu1; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}

																		// до 11 уровня вроде всё верно 3 января 2016

																		move_down(nu1, nu2);

																		if (ilevel > 11) {
																			// 8 сентября 2015 РИМИНИ пляж 

																			// residual
																			//doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
																			integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


																			//doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

																			// restriction
																			integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

																			// Amat*e=r;
																			//doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];


																			if (imyinit == ZERO_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = 0.0;
																				}
																			}
																			if (imyinit == RANDOM_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = (rand() / ((doublerealT)RAND_MAX));
																				}
																			}

																			//for (integer i_37 = 1; i_37 <= igam; i_37++)
																			{
																				// pre smothing
																				for (integer iter = 0; iter < nu1; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}

																				move_down(nu1, nu2);

																				if (ilevel > 12) {
																					// 11 сентября 2015 РИМИНИ пляж 

																					// residual
																					//doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
																					integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


																					//doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

																					// restriction
																					integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

																					// Amat*e=r;
																					//doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];

																					if (imyinit == ZERO_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = 0.0;
																						}
																					}
																					if (imyinit == RANDOM_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = (rand() / ((doublerealT)RAND_MAX));
																						}
																					}

																					//for (integer i_37 = 1; i_37 <= igam; i_37++)
																					{
																						// pre smothing
																						for (integer iter = 0; iter < nu1; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}

																						move_down(nu1, nu2);

																						if (ilevel > 13) {
																							// 11 сентября 2015 РИМИНИ пляж 

																							// residual
																							//doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
																							integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


																							//doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

																							// restriction
																							integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

																							// Amat*e=r;
																							//doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];

																							if (imyinit == ZERO_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = 0.0;
																								}
																							}
																							if (imyinit == RANDOM_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = (rand() / ((doublerealT)RAND_MAX));
																								}
																							}

																							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																							{
																								// pre smothing
																								for (integer iter = 0; iter < nu1; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}


																								move_down(nu1, nu2);

																								if (ilevel > 14) {
																									// 11 сентября 2015 РИМИНИ пляж 

																									// residual
																									//doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																									integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																									//doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																									// restriction
																									integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																									// Amat*e=r;
																									//doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];

																									if (imyinit == ZERO_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = 0.0;
																										}
																									}
																									if (imyinit == RANDOM_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = (rand() / ((doublerealT)RAND_MAX));
																										}
																									}


																									//for (integer i_37 = 1; i_37 <= igam; i_37++)
																									{
																										// pre smothing
																										for (integer iter = 0; iter < nu1; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}


																										move_down(nu1, nu2);

																										if (ilevel > 15) {
																											// 14 сентября 2015 Москва на работе в пн. 

																											// residual
																											//doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																											integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																											//doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																											// restriction
																											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																											// Amat*e=r;
																											//doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																											if (imyinit == ZERO_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = 0.0;
																												}
																											}
																											if (imyinit == RANDOM_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = (rand() / ((doublerealT)RAND_MAX));
																												}
																											}

																											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																											{
																												// pre smothing
																												for (integer iter = 0; iter < nu1; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}


																												move_down(nu1, nu2);

																												if (ilevel > 16) {
																													// 10 октября 2015. 

																													// residual
																													//doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																													integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													residual(Amat, n1, n2, error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);


																													//doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																													// restriction
																													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													restriction(R, n3, n4, flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																													// Amat*e=r;
																													//doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];

																													if (imyinit == ZERO_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = 0.0;
																														}
																													}
																													if (imyinit == RANDOM_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = (rand() / ((doublerealT)RAND_MAX));
																														}
																													}

																													//for (integer i_37 = 1; i_37 <= igam; i_37++)
																													{
																														// pre smothing
																														for (integer iter = 0; iter < nu1; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}


																														move_down(nu1, nu2);

																														if (ilevel > 17) {
																															// 10 октября 2015. 

																															// residual
																															//doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															residual(Amat, n1, n2, error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);


																															//doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																															// restriction
																															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															restriction(R, n3, n4, flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																															// Amat*e=r;
																															//doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																															if (imyinit == ZERO_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = 0.0;
																																}
																															}
																															if (imyinit == RANDOM_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = (rand() / ((doublerealT)RAND_MAX));
																																}
																															}


																															//for (integer i_37 = 1; i_37 <= igam; i_37++)
																															{
																																// pre smothing
																																for (integer iter = 0; iter < nu1; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}

																																move_down(nu1, nu2);


																																if (ilevel > 18) {
																																	// 5 декабря 2015. 

																																	// residual
																																	//doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	residual(Amat, n1, n2, error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);


																																	//doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																																	// restriction
																																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	restriction(R, n3, n4, flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);

																																	// Amat*e=r;
																																	//doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];

																																	if (imyinit == ZERO_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = 0.0;
																																		}
																																	}
																																	if (imyinit == RANDOM_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = (rand() / ((doublerealT)RAND_MAX));
																																		}
																																	}


																																	//for (integer i_37 = 1; i_37 <= igam; i_37++)
																																	{
																																		// pre smothing
																																		for (integer iter = 0; iter < nu1; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}

																																		// post smothing
																																		for (integer iter = 0; iter < nu2; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}
																																	}

																																	// prolongation
																																	// residual_r
																																	//doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_fine17[ii] = 0.0;
																																	}



																																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	prolongation(P, n7, n8, flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																																	// correction
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_coarse16[ii] += error_approx_fine17[ii];
																																	}

																																	// free
																																	//delete[] error_approx_fine17;
																																	//delete[] error_approx_coarse17;
																																	//delete[] residual_coarse17;
																																	//delete[] residual_fine17;

																																}



																																// post smothing
																																for (integer iter = 0; iter < nu2; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}
																															}
																															move_up(nu1, nu2);

																															// prolongation
																															// residual_r
																															//doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_fine16[ii] = 0.0;
																															}



																															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															prolongation(P, n7, n8, flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																															// correction
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_coarse15[ii] += error_approx_fine16[ii];
																															}

																															// free
																															//delete[] error_approx_fine16;
																															//delete[] error_approx_coarse16;
																															//delete[] residual_coarse16;
																															//delete[] residual_fine16;

																														}


																														// post smothing
																														for (integer iter = 0; iter < nu2; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}
																													}
																													move_up(nu1, nu2);

																													// prolongation
																													// residual_r
																													//doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_fine15[ii] = 0.0;
																													}



																													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													prolongation(P, n7, n8, flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																													// correction
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_coarse14[ii] += error_approx_fine15[ii];
																													}

																													// free
																													//delete[] error_approx_fine15;
																													//delete[] error_approx_coarse15;
																													//delete[] residual_coarse15;
																													//delete[] residual_fine15;

																												}

																												// post smothing
																												for (integer iter = 0; iter < nu2; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}
																											}
																											move_up(nu1, nu2);

																											// prolongation
																											// residual_r
																											//doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_fine14[ii] = 0.0;
																											}



																											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																											// correction
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_coarse13[ii] += error_approx_fine14[ii];
																											}

																											// free
																											//delete[] error_approx_fine14;
																											//delete[] error_approx_coarse14;
																											//delete[] residual_coarse14;
																											//delete[] residual_fine14;

																										}


																										// post smothing
																										for (integer iter = 0; iter < nu2; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}
																									}

																									move_up(nu1, nu2);

																									// prolongation
																									// residual_r
																									//doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_fine13[ii] = 0.0;
																									}

#if doubleintprecision == 1
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#else
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#endif
																									

																									integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																									// correction
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_coarse12[ii] += error_approx_fine13[ii];
																									}

																									// free
																									//delete[] error_approx_fine13;
																									//delete[] error_approx_coarse13;
																									//delete[] residual_coarse13;
																									//delete[] residual_fine13;

																								}


																								// post smothing
																								for (integer iter = 0; iter < nu2; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}
																							}

																							move_up(nu1, nu2);

																							// prolongation
																							// residual_r
																							//doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_fine12[ii] = 0.0;
																							}

#if doubleintprecision == 1
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#else
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#endif
																							

																							integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

																							// correction
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_coarse11[ii] += error_approx_fine12[ii];
																							}

																							// free
																							//delete[] error_approx_fine12;
																							//delete[] error_approx_coarse12;
																							//delete[] residual_coarse12;
																							//delete[] residual_fine12;

																						}



																						// post smothing
																						for (integer iter = 0; iter < nu2; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}
																					}
																					move_up(nu1, nu2);

																					// prolongation
																					// residual_r
																					//doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_fine11[ii] = 0.0;
																					}

#if doubleintprecision == 1
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#else
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#endif
																					

																					integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

																					// correction
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_coarse10[ii] += error_approx_fine11[ii];
																					}

																					// free
																					//delete[] error_approx_fine11;
																					//delete[] error_approx_coarse11;
																					//delete[] residual_coarse11;
																					//delete[] residual_fine11;

																				}


																				// post smothing
																				for (integer iter = 0; iter < nu2; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}
																			}
																			move_up(nu1, nu2);

																			// prolongation
																			// residual_r
																			//doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_fine10[ii] = 0.0;
																			}

#if doubleintprecision == 1
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#else
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#endif
																			

																			integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

																			// correction
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_coarse9[ii] += error_approx_fine10[ii];
																			}

																			// free
																			//delete[] error_approx_fine10;
																			//delete[] error_approx_coarse10;
																			//delete[] residual_coarse10;
																			//delete[] residual_fine10;

																		}



																		// post smothing
																		for (integer iter = 0; iter < nu2; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}
																	}

																	move_up(nu1, nu2);

																	// prolongation
																	// residual_r
																	//doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_fine9[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif
																	

																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

																	// correction
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_coarse8[ii] += error_approx_fine9[ii];
																	}

																	// free
																	//delete[] error_approx_fine9;
																	//delete[] error_approx_coarse9;
																	//delete[] residual_coarse9;
																	//delete[] residual_fine9;

																}

																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}
															}

															move_up(nu1, nu2);

															// prolongation
															// residual_r
															//doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_fine8[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif
															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

															// correction
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_coarse7[ii] += error_approx_fine8[ii];
															}

															// free
															//delete[] error_approx_fine8;
															//delete[] error_approx_coarse8;
															//delete[] residual_coarse8;
															//delete[] residual_fine8;

														}




														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
														}
													}
													move_up(nu1, nu2);

													// prolongation
													// residual_r
													//doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_fine7[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif
													

													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

													// correction
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_coarse6[ii] += error_approx_fine7[ii];
													}

													// free
													//delete[] error_approx_fine7;
													//delete[] error_approx_coarse7;
													//delete[] residual_coarse7;
													//delete[] residual_fine7;

												}

												// post smothing
												//doublerealT R0_7 = 0.0;
												//doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);



													//Rprev_7 = norma(residual_fine7, n_a[7]);


													// smother
													integer iter = 0;
													for (iter = 0; iter < nu2; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7,diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 < process_flow_alpha*R0_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu2) {
														printf("level 7 limit postsmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu2; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}
											}

											move_up(nu1, nu2);


											// prolongation
											// residual_r
											//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_fine6[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif
											

											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

											// correction
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_coarse5[ii] += error_approx_fine6[ii];
											}

											// free
											//delete[] error_approx_fine6;
											//delete[] error_approx_coarse6;
											//delete[] residual_coarse6;
											//delete[] residual_fine6;

										}



										// post smothing
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);



											//Rprev_6 = norma(residual_fine6, n_a[6]);


											// smother
											integer iter = 0;
											for (iter = 0; iter < nu2; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6,diag6);



												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 < process_flow_alpha*R0_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu2) {
												printf("level 6 limit postsmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu2; iter++) {
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}
									}

									move_up(nu1, nu2);

									// prolongation
									// residual_r
									//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_fine5[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif
									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

									// correction
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] += error_approx_fine5[ii];
									}

									// free
									//delete[] error_approx_fine5;
									//delete[] error_approx_coarse5;
									//delete[] residual_coarse5;
									//delete[] residual_fine5;

								}
							


							// post smothing
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);



								//Rprev_5 = norma(residual_fine5, n_a[5]);


								// smother
								integer iter = 0;
								for (iter = 0; iter < nu2; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}

									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5,diag5);


									Rnext_5 = norma(residual_fine5, n_a[5]);
									// this is process flow logic
									if (Rnext_5 < process_flow_alpha*R0_5) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_5 = Rnext_5;
									}
								}

								if (iter == nu2) {
									printf("level 5 limit postsmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu2; iter++) {
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
									else
									{
										seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
									}
								}
							}
							}

							move_up(nu1, nu2);

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif
							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

						}
						



						// post smothing
						if (process_flow_logic) {
							

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu2; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}

								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] , residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4,diag4);


								Rnext_4 = norma(residual_fine4, n_a[4]);
								// this is process flow logic
								if (Rnext_4 < process_flow_alpha*R0_4) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_4 = Rnext_4;
								}
							}

							if (iter == nu2) {
								printf("level 4 limit postsmother iteration is reached\n");
							}

						}
						else {
							for (integer iter = 0; iter < nu2; iter++) {
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
								else {
									seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
								}
							}
						}
						}
						move_up(nu1, nu2);

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif
						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

					}
					


					// post smothing
					if (process_flow_logic) {


						// smother
						integer iter = 0;
						for (iter = 0; iter < nu2; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}

							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] , residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3,diag3);


							Rnext_3 = norma(residual_fine3, n_a[3]);
							// this is process flow logic
							if (Rnext_3 < process_flow_alpha*R0_3) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_3 = Rnext_3;
							}
						}

						if (iter == nu2) {
							printf("level 3 limit postsmother iteration is reached\n");
						}

					}
					else {
						for (integer iter = 0; iter < nu2; iter++) {
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
							else {
								seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
							}
						}
					}
					}

					move_up(nu1, nu2);

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif
				

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

				}
				

				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}

						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2,diag2);



						Rnext_2 = norma(residual_fine2, n_a[2]);
						// this is process flow logic
						if (Rnext_2 < process_flow_alpha*R0_2) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_2 = Rnext_2;
						}
					}

					if (iter == nu2) {
						printf("level 2 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
						else {
							seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
						}
					}
				}
				}

				move_up(nu1, nu2);

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif
				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

			}
			
			

			// post smothing
			if (process_flow_logic) {


				// smother
				integer iter = 0;
				for (iter = 0; iter < nu2; iter++) {
					//quick seidel
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}

					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1,diag1);


					Rnext_1 = norma(residual_fine1, n_a[1]);
					// this is process flow logic
					if (Rnext_1 < process_flow_alpha*R0_1) {
						// Смысл модификации в том что мы экономим итерации на пресмутере.
						break; // досрочно опускаемся на следующий уровень если он есть конечно.
					}
					else {
						Rprev_1 = Rnext_1;
					}
				}

				if (iter == nu2) {
					printf("level 1 limit postsmother iteration is reached\n");
				}

			}
			else {
				for (integer iter = 0; iter < nu2; iter++) {
					if (bonly_serial) {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
					}
					else {
						seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
					}
				}
			}
			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}
		


		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			Rprev_0 = norma(residual_fine, n_a[0]);

			// smother
			//integer iter = 0;
			//for (iter = 0; iter < nu2; iter++) {
				//quick seidel
			if (bonly_serial) {
				//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
			}
			else {
				//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
			}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			//	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			//	Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
			//	if (Rnext_0 < process_flow_alpha*R0_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
			//		break; // досрочно опускаемся на следующий уровень если он есть конечно.
			//	}
			//	else {
			//		Rprev_0 = Rnext_0;
			//	}
		//	}
			//if (iter == nu1) {
			//	printf("level 0 limit postsmother iteration is reached\n");
			//}

		}
		//else {
			// nFinnestSweeps new logic 14 jan 2016.
			// smother
			//for (integer iter = 0; iter < nu2; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
		if (bonly_serial) {
			//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}
		else {
			//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
		}
//			}
		//}



		


		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");

	


	// free
	/*
	delete[] diag0;
	delete[] error_approx_fine;
	if (ilevel > 1) {
		delete[] diag1;
		delete[] error_approx_coarse;
		delete[] residual_coarse;
		if (ilevel > 2) {
			// free
			delete[] diag2;
			delete[] error_approx_fine1;
			delete[] error_approx_coarse1;
			delete[] residual_coarse1;
			delete[] residual_fine1;
			if (ilevel > 3) {
				// free
				delete[] diag3;
				delete[] error_approx_fine2;
				delete[] error_approx_coarse2;
				delete[] residual_coarse2;
				delete[] residual_fine2;
				if (ilevel > 4) {
					// free
					delete[] diag4;
					delete[] error_approx_fine3;
					delete[] error_approx_coarse3;
					delete[] residual_coarse3;
					delete[] residual_fine3;
					if (ilevel > 5) {
						// free
						delete[] diag5;
						delete[] error_approx_fine4;
						delete[] error_approx_coarse4;
						delete[] residual_coarse4;
						delete[] residual_fine4;
						if (ilevel > 6) {
							// free
							delete[] diag6;
							delete[] error_approx_fine5;
							delete[] error_approx_coarse5;
							delete[] residual_coarse5;
							delete[] residual_fine5;
							if (ilevel > 7) {
								// free
								delete[] diag7;
								delete[] error_approx_fine6;
								delete[] error_approx_coarse6;
								delete[] residual_coarse6;
								delete[] residual_fine6;
								if (ilevel > 8) {
									// free
									delete[] diag8;
									delete[] error_approx_fine7;
									delete[] error_approx_coarse7;
									delete[] residual_coarse7;
									delete[] residual_fine7;
									if (ilevel > 9) {
										// free
										delete[] error_approx_fine8;
										delete[] error_approx_coarse8;
										delete[] residual_coarse8;
										delete[] residual_fine8;
										if (ilevel > 10) {
											// free
											delete[] error_approx_fine9;
											delete[] error_approx_coarse9;
											delete[] residual_coarse9;
											delete[] residual_fine9;
											if (ilevel > 11) {
												// free
												delete[] error_approx_fine10;
												delete[] error_approx_coarse10;
												delete[] residual_coarse10;
												delete[] residual_fine10;
												if (ilevel > 12) {
													// free
													delete[] error_approx_fine11;
													delete[] error_approx_coarse11;
													delete[] residual_coarse11;
													delete[] residual_fine11;
													if (ilevel > 13) {
														// free
														delete[] error_approx_fine12;
														delete[] error_approx_coarse12;
														delete[] residual_coarse12;
														delete[] residual_fine12;
														if (ilevel > 14) {
															// free
															delete[] error_approx_fine13;
															delete[] error_approx_coarse13;
															delete[] residual_coarse13;
															delete[] residual_fine13;
															if (ilevel > 15) {
																// free
																delete[] error_approx_fine14;
																delete[] error_approx_coarse14;
																delete[] residual_coarse14;
																delete[] residual_fine14;
																if (ilevel > 16) {
																	// free
																	delete[] error_approx_fine15;
																	delete[] error_approx_coarse15;
																	delete[] residual_coarse15;
																	delete[] residual_fine15;
																	if (ilevel > 17) {
																		// free
																		delete[] error_approx_fine16;
																		delete[] error_approx_coarse16;
																		delete[] residual_coarse16;
																		delete[] residual_fine16;
																		if (ilevel > 18) {
																			// free
																			delete[] error_approx_fine17;
																			delete[] error_approx_coarse17;
																			delete[] residual_coarse17;
																			delete[] residual_fine17;

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	*/

// free
free(diag0);
free(bnested_desection_global_amg);  // Глобальная память.
free(nested_desection0);
free(error_approx_fine);
if (ilevel > 1) {
	free(diag1);
	free(nested_desection1);
	free(error_approx_coarse);
	free(residual_coarse);
	if (ilevel > 2) {
		// free
		free(diag2);
		free(nested_desection2);
		free(error_approx_fine1);
		free(error_approx_coarse1);
		free(residual_coarse1);
		free(residual_fine1);
		if (ilevel > 3) {
			// free
			free(diag3);
			free(nested_desection3);
			free(error_approx_fine2);
			free(error_approx_coarse2);
			free(residual_coarse2);
			free(residual_fine2);
			if (ilevel > 4) {
				// free
				free(diag4);
				free(nested_desection4);
				free(error_approx_fine3);
				free(error_approx_coarse3);
				free(residual_coarse3);
				free(residual_fine3);
				if (ilevel > 5) {
					// free
					free(diag5);
					free(nested_desection5);
					free(error_approx_fine4);
					free(error_approx_coarse4);
					free(residual_coarse4);
					free(residual_fine4);
					if (ilevel > 6) {
						// free
						 free(diag6);
						 free(nested_desection6);
						 free(error_approx_fine5);
						 free(error_approx_coarse5);
						 free(residual_coarse5);
						 free(residual_fine5);
						if (ilevel > 7) {
							// free
							free(diag7);
							free(nested_desection7);
							free(error_approx_fine6);
							free(error_approx_coarse6);
							free(residual_coarse6);
							free(residual_fine6);
							if (ilevel > 8) {
								// free
								free(diag8);
								free(nested_desection8);
								free(error_approx_fine7);
								free(error_approx_coarse7);
								free(residual_coarse7);
								free(residual_fine7);
								if (ilevel > 9) {
									// free
									free(error_approx_fine8);
									free(error_approx_coarse8);
									free(residual_coarse8);
									free(residual_fine8);
									if (ilevel > 10) {
										// free
										free(error_approx_fine9);
										free(error_approx_coarse9);
										free(residual_coarse9);
										free(residual_fine9);
										if (ilevel > 11) {
											// free
											free(error_approx_fine10);
											free(error_approx_coarse10);
											free(residual_coarse10);
											free(residual_fine10);
											if (ilevel > 12) {
												// free
												 free(error_approx_fine11);
												 free(error_approx_coarse11);
												 free(residual_coarse11);
												 free(residual_fine11);
												if (ilevel > 13) {
													// free
													free(error_approx_fine12);
													free(error_approx_coarse12);
													free(residual_coarse12);
													free(residual_fine12);
													if (ilevel > 14) {
														// free
														free(error_approx_fine13);
														free(error_approx_coarse13);
														free(residual_coarse13);
														free(residual_fine13);
														if (ilevel > 15) {
															// free
															free(error_approx_fine14);
															free(error_approx_coarse14);
															free(residual_coarse14);
															free(residual_fine14);
															if (ilevel > 16) {
																// free
																free(error_approx_fine15);
																free(error_approx_coarse15);
																free(residual_coarse15);
																free(residual_fine15);
																if (ilevel > 17) {
																	// free
																	free(error_approx_fine16);
																	free(error_approx_coarse16);
																	free(residual_coarse16);
																	free(residual_fine16);
																	if (ilevel > 18) {
																		// free
																		free(error_approx_fine17);
																		free(error_approx_coarse17);
																		free(residual_coarse17);
																		free(residual_fine17);

																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


	//delete[] residual_fine;
	free(residual_fine);

	//delete[] row_ptr_start;
	//delete[] row_ptr_end;
	free(row_ptr_start);
	free(row_ptr_end);


	//delete[] flag_shadow;
	free(flag_shadow);
	
	
	//delete[] flag;
	free(flag);
	free(x_copy);
	free(x_best_search);
	//return false;
	return ret_value;

} // classic_aglomerative_amg2

// 27 янв 2016. Предпринята попытка сделать в точности как у Руге и Стубена. Попытка провалилась.
// Сходимость сильно испорчена.
// 22 января текущий работоспособный вариант кода.
// Планы : 1. сделать версию amg3. 
// В ней : 2. заменить все проверки на невыделение оперативной памяти на универсальную функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
// 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C-F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C-F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С-F разбиения 
// учитывается уже построеннная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведеия Галёркина получена самая оптимальная по быстродествию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C-F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполляции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
template <typename doublerealT>
integer classic_aglomerative_amg3(Ak1* &Amat,
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	doublerealT &theta
	) {

	const bool bprint_mesage_diagnostic = true;

	const integer AVL_TREE_ID = 0;
	const integer SPLAY_TREE_ID = 1;
	integer id_tree = SPLAY_TREE_ID;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	doublerealT barjer = 1.0e-7; // 1.0e-7 
	doublerealT barjerA = 1.0e-7; // 1.0e-7

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	bool bqs = true; // Использовать ли quicksort qs and qsj.
	// Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая жрёт килотонну памяти (Короче для машин у которых море оперативки).


	const doublerealT RealZERO = 1.0e-300;// 1.0e-10;
	const doublerealT divisionZERO = 1.0e-300;
	const doublerealT RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_sosed = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumsosedcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C-F разбиения.
	bool bmaxsosedinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = NULL;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	//bool* flag = new bool[n + 1];
	bool* flag = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_3", (n + 1));

	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_3", (n + 1));

	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = (bool*)malloc((nnz + 1)*sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_3", (nnz + 1));

	// Огромный размер поэтому инициализация делается лишь единожды.
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n + 1; // 128000
	//integer ipool[ipool_size_limit];
	integer* istack = NULL;
	//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit)*sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_3", (istack_size_limit));

	// Для построения C-F декомпозиции нам тоже потребуется хеш таблица
	// и стек для очистки хеш таблицы.
	bool* hash_table2 = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_3", (n + 1));

	// Инициализация.
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш таблицы.
	integer* istack2 = NULL;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1)*sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_3", (n + 1));


	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_3", (n + 1));

	bool* this_is_F_node = (bool*)malloc((n + 1)*sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_3", (n + 1));


	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {


		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumsosedcount = -1;
		bmaxsosedinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 10) {
			if (n_a[ilevel - 1] < 300) break;
		}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

#if doubleintprecision == 1
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#else
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#endif

		

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]; ii <= n; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);


			// 7 января 2016. Обязательно нужна эта сортировка.
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, true);
				}
				else {
					// quicksort
					qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}
			}
			else {
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}





		if (bji) {
			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			if (bqs) {
				if (bCounting_Sort) {
					// Сортировка с подсчётом за линейное время.
					Counting_Sortj(Atemp, 1, nnz_a[ilevel - 1]);
				}
				else {
					// Быстрая сортировка Чарльза Хоара.
					qsj(Atemp, 1, nnz_a[ilevel - 1]);
				}
			}
			else {
				HeapSort_j(Atemp, 1, nnz_a[ilevel - 1]);
			}
		}

		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = NULL;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_sosed = NULL;
		//count_sosed = new integer[n_a[ilevel - 1] + 1];
		count_sosed = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(count_sosed, "count_sosed", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_sosed[ii] = 0; // нет соседей.
		}




		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				integer cand[max_sosed];
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
				}
				else {
					// 12 января 2016.
					// Учитываем только Strong соседей.
					doublerealT threshold = -1.0;
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > threshold) {
								// Определяем максимальный внедиагональный элемент.
								threshold = fabs(Amat[is0].aij);
							}
						}
					}
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (fabs(Amat[is0].aij) > theta*threshold) {
								// Учитываем только сильно связанных соседей.
								ic++; //i,j
								cand[ic] = Amat[is0].j;
							}
						}
					}
				}
				integer len_sosed = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundsosed = false;
				//		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
				//			if (Amat[ii1].j == cand[i_1]) foundsosed = true;
				//		}
				//		if (!foundsosed) {
				//			ic++;
				//			cand[ic] = Amat[ii1].j;
				//			len_sosed++;
				//		}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundsosed = false;
							for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
							}
							if (!foundsosed) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_sosed++;
							}
						}
					}
				}


				count_sosed[Amat[ii].i] = ic;
				if (ic > Maximumsosedcount) {
					Maximumsosedcount = ic;
					bmaxsosedinfoactive = true;
				}
				flag[Amat[ii].i] = true;
			}
		}



		integer maxsosed = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				if (count_sosed[Amat[ii].i] > maxsosed) {
					maxsosed = count_sosed[Amat[ii].i];
					icandidate = ii;
					if (bmaxsosedinfoactive) {
						// организуем досрочный выход из цикла for.
						// Это должно сильно сокращать количество сканирований.
						if (maxsosed == Maximumsosedcount) break;
					}
				}
				flag[Amat[ii].i] = true;
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_SOSED = -1;
		integer vacant = NULL_SOSED;
		bool bcontinue = true;

		// Построение C-F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = NULL;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n + 1)*sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_3", (n + 1));

		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;



		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;
		Tree_splay* root_splay = 0;
		size_splay_Tree = 0;

		integer newCcount = 0;




		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_sosed]; // не более 20 узлов в одном агрегате.
			integer set17[max_sosed]; // для новой ветки кода.
			// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
			//for (integer js = 0; js < max_sosed; js++) {
			//set[js] = NULL_SOSED;
			//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;



				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
				// добавляем диагональный элемент.
				// узел set[0]==Amat[is0].i.
				// Нахождение значения максимального внедиагольного элемента, с 
				// учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				// 17 января 2016 правильное определение максимального внедиагонального элемента.
				// Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set[0])) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0;
				doublerealT min_vnediagonal1 = 1.0e30;
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				for (integer is0 = ii_back; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
					if (Amat[is0].j != set[0]) {
						counter_vnediagonal = counter_vnediagonal + 1.0;
						avg_vnediagonal1 += fabs(Amat[is0].aij);
						if (fabs(Amat[is0].aij) > max_vnediagonal1) {
							max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
							// Большое количество элементов на грубых уровнях,
							// очень медленная сходимость.
							//if (Amat[is0].j == set[0]) break; 
						}
						if (fabs(Amat[is0].aij) < min_vnediagonal1) {
							min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				// Только сильные связи станут F узлами.
				max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				//max_vnediagonal = -1.0;  // все связи!!!

				/*
				// Лишний код 19 января 2016.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
				if (Amat[is0].j == set[0]) {

				// Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
				// поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
				break;
				}
				else {
				if (fabs(Amat[is0].aij) > max_vnediagonal) {
				// При стабильной версии требуется расскоментировать
				// 19 jan 2016.
				//max_vnediagonal = fabs(Amat[is0].aij); //i,j
				}
				}

				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Медленный линейный поиск.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != set[0]) {
				//if (!flag[Amat[ii1].i]) {
				//	if (Amat[ii1].j == set[0]) {
				//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
				//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
				//		}
				//	}
				//}
				//}
				//}

				if (bji) {
				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Ускоренная версия на основе двоичного поиска.
				integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
				for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
				{
				if (Atemp[ii1].i != set[0]) {
				if (!flag[Atemp[ii1].i]) {
				if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
				max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
				}
				}
				}
				}
				}


				}
				*/

				ic++;



				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_SOSED;
							}
						}
						if (vacant != NULL_SOSED) {
							set[ic] = vacant;

							ic++;
						}
					}
				}
				//integer iscan = ii + 1;
				integer iscan = ii_back; // важная модификация 19 января 2016г.
				// TODO 19 jan 2016.
				while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
					// если узел j ещё не был добавлен в агрегат.
					if (flag[Amat[iscan].j] == false) {
						if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
							vacant = Amat[iscan].j;
							for (integer js = 0; js < ic; js++) {
								if (vacant == set[js]) {
									vacant = NULL_SOSED;
								}
							}
							if (vacant != NULL_SOSED) {
								set[ic] = vacant;

								ic++;

							}
						}
					}

					iscan++;

				} // while

				// Это была учтена только связь i,j



				// Учёт свяи j,i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_SOSED;
				//		}
				//	}
				//	if (vacant != NULL_SOSED) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//	}
				//}
				//}
				//}

				// Учёт связи j,i
				// Медленная версия на основе линейного поиска.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_SOSED;
				//		}
				//	}
				//	if (vacant != NULL_SOSED) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//}
				//}
				//}
				//}

				if (bji) {
					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= nnz_a[ilevel - 1]) && (Atemp[ii2].j == set[0]); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {
								vacant = Atemp[ii2].i;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant; // j,i связь.
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.countsosed = count_sosed[set[js]];
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						default: root = remove_AVL(root, ddel);
							break;
						}

						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}


				//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				//flag_shadow[i_1] = flag[i_1];
				//}



				//integer i3 = 1;
				//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
				//integer i4 = n_a[ilevel - 1];
				//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


				// Ищем только среди ближайшего окружения вновь добавленного F узла.
				//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

				// Старая реализация которой присуща большая нагрузка на операторы new && delete.
				if (0) {
					for (integer js = 1; js < ic; js++) {

						// см. новый вариант от 10 января 2016.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						List *lsos = NULL;
						List *lsos_head = NULL;
						lsos = new List;
						lsos->prev = NULL;
						lsos_head = lsos;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_11;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
							istart2++;
							bool bvisitsos = false;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {
									lsos->next = NULL;
									lsos->i = Amat[is0].j;
									lsos->ii = row_startA[lsos->i];
									// lsos->countsosed // не используется.
									List *newnodesos = new List;
									newnodesos->prev = lsos;
									lsos->next = newnodesos;
									newnodesos->next = NULL;
									lsos = lsos->next;
									newnodesos = NULL;
									bvisitsos = true;
								}
							}
							if (bvisitsos) {

								List *delsos = lsos;
								lsos = lsos->prev;
								lsos->next = NULL;
								delsos->prev = NULL;
								delete delsos;
								delsos = NULL;
							}
							else {
								// Нет ни одного соседа
								lsos_head = NULL;
								delete lsos;
								lsos = NULL;
							}
						}

						lsos = lsos_head;
						// ищем соседа узла set[js].
						//for (integer i5 = i3; i5 <= i4; i5++) {
						while (lsos != NULL) {


							//integer isc = Amat[ii_2].i;
							//integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//integer isc = i5;

							integer isc = lsos->i;
							integer ii_2 = lsos->ii;


							//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
							//if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
								if (Amat[is0].j == set[js]) {
									ic2++;
								}
							}

							data_BalTree dsearch;
							dsearch.countsosed = count_sosed[isc];
							//dsearch.ii = ii_2;
							dsearch.i = isc;
							count_sosed[isc] += ic2;
							data_BalTree dadd;
							dadd.countsosed = count_sosed[isc];
							//dadd.ii = ii_2;
							dadd.i = isc;
							if (bmaxsosedinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_sosed[isc] >= Maximumsosedcount) {
									Maximumsosedcount = count_sosed[isc];
								}

								// Добавляем соседа в любом случае
								// позволило существенным образом 
								// ускорить алгоритм. Если раньше 
								// old = 48595  | 21229
								// new = 433315 | 63031
								// new2 = 19434 | 3698
								// и основное время уходило на old
								// то теперь
								// old = 1449 | 1466
								// new = 472600 | 64525
								// new2= 56544 | 18431
								// Время решения 3D задачи с 1M неизвестными 
								// сократилось с 6мин 48с до 4мин 45с.

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree) {
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}


							}
							//}
							lsos = lsos->next;
						}

						// Уничтожение lsos
						// Список постепенно уничтожается с головы.
						lsos = lsos_head;
						while (lsos != NULL) {
							lsos_head = lsos_head->next;
							if (lsos_head != NULL) {
								lsos_head->prev = NULL;
							}
							lsos->next = NULL;
							delete lsos;
							lsos = lsos_head;
						}

					}
				}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

						// см.ниже  новый вариант от 10 января 2016.
						// 7 января 2016.
						// Новая версия в которой я избавился от лишних оператров new&&delete.
						// Никаких дублирующих линейных списков, никаких операторов new && delete.
						// Код стал намного понятнее.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_sosed[isc] += ic2;
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;
									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.

										if (bAVL) {

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}

											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}


									}

								}
							}

						}
					}

				}
				else if (0) {
					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								// При таком подходе некоторые соседи инкрементируются дважды и это
								// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
								// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
								// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.countsosed = count_sosed[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_sosed[isc] += ic2;
								data_BalTree dadd;
								dadd.countsosed = count_sosed[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree)
									{
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
										break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}

								if (bmaxsosedinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_sosed[isc] >= Maximumsosedcount) {
										Maximumsosedcount = count_sosed[isc];
									}
								}

							}

						}
					}
				}
				else if (0) {
					// 10 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
					// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
					// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
					integer itop_stack2 = 0;

					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;

								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах :
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
									hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;

									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_sosed[isc] += ic2;
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}
									}
								}

							}

						}
					}

					// Очистка (восстановление хеш таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				} // the end
				else {
					// 27 января 2016.
					// 13 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
					// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
					// Это было при magic=0.4
					// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
					integer itop_stack2 = 0;

					// На основе  старого варианта просто очищенного от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						doublerealT threshold9 = -1.0;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (Amat[is0].j != Amat[ii_11].i) {
								if (fabs(Amat[is0].aij) > threshold9) {
									threshold9 = fabs(Amat[is0].aij);
								}
							}
						}

						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (fabs(Amat[is0].aij) > theta*threshold9) {
								if (flag[Amat[is0].j] == false) {

									// Здесь только сильные соседи Strong F.
									// Данного соседа инкрементируем на количество сильных связей с новыми F узлами.
									integer isc = Amat[is0].j;

									// Избавляемся от повторных инкрементаций.
									// В 2D на пятиточечном шаблоне повторные инкрементации составляют
									// около 33%.
									// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
									// на ряде тестовых задач при таком подходе агломерация проходила очень
									// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
									// Эта проблема проявилась на задачах :
									// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
									// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
									// Проблема не в этом месте кода.
									if (hash_table2[isc] == false) {
										hash_table2[isc] = true;
										istack2[itop_stack2] = isc;
										itop_stack2++;

										integer ii_2 = row_startA[isc];


										integer ic2 = 0;
										integer iend2loc = nnz_a[ilevel - 1] + iadd;
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										// Определяем модуль максимального внедиагонального элемента.
										doublerealT threshold_loc1 = -1.0; // инициализация порога.
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if (fabs(Amat[is01].aij) > threshold_loc1) {
													threshold_loc1 = fabs(Amat[is01].aij);
												}
											}
										}
										//threshold_loc1 = -1; // 27 фнваря 2016.
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if (Amat[is01].j == set[js]) {
													// только Strong связи
													// по крайней мере именно так рекомендуют в литературе.
													if (fabs(Amat[is01].aij) > theta*threshold_loc1) {
														ic2++;
													}
												}
											}
										}

										if (ic2 > 0) {
											// Только если были Strong связи приводящие к инкрементации счётчика ic2.


											data_BalTree dsearch;
											dsearch.countsosed = count_sosed[isc];
											//dsearch.ii = ii_2;
											dsearch.i = isc;
											count_sosed[isc] += ic2;
											data_BalTree dadd;
											dadd.countsosed = count_sosed[isc];
											//dadd.ii = ii_2;
											dadd.i = isc;

											if (bAVL) {

												// добавляем элемент в АВЛ дерево,
												// причём если элемент уже находился в дереве то он модифицируется.
												// 12 декабря 2015.
												// Добавление узла происходит за логарифмическое по основанию 2 время,
												// причём после добавления дерево остаётся сбалансированным.
												// Адельсон-Вельский и Ландис 1962.
												switch (id_tree)
												{
												case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
													break;
												case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
													break;
												default: root = insert_and_modify(root, dadd, dsearch);
													break;
												}
												if (bAVL_deb)
												{
													printf("insert and modify\n");
												}
											}
										}

										if (bmaxsosedinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_sosed[isc] >= Maximumsosedcount) {
												Maximumsosedcount = count_sosed[isc];
											}
										}
									}

								}
							}

						}
					}

					// Очистка (восстановление хеш таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.



					if (1) {
						// set17
						// актуален ли ii_back
						integer ic17 = 0;
						integer vacant17;

						// Декрементация счётчиков в дереве для Weakly связей.
						// если узел j ещё не был добавлен в агрегат.
						if (flag[Amat[ii].j] == false) {
							if ((Amat[ii].j != set[0]) && (fabs(Amat[ii].aij) < theta*max_vnediagonal)) {
								vacant17 = Amat[ii].j;
								for (integer js = 0; js < ic17; js++) {
									if (vacant17 == set17[js]) {
										vacant17 = NULL_SOSED;
									}
								}
								if (vacant17 != NULL_SOSED) {
									set17[ic17] = vacant17;

									ic17++;
								}
							}
						}
						//integer iscan17 = ii + 1;
						integer iscan17 = ii_back; // важная модификация 19 января 2016г.
						// TODO 19 jan 2016.
						while ((iscan17 <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan17].i == set[0])) {
							// если узел j ещё не был добавлен в агрегат.
							if (flag[Amat[iscan].j] == false) {
								if ((Amat[iscan].j != set[0]) && (fabs(Amat[iscan].aij) < theta*max_vnediagonal)) {
									vacant17 = Amat[iscan].j;
									for (integer js = 0; js < ic; js++) {
										if (vacant17 == set17[js]) {
											vacant17 = NULL_SOSED;
										}
									}
									if (vacant != NULL_SOSED) {
										set17[ic17] = vacant;

										ic17++;

									}
								}
							}

							iscan17++;

						} // while


						// Декрементация счётчика для всех Weakly соседей нового узла С.
						// Нужно декремировать счётчик для всех <ic17 в set17.
						// flag == false гарантировал что узлы еще не были добавлены в агломераты.

						for (integer js = 0; js < ic17; js++) {
							integer isc17 = set17[js];
							data_BalTree dsearch;
							dsearch.countsosed = count_sosed[isc17];
							//dsearch.ii = ii_2;
							dsearch.i = isc17;
							bool foundnow = false;
							switch (id_tree)
							{
							case AVL_TREE_ID: foundnow = isfound(root, dsearch);
								break;
							case SPLAY_TREE_ID: foundnow = isfound(root_splay, dsearch);
								break;
							default: foundnow = isfound(root, dsearch);
								break;
							}
							
							if (foundnow) {
								data_BalTree  dadd;
								// декрементация счётчика для всех Weakly соседей нового С узла.
								dadd.countsosed = count_sosed[isc17] - 1;
								count_sosed[isc17]--;
								dadd.i = isc17;
								switch (id_tree)
								{
								case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
									break;
								case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
									break;
								default: root = insert_and_modify(root, dadd, dsearch);
									break;
								}
							}
							

						}
						

					}

				}

				

				n_coarce++; // Увеличено количество С узлов.

				// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
					//if (maxsosed == -1) {
#if doubleintprecision == 1
					//printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
					//printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
					
					//system("pause");
					//}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxsosed = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

			// На основе линейного поиска (медленный вариант на больших размерностях).

			const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			integer* ipool = new integer[ipool_size_limit];

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			if (i_7 < ipool_size_limit) {
			if (ipool[i_7] == icandidateq) {
			found1 = true;
			}
			}
			else {
			#if doubleintprecision == 1
				printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;
			if (isize_p < ipool_size_limit) {
			ipool[isize_p] = icandidateq;
			}
			else {
			#if doubleintprecision == 1
				printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			ii_c++;
			}
			}
			delete[] ipool;

			}
			else if (0){

			// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

			// На основе АВЛ дерева.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			node_AVL_Gus* root_Gus = 0;

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			found1 = isfound_Gus(root_Gus, icandidateq);
			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			root_Gus = insert_Gus(root_Gus, icandidateq);

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

			// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

			// На основе hash таблицы.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			//node_AVL_Gus* root_Gus = 0;
			// Нельзя это вызывать это очень медленно.
			//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
			integer itop = 0; // указатель на вершину стека.

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			//found1 = isfound_Gus(root_Gus, icandidateq);
			found1 = hash_table[icandidateq - iadd];

			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			//root_Gus = insert_Gus(root_Gus, icandidateq);
			hash_table[icandidateq - iadd] = true;
			if (itop < istack_size_limit ) {
			istack[itop] = icandidateq - iadd;
			itop++;
			}
			else {
			printf("itop>=istack_size_limit nado uvelichit istack_size_limit");
			}

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			//clear_AVL_Gus(root_Gus);
			//root_Gus = 0;

			for (integer isc = itop - 1; isc >= 0; isc--) {
			hash_table[istack[isc]] = false;
			}
			itop = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			*/


			//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxsosedinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				default: emax = findmax(root);
					break;
				}


				switch (id_tree) {
				case AVL_TREE_ID:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						root_splay = 0;
						size_splay_Tree = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				}




			}

#if doubleintprecision == 1
			//printf("maximum number of sosed=%lld\n",maxsosed);
#else
			//printf("maximum number of sosed=%d\n",maxsosed);
#endif
			
			if (maxsosed == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxsosed == -1)) {
				bcontinue = false;
			}

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C-F разбиения. создано.

		//delete[] bmarkervisit;
		free(bmarkervisit);

		if (bprint_mesage_diagnostic) {
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}

		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		integer ipromah_oneF = 0;

		integer iadditionalCstatistic = 0;

		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1] == true) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				// старая версия до 10 января 2016.
				//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
				// 10 января 2016. на основе хеширования.
				integer i_2 = row_startA[i_1];

				bool bvisit = false;
				for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j] == true) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
				// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
					newCcount++;
				}

				// 1 января 2015 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					// bvisit и так true т.к. icsos==1.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					bweSholdbeContinue = true;
				}

			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}




		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		integer* C_numerate = NULL;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(C_numerate, "C_numerate", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = NULL;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C-F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");



			// C-F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполляции : 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

			ap_coarse[0] = 0.0;




			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8] == true) {
				// Старая версия до 10 января 2016. Время O(log2(nnz))
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// 10 января 2016 новая версия на основе хеширования. Время O(1).
				integer ii1 = row_startA[i8];
				// бинарный поиск должен гарантирует нахождение самого левого представителя.
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {

						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();
			}

			// верно 2 октября.

			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполляция.
				// К тому же чрезвычайно простая.

				if (0) {

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
										icsos++;
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {



							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}

										}

									}
								}
							}

						}

					}
				}
				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполляция с элементам непрямой.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторн запускаем алгоритм построения с учётом уже добавленных С узлов.


					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполляция.
								bool* empty_interpol = NULL;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_3", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								bool bCinsert = false;

								// Сканируем сильных F соседей данного F узла для которого надо построить интерполляцию.
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//O(log2(nnz))
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												// O(1)
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Будем рассматривать только действительно сильных C кандидатов второго уровня.
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j] == true) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполляция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													bCinsert = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

												}

												i_38_count++;

											}
										}
									}
								}

								if (!bCinsert) {
									// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

									bool bstandart_vjzov = true;
									for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
										// 3 января. На самом деле здесь хорошо бы посмотреть вариант
										// когда с не менее чем двух сторон интерполляция сработала, здесь 
										// же срабатывание было лишь с одной из сторон как минимум.
										if (empty_interpol[i_38] == true) {
											bstandart_vjzov = false;
										}
									}
									if (bstandart_vjzov) {
										this_is_F_node[i8] = false;
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
									}
								}

								free(empty_interpol);

							}



							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (0) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполляция с элементам непрямой. Экспериментальный вариант. TODO.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей или имеют недостаточное число С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

					// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполляцию.
					// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
					// двух  C соседей учитывая эффект непрямой интерполляции.


					ipromah = 0;
					ipromah_one = 0;
					ipromah_oneF = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполляция.
								bool* empty_interpol = NULL;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_3", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Будем рассматривать только действительно сильных С кандидатов второго уровня.
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j] == true) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполляция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне вложенности.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
												}

												i_38_count++;

											}
										}
									}
								}

								bool bstandart_vjzov = true;
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									// 3 января. На самом деле здесь хорошо бы посмотреть вариант
									// когда с не менее чем двух сторон интерполляция сработала, здесь 
									// же срабатывание было лишь с одной из сторон как минимум.
									if (empty_interpol[i_38] == true) {
										bstandart_vjzov = false;
									}
								}
								if (bstandart_vjzov) {
									this_is_F_node[i8] = false;
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
								}

								free(empty_interpol);

							}
							else if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				if (1) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = 0.23; // оптимальный выбор.

					// четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					//6interpolation 0.4 6.77 11 26 28.355
					//6interpolation 0.45 6.6 10 27 28.151
					//6interpolation 0.5 6.42 12 32 28.735
					//4interpolation 0.4 3.7  52 24.736 // best
					//4interpolation 0.3 3.78 13 59 27.525
					//4interpolation 0.5 3.61 12 55 25.533
					//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij)>maxelem_threshold_theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									//SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												if (this_is_C_node[Amat[is0].j] == true) {

													// 20 января 2016.
													// По-моему этой ситуации вообще быть не может так как у нас 
													// заведомо один С сосед.
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}


												}

											}
										}
									}
								}
								else {

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (this_is_C_node[Amat[is0].j] == true) {
											if (Amat[is0].j != Amat[ii1].i) {


												// 20 jan 2016.
												// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


												if (fabs(sumP) < RealZERO) {
													// Это случай когда вообще нет сильных С соседей.


													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													byes_add = true; // Были добавления узлов.
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}


											}
										}
									}
								}

							}

						}

					}



					if (!byes_add) {

						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						doublerealT magic = 0.4; // 0.4 optimum

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							integer istr_etalon1 = Amat[ii1].i;
							integer iend_for1 = -1;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == istr_etalon1); is0++) {
								iend_for1 = is0;
								if (Amat[is0].j != istr_etalon1) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; is0 <= iend_for1; is0++) {
								if (Amat[is0].j != istr_etalon1) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if (((icsos == 1) || (icsos == 2)) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.


											if (this_is_C_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}
												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
														// Рассматриваем Strong F связи.

														// Смысл :
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														integer istr_etalon = Amat[ii1_loc].i;
														integer iend_for = -1;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == istr_etalon); is0_loc++) {
															iend_for = is0_loc;
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (Amat[is0_loc].j != istr_etalon) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (Amat[is0_loc].j != istr_etalon) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

														// В общем это двойная интерполляционная сумма 
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (Amat[is0_loc].j != istr_etalon) {

																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																	if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
												}
										}

									}
								}
								else {

									// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
									// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
									// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
									// bmodify_interpol4_amg = false;
									// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
									bool bmodify_interpol4_amg = false;
									doublerealT magic2 = 0.5;

									// Подготовительный этап к усилению четвертой интерполяции 
									// Усиление интерполяции происходит без добавления новых С узлов.
									// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
									// имеется конечно.
									// Подготовительный этап заключается в определении положения is0_candidate самой сильной
									// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
									doublerealT sum1 = 0.0;
									integer is0_candidate = -1;
									if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
										for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_C_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
														if (fabs(Amat[is0].aij) > sum1) {
															sum1 = fabs(Amat[is0].aij);
															is0_candidate = is0;
														}
													}
												}
											}
										}

										if (sum1 / sumP < magic2) {
											// Если найденный элемент слишком слабый ничего не делаем с этим С,
											// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
											sum1 = 0.0;
											is0_candidate = -1;

											// Тогда ищем среди Weakly F узлов кандидата.
											for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
												if (Amat[is0].j != Amat[ii1].i) {
													if (this_is_F_node[Amat[is0].j] == true) {
														//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
															if (fabs(Amat[is0].aij) > sum1) {
																sum1 = fabs(Amat[is0].aij);
																is0_candidate = is0;
															}
														}
													}
												}
											}

											// такой узел F должен стать новым С узлом.
											if (sum1 / sumP >= magic2) {
												this_is_F_node[i8] = false; // Этот узел  станет С нодом.
												this_is_C_node[i8] = true;
												bweSholdbeContinue = true;
												byes_add = true;
												iadditionalCstatistic++;

											}
											// Обязательный сброс перед рестартом чтобы не было деления на ноль.
											sum1 = 0.0;
											is0_candidate = -1;

										}
									}


									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											if (this_is_C_node[Amat[is0].j] == true) {



												if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
													// Мы усиливаем силу интерполяции без добавления новых узлов за
													// счёт одной дополнительной самой сильной Weakly C связи.
													// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

													ioneStrongC_and_0_StrongF++;
													if (is0_candidate != -1) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_candidate].j];
														P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
														icount1++;
													}

													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
														icount1++;
													}
												}
												else {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {

														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															icount1++;
														}

													}

												}

											}
										}
									}
								}

							}
						}

					}

#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				if (0) {
					// пятая попытка.
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {

										if (this_is_C_node[Amat[is0].j] == true) {

											if (fabs(sumP) < RealZERO) {
												//printf("error interpolation zero diagonal sumP.\n");
												//printf("Fnode all sosed is F");
												//system("pause");
												//printf("i8 is Dirichlet node\n");
												this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
												this_is_C_node[i8] = true;
												bweSholdbeContinue = true;
												iadditionalCstatistic++;
												//exit(1);
												// здесь нужна непрямая интерполляция.
											}
											else {

												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0].j];
													P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													icount1++;
												}

											}

										}
										else
											if (this_is_F_node[Amat[is0].j] == true) {

												// Рассматриваем Strong F связи.
												// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
												// Смысл :
												//



												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												// Это лишнее условие, ранее уже было проверено что мы имеем дело
												// с сильной F связью.
												if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpoint
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции
															}
														}
													}

													// В общем это двойная интерполляционная сумма
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять
																// разреженность оператора Галёркина на глубоких
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																}
															}
														}
													}


													//}
												}
											}


									}
								}
							}

						}

					}
				}

				if (0) {

					bool byes_add = false;
					//  быстрая проверка на добавление.
					if (1) {
						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							 {

								 if ((icsos == 1) && (icsosF != 0)) {
									 // Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									 //
									 SumPall += sumP;

									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {
											 // Нас интересуют только Strong связи.
											 if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												 if (this_is_C_node[Amat[is0].j] == true) {

													 if (fabs(sumP) < RealZERO) {
														 //printf("error interpolation zero diagonal sumP.\n");
														 //printf("Fnode all sosed is F");
														 //system("pause");
														 //	printf("i8 is Dirichlet node\n");
														 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														 this_is_C_node[i8] = true;
														 bweSholdbeContinue = true;
														 iadditionalCstatistic++;
														 byes_add = true;
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
													 }


												 }

											 }
										 }
									 }
								 }
								 else {



									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {

											 if (this_is_C_node[Amat[is0].j] == true) {

												 if (fabs(sumP) < RealZERO) {
													 //printf("error interpolation zero diagonal sumP.\n");
													 //printf("Fnode all sosed is F");
													 //system("pause");
													 //printf("i8 is Dirichlet node\n");
													 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													 this_is_C_node[i8] = true;
													 bweSholdbeContinue = true;
													 iadditionalCstatistic++;
													 byes_add = true;
													 //exit(1);
													 // здесь нужна непрямая интерполляция.
												 }


											 }



										 }
									 }



								 }

							 }

						}
					}


					// Проверка на добавление пройдена успешно, 
					// добавлений не было и можно интерполировать !!!.
					if (byes_add == false) {

						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) > maxelem_threshold) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if (this_is_C_node[Amat[is0].j] == true) {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
														}

													}

												}
												else
													if (this_is_F_node[Amat[is0].j] == true) {

														// Рассматриваем Strong F связи.

														// Смысл :
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполляционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																	}
																}
															}
														}


														//}
													}
											}
										}
									}
								}
								else {

									SumPall += sumP;
									doublerealT sum_ok = 0.0;
									bool bbackreturn = false;
									integer icount1_mem = icount1;
									bool* bbackrarr = NULL;
									//bbackrarr = new bool[icount_StronglyF];
									bbackrarr = (bool*)malloc(icount_StronglyF*sizeof(bool));
									handle_error<bool>(bbackrarr, "bbackrarr", "classic_aglomerative_amg_3", icount_StronglyF);

									for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
										bbackrarr[i_63] = false;
									}
									integer icounter_bbackarr = -1;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {

											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														P[icount1].aij = fabs(Amat[is0].aij);
														sum_ok += fabs(Amat[is0].aij);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл :
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														icounter_bbackarr++;

														integer iFpoint = Amat[is0].j;
														//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														doublerealT mult1 = fabs(Amat[is0].aij);
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														icsos_loc = 0;
														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc1 = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																		//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
																		sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																		//	}
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														if (icsos_loc > 0) {
															// В общем это двойная интерполляционная сумма
															for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
																if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																	if (this_is_C_node[Amat[is0_loc].j] == true) {
																		// Внедиагональный элемент из множества С узлов.

																		// Данная вставка должна существенно сохранять
																		// разреженность оператора Галёркина на глубоких
																		// сеточных уровнях.
																		// Модификация 5 декабря 2015.
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																			//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																			P[icount1].j = i8;
																			P[icount1].i = C_numerate[Amat[is0_loc].j];
																			//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																			//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			icount1++;
																		}
																		//}
																	}
																}
															}
														}
														else {
															//bbackreturn = true;
															bbackrarr[icounter_bbackarr] = true;
														}


														//}
													}
												}


										}
									}


									//bbackreturn = true;
									//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
									//if (!bbackrarr[i_63]) {
									//	bbackreturn = false;
									//}
									//}

									//if (bbackreturn) {
									// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
									// варианту интерполяции.
									//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
									//P[i_95].aij = P[i_95].aij*SumPall / sumP;
									//}
									//}

									// Апосториорная корекция
									for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
										P[i_95].aij = P[i_95].aij / sum_ok;
									}

									free(bbackrarr);

								}

							}

						}
					}

				}

			}
			else if (true) {


				// Экспериментальная интерполляция 1 января 2016.

				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполляции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;

					doublerealT SumPall = 0.0;
					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							// Сумма вообще всех внедиагональных элементов.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij);
							}


							if (this_is_C_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									icsos++;
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//ipromah_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполляционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
														}
													}
												}
											}


										}
									}
							}
						}

					}


				}
			}
			else {
				// От интерполляции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполляции.
				// Эта интерполляция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.


				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполляции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					//integer icsos = 0;

					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					doublerealT sumPindicator = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								else {
									sumPindicator += fabs(Amat[is0].aij);
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
						else {
							// Диагональный элемент.
							sumP += fabs(Amat[is0].aij);
						}
					}
					//if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					//if ((false) && (icsos == 1)) {
					//this_is_F_node[i8] = false;
					//this_is_C_node[i8] = true;
					//bweSholdbeContinue = true;
					//}
					//else
					{

						if (fabs(sumPindicator) < RealZERO) {
							//printf("error interpolation zero diagonal sumP.\n");
							//printf("Fnode all sosed is F");
							//system("pause");
							//printf("i8 is Dirichlet node\n");
							this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							//exit(1);
							// здесь нужна непрямая интерполляция.

							// Мы не будем добалять С узлы, мы будем использовать непрямую интерполляцию.



						}
						else {

							integer icount1_frozen = icount1;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connectors.

											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
										}


									}
								}
							}

							integer ilength_n = icount1 - icount1_frozen;
							integer* jposition_in_P = NULL;
							//jposition_in_P = new integer[ilength_n];
							jposition_in_P = (integer*)malloc(ilength_n*sizeof(integer));
							handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_3", ilength_n);



							integer i_97 = 0;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strongly C connections j position.
											jposition_in_P[i_97] = Amat[is0].j;
											i_97++;
										}
									}
								}
							}


							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j] == true) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											// Strong F connections
											doublerealT my_mult = fabs(Amat[is0].aij);
											integer iFpoint = Amat[is0].j;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];

											// Смотрим всех соседей узла iFpoint
											// если среди них окажутся сильные С соседи 
											// первоначально рассматриваемого узла Amat[ii1].i
											// то мы будем накапливать в сумматоре sum23 
											// модули значеий матрицы.
											doublerealT sum23 = 0.0;
											bool bvisit23 = false;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														for (i_97 = 0; i_97 < ilength_n; i_97++) {
															if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																sum23 += fabs(Amat[is0_loc].aij);
																bvisit23 = true;
																break;
															}
														}
													}
												}
											}

											//if (fabs(sum23) > RealZERO) {
											if (bvisit23) {
												// мы точно не делим на ноль.

												// Сканируем всех соседей узла F.
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	//P[icount1_frozen + i_97].j = i8;
																	//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																	P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																	break;
																}
															}
														}
													}
												}
											}


										}
									}
								}
							}

							//delete[] jposition_in_P;
							free(jposition_in_P);

						}

					}


				}
			}



			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				free(ap_coarse);
				ap_coarse = NULL;
				if (bprint_mesage_diagnostic) {
					printf("Feedback restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes  %3.1f %%", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");


		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);

		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1,false);
			}
			else {
				qs(R, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1);
		}


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = 0.5*ap_coarse[R[i_1].i];
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		free(ap_coarse);





		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закоментировано.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Нахождение матрицы грубосеточного уровня :
		// Acorse=R*Afine*P;
		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/
		// Преобразование к формату CRS.

		integer* row_ind_SR = NULL;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		integer* row_ind_ER = NULL;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		integer istart1 = 1 + iaddR;
		integer iend1 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}
		for (integer ii = istart1; ii <= iend1; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SR[istr] = ic;
				row_ind_ER[istr] = kf;
				flag[R[ii].i] = true;
			}
		}

		// Пустые строки просто отсутствуют.
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
		//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
		//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
		//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
		
		//}
		//}

		integer* row_ind_SA = NULL;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer* row_ind_EA = NULL;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer istart3 = 1 + iadd;
		integer iend3 = nnz_a[ilevel - 1] + iadd;
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}
		for (integer ii = istart3; ii <= iend3; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SA[istr] = ic;
				row_ind_EA[istr] = kf;
				flag[Amat[ii].i] = true;
			}
		}

		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

		// Данные используемые для частичного формирователя суммы.
		doublerealT* vector_sum = NULL;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		integer* index_visit = NULL;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer index_size = 0;

		


		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// Закоментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполляции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else {

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
#pragma omp parallel for 
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}


			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				if (istr != jstr) {
					// 14 января 2016.
					// Правильнее определить величину барьера только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015. threshold.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjer*maxth) {
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			else {
			// диагональный элемент записываем обязательно.
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];

					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
						//Amat[istartAnew].aij = vs1;
						//Amat[istartAnew].i = istr;
						//Amat[istartAnew].j = jstr;
						//istartAnew++;

						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;
						Amat[istartAnew++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}



		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		free(row_ind_SR);
		free(row_ind_ER);
		free(row_ind_SA);
		free(row_ind_EA);
		free(vector_sum);


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else
		{
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error : negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		if (bqs) {
		// Обязательно нужна сортировка.
		if (bCounting_Sort) {
		Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		else {
		qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		}
		else {
		HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error : negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}




		/*
		// 10 января 2016. Данная сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		qs(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода :
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно сумирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		integer* row_ind_AS = NULL;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		integer* row_ind_AE = NULL;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2 = istartAnew - 1;

#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
#pragma omp parallel for
		for (integer ii = istart2; ii <= iend2; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend2) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				flag[Amat[ii].i] = true;

			}
		}

		integer* row_ind_PS = NULL;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		integer* row_ind_PE = NULL;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));


		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		integer istart4 = 1 + iaddR;
		integer iend4 = nnzR - 1 + iaddR;
#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
#pragma omp parallel for
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_3", (numberofcoarcenodes + 1));

		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_3", (n_a[ilevel - 1] + 1));

		index_visit[0] = 0;
		index_size = 0;

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);
							

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
#pragma omp parallel for 
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						
						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}


			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
				}
			}

			/*
			if (nsizeA > istartAnew2 + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			// 15 декабря 2015.
			// Если не принять специальных мер элементы не будут упорядочены
			// и двоичным поиском воспользоваться нельзя.
			//if (index_visit[i_6] < index_visit[i_6 - 1]) {
			//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
			//system("pause");
			//}

			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015 года. Сохранение разреженности.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjerA*maxth) {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			else {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;

						//Amat[istartAnew2].aij = vs1;
						//Amat[istartAnew2].i = istr;
						//Amat[istartAnew2].j = jstr;
						//istartAnew2++;

						Amat[istartAnew2++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0;
			
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
			
		}

		//delete[] vector_sum;
		//delete[] index_visit;
		free(vector_sum);
		free(index_visit);


		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		free(row_ind_AS);
		free(row_ind_AE);
		free(row_ind_PS);
		free(row_ind_PE);




		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
#if doubleintprecision == 1
			// Общее количество узлов не являющихся соседемя, но не С соседями 
			printf("Error interpolation is count %lld\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%lld iz nih kol-vo beznadechnjh %lld\n", ipromah_one, ipromah_oneF);
#else
			// Общее количество узлов не являющихся соседемя, но не С соседями 
			printf("Error interpolation is count %d\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%d iz nih kol-vo beznadechnjh %d\n", ipromah_one, ipromah_oneF);
#endif
			
			//system("pause");
		}
		if (debug_reshime) system("pause");


		//delete[] C_numerate;
		free(C_numerate);

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = NULL;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		}

		for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
		if (flag[Amat[ii77].i] == false) {
		integer istr77 = Amat[ii77].i;
		integer ic77 = ii77;
		//integer icdiag = ii77;
		doublerealT ap = 0.0;
		//x[istr] = b[istr];
		while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
		if (Amat[ic77].j != istr77) {
		//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
		}
		else {
		ap = Amat[ic77].aij;
		//icdiag = ic77;
		}
		ic77++;
		}
		if (fabs(ap) < RealZERO) {
		#if doubleintprecision == 1
			printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
		#else
			printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
		#endif
		
		system("PAUSE");
		//exit(1);
		}

		flag[Amat[ii77].i] = true;

		}
		}
		}
		*/

		//проверка конец

		//delete[] count_sosed;
		free(count_sosed);
		//delete[] row_startA;
		free(row_startA);

	}// иерархия сеток построена.

	ilevel--;
	if (n_a[ilevel - 1] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f", (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0]))));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = NULL;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

#if doubleintprecision == 1
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%lld\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#else
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%d\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#endif
	
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);





	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel


	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=NULL;
	if (ilevel > 1) {
	diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=NULL;
	if (ilevel > 2) {
	diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = NULL;
	if (ilevel > 3) {
	diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = NULL;
	if (ilevel > 4) {
	diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = NULL;
	if (ilevel > 5) {
	diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = NULL;
	if (ilevel > 6) {
	diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = NULL;
	if (ilevel > 7) {
	diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = NULL;
	if (ilevel > 8) {
	diag8 = new doublerealT[n_a[8] + 1];
	}
	*/

	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = NULL;
	//diag0 = new doublerealT[n_a[0] + 1];
	diag0 = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(diag0, "diag0", "classic_aglomerative_amg_3", (n_a[0] + 1));

	doublerealT *diag1 = NULL;
	if (ilevel > 1) {
		//diag1 = new doublerealT[n_a[1] + 1];
		diag1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag1, "diag1", "classic_aglomerative_amg_3", (n_a[1] + 1));
	}
	doublerealT *diag2 = NULL;
	if (ilevel > 2) {
		//diag2 = new doublerealT[n_a[2] + 1];
		diag2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag2, "diag2", "classic_aglomerative_amg_3", (n_a[2] + 1));
	}
	doublerealT *diag3 = NULL;
	if (ilevel > 3) {
		//diag3 = new doublerealT[n_a[3] + 1];
		diag3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag3, "diag3", "classic_aglomerative_amg_3", (n_a[3] + 1));
	}
	doublerealT *diag4 = NULL;
	if (ilevel > 4) {
		//diag4 = new doublerealT[n_a[4] + 1];
		diag4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag4, "diag4", "classic_aglomerative_amg_3", (n_a[4] + 1));
	}
	doublerealT *diag5 = NULL;
	if (ilevel > 5) {
		//diag5 = new doublerealT[n_a[5] + 1];
		diag5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag5, "diag5", "classic_aglomerative_amg_3", (n_a[5] + 1));
	}
	doublerealT *diag6 = NULL;
	if (ilevel > 6) {
		//diag6 = new doublerealT[n_a[6] + 1];
		diag6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag6, "diag6", "classic_aglomerative_amg_3", (n_a[6] + 1));
	}
	doublerealT *diag7 = NULL;
	if (ilevel > 7) {
		//diag7 = new doublerealT[n_a[7] + 1];
		diag7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag7, "diag7", "classic_aglomerative_amg_3", (n_a[7] + 1));
	}
	doublerealT *diag8 = NULL;
	if (ilevel > 8) {
		// diag8 = new doublerealT[n_a[8] + 1];
		diag8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag8, "diag8", "classic_aglomerative_amg_3", (n_a[8] + 1));
	}

	bnested_desection_global_amg = NULL;
	bool *nested_desection0 = NULL;
	bool *nested_desection1 = NULL;
	bool *nested_desection2 = NULL;
	bool *nested_desection3 = NULL;
	bool *nested_desection4 = NULL;
	bool *nested_desection5 = NULL;
	bool *nested_desection6 = NULL;
	bool *nested_desection7 = NULL;
	bool *nested_desection8 = NULL;
	if (!bonly_serial) {
		// nested desection start
		bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_3", (n_a[0] + 1));


		nested_desection0 = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(nested_desection0, "nested_desection0", "classic_aglomerative_amg_3", (n_a[0] + 1));


		if (ilevel > 1) {
			nested_desection1 = (bool*)malloc((n_a[1] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection1, "nested_desection1", "classic_aglomerative_amg_3", (n_a[1] + 1));
		}

		if (ilevel > 2) {
			nested_desection2 = (bool*)malloc((n_a[2] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection2, "nested_desection2", "classic_aglomerative_amg_3", (n_a[2] + 1));
		}

		if (ilevel > 3) {
			nested_desection3 = (bool*)malloc((n_a[3] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection3, "nested_desection3", "classic_aglomerative_amg_3", (n_a[3] + 1));
		}

		if (ilevel > 4) {
			nested_desection4 = (bool*)malloc((n_a[4] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection4, "nested_desection4", "classic_aglomerative_amg_3", (n_a[4] + 1));
		}

		if (ilevel > 5) {
			nested_desection5 = (bool*)malloc((n_a[5] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection5, "nested_desection5", "classic_aglomerative_amg_3", (n_a[5] + 1));
		}

		if (ilevel > 6) {
			nested_desection6 = (bool*)malloc((n_a[6] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection6, "nested_desection6", "classic_aglomerative_amg_3", (n_a[6] + 1));
		}

		if (ilevel > 7) {
			nested_desection7 = (bool*)malloc((n_a[7] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection7, "nested_desection7", "classic_aglomerative_amg_3", (n_a[7] + 1));
		}

		if (ilevel > 8) {
			nested_desection8 = (bool*)malloc((n_a[8] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection8, "nested_desection8", "classic_aglomerative_amg_3", (n_a[8] + 1));
		}
	}
	// nested_desection_end

	integer *row_ptr_start = NULL;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	row_ptr_start = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_3", (4 * n_a[0] + 1));

	integer *row_ptr_end = NULL;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((4 * n_a[0] + 1)*sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_3", (4 * n_a[0] + 1));

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
				}
				else {
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			diag0[Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	bool bstop = false;

	// 14 сентября 2015 понедельник четвёртый уровень вложенности.
	// Уровни вложенности с первого по седьмой сразу. 12.07.2016.

	for (integer ilevel_detector = 1; ilevel_detector <= 7; ilevel_detector++) {

		if (ilevel > ilevel_detector) {
			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			integer ist = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				ist += nnz_a[ilev];
			}
			integer iend = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iend += nnz_a[ilev];
			}
			for (integer ii = ist; ii <= iend; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer istr = Amat[ii].i;
					integer ic = ii;
					integer icdiag = ii;
					integer istart_row_ptr = istr;
					for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
						istart_row_ptr += n_a[ilev];
					}
					row_ptr_start[istart_row_ptr] = ii;
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic <= iend) && (Amat[ic].i == istr)) {
						if (Amat[ic].j != istr) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
							// Все внедиагональные элементы должны быть строго отрицательны.
							// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
							if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
								printf("polochitelnji vnediagonalnj element %e in matrix level %lld in string %lld...\n", Amat[ic].aij, ilevel_detector, istr);
#else
								printf("polochitelnji vnediagonalnj element %e in matrix level %d in string %d...\n", Amat[ic].aij, ilevel_detector, istr);
#endif
								system("PAUSE");
							}
						}
						else {
							ap = Amat[ic].aij;
							icdiag = ic;
						}
						ic++;
					}
					row_ptr_end[istart_row_ptr] = ic - 1;
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal elements in string %lld in level 7 matrix", istr);
#else
						printf("zero diagonal elements in string %d in level 7 matrix", istr);
#endif
						
						system("PAUSE");
						exit(1);
					}
					else {
						//x[istr] /= ap;
					}

					flag[Amat[ii].i] = true;
					Ak1 temp = Amat[ii];
					Amat[ii] = Amat[icdiag];
					Amat[icdiag] = temp;
					switch (ilevel_detector) {
					case 1: diag1[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 2: diag2[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 3: diag3[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 4: diag4[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 5: diag5[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 6: diag6[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					case 7: diag7[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
					default: printf("ilevel_detector incorrect\n"); 
						//getchar();
						system("PAUSE");
						break;
					}

					Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
				}
			}
		}
	}

	if (bstop) exit(1);

	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
	integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
	for (integer ii = ist; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	integer icdiag = ii;
	row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
	doublerealT ap = 0.0;
	//x[istr] = b[istr];
	while ((ic <= iend) && (Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else {
	ap = Amat[ic].aij;
	icdiag = ic;
	}
	ic++;
	}
	row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld in level 7 matrix", istr);
	#else
		printf("zero diagonal elements in string %d in level 7 matrix", istr);
	#endif
	
	system("PAUSE");
	exit(1);
	}
	else {
	//x[istr] /= ap;
	}

	flag[Amat[ii].i] = true;
	Ak1 temp = Amat[ii];
	Amat[ii] = Amat[icdiag];
	Amat[icdiag] = temp;
	diag8[Amat[ii].i] = ap; // для ускорения вычисления невязки.
	Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
	}
	}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection0
		nested_desection_patch(Amat, n_a[0], nested_desection0, row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection1
		nested_desection_patch(Amat, n_a[1], nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
		if (bprint_mesage_diagnostic) {
			printf("part2\n");
		}
		nested_desection_patch(Amat, n_a[2], nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
		if (bprint_mesage_diagnostic) {
			printf("part3\n");
		}
		nested_desection_patch(Amat, n_a[3], nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
		if (bprint_mesage_diagnostic) {
			printf("part4\n");
		}
		nested_desection_patch(Amat, n_a[4], nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
		if (bprint_mesage_diagnostic) {
			printf("part5\n");
		}
		nested_desection_patch(Amat, n_a[5], nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
		if (bprint_mesage_diagnostic) {
			printf("part6\n");
		}
		nested_desection_patch(Amat, n_a[6], nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
		if (bprint_mesage_diagnostic) {
			printf("part7\n");
		}
		nested_desection_patch(Amat, n_a[7], nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
		if (bprint_mesage_diagnostic) {
			printf("part8 \n");
			printf("nested desection is finish\n");
		}

	}


	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=NULL) {
	   free(this_is_C_node);
	   this_is_C_node=NULL;
	}
	if (this_is_F_node!=NULL) {
	   free(this_is_F_node);
       this_is_F_node=NULL;
	}
	//delete[] hash_table;
	free(hash_table);
	free(hash_table2);
	//delete[] istack;
	//delete[] istack2;
	free(istack);
	free(istack2);


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

	integer nFinestSweeps = 3;


	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = 0.7;
	doublerealT process_flow_alpha = 0.1;
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	const doublerealT tolerance = 0.003; // точность выхода по классическому определению L2 нормы.


	doublerealT *residual_fine = NULL;
	//residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = NULL;
	doublerealT* error_approx_coarse = NULL;
	doublerealT *residual_fine1 = NULL;
	doublerealT *residual_coarse1 = NULL;
	doublerealT* error_approx_coarse1 = NULL;
	doublerealT *error_approx_fine1 = NULL;
	doublerealT *residual_fine2 = NULL;
	doublerealT *residual_coarse2 = NULL;
	doublerealT* error_approx_coarse2 = NULL;
	doublerealT *error_approx_fine2 = NULL;
	doublerealT *residual_fine3 = NULL;
	doublerealT *residual_coarse3 = NULL;
	doublerealT* error_approx_coarse3 = NULL;
	doublerealT *error_approx_fine3 = NULL;
	doublerealT *residual_fine4 = NULL;
	doublerealT *residual_coarse4 = NULL;
	doublerealT *error_approx_coarse4 = NULL;
	doublerealT *error_approx_fine4 = NULL;
	doublerealT *residual_fine5 = NULL;
	doublerealT *residual_coarse5 = NULL;
	doublerealT* error_approx_coarse5 = NULL;
	doublerealT *error_approx_fine5 = NULL;
	doublerealT *residual_fine6 = NULL;
	doublerealT *residual_coarse6 = NULL;
	doublerealT* error_approx_coarse6 = NULL;
	doublerealT *error_approx_fine6 = NULL;
	doublerealT *residual_fine7 = NULL;
	doublerealT *residual_coarse7 = NULL;
	doublerealT* error_approx_coarse7 = NULL;
	doublerealT *error_approx_fine7 = NULL;
	doublerealT *residual_fine8 = NULL;
	doublerealT *residual_coarse8 = NULL;
	doublerealT* error_approx_coarse8 = NULL;
	doublerealT *error_approx_fine8 = NULL;
	doublerealT *residual_fine9 = NULL;
	doublerealT *residual_coarse9 = NULL;
	doublerealT* error_approx_coarse9 = NULL;
	doublerealT *error_approx_fine9 = NULL;
	doublerealT *residual_fine10 = NULL;
	doublerealT *residual_coarse10 = NULL;
	doublerealT* error_approx_coarse10 = NULL;
	doublerealT *error_approx_fine10 = NULL;
	doublerealT *residual_fine11 = NULL;
	doublerealT *residual_coarse11 = NULL;
	doublerealT* error_approx_coarse11 = NULL;
	doublerealT *error_approx_fine11 = NULL;
	doublerealT *residual_fine12 = NULL;
	doublerealT *residual_coarse12 = NULL;
	doublerealT* error_approx_coarse12 = NULL;
	doublerealT *error_approx_fine12 = NULL;
	doublerealT *residual_fine13 = NULL;
	doublerealT *residual_coarse13 = NULL;
	doublerealT* error_approx_coarse13 = NULL;
	doublerealT *error_approx_fine13 = NULL;
	doublerealT *residual_fine14 = NULL;
	doublerealT *residual_coarse14 = NULL;
	doublerealT* error_approx_coarse14 = NULL;
	doublerealT *error_approx_fine14 = NULL;
	doublerealT *residual_fine15 = NULL;
	doublerealT *residual_coarse15 = NULL;
	doublerealT* error_approx_coarse15 = NULL;
	doublerealT *error_approx_fine15 = NULL;
	doublerealT *residual_fine16 = NULL;
	doublerealT *residual_coarse16 = NULL;
	doublerealT* error_approx_coarse16 = NULL;
	doublerealT *error_approx_fine16 = NULL;
	doublerealT *residual_fine17 = NULL;
	doublerealT *residual_coarse17 = NULL;
	doublerealT* error_approx_coarse17 = NULL;
	doublerealT *error_approx_fine17 = NULL;

	/*
	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	if (residual_fine == NULL) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem : not enough memory on your equipment for residual_fine in classic_aglomerative_amg2 my_agregat_amg...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	if (ilevel > 1) {
	residual_coarse = new doublerealT[n_a[1] + 1];
	error_approx_coarse = new doublerealT[n_a[1] + 1];
	if (ilevel > 2) {
	// residual
	residual_fine1 = new doublerealT[n_a[1] + 1];
	residual_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_fine1 = new doublerealT[n_a[1] + 1];
	if (ilevel > 3) {
	// residual
	residual_fine2 = new doublerealT[n_a[2] + 1];
	residual_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_fine2 = new doublerealT[n_a[2] + 1];
	if (ilevel > 4) {
	// residual
	residual_fine3 = new doublerealT[n_a[3] + 1];
	residual_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_fine3 = new doublerealT[n_a[3] + 1];
	if (ilevel > 5) {
	// residual
	residual_fine4 = new doublerealT[n_a[4] + 1];
	residual_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_fine4 = new doublerealT[n_a[4] + 1];
	if (ilevel > 6) {
	// residual
	residual_fine5 = new doublerealT[n_a[5] + 1];
	residual_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_fine5 = new doublerealT[n_a[5] + 1];
	if (ilevel > 7) {
	// residual
	residual_fine6 = new doublerealT[n_a[6] + 1];
	residual_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_fine6 = new doublerealT[n_a[6] + 1];
	if (ilevel > 8) {
	// residual
	residual_fine7 = new doublerealT[n_a[7] + 1];
	residual_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_fine7 = new doublerealT[n_a[7] + 1];
	if (ilevel > 9) {
	// residual
	residual_fine8 = new doublerealT[n_a[8] + 1];
	residual_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_fine8 = new doublerealT[n_a[8] + 1];
	if (ilevel > 10) {
	// residual
	residual_fine9 = new doublerealT[n_a[9] + 1];
	residual_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_fine9 = new doublerealT[n_a[9] + 1];
	if (ilevel > 11) {
	// residual
	residual_fine10 = new doublerealT[n_a[10] + 1];
	residual_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_fine10 = new doublerealT[n_a[10] + 1];
	if (ilevel > 12) {
	// residual
	residual_fine11 = new doublerealT[n_a[11] + 1];
	residual_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_fine11 = new doublerealT[n_a[11] + 1];
	if (ilevel > 13) {
	// residual
	residual_fine12 = new doublerealT[n_a[12] + 1];
	residual_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_fine12 = new doublerealT[n_a[12] + 1];
	if (ilevel > 14) {
	// residual
	residual_fine13 = new doublerealT[n_a[13] + 1];
	residual_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_fine13 = new doublerealT[n_a[13] + 1];
	if (ilevel > 15) {
	// residual
	residual_fine14 = new doublerealT[n_a[14] + 1];
	residual_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_fine14 = new doublerealT[n_a[14] + 1];
	if (ilevel > 16) {
	// residual
	residual_fine15 = new doublerealT[n_a[15] + 1];
	residual_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_fine15 = new doublerealT[n_a[15] + 1];
	if (ilevel > 17) {
	// residual
	residual_fine16 = new doublerealT[n_a[16] + 1];
	residual_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_fine16 = new doublerealT[n_a[16] + 1];
	if (ilevel > 18) {
	// residual
	residual_fine17 = new doublerealT[n_a[17] + 1];
	residual_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_fine17 = new doublerealT[n_a[17] + 1];

	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
	*/

	// лучше выделять оперативную память небольшими блоками т.к.
	// оперативная память фрагментирована системными dll и
	// большого свободного блока может не найтись.


	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(residual_fine, "residual_fine", "classic_aglomerative_amg_3", (n_a[0] + 1));

	if (ilevel > 1) {
		//residual_coarse = new doublerealT[n_a[1] + 1];
		residual_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_coarse, "residual_coarse", "classic_aglomerative_amg_3", (n_a[1] + 1));

		//error_approx_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_coarse, "error_approx_coarse", "classic_aglomerative_amg_3", (n_a[1] + 1));

		if (ilevel > 2) {
			// residual
			//residual_fine1 = new doublerealT[n_a[1] + 1];
			residual_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_fine1, "residual_fine1", "classic_aglomerative_amg_3", (n_a[1] + 1));

			//residual_coarse1 = new doublerealT[n_a[2] + 1];
			residual_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse1, "residual_coarse1", "classic_aglomerative_amg_3", (n_a[2] + 1));

			//error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse1, "error_approx_coarse1", "classic_aglomerative_amg_3", (n_a[2] + 1));

			//error_approx_fine1 = new doublerealT[n_a[1] + 1];
			error_approx_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine1, "error_approx_fine1", "classic_aglomerative_amg_3", (n_a[1] + 1));

			if (ilevel > 3) {
				// residual
				//residual_fine2 = new doublerealT[n_a[2] + 1];
				residual_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_fine2, "residual_fine2", "classic_aglomerative_amg_3", (n_a[2] + 1));

				//residual_coarse2 = new doublerealT[n_a[3] + 1];
				residual_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_coarse2, "residual_coarse2", "classic_aglomerative_amg_3", (n_a[3] + 1));

				//error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_coarse2, "error_approx_coarse2", "classic_aglomerative_amg_3", (n_a[3] + 1));

				//error_approx_fine2 = new doublerealT[n_a[2] + 1];
				error_approx_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_fine2, "error_approx_fine2", "classic_aglomerative_amg_3", (n_a[2] + 1));

				if (ilevel > 4) {
					// residual
					//residual_fine3 = new doublerealT[n_a[3] + 1];
					residual_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_fine3, "residual_fine3", "classic_aglomerative_amg_3", (n_a[3] + 1));

					//residual_coarse3 = new doublerealT[n_a[4] + 1];
					residual_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_coarse3, "residual_coarse3", "classic_aglomerative_amg_3", (n_a[4] + 1));

					//error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_coarse3, "error_approx_coarse3", "classic_aglomerative_amg_3", (n_a[4] + 1));

					//error_approx_fine3 = new doublerealT[n_a[3] + 1];
					error_approx_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_fine3, "error_approx_fine3", "classic_aglomerative_amg_3", (n_a[3] + 1));

					if (ilevel > 5) {
						// residual
						//residual_fine4 = new doublerealT[n_a[4] + 1];
						residual_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_fine4, "residual_fine4", "classic_aglomerative_amg_3", (n_a[4] + 1));

						//residual_coarse4 = new doublerealT[n_a[5] + 1];
						residual_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_coarse4, "residual_coarse4", "classic_aglomerative_amg_3", (n_a[5] + 1));

						//error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_coarse4, "error_approx_coarse4", "classic_aglomerative_amg_3", (n_a[5] + 1));

						//error_approx_fine4 = new doublerealT[n_a[4] + 1];
						error_approx_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_fine4, "error_approx_fine4", "classic_aglomerative_amg_3", (n_a[4] + 1));

						if (ilevel > 6) {
							// residual
							//residual_fine5 = new doublerealT[n_a[5] + 1];
							residual_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_fine5, "residual_fine5", "classic_aglomerative_amg_3", (n_a[5] + 1));

							//residual_coarse5 = new doublerealT[n_a[6] + 1];
							residual_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_coarse5, "residual_coarse5", "classic_aglomerative_amg_3", (n_a[6] + 1));

							//error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_coarse5, "error_approx_coarse5", "classic_aglomerative_amg_3", (n_a[6] + 1));

							//error_approx_fine5 = new doublerealT[n_a[5] + 1];
							error_approx_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_fine5, "error_approx_fine5", "classic_aglomerative_amg_3", (n_a[5] + 1));

							if (ilevel > 7) {
								// residual
								//residual_fine6 = new doublerealT[n_a[6] + 1];
								residual_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_fine6, "residual_fine6", "classic_aglomerative_amg_3", (n_a[6] + 1));

								//residual_coarse6 = new doublerealT[n_a[7] + 1];
								residual_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_coarse6, "residual_coarse6", "classic_aglomerative_amg_3", (n_a[7] + 1));

								//error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_coarse6, "error_approx_coarse6", "classic_aglomerative_amg_3", (n_a[7] + 1));

								//error_approx_fine6 = new doublerealT[n_a[6] + 1];
								error_approx_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_fine6, "error_approx_fine6", "classic_aglomerative_amg_3", (n_a[6] + 1));

								if (ilevel > 8) {
									// residual
									//residual_fine7 = new doublerealT[n_a[7] + 1];
									residual_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_fine7, "residual_fine7", "classic_aglomerative_amg_3", (n_a[7] + 1));

									//residual_coarse7 = new doublerealT[n_a[8] + 1];
									residual_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_coarse7, "residual_coarse7", "classic_aglomerative_amg_3", (n_a[8] + 1));

									//error_approx_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_coarse7, "error_approx_coarse7", "classic_aglomerative_amg_3", (n_a[8] + 1));

									//error_approx_fine7 = new doublerealT[n_a[7] + 1];
									error_approx_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_fine7, "error_approx_fine7", "classic_aglomerative_amg_3", (n_a[7] + 1));

									if (ilevel > 9) {
										// residual
										//residual_fine8 = new doublerealT[n_a[8] + 1];
										residual_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_fine8, "residual_fine8", "classic_aglomerative_amg_3", (n_a[8] + 1));

										//residual_coarse8 = new doublerealT[n_a[9] + 1];
										residual_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_coarse8, "residual_coarse8", "classic_aglomerative_amg_3", (n_a[9] + 1));

										//error_approx_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_coarse8, "error_approx_coarse8", "classic_aglomerative_amg_3", (n_a[9] + 1));

										//error_approx_fine8 = new doublerealT[n_a[8] + 1];
										error_approx_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_fine8, "error_approx_fine8", "classic_aglomerative_amg_3", (n_a[8] + 1));

										if (ilevel > 10) {
											// residual
											//residual_fine9 = new doublerealT[n_a[9] + 1];
											residual_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_fine9, "residual_fine9", "classic_aglomerative_amg_3", (n_a[9] + 1));

											//residual_coarse9 = new doublerealT[n_a[10] + 1];
											residual_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_coarse9, "residual_coarse9", "classic_aglomerative_amg_3", (n_a[10] + 1));

											//error_approx_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_coarse9, "error_approx_coarse9", "classic_aglomerative_amg_3", (n_a[10] + 1));

											//error_approx_fine9 = new doublerealT[n_a[9] + 1];
											error_approx_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_fine9, "error_approx_fine9", "classic_aglomerative_amg_3", (n_a[9] + 1));

											if (ilevel > 11) {
												// residual
												//residual_fine10 = new doublerealT[n_a[10] + 1];
												residual_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_fine10, "residual_fine10", "classic_aglomerative_amg_3", (n_a[10] + 1));

												//residual_coarse10 = new doublerealT[n_a[11] + 1];
												residual_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_coarse10, "residual_coarse10", "classic_aglomerative_amg_3", (n_a[11] + 1));

												//error_approx_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_coarse10, "error_approx_coarse10", "classic_aglomerative_amg_3", (n_a[11] + 1));

												//error_approx_fine10 = new doublerealT[n_a[10] + 1];
												error_approx_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_fine10, "error_approx_fine10", "classic_aglomerative_amg_3", (n_a[10] + 1));

												if (ilevel > 12) {
													// residual
													//residual_fine11 = new doublerealT[n_a[11] + 1];
													residual_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_fine11, "residual_fine11", "classic_aglomerative_amg_3", (n_a[11] + 1));

													//residual_coarse11 = new doublerealT[n_a[12] + 1];
													residual_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_coarse11, "residual_coarse11", "classic_aglomerative_amg_3", (n_a[12] + 1));

													//error_approx_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_coarse11, "error_approx_coarse11", "classic_aglomerative_amg_3", (n_a[12] + 1));

													//error_approx_fine11 = new doublerealT[n_a[11] + 1];
													error_approx_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_fine11, "error_approx_fine11", "classic_aglomerative_amg_3", (n_a[11] + 1));

													if (ilevel > 13) {
														// residual
														//residual_fine12 = new doublerealT[n_a[12] + 1];
														residual_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_fine12, "residual_fine12", "classic_aglomerative_amg_3", (n_a[12] + 1));

														//residual_coarse12 = new doublerealT[n_a[13] + 1];
														residual_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_coarse12, "residual_coarse12", "classic_aglomerative_amg_3", (n_a[13] + 1));

														//error_approx_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_coarse12, "error_approx_coarse12", "classic_aglomerative_amg_3", (n_a[13] + 1));

														//error_approx_fine12 = new doublerealT[n_a[12] + 1];
														error_approx_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_fine12, "error_approx_fine12", "classic_aglomerative_amg_3", (n_a[12] + 1));

														if (ilevel > 14) {
															// residual
															//residual_fine13 = new doublerealT[n_a[13] + 1];
															residual_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_fine13, "residual_fine13", "classic_aglomerative_amg_3", (n_a[13] + 1));

															//residual_coarse13 = new doublerealT[n_a[14] + 1];
															residual_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_coarse13, "residual_coarse13", "classic_aglomerative_amg_3", (n_a[14] + 1));

															//error_approx_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_coarse13, "error_approx_coarse13", "classic_aglomerative_amg_3", (n_a[14] + 1));

															//error_approx_fine13 = new doublerealT[n_a[13] + 1];
															error_approx_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_fine13, "error_approx_fine13", "classic_aglomerative_amg_3", (n_a[13] + 1));

															if (ilevel > 15) {
																// residual
																//residual_fine14 = new doublerealT[n_a[14] + 1];
																residual_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_fine14, "residual_fine14", "classic_aglomerative_amg_3", (n_a[14] + 1));

																//residual_coarse14 = new doublerealT[n_a[15] + 1];
																residual_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_coarse14, "residual_coarse14", "classic_aglomerative_amg_3", (n_a[15] + 1));

																//error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_coarse14, "error_approx_coarse14", "classic_aglomerative_amg_3", (n_a[15] + 1));

																//error_approx_fine14 = new doublerealT[n_a[14] + 1];
																error_approx_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_fine14, "error_approx_fine14", "classic_aglomerative_amg_3", (n_a[14] + 1));

																if (ilevel > 16) {
																	// residual
																	//residual_fine15 = new doublerealT[n_a[15] + 1];
																	residual_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_fine15, "residual_fine15", "classic_aglomerative_amg_3", (n_a[15] + 1));

																	//residual_coarse15 = new doublerealT[n_a[16] + 1];
																	residual_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_coarse15, "residual_coarse15", "classic_aglomerative_amg_3", (n_a[16] + 1));

																	//error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_coarse15, "error_approx_coarse15", "classic_aglomerative_amg_3", (n_a[16] + 1));

																	//error_approx_fine15 = new doublerealT[n_a[15] + 1];
																	error_approx_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_fine15, "error_approx_fine15", "classic_aglomerative_amg_3", (n_a[15] + 1));

																	if (ilevel > 17) {
																		// residual
																		//residual_fine16 = new doublerealT[n_a[16] + 1];
																		residual_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_fine16, "residual_fine16", "classic_aglomerative_amg_3", (n_a[16] + 1));

																		//residual_coarse16 = new doublerealT[n_a[17] + 1];
																		residual_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_coarse16, "residual_coarse16", "classic_aglomerative_amg_3", (n_a[17] + 1));

																		//error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_coarse16, "error_approx_coarse16", "classic_aglomerative_amg_3", (n_a[17] + 1));

																		//error_approx_fine16 = new doublerealT[n_a[16] + 1];
																		error_approx_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_fine16, "error_approx_fine16", "classic_aglomerative_amg_3", (n_a[16] + 1));

																		if (ilevel > 18) {
																			// residual
																			//residual_fine17 = new doublerealT[n_a[17] + 1];
																			residual_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(residual_fine17, "residual_fine17", "classic_aglomerative_amg_3", (n_a[17] + 1));

																			//residual_coarse17 = new doublerealT[n_a[18] + 1];
																			residual_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(residual_coarse17, "residual_coarse17", "classic_aglomerative_amg_3", (n_a[18] + 1));

																			//error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_coarse17, "error_approx_coarse17", "classic_aglomerative_amg_3", (n_a[18] + 1));

																			//error_approx_fine17 = new doublerealT[n_a[17] + 1];
																			error_approx_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_fine17, "error_approx_fine17", "classic_aglomerative_amg_3", (n_a[17] + 1));


																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = NULL;
	//error_approx_fine = new doublerealT[n_a[0] + 1];
	error_approx_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(error_approx_fine, "error_approx_fine", "classic_aglomerative_amg_3", (n_a[0] + 1));



	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	const integer ZERO_INIT = 0;
	const integer RANDOM_INIT = 1;// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	integer imyinit = ZERO_INIT; // ZERO_INIT optimum



	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;

	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while (dres>tolerance) {

		if (iter_limit > 2000) {
			printf("may be Neimann in the all boundares.\n");
			break; // досрочный выход из while цикла.
		}
		iter_limit++;


		if (dres!=dres) {
			printf("divergence AMG detected\n");
			printf("\a\a\a\a\a\a\a\a");
			system("pause");
			exit(1);
		}


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			R0_0 = norma(residual_fine, n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
		}
		dres = norma(residual_fine, n_a[0]);
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
			printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
			
		}
		iiter++;
		//rho=norma(residual_fine, n_a[0]);
		rho = dres;

		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			if (imyinit == ZERO_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = 0.0;
				}
			}

			if (imyinit == RANDOM_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = (rand() / ((doublerealT)RAND_MAX));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
				doublerealT R0_1 = 0.0;
				doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

					R0_1 = norma(residual_fine1, n_a[1]);
					Rprev_1 = R0_1;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 > process_flow_beta*Rprev_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu1) {
						printf("level 1 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}

				move_down(nu1, nu2);


				if (ilevel > 2) {
					// residual
					if (!process_flow_logic) {
						//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
						//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);
						//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					}

					//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];

					// restriction
					restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
					if (imyinit == ZERO_INIT) {
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = 0.0;
						}
					}
					if (imyinit == RANDOM_INIT) {
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = (rand() / ((doublerealT)RAND_MAX));
						}
					}

					//for (integer i_37 = 1; i_37 <= igam; i_37++)
				{
					doublerealT R0_2 = 0.0;
					doublerealT Rprev_2 = 0.0, Rnext_2 = 0.0;
					if (process_flow_logic) {
						// calculate initial residual.
						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

						R0_2 = norma(residual_fine2, n_a[2]);
						Rprev_2 = R0_2;

						// smother
						integer iter = 0;
						for (iter = 0; iter < nu1; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 > process_flow_beta*Rprev_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu1) {
							printf("level 2 limit presmother iteration is reached\n");
						}

					}
					else {

						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}

					}

					move_down(nu1, nu2);

					if (ilevel > 3) {
						// residual
						if (!process_flow_logic) {
							//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);
							//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						}

						//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
						if (imyinit == ZERO_INIT) {
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = 0.0;
							}
						}
						if (imyinit == RANDOM_INIT) {
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = (rand() / ((doublerealT)RAND_MAX));
							}
						}
						//for (integer i_37 = 1; i_37 <= igam; i_37++)
					{
						doublerealT R0_3 = 0.0;
						doublerealT Rprev_3 = 0.0, Rnext_3 = 0.0;
						if (process_flow_logic) {
							// calculate initial residual.
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


							R0_3 = norma(residual_fine3, n_a[3]);
							Rprev_3 = R0_3;

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu1; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 > process_flow_beta*Rprev_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu1) {
								printf("level 3 limit presmother iteration is reached\n");
							}

						}
						else {
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}


						move_down(nu1, nu2);


						if (ilevel > 4) {
							// residual
							if (!process_flow_logic) {
								//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

								//speshial
								//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							}


							//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
							if (imyinit == ZERO_INIT) {
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = 0.0;
								}
							}
							if (imyinit == RANDOM_INIT) {
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = (rand() / ((doublerealT)RAND_MAX));
								}
							}

							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
						{
							doublerealT R0_4 = 0.0;
							doublerealT Rprev_4 = 0.0, Rnext_4 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


								R0_4 = norma(residual_fine4, n_a[4]);
								Rprev_4 = R0_4;

								// smother
								integer iter = 0;
								for (iter = 0; iter < nu1; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 > process_flow_beta*Rprev_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu1) {
									printf("level 4 limit presmother iteration is reached\n");
								}

							}
							else {
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}


							move_down(nu1, nu2);

							if (ilevel > 5) {
								// residual
								if (!process_flow_logic) {
									//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

									//speshial 14 september 2015.
									//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								}


								//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
								if (imyinit == ZERO_INIT) {
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = 0.0;
									}
								}
								if (imyinit == RANDOM_INIT) {
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = (rand() / ((doublerealT)RAND_MAX));
									}
								}

								// pre smothing
								//for (integer i_37 = 1; i_37 <= igam; i_37++)
							{
								doublerealT R0_5 = 0.0;
								doublerealT Rprev_5 = 0.0, Rnext_5 = 0.0;
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);



									R0_5 = norma(residual_fine5, n_a[5]);
									Rprev_5 = R0_5;

									// smother
									integer iter = 0;
									for (iter = 0; iter < nu1; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 > process_flow_beta*Rprev_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu1) {
										printf("level 5 limit presmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu1; iter++) {
										//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}


								move_down(nu1, nu2);

								if (ilevel > 6) {
									// residual
									if (!process_flow_logic) {
										//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
										//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
										//if (ilevel <= 15) {
										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

										//}
										//else {
										// приводит к расходимости.
										//speshial 14 september 2015.
										// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
										//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										//}
									}

									//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
									if (imyinit == ZERO_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = 0.0;
										}
									}
									if (imyinit == RANDOM_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = (rand() / ((doublerealT)RAND_MAX));
										}
									}

									//for (integer i_37 = 1; i_37 <= igam; i_37++) 
									{
										// pre smothing

										doublerealT R0_6 = 0.0;
										doublerealT Rprev_6 = 0.0, Rnext_6 = 0.0;
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
											residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



											R0_6 = norma(residual_fine6, n_a[6]);
											Rprev_6 = R0_6;

											// smother
											integer iter = 0;
											for (iter = 0; iter < nu1; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);


												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 > process_flow_beta*Rprev_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu1) {
												printf("level 6 limit presmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu1; iter++) {
												//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}


										move_down(nu1, nu2);

										if (ilevel > 7) {
											// residual
											if (!process_flow_logic) {
												//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
												//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);
											}

											//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

											// restriction
											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

											// Amat*e=r;
											//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
											if (imyinit == ZERO_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = 0.0;
												}
											}
											if (imyinit == RANDOM_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = (rand() / ((doublerealT)RAND_MAX));
												}
											}

											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
											{

												// pre smothing


												doublerealT R0_7 = 0.0;
												doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
													residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);



													R0_7 = norma(residual_fine7, n_a[7]);
													Rprev_7 = R0_7;

													// smother
													integer iter = 0;
													for (iter = 0; iter < nu1; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 > process_flow_beta*Rprev_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu1) {
														printf("level 7 limit presmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu1; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}


												move_down(nu1, nu2);

												if (ilevel > 8) {
													// residual
													if (!process_flow_logic) {
														//doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);
														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

													}


													//doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

													// restriction
													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

													// Amat*e=r;
													//doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
													if (imyinit == ZERO_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = 0.0;
														}
													}
													if (imyinit == RANDOM_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = (rand() / ((doublerealT)RAND_MAX));
														}
													}

													//for (integer i_37 = 1; i_37 <= igam; i_37++)
													{
														// pre smothing
														for (integer iter = 0; iter < nu1; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
															//nested_desection8 futures

														}


														if (ilevel > 9) {
															// residual
															//doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7];
															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
															residual(Amat, n1, n2, error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);


															//doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

															// restriction
															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															restriction(R, n3, n4, flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);

															// Amat*e=r;
															//doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
															if (imyinit == ZERO_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = 0.0;
																}
															}
															if (imyinit == RANDOM_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = (rand() / ((doublerealT)RAND_MAX));
																}
															}

															//for (integer i_37 = 1; i_37 <= igam; i_37++) 
															{
																// pre smothing
																for (integer iter = 0; iter < nu1; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}


																move_down(nu1, nu2);

																if (ilevel > 10) {
																	// 8 сентября 2015 РИМИНИ пляж 

																	// residual
																	//doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	residual(Amat, n1, n2, error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);


																	//doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

																	// restriction
																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	restriction(R, n3, n4, flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);

																	// Amat*e=r;
																	//doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];


																	if (imyinit == ZERO_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = 0.0;
																		}
																	}
																	if (imyinit == RANDOM_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = (rand() / ((doublerealT)RAND_MAX));
																		}
																	}

																	//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																	{
																		// pre smothing
																		for (integer iter = 0; iter < nu1; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}

																		// до 11 уровня вроде всё верно 3 января 2016

																		move_down(nu1, nu2);

																		if (ilevel > 11) {
																			// 8 сентября 2015 РИМИНИ пляж 

																			// residual
																			//doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
																			integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			residual(Amat, n1, n2, error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);


																			//doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

																			// restriction
																			integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			restriction(R, n3, n4, flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);

																			// Amat*e=r;
																			//doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];


																			if (imyinit == ZERO_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = 0.0;
																				}
																			}
																			if (imyinit == RANDOM_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = (rand() / ((doublerealT)RAND_MAX));
																				}
																			}

																			//for (integer i_37 = 1; i_37 <= igam; i_37++)
																			{
																				// pre smothing
																				for (integer iter = 0; iter < nu1; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}

																				move_down(nu1, nu2);

																				if (ilevel > 12) {
																					// 11 сентября 2015 РИМИНИ пляж 

																					// residual
																					//doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
																					integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					residual(Amat, n1, n2, error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);


																					//doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

																					// restriction
																					integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					restriction(R, n3, n4, flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);

																					// Amat*e=r;
																					//doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];

																					if (imyinit == ZERO_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = 0.0;
																						}
																					}
																					if (imyinit == RANDOM_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = (rand() / ((doublerealT)RAND_MAX));
																						}
																					}

																					//for (integer i_37 = 1; i_37 <= igam; i_37++)
																					{
																						// pre smothing
																						for (integer iter = 0; iter < nu1; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}

																						move_down(nu1, nu2);

																						if (ilevel > 13) {
																							// 11 сентября 2015 РИМИНИ пляж 

																							// residual
																							//doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
																							integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							residual(Amat, n1, n2, error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);


																							//doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

																							// restriction
																							integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							restriction(R, n3, n4, flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);

																							// Amat*e=r;
																							//doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];

																							if (imyinit == ZERO_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = 0.0;
																								}
																							}
																							if (imyinit == RANDOM_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = (rand() / ((doublerealT)RAND_MAX));
																								}
																							}

																							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																							{
																								// pre smothing
																								for (integer iter = 0; iter < nu1; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}


																								move_down(nu1, nu2);

																								if (ilevel > 14) {
																									// 11 сентября 2015 РИМИНИ пляж 

																									// residual
																									//doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																									integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									residual(Amat, n1, n2, error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);


																									//doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																									// restriction
																									integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									restriction(R, n3, n4, flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);

																									// Amat*e=r;
																									//doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];

																									if (imyinit == ZERO_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = 0.0;
																										}
																									}
																									if (imyinit == RANDOM_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = (rand() / ((doublerealT)RAND_MAX));
																										}
																									}


																									//for (integer i_37 = 1; i_37 <= igam; i_37++)
																									{
																										// pre smothing
																										for (integer iter = 0; iter < nu1; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}


																										move_down(nu1, nu2);

																										if (ilevel > 15) {
																											// 14 сентября 2015 Москва на работе в пн. 

																											// residual
																											//doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																											integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											residual(Amat, n1, n2, error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);


																											//doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																											// restriction
																											integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											restriction(R, n3, n4, flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																											// Amat*e=r;
																											//doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																											if (imyinit == ZERO_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = 0.0;
																												}
																											}
																											if (imyinit == RANDOM_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = (rand() / ((doublerealT)RAND_MAX));
																												}
																											}

																											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																											{
																												// pre smothing
																												for (integer iter = 0; iter < nu1; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}


																												move_down(nu1, nu2);

																												if (ilevel > 16) {
																													// 10 октября 2015. 

																													// residual
																													//doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																													integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													residual(Amat, n1, n2, error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);


																													//doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																													// restriction
																													integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													restriction(R, n3, n4, flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																													// Amat*e=r;
																													//doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];

																													if (imyinit == ZERO_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = 0.0;
																														}
																													}
																													if (imyinit == RANDOM_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = (rand() / ((doublerealT)RAND_MAX));
																														}
																													}

																													//for (integer i_37 = 1; i_37 <= igam; i_37++)
																													{
																														// pre smothing
																														for (integer iter = 0; iter < nu1; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}


																														move_down(nu1, nu2);

																														if (ilevel > 17) {
																															// 10 октября 2015. 

																															// residual
																															//doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																															integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															residual(Amat, n1, n2, error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);


																															//doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																															// restriction
																															integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															restriction(R, n3, n4, flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																															// Amat*e=r;
																															//doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																															if (imyinit == ZERO_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = 0.0;
																																}
																															}
																															if (imyinit == RANDOM_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = (rand() / ((doublerealT)RAND_MAX));
																																}
																															}


																															//for (integer i_37 = 1; i_37 <= igam; i_37++)
																															{
																																// pre smothing
																																for (integer iter = 0; iter < nu1; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}

																																move_down(nu1, nu2);


																																if (ilevel > 18) {
																																	// 5 декабря 2015. 

																																	// residual
																																	//doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																																	integer n1 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n2 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	residual(Amat, n1, n2, error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);


																																	//doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																																	// restriction
																																	integer n3 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n4 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	restriction(R, n3, n4, flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);

																																	// Amat*e=r;
																																	//doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];

																																	if (imyinit == ZERO_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = 0.0;
																																		}
																																	}
																																	if (imyinit == RANDOM_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = (rand() / ((doublerealT)RAND_MAX));
																																		}
																																	}


																																	//for (integer i_37 = 1; i_37 <= igam; i_37++)
																																	{
																																		// pre smothing
																																		for (integer iter = 0; iter < nu1; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}

																																		// post smothing
																																		for (integer iter = 0; iter < nu2; iter++) {
																																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17] + nnz_a[18];
																																			seidel(Amat, n5, n6, error_approx_coarse17, residual_coarse17, flag, n_a[18]);
																																		}
																																	}

																																	// prolongation
																																	// residual_r
																																	//doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_fine17[ii] = 0.0;
																																	}



																																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17];
																																	prolongation(P, n7, n8, flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																																	// correction
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_coarse16[ii] += error_approx_fine17[ii];
																																	}

																																	// free
																																	//delete[] error_approx_fine17;
																																	//delete[] error_approx_coarse17;
																																	//delete[] residual_coarse17;
																																	//delete[] residual_fine17;

																																}



																																// post smothing
																																for (integer iter = 0; iter < nu2; iter++) {
																																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16] + nnz_a[17];
																																	seidel(Amat, n5, n6, error_approx_coarse16, residual_coarse16, flag, n_a[17]);
																																}
																															}
																															move_up(nu1, nu2);

																															// prolongation
																															// residual_r
																															//doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_fine16[ii] = 0.0;
																															}



																															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16];
																															prolongation(P, n7, n8, flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																															// correction
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_coarse15[ii] += error_approx_fine16[ii];
																															}

																															// free
																															//delete[] error_approx_fine16;
																															//delete[] error_approx_coarse16;
																															//delete[] residual_coarse16;
																															//delete[] residual_fine16;

																														}


																														// post smothing
																														for (integer iter = 0; iter < nu2; iter++) {
																															integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																															integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15] + nnz_a[16];
																															seidel(Amat, n5, n6, error_approx_coarse15, residual_coarse15, flag, n_a[16]);
																														}
																													}
																													move_up(nu1, nu2);

																													// prolongation
																													// residual_r
																													//doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_fine15[ii] = 0.0;
																													}



																													integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																													integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15];
																													prolongation(P, n7, n8, flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																													// correction
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_coarse14[ii] += error_approx_fine15[ii];
																													}

																													// free
																													//delete[] error_approx_fine15;
																													//delete[] error_approx_coarse15;
																													//delete[] residual_coarse15;
																													//delete[] residual_fine15;

																												}

																												// post smothing
																												for (integer iter = 0; iter < nu2; iter++) {
																													integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																													integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14] + nnz_a[15];
																													seidel(Amat, n5, n6, error_approx_coarse14, residual_coarse14, flag, n_a[15]);
																												}
																											}
																											move_up(nu1, nu2);

																											// prolongation
																											// residual_r
																											//doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_fine14[ii] = 0.0;
																											}



																											integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																											integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14];
																											prolongation(P, n7, n8, flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																											// correction
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_coarse13[ii] += error_approx_fine14[ii];
																											}

																											// free
																											//delete[] error_approx_fine14;
																											//delete[] error_approx_coarse14;
																											//delete[] residual_coarse14;
																											//delete[] residual_fine14;

																										}


																										// post smothing
																										for (integer iter = 0; iter < nu2; iter++) {
																											integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																											integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13] + nnz_a[14];
																											seidel(Amat, n5, n6, error_approx_coarse13, residual_coarse13, flag, n_a[14]);
																										}
																									}

																									move_up(nu1, nu2);

																									// prolongation
																									// residual_r
																									//doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_fine13[ii] = 0.0;
																									}

#if doubleintprecision == 1
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#else
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#endif
																									

																									integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																									integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13];
																									prolongation(P, n7, n8, flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																									// correction
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_coarse12[ii] += error_approx_fine13[ii];
																									}

																									// free
																									//delete[] error_approx_fine13;
																									//delete[] error_approx_coarse13;
																									//delete[] residual_coarse13;
																									//delete[] residual_fine13;

																								}


																								// post smothing
																								for (integer iter = 0; iter < nu2; iter++) {
																									integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																									integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12] + nnz_a[13];
																									seidel(Amat, n5, n6, error_approx_coarse12, residual_coarse12, flag, n_a[13]);
																								}
																							}

																							move_up(nu1, nu2);

																							// prolongation
																							// residual_r
																							//doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_fine12[ii] = 0.0;
																							}

#if doubleintprecision == 1
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#else
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#endif

																							

																							integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																							integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12];
																							prolongation(P, n7, n8, flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);

																							// correction
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_coarse11[ii] += error_approx_fine12[ii];
																							}

																							// free
																							//delete[] error_approx_fine12;
																							//delete[] error_approx_coarse12;
																							//delete[] residual_coarse12;
																							//delete[] residual_fine12;

																						}



																						// post smothing
																						for (integer iter = 0; iter < nu2; iter++) {
																							integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																							integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11] + nnz_a[12];
																							seidel(Amat, n5, n6, error_approx_coarse11, residual_coarse11, flag, n_a[12]);
																						}
																					}
																					move_up(nu1, nu2);

																					// prolongation
																					// residual_r
																					//doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_fine11[ii] = 0.0;
																					}

#if doubleintprecision == 1
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#else
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#endif

																					

																					integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																					integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11];
																					prolongation(P, n7, n8, flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);

																					// correction
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_coarse10[ii] += error_approx_fine11[ii];
																					}

																					// free
																					//delete[] error_approx_fine11;
																					//delete[] error_approx_coarse11;
																					//delete[] residual_coarse11;
																					//delete[] residual_fine11;

																				}


																				// post smothing
																				for (integer iter = 0; iter < nu2; iter++) {
																					integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																					integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10] + nnz_a[11];
																					seidel(Amat, n5, n6, error_approx_coarse10, residual_coarse10, flag, n_a[11]);
																				}
																			}
																			move_up(nu1, nu2);

																			// prolongation
																			// residual_r
																			//doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_fine10[ii] = 0.0;
																			}

#if doubleintprecision == 1
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#else
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#endif

																			

																			integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																			integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10];
																			prolongation(P, n7, n8, flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

																			// correction
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_coarse9[ii] += error_approx_fine10[ii];
																			}

																			// free
																			//delete[] error_approx_fine10;
																			//delete[] error_approx_coarse10;
																			//delete[] residual_coarse10;
																			//delete[] residual_fine10;

																		}



																		// post smothing
																		for (integer iter = 0; iter < nu2; iter++) {
																			integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																			integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9] + nnz_a[10];
																			seidel(Amat, n5, n6, error_approx_coarse9, residual_coarse9, flag, n_a[10]);
																		}
																	}

																	move_up(nu1, nu2);

																	// prolongation
																	// residual_r
																	//doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_fine9[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif

																	

																	integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
																	integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9];
																	prolongation(P, n7, n8, flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

																	// correction
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_coarse8[ii] += error_approx_fine9[ii];
																	}

																	// free
																	//delete[] error_approx_fine9;
																	//delete[] error_approx_coarse9;
																	//delete[] residual_coarse9;
																	//delete[] residual_fine9;

																}

																// post smothing
																for (integer iter = 0; iter < nu2; iter++) {
																	integer n5 = 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
																	integer n6 = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8] + nnz_a[9];
																	seidel(Amat, n5, n6, error_approx_coarse8, residual_coarse8, flag, n_a[9]);
																}
															}

															move_up(nu1, nu2);

															// prolongation
															// residual_r
															//doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_fine8[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif

															

															integer n7 = 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7];
															integer n8 = nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8];
															prolongation(P, n7, n8, flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);

															// correction
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_coarse7[ii] += error_approx_fine8[ii];
															}

															// free
															//delete[] error_approx_fine8;
															//delete[] error_approx_coarse8;
															//delete[] residual_coarse8;
															//delete[] residual_fine8;

														}




														// post smothing
														for (integer iter = 0; iter < nu2; iter++) {
															seidel(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8]);
														}
													}
													move_up(nu1, nu2);

													// prolongation
													// residual_r
													//doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_fine7[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif

													

													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

													// correction
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_coarse6[ii] += error_approx_fine7[ii];
													}

													// free
													//delete[] error_approx_fine7;
													//delete[] error_approx_coarse7;
													//delete[] residual_coarse7;
													//delete[] residual_fine7;

												}

												// post smothing
												//doublerealT R0_7 = 0.0;
												//doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);



													//Rprev_7 = norma(residual_fine7, n_a[7]);


													// smother
													integer iter = 0;
													for (iter = 0; iter < nu2; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 < process_flow_alpha*R0_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu2) {
														printf("level 7 limit postsmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu2; iter++) {
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}
											}

											move_up(nu1, nu2);


											// prolongation
											// residual_r
											//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_fine6[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif

											

											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

											// correction
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_coarse5[ii] += error_approx_fine6[ii];
											}

											// free
											//delete[] error_approx_fine6;
											//delete[] error_approx_coarse6;
											//delete[] residual_coarse6;
											//delete[] residual_fine6;

										}



										// post smothing
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);



											//Rprev_6 = norma(residual_fine6, n_a[6]);


											// smother
											integer iter = 0;
											for (iter = 0; iter < nu2; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 < process_flow_alpha*R0_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu2) {
												printf("level 6 limit postsmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu2; iter++) {
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}
									}

									move_up(nu1, nu2);

									// prolongation
									// residual_r
									//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_fine5[ii] = 0.0;
									}

#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif

									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

									// correction
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] += error_approx_fine5[ii];
									}

									// free
									//delete[] error_approx_fine5;
									//delete[] error_approx_coarse5;
									//delete[] residual_coarse5;
									//delete[] residual_fine5;

								}



								// post smothing
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);



									//Rprev_5 = norma(residual_fine5, n_a[5]);


									// smother
									integer iter = 0;
									for (iter = 0; iter < nu2; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 < process_flow_alpha*R0_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu2) {
										printf("level 5 limit postsmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu2; iter++) {
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else
										{
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}
							}

							move_up(nu1, nu2);

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}


#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif

							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

							}




							// post smothing
							if (process_flow_logic) {


								// smother
								integer iter = 0;
								for (iter = 0; iter < nu2; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] , residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 < process_flow_alpha*R0_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu2) {
									printf("level 4 limit postsmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu2; iter++) {
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}
						}
						move_up(nu1, nu2);

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}

#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif

						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

						}



						// post smothing
						if (process_flow_logic) {


							// smother
							integer iter = 0;
							for (iter = 0; iter < nu2; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}

								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] , residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 < process_flow_alpha*R0_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu2) {
								printf("level 3 limit postsmother iteration is reached\n");
							}

						}
						else {
							for (integer iter = 0; iter < nu2; iter++) {
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}
					}

					move_up(nu1, nu2);

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif

					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

					}


					// post smothing
					if (process_flow_logic) {


						// smother
						integer iter = 0;
						for (iter = 0; iter < nu2; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);



							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 < process_flow_alpha*R0_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu2) {
							printf("level 2 limit postsmother iteration is reached\n");
						}

					}
					else {
						for (integer iter = 0; iter < nu2; iter++) {
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}
					}
				}

				move_up(nu1, nu2);

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}


#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif

			

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

				}



				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);


						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 < process_flow_alpha*R0_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu2) {
						printf("level 1 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}
			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}

			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}



		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			Rprev_0 = norma(residual_fine, n_a[0]);

			// smother
			//integer iter = 0;
			//for (iter = 0; iter < nu2; iter++) {
			//quick seidel
			if (bonly_serial) {
				//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
			}
			else {
				//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
			}
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			//	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine,diag0);
			//	Rnext_0 = norma(residual_fine, n_a[0]);
			// this is process flow logic
			//	if (Rnext_0 < process_flow_alpha*R0_0) {
			// Смысл модификации в том что мы экономим итерации на пресмутере.
			//		break; // досрочно опускаемся на следующий уровень если он есть конечно.
			//	}
			//	else {
			//		Rprev_0 = Rnext_0;
			//	}
			//	}
			//if (iter == nu1) {
			//	printf("level 0 limit postsmother iteration is reached\n");
			//}

		}
		//else {
		// nFinnestSweeps new logic 14 jan 2016.
		// smother
		//for (integer iter = 0; iter < nu2; iter++) {
		//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
		//quick seidel
		if (bonly_serial) {
			//	seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
		}
		else {
			//seidelq(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
		}
		//			}
		//}






		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");




	// free
	/*
	delete[] diag0;
	delete[] error_approx_fine;
	if (ilevel > 1) {
	delete[] diag1;
	delete[] error_approx_coarse;
	delete[] residual_coarse;
	if (ilevel > 2) {
	// free
	delete[] diag2;
	delete[] error_approx_fine1;
	delete[] error_approx_coarse1;
	delete[] residual_coarse1;
	delete[] residual_fine1;
	if (ilevel > 3) {
	// free
	delete[] diag3;
	delete[] error_approx_fine2;
	delete[] error_approx_coarse2;
	delete[] residual_coarse2;
	delete[] residual_fine2;
	if (ilevel > 4) {
	// free
	delete[] diag4;
	delete[] error_approx_fine3;
	delete[] error_approx_coarse3;
	delete[] residual_coarse3;
	delete[] residual_fine3;
	if (ilevel > 5) {
	// free
	delete[] diag5;
	delete[] error_approx_fine4;
	delete[] error_approx_coarse4;
	delete[] residual_coarse4;
	delete[] residual_fine4;
	if (ilevel > 6) {
	// free
	delete[] diag6;
	delete[] error_approx_fine5;
	delete[] error_approx_coarse5;
	delete[] residual_coarse5;
	delete[] residual_fine5;
	if (ilevel > 7) {
	// free
	delete[] diag7;
	delete[] error_approx_fine6;
	delete[] error_approx_coarse6;
	delete[] residual_coarse6;
	delete[] residual_fine6;
	if (ilevel > 8) {
	// free
	delete[] diag8;
	delete[] error_approx_fine7;
	delete[] error_approx_coarse7;
	delete[] residual_coarse7;
	delete[] residual_fine7;
	if (ilevel > 9) {
	// free
	delete[] error_approx_fine8;
	delete[] error_approx_coarse8;
	delete[] residual_coarse8;
	delete[] residual_fine8;
	if (ilevel > 10) {
	// free
	delete[] error_approx_fine9;
	delete[] error_approx_coarse9;
	delete[] residual_coarse9;
	delete[] residual_fine9;
	if (ilevel > 11) {
	// free
	delete[] error_approx_fine10;
	delete[] error_approx_coarse10;
	delete[] residual_coarse10;
	delete[] residual_fine10;
	if (ilevel > 12) {
	// free
	delete[] error_approx_fine11;
	delete[] error_approx_coarse11;
	delete[] residual_coarse11;
	delete[] residual_fine11;
	if (ilevel > 13) {
	// free
	delete[] error_approx_fine12;
	delete[] error_approx_coarse12;
	delete[] residual_coarse12;
	delete[] residual_fine12;
	if (ilevel > 14) {
	// free
	delete[] error_approx_fine13;
	delete[] error_approx_coarse13;
	delete[] residual_coarse13;
	delete[] residual_fine13;
	if (ilevel > 15) {
	// free
	delete[] error_approx_fine14;
	delete[] error_approx_coarse14;
	delete[] residual_coarse14;
	delete[] residual_fine14;
	if (ilevel > 16) {
	// free
	delete[] error_approx_fine15;
	delete[] error_approx_coarse15;
	delete[] residual_coarse15;
	delete[] residual_fine15;
	if (ilevel > 17) {
	// free
	delete[] error_approx_fine16;
	delete[] error_approx_coarse16;
	delete[] residual_coarse16;
	delete[] residual_fine16;
	if (ilevel > 18) {
	// free
	delete[] error_approx_fine17;
	delete[] error_approx_coarse17;
	delete[] residual_coarse17;
	delete[] residual_fine17;

	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	*/

	// free
	free(diag0);
	free(bnested_desection_global_amg);  // Глобальная память.
	free(nested_desection0);
	free(error_approx_fine);
	if (ilevel > 1) {
		free(diag1);
		free(nested_desection1);
		free(error_approx_coarse);
		free(residual_coarse);
		if (ilevel > 2) {
			// free
			free(diag2);
			free(nested_desection2);
			free(error_approx_fine1);
			free(error_approx_coarse1);
			free(residual_coarse1);
			free(residual_fine1);
			if (ilevel > 3) {
				// free
				free(diag3);
				free(nested_desection3);
				free(error_approx_fine2);
				free(error_approx_coarse2);
				free(residual_coarse2);
				free(residual_fine2);
				if (ilevel > 4) {
					// free
					free(diag4);
					free(nested_desection4);
					free(error_approx_fine3);
					free(error_approx_coarse3);
					free(residual_coarse3);
					free(residual_fine3);
					if (ilevel > 5) {
						// free
						free(diag5);
						free(nested_desection5);
						free(error_approx_fine4);
						free(error_approx_coarse4);
						free(residual_coarse4);
						free(residual_fine4);
						if (ilevel > 6) {
							// free
							free(diag6);
							free(nested_desection6);
							free(error_approx_fine5);
							free(error_approx_coarse5);
							free(residual_coarse5);
							free(residual_fine5);
							if (ilevel > 7) {
								// free
								free(diag7);
								free(nested_desection7);
								free(error_approx_fine6);
								free(error_approx_coarse6);
								free(residual_coarse6);
								free(residual_fine6);
								if (ilevel > 8) {
									// free
									free(diag8);
									free(nested_desection8);
									free(error_approx_fine7);
									free(error_approx_coarse7);
									free(residual_coarse7);
									free(residual_fine7);
									if (ilevel > 9) {
										// free
										free(error_approx_fine8);
										free(error_approx_coarse8);
										free(residual_coarse8);
										free(residual_fine8);
										if (ilevel > 10) {
											// free
											free(error_approx_fine9);
											free(error_approx_coarse9);
											free(residual_coarse9);
											free(residual_fine9);
											if (ilevel > 11) {
												// free
												free(error_approx_fine10);
												free(error_approx_coarse10);
												free(residual_coarse10);
												free(residual_fine10);
												if (ilevel > 12) {
													// free
													free(error_approx_fine11);
													free(error_approx_coarse11);
													free(residual_coarse11);
													free(residual_fine11);
													if (ilevel > 13) {
														// free
														free(error_approx_fine12);
														free(error_approx_coarse12);
														free(residual_coarse12);
														free(residual_fine12);
														if (ilevel > 14) {
															// free
															free(error_approx_fine13);
															free(error_approx_coarse13);
															free(residual_coarse13);
															free(residual_fine13);
															if (ilevel > 15) {
																// free
																free(error_approx_fine14);
																free(error_approx_coarse14);
																free(residual_coarse14);
																free(residual_fine14);
																if (ilevel > 16) {
																	// free
																	free(error_approx_fine15);
																	free(error_approx_coarse15);
																	free(residual_coarse15);
																	free(residual_fine15);
																	if (ilevel > 17) {
																		// free
																		free(error_approx_fine16);
																		free(error_approx_coarse16);
																		free(residual_coarse16);
																		free(residual_fine16);
																		if (ilevel > 18) {
																			// free
																			free(error_approx_fine17);
																			free(error_approx_coarse17);
																			free(residual_coarse17);
																			free(residual_fine17);

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}


	//delete[] residual_fine;
	free(residual_fine);

	//delete[] row_ptr_start;
	//delete[] row_ptr_end;
	free(row_ptr_start);
	free(row_ptr_end);


	//delete[] flag_shadow;
	free(flag_shadow);


	//delete[] flag;
	free(flag);
	return 0;

} // classic_aglomerative_amg3

// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
// Объявление функции которая нужна уже здесь но её реализация
// встретится лишь ниже по тексту в файле my_linalg.c.
void QuickSortCSIR(integer* &jptr, doublereal* &altr, integer first, integer last);



// Объявление структуры LEVEL_ADDITIONAL_DATA см. в файле ilut.c:
// 11 августа 2016.

// Объявление структуры LEVEL_ADDITIONAL_DATA0 см. в файле ilut.c:
// 11 августа 2016.

// Выделение оперативной прамяти для : 
// LEVEL_ADDITIONAL_DATA_BUFER milu_gl_buffer
void memory_allocation_apostoriory_buffer_ilu(LEVEL_ADDITIONAL_DATA* &milu2, integer ilevel) {
	if (milu_gl_buffer.alu_copy != NULL) {
		delete[] milu_gl_buffer.alu_copy;
		milu_gl_buffer.alu_copy = NULL;
	}
	if (milu_gl_buffer.jlu_copy != NULL) {
		delete[] milu_gl_buffer.jlu_copy;
		milu_gl_buffer.jlu_copy = NULL;
	}
	if (milu_gl_buffer.ju_copy != NULL) {
		delete[] milu_gl_buffer.ju_copy;
		milu_gl_buffer.ju_copy = NULL;
	}

	// Определяем максимум памяти чтобы хватило универсально на все уровни.
	integer iwk = -1;
	integer maxelm_plus_maxbound = -1;
	for (integer i = 0; i <= ilevel; i++) {
		if (iwk < milu2[i].iwk) iwk = milu2[i].iwk;
		if (maxelm_plus_maxbound < milu2[i].maxelm_plus_maxbound) maxelm_plus_maxbound = milu2[i].maxelm_plus_maxbound;
	}

	milu_gl_buffer.alu_copy = new doublereal[iwk + 2]; // +2 запас по памяти.
	milu_gl_buffer.jlu_copy = new integer[iwk + 2];
	milu_gl_buffer.ju_copy = new integer[maxelm_plus_maxbound + 2];
} // memory_allocation_apostoriory_buffer_ilu

// 15 11 2016 метод полностью на malloc с контролем через handle_error.
// Мы усилим РУМБА0.14 алгоритм ILU2 предобуславливанием на каждом уровне вложенности.
// Преобразует equation3D  формат хранения в CRS формат.
// Цель написания этого преобразователя: экономия оперативной памяти компьютера.
// Т.к. формат SIMPLESPARSE требует слишком много памяти.
void equation3DtoCRSRUMBA1(LEVEL_ADDITIONAL_DATA &milu2,
	bool ballocmemory, Ak1* &Amat, integer istartq, integer iendq, 
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, integer ilevel) {

	// Если ballocmemory равен true то происходит выделение памяти.
	const bool bonly_negative_connections = false;
	bool flag = true;
	integer n = 0; // число ненулевых элементов
	integer maxelm_plus_maxbound = 0; // Число уравнений в СЛАУ.

	const doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;


	// подсчёт количества ненулевых элементов
	// во всех точках расчётной области как внутренних так и граничных.
	for (integer ii = startpos; ii <= endpos; ii++) {
		maxelm_plus_maxbound++;
		integer istr = ii - iadd;
		if (fabs(Amat[row_ptr_start[ii]].aij) < 1.0e-20)
		{
#if doubleintprecision == 1
			printf("zero diagonal coefficient in level = %lld, istr=%lld\n", ilevel, istr);
#else
			printf("zero diagonal coefficient in level = %d, istr=%d\n", ilevel, istr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}
		doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

		//if (fabs(ap_now)> 1e10*nonzeroEPS) n++; // диагональный элемент
		if (ap_now > nonzeroEPS) n++; // Диагональный элемент.
		else {
			// 5 августа 2016. 
			flag = false;
			printf("internal zero diagonal element.\n");
			//printf("ae=%e aw=%e an=%e as=%e at=%e ab=%e sum_nb=%e", sl[k].ae, sl[k].aw, sl[k].an, sl[k].as, sl[k].at, sl[k].ab, sl[k].ae + sl[k].aw + sl[k].an + sl[k].as + sl[k].at + sl[k].ab);
			if (ap_now < 0.0) {
				printf("found negativ diagonal coefficient=%e...\n", ap_now);
			}
			printf("fatal error equation3DtoCRS in RUMBA...\n");
			//getchar();
			system("PAUSE");
			exit(1);
			//n++;
			//sl[k].ap = fabs(sl[k].ae) + fabs(sl[k].aw) + fabs(sl[k].an) + fabs(sl[k].as) + fabs(sl[k].at) + fabs(sl[k].ab);
		}

		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];

		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			if (bonly_negative_connections) {
				if (Amat[ii1].aij < -nonzeroEPS) {
					n++;
				}
			}
			else {
				if (fabs(Amat[ii1].aij) > nonzeroEPS) n++;
			}
		}
	}


	if (flag) {
		// memory +15N
		// Теперь выделение памяти будет происходить централизованно, вне данного кода.
		// Это сделано для кода BICGSTAB_internal3. дата изменения 12 апреля 2013.
		// Другой код, использующий equation3dtoCRS может оказаться неработоспособным после этого изменения.
		if (ballocmemory) {
			// Важно выделить память с запасом, т.к. одна и таже память используется и для компонент скорости и для попрапвки давления.
			//val = new doublereal[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			//col_ind = new integer[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			
			//milu2.val = new doublereal[n + 2];
			milu2.val = (doublereal*)malloc((n+2) * sizeof(doublereal));
			char c1[11] = "milu2.val";
			char c2[23] = "equation3DtoCRSRUMBA1";
			handle_error<doublereal>(milu2.val,  c1, c2, (n + 2));
			//milu2.col_ind = new integer[n + 2];
			milu2.col_ind = (integer*)malloc((n + 2) * sizeof(integer));
			char c3[14] = "milu2.col_ind";
			handle_error<integer>(milu2.col_ind, c3, c2, (n + 2));
			//row_ptr = new integer[(maxelm + maxbound) + 1];
			//milu2.row_ptr = new integer[maxelm_plus_maxbound + 1];
			milu2.row_ptr= (integer*)malloc((maxelm_plus_maxbound + 1) * sizeof(integer));
			char c4[14] = "milu2.row_ptr";
			handle_error<integer>(milu2.row_ptr, c4, c2, (maxelm_plus_maxbound + 1));

			if ((milu2.val == NULL) || (milu2.col_ind == NULL) || (milu2.row_ptr == NULL)) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
		}


		// инициализация
#pragma omp parallel for
		for (integer k = 0; k<(n); k++) {
			milu2.val[k] = 0.0;
			milu2.col_ind[k] = -1;
		}
#pragma omp parallel for
		for (integer k = 0; k <= (maxelm_plus_maxbound); k++) {
			milu2.row_ptr[k] = n; // присваиваем количество ненулевых элементов плюс 1 с учётом того что нумерация массива начинается с 0
		}

		// Быстрая Сортировка Хоара.
		// упорядочивание по строкам
		//QuickSort(...); не требуется,
		// т.к. сама структура хранения 
		// подразумевает упорядочивание по строкам.

		/*
		// заполнение разреженной матрицы
		for (integer k=0; k<M.n; k++) {
		val[k]=M.a[k].aij;
		col_ind[k]=M.a[k].j;
		row_ptr[M.a[k].i]=min(k,row_ptr[M.a[k].i]);
		}
		*/
		integer ik = 0; // счётчик ненулевых элементов СЛАУ

		// для всех узлов расчётной области как внутренних так и внешних:
		for (integer ii = startpos; ii <= endpos; ii++) {
			 integer istr = ii - iadd;
			 integer k = istr-1; // нумерация с нуля.
			 doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;
		

			 // Диагональный коэффициент.
			if (fabs(ap_now) > nonzeroEPS) {
				milu2.val[ik] = ap_now;
				milu2.col_ind[ik] = istr-1; // Нуменрация начинается с нуля.
				milu2.row_ptr[k] = min(ik, milu2.row_ptr[k]);
				ik++;
			}

			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];

			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				if (bonly_negative_connections) {
					if (Amat[ii1].aij < -nonzeroEPS) {
						milu2.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu2.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu2.row_ptr[k] = min(ik, milu2.row_ptr[k]);
						ik++;
					}
				}
				else {
					if (fabs(Amat[ii1].aij) > nonzeroEPS) {
						milu2.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu2.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu2.row_ptr[k] = min(ik, milu2.row_ptr[k]);
						ik++;
					}
				}
			}
		}	

		// в каждой строке элементы отсортированы по номерам столбцов:
#pragma omp parallel for
		for (integer k = 0; k<(maxelm_plus_maxbound); k++) QuickSortCSIR(milu2.col_ind, milu2.val, milu2.row_ptr[k] + 1, milu2.row_ptr[k + 1] - 1);

#if doubleintprecision == 1
		//printf("n==%lld row_ptr=%lld\n", n, milu2.row_ptr[maxelm_plus_maxbound]);
#else
		//printf("n==%d row_ptr=%d\n", n, milu2.row_ptr[maxelm_plus_maxbound]);
#endif
		
		//getchar();

		milu2.maxelm_plus_maxbound = maxelm_plus_maxbound;
#pragma omp parallel for
		for (integer i = 0; i<milu2.row_ptr[maxelm_plus_maxbound]; i++) {
			milu2.col_ind[i] = milu2.col_ind[i] + 1;
		}
#pragma omp parallel for
		for (integer i = 0; i<maxelm_plus_maxbound + 1; i++) {
			milu2.row_ptr[i] = milu2.row_ptr[i] + 1;
		}

		/*
		FILE *fp;
		errno_t err;
		// создание файла для записи.
		if ((err = fopen_s( &fp, "matr.txt", "w")) != 0) {
		printf("Create File Error\n");
		}
		else {

		// debug
		for (k=0; k<=maxelm+maxbound; k++) {
		#if doubleintprecision == 1
			fprintf(fp,"%lld ",milu2.row_ptr[k]);
		#else
			fprintf(fp,"%d ",milu2.row_ptr[k]);
		#endif
		
		}
		fprintf(fp,"\n");
		for (k=0; k<milu2.row_ptr[maxelm+maxbound]; k++) {
		#if doubleintprecision == 1
			fprintf(fp, "%e %lld\n",milu2.val[k],milu2.col_ind[k]);
		#else
			fprintf(fp, "%e %d\n",milu2.val[k],milu2.col_ind[k]);
		#endif
		
		}

		fclose(fp);
		}
		printf("ready");
		getchar();
		*/
		doublereal radd = 0.0;
		/*
		if (ilevel == 0) {
			radd = 1.8;
		}
		else if (ilevel == 1) {
			radd = 4.2;
		}
		else if ((ilevel >=2)&&(ilevel<=5)) {
			radd = 7.0;
		}
		else if (ilevel==6) {
			radd = 7.0;
		}
		else {
			radd = 8.0;
		}
		*/
		if (1||milu2.lfil == 0) {
			//radd = 3.3*(n / (5.0*maxelm_plus_maxbound));
			//milu2.iwk = (integer)((milu2.lfil + 1 + radd) * n + 4 * maxelm_plus_maxbound);
			milu2.iwk = n + 4; // ilu0 не требует лишней памяти.
		}

		 // размерность памяти под матрицу предобуславливания.
		//milu2.alu = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
		milu2.alu = (doublereal*)malloc((milu2.iwk + 2) * sizeof(doublereal));
		char c1[23] = "equation3DtoCRSRUMBA1";
		char c2[11] = "milu2.alu";
		handle_error<doublereal>(milu2.alu, c2 ,  c1, (milu2.iwk + 2));
		//milu2.jlu = new integer[milu2.iwk + 2];
		milu2.jlu = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
		char c3[11] = "milu2.jlu";
		handle_error<integer>(milu2.jlu, c3,  c1, (milu2.iwk + 2));
		//milu2.ju = new integer[maxelm_plus_maxbound + 2];
		milu2.ju = (integer*)malloc((maxelm_plus_maxbound + 2) * sizeof(integer));
		char c4[10] = "milu2.ju";
		handle_error<integer>(milu2.ju, c4,  c1, (maxelm_plus_maxbound + 2));
		//milu2.levs = new integer[milu2.iwk + 2]; // уровень.
		milu2.levs = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
		char c5[12] = "milu2.levs";
		handle_error<integer>(milu2.levs, c5,  c1, (milu2.iwk + 2));
		//milu2.w = new doublereal[maxelm_plus_maxbound + 2]; // +2 запас по памяти.
		milu2.w = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c6[9] = "milu2.w";
		handle_error<doublereal>(milu2.w, c6 ,  c1, (maxelm_plus_maxbound + 2));
		char c7[10] = "milu2.jw";
		if (1 || milu2.lfil == 0) {
			//milu2.jw = new integer[3 * maxelm_plus_maxbound + 2]; // +2 запас по памяти.
			milu2.jw = (integer*)malloc((3 * maxelm_plus_maxbound + 2) * sizeof(integer));			
			handle_error<integer>(milu2.jw, c7,  c1, (3 * maxelm_plus_maxbound + 2));
		}
		else {
			if (ilevel < 6) {
				///milu2.jw = new integer[5 * maxelm_plus_maxbound + 2]; // +2 запас по памяти.
				milu2.jw = (integer*)malloc((5 * maxelm_plus_maxbound + 2) * sizeof(integer));
				handle_error<integer>(milu2.jw, c7,  c1, (5 * maxelm_plus_maxbound + 2));
			}
			else {
				//milu2.jw = new integer[12 * maxelm_plus_maxbound + 2]; // +2 запас по памяти.
				milu2.jw = (integer*)malloc((12 * maxelm_plus_maxbound + 2) * sizeof(integer));
				handle_error<integer>(milu2.jw, c7,  c1, (12 * maxelm_plus_maxbound + 2));
			}
		}
		if ((milu2.alu == NULL) || (milu2.jlu == NULL) || (milu2.levs == NULL) || (milu2.ju == NULL) || (milu2.w == NULL) || (milu2.jw == NULL)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		// копии объектов
		// 9 ноября 2016 Копии объектов теперь хранятся централизованно :
		// см. LEVEL_ADDITIONAL_DATA_BUFER milu_gl_buffer; in ilut.c module.
		//milu2.alu_copy = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
		//milu2.jlu_copy = new integer[milu2.iwk + 2];
		//milu2.ju_copy = new integer[maxelm_plus_maxbound + 2];
		//milu2.b_copy = new doublereal[maxelm_plus_maxbound + 2];
		char c8[13] = "milu2.b_copy";
		milu2.b_copy = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		handle_error<doublereal>(milu2.b_copy, c8 ,  c1, (maxelm_plus_maxbound + 2));
		//milu2.x_copy = new doublereal[maxelm_plus_maxbound + 2];
		milu2.x_copy = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c9[13] = "milu2.x_copy";
		handle_error<doublereal>(milu2.x_copy, c9,  c1, (maxelm_plus_maxbound + 2));
		//milu2.zbuf = new doublereal[maxelm_plus_maxbound + 2];
		milu2.zbuf = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c10[11] = "milu2.zbuf";
		handle_error<doublereal>(milu2.zbuf, c10,  c1, (maxelm_plus_maxbound + 2));
		//milu2.zbuf2 = new doublereal[maxelm_plus_maxbound + 2];
		milu2.zbuf2 = (doublereal*)malloc((maxelm_plus_maxbound + 2) * sizeof(doublereal));
		char c11[12] = "milu2.zbuf2";
		handle_error<doublereal>(milu2.zbuf2, c11,  c1, (maxelm_plus_maxbound + 2));

		//if ((milu2.alu_copy == NULL) || (milu2.jlu_copy == NULL) || (milu2.ju_copy == NULL) || (milu2.b_copy == NULL) || (milu2.x_copy == NULL) || (milu2.zbuf==NULL)||(milu2.zbuf2==NULL)) {
		if ((milu2.b_copy == NULL) || (milu2.x_copy == NULL) || (milu2.zbuf == NULL) || (milu2.zbuf2 == NULL)) {
		    // недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		//milu2.lfil = 2;
		integer ierr=0;
		iluk_(maxelm_plus_maxbound, milu2.val, milu2.col_ind, milu2.row_ptr, 0/*milu2.lfil*/, milu2.alu, milu2.jlu, milu2.ju, milu2.levs, milu2.iwk, milu2.w, milu2.jw, ierr);
		if (ierr != 0) {
#if doubleintprecision == 1
			printf("ierr=%lld\n", ierr);
#else
			printf("ierr=%d\n", ierr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}

		if ((ierr == -2) || (ierr == -3)) {

			integer ipassage = 1;
			do {
				printf("\nPlease WAIT... ... ...\n");

				// задаче не хватило памяти, значит нужно перевыделить !
				//if (milu2.alu != NULL) delete[] milu2.alu;
				//if (milu2.jlu != NULL) delete[] milu2.jlu;
				//if (milu2.levs != NULL) delete[] milu2.levs;
				if (milu2.alu != NULL) free(milu2.alu);
				if (milu2.jlu != NULL) free(milu2.jlu);
				if (milu2.levs != NULL) free(milu2.levs);
				//if (milu2.alu_copy != NULL) delete[] milu2.alu_copy;
				//if (milu2.jlu_copy != NULL) delete[] milu2.jlu_copy;

				// инициализация !
				milu2.alu = NULL;
				milu2.jlu = NULL;
				milu2.levs = NULL;
				//milu2.alu_copy = NULL;
				//milu2.jlu_copy = NULL;

				milu2.iwk = (integer)((milu2.lfil + 1 + radd) * n + ((1 + 3 + 3 * ipassage)*maxelm_plus_maxbound));
				//milu2.alu = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
				milu2.alu = (doublereal*)malloc((milu2.iwk + 2) * sizeof(doublereal));
				char c12[11] = "milu2.alu";
				handle_error<doublereal>(milu2.alu, c12,  c1, (milu2.iwk + 2));
				//milu2.jlu = new integer[milu2.iwk + 2];
				milu2.jlu = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
				char c13[11] = "milu2.jlu";
				handle_error<integer>(milu2.jlu, c13,  c1, (milu2.iwk + 2));
				//milu2.levs = new integer[milu2.iwk + 2]; // уровень.
				milu2.levs = (integer*)malloc((milu2.iwk + 2) * sizeof(integer));
				char c14[11] = "milu2.levs";
				handle_error<integer>(milu2.levs, c14,  c1, (milu2.iwk + 2));
				//milu2.alu_copy = new doublereal[milu2.iwk + 2]; // +2 запас по памяти.
				//milu2.jlu_copy = new integer[milu2.iwk + 2];

				//if ((milu2.alu_copy != NULL) && (milu2.jlu_copy != NULL) && (milu2.alu != NULL) && (milu2.jlu != NULL) && (milu2.levs != NULL)) {
				if ((milu2.alu != NULL) && (milu2.jlu != NULL) && (milu2.levs != NULL)) {
					iluk_(maxelm_plus_maxbound, milu2.val, milu2.col_ind, milu2.row_ptr, milu2.lfil, milu2.alu, milu2.jlu, milu2.ju, milu2.levs, milu2.iwk, milu2.w, milu2.jw, ierr);
				}
				else {
					// недостаточно памяти на данном оборудовании.
					ipassage = 4;
					printf("Problem : not enough memory on your equipment...\n");
					printf("Please any key to exit...\n");
					exit(1);
				}

				ipassage++;
				// Пока просто контролируем, в добавок хорошо бы выводить информацию на каком уровне это произошло.
#if doubleintprecision == 1
				printf("control memory allocation for ilu2 in RUMBA0.14 in level=%lld\n", ilevel);
#else
				printf("control memory allocation for ilu2 in RUMBA0.14 in level=%d\n", ilevel);
#endif
				
				system("PAUSE");
			} while ((ierr != 0) && (ipassage<4));

			if (ipassage == 4) {
				printf("Error memory alloc !!!\n");
				printf("failed to obtain an expansion for the 4 approaches...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("PAUSE");
				exit(1);
			}
		}

		for (integer k = 0; k<n; k++) if (milu2.col_ind[k] == (-1)) {
			printf("Error equation3D to CRS.\n");
			//getchar();
			system("pause");
		}

		// Нумерация начинается с единицы (это важно).
		for (integer k = 0; k<maxelm_plus_maxbound; k++) {
			if (milu2.val[milu2.row_ptr[k] - 1]<nonzeroEPS) {
#if doubleintprecision == 1
				printf("negativ diagonal element equation3DtoCRS %lld\n", k);
#else
				printf("negativ diagonal element equation3DtoCRS %d\n", k);
#endif
				
				//getchar();
				system("pause");
			}
		}

		if (1 || milu2.lfil == 0) {
			// экономим оперативную память.
			//if (milu2.val != NULL) delete[] milu2.val;
			//if (milu2.col_ind != NULL) delete[] milu2.col_ind;
			//if (milu2.row_ptr != NULL) delete[] milu2.row_ptr;
			if (milu2.val != NULL) free(milu2.val);
			if (milu2.col_ind != NULL) free(milu2.col_ind);
			if (milu2.row_ptr != NULL) free(milu2.row_ptr);
			milu2.val = NULL;
			milu2.col_ind = NULL;
			milu2.row_ptr = NULL;
		}

	}

	if (!flag) {
		printf("Error equation 3D to CRS: zero diagonal element...\n");
		//getchar();
		system("pause");
	}	


} // equation3DtoCRSRUMBA1


  // Мы усилим РУМБА0.14 алгоритм ILU0 предобуславливанием (сглаживателем) на каждом уровне вложенности.
  // Преобразует equation3D  формат хранения в CRS формат.
  // Цель написания этого преобразователя: экономия оперативной памяти компьютера.
  // Т.к. формат SIMPLESPARSE требует слишком много памяти.
// Для многих задач сходимость мульгрида на базе Зейдель сглаживателя недостаточна. 
// Судя по документации ILU0 smoother more effective по сравнению с Зейдель сглаживателем.
// ILU0 - универсален и не накладывает ограничений на структуру матрицы СЛАУ. ILU0 потребляет мало пользователей.
void equation3DtoCRSRUMBA0(LEVEL_ADDITIONAL_DATA0 &milu0,
	bool ballocmemory, Ak1* &Amat, integer istartq, integer iendq,
	integer* &row_ptr_start, integer* &row_ptr_end, integer iadd, integer ilevel) {


	// iadd_now=n_a[0]+...+n_a[ilevel_detector-1];
	//equation3DtoCRSRUMBA0(milu0[ilevel_detector], true,
		//Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);

	// Если ballocmemory равен true то происходит выделение памяти.
	const bool bonly_negative_connections = false;
	bool flag = true;
	integer n = 0; // число ненулевых элементов
	integer maxelm_plus_maxbound = 0; // Число уравнений в СЛАУ.

	const doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	integer startpos = istartq + iadd;
	integer endpos = iendq + iadd;


	// подсчёт количества ненулевых элементов
	// во всех точках расчётной области как внутренних так и граничных.
	for (integer ii = startpos; ii <= endpos; ii++) {
		maxelm_plus_maxbound++;
		integer istr = ii - iadd;
		if (fabs(Amat[row_ptr_start[ii]].aij) < 1.0e-20)
		{
#if doubleintprecision == 1
			printf("zero diagonal coefficient in level = %lld, istr=%lld\n", ilevel, istr);
#else
			printf("zero diagonal coefficient in level = %d, istr=%d\n", ilevel, istr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}
		doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;

		//if (fabs(ap_now)> 1e10*nonzeroEPS) n++; // диагональный элемент
		if (ap_now > nonzeroEPS) n++; // Диагональный элемент.
		else {
			// 5 августа 2016. 
			flag = false;
			printf("internal zero diagonal element.\n");
			//printf("ae=%e aw=%e an=%e as=%e at=%e ab=%e sum_nb=%e", sl[k].ae, sl[k].aw, sl[k].an, sl[k].as, sl[k].at, sl[k].ab, sl[k].ae + sl[k].aw + sl[k].an + sl[k].as + sl[k].at + sl[k].ab);
			if (ap_now < 0.0) {
				printf("found negativ diagonal coefficient=%e...\n", ap_now);
			}
			printf("fatal error equation3DtoCRS in RUMBA...\n");
			//getchar();
			system("PAUSE");
			exit(1);
			//n++;
			//sl[k].ap = fabs(sl[k].ae) + fabs(sl[k].aw) + fabs(sl[k].an) + fabs(sl[k].as) + fabs(sl[k].at) + fabs(sl[k].ab);
		}

		integer is1 = row_ptr_start[ii] + 1;
		integer is2 = row_ptr_end[ii];

		for (integer ii1 = is1; ii1 <= is2; ii1++)
		{
			if (bonly_negative_connections) {
				if (Amat[ii1].aij < -nonzeroEPS) {
					n++;
				}
			}
			else {
				if (fabs(Amat[ii1].aij) > nonzeroEPS) {
					n++;
				}
				else {
#if doubleintprecision == 1
					printf("igmoring a[%lld][%lld]=%e istr=%lld\n", Amat[ii1].i, Amat[ii1].j, fabs(Amat[ii1].aij), istr);
#else
					printf("igmoring a[%d][%d]=%e istr=%d\n", Amat[ii1].i, Amat[ii1].j, fabs(Amat[ii1].aij), istr);
#endif
					
				}
			}
		}
	}

#if doubleintprecision == 1
	printf("nnz=%lld, %lld startpos=%lld endpos=%lld\n", n, row_ptr_end[endpos] - row_ptr_start[startpos] + 1, startpos, endpos);
#else
	printf("nnz=%d, %d startpos=%d endpos=%d\n", n, row_ptr_end[endpos] - row_ptr_start[startpos] + 1, startpos, endpos);
#endif
	
	system("PAUSE");

	if (flag) {
		// memory +15N
		// Теперь выделение памяти будет происходить централизованно, вне данного кода.
		// Это сделано для кода BICGSTAB_internal3. дата изменения 12 апреля 2013.
		// Другой код, использующий equation3dtoCRS может оказаться неработоспособным после этого изменения.
		if (ballocmemory) {
			// Важно выделить память с запасом, т.к. одна и таже память используется и для компонент скорости и для попрапвки давления.
			//val = new doublereal[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			//col_ind = new integer[7 * (maxelm + maxbound) + 2 * maxbound + 2];
			milu0.val = new doublereal[n + 2];
			milu0.col_ind = new integer[n + 2];
			//row_ptr = new integer[(maxelm + maxbound) + 1];
			milu0.row_ptr = new integer[maxelm_plus_maxbound + 1];
			if ((milu0.val == NULL) || (milu0.col_ind == NULL) || (milu0.row_ptr == NULL)) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for ILU0 decomposition...\n");
				printf("Please any key to exit...\n");
				exit(1);
			}
		}


		// инициализация
#pragma omp parallel for
		for (integer k = 0; k<(n); k++) {
			milu0.val[k] = 0.0;
			milu0.col_ind[k] = -1;
		}
#pragma omp parallel for
		for (integer k = 0; k <= (maxelm_plus_maxbound); k++) {
			milu0.row_ptr[k] = n; // присваиваем количество ненулевых элементов плюс 1 с учётом того что нумерация массива начинается с 0
		}

		// Быстрая Сортировка Хоара.
		// упорядочивание по строкам
		//QuickSort(...); не требуется,
		// т.к. сама структура хранения 
		// подразумевает упорядочивание по строкам.

		/*
		// заполнение разреженной матрицы
		for (integer k=0; k<M.n; k++) {
		val[k]=M.a[k].aij;
		col_ind[k]=M.a[k].j;
		row_ptr[M.a[k].i]=min(k,row_ptr[M.a[k].i]);
		}
		*/
		integer ik = 0; // счётчик ненулевых элементов СЛАУ

					// для всех узлов расчётной области как внутренних так и внешних:
		for (integer ii = startpos; ii <= endpos; ii++) {
			integer istr = ii - iadd;
			integer k = istr - 1; // нумерация с нуля.
			doublereal ap_now = 1.0 / Amat[row_ptr_start[ii]].aij;


			// Диагональный коэффициент.
			if (fabs(ap_now) > nonzeroEPS) {
				milu0.val[ik] = ap_now;
				milu0.col_ind[ik] = istr - 1; // Нуменрация начинается с нуля.
				milu0.row_ptr[k] = min(ik, milu0.row_ptr[k]);
				ik++;
			}

			integer is1 = row_ptr_start[ii] + 1;
			integer is2 = row_ptr_end[ii];

			for (integer ii1 = is1; ii1 <= is2; ii1++)
			{
				if (bonly_negative_connections) {
					if (Amat[ii1].aij < -nonzeroEPS) {
						milu0.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu0.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu0.row_ptr[k] = min(ik, milu0.row_ptr[k]);
						ik++;
					}
				}
				else {
					if (fabs(Amat[ii1].aij) > nonzeroEPS) {
						milu0.val[ik] = Amat[ii1].aij; // уже с учётом знака.
						milu0.col_ind[ik] = Amat[ii1].j - 1; // Нумерация начинается с нуля.
						milu0.row_ptr[k] = min(ik, milu0.row_ptr[k]);
						ik++;
					}
				}
			}
		}

		// в каждой строке элементы отсортированы по номерам столбцов:
#pragma omp parallel for
		for (integer k = 0; k<(maxelm_plus_maxbound); k++) QuickSortCSIR(milu0.col_ind, milu0.val, milu0.row_ptr[k] + 1, milu0.row_ptr[k + 1] - 1);

#if doubleintprecision == 1
		//printf("n==%lld row_ptr=%lld\n", n, milu0.row_ptr[maxelm_plus_maxbound]);
#else
		//printf("n==%d row_ptr=%d\n", n, milu0.row_ptr[maxelm_plus_maxbound]);
#endif
		
		//getchar();
#pragma omp parallel for
		for (integer i = 0; i<milu0.row_ptr[maxelm_plus_maxbound]; i++) {
			milu0.col_ind[i] = milu0.col_ind[i] + 1;
		}
#pragma omp parallel for
		for (integer i = 0; i<maxelm_plus_maxbound + 1; i++) {
			milu0.row_ptr[i] = milu0.row_ptr[i] + 1;
		}

		/*
		FILE *fp;
		errno_t err;
		// создание файла для записи.
		if ((err = fopen_s( &fp, "matr.txt", "w")) != 0) {
		printf("Create File Error\n");
		}
		else {
		#if doubleintprecision == 1
			// debug
			for (k=0; k<=maxelm+maxbound; k++) {
				fprintf(fp,"%lld ",milu0.row_ptr[k]);
			}
			fprintf(fp,"\n");
			for (k=0; k<milu0.row_ptr[maxelm+maxbound]; k++) {
				fprintf(fp, "%e %lld\n",milu0.val[k],milu0.col_ind[k]);
			}
		#else
			// debug
			for (k=0; k<=maxelm+maxbound; k++) {
				fprintf(fp,"%d ",milu0.row_ptr[k]);
			}
			fprintf(fp,"\n");
			for (k=0; k<milu0.row_ptr[maxelm+maxbound]; k++) {
				fprintf(fp, "%e %d\n",milu0.val[k],milu0.col_ind[k]);
			}
		#endif

		

		fclose(fp);
		}
		printf("ready");
		getchar();
		*/
		doublereal radd = 0.0;
		/*
		if (ilevel == 0) {
			radd = 1.8;
		}
		else if (ilevel == 1) {
			radd = 4.2;
		}
		else if ((ilevel >= 2) && (ilevel <= 5)) {
			radd = 6.5;
		}
		else if (ilevel == 6) {
			radd = 7.0;
		}
		else {
			radd = 8.0;
		}
		*/

		// ILU0 не требует памяти больше чем размер исходных матриц. 
		// Новых ненулевых элементов для него не появляется.
		milu0.iwk = milu0.row_ptr[maxelm_plus_maxbound];
		milu0.alu = new doublereal[milu0.row_ptr[maxelm_plus_maxbound]  + 2];
		milu0.jlu = new integer[milu0.row_ptr[maxelm_plus_maxbound]  + 2];

		milu0.ju = new integer[maxelm_plus_maxbound + 2];

		
		milu0.iw = new integer[maxelm_plus_maxbound + 2]; // +2 запас по памяти.
		
		if ((milu0.alu == NULL) || (milu0.jlu == NULL) || (milu0.ju == NULL) || (milu0.iw == NULL)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for ILU0 decomposition: alu, jlu, ju, iw...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		// копии объектов

		// ILU0 не требует памяти больше чем размер исходных матриц. 
		// Новых ненулевых элементов для него не появляется.
		milu0.alu_copy = new doublereal[milu0.row_ptr[maxelm_plus_maxbound] + 2];
		milu0.jlu_copy = new integer[milu0.row_ptr[maxelm_plus_maxbound] + 2];

		milu0.ju_copy = new integer[maxelm_plus_maxbound + 2];

		milu0.b_copy = new doublereal[maxelm_plus_maxbound + 2];
		milu0.x_copy = new doublereal[maxelm_plus_maxbound + 2];
		milu0.zbuf = new doublereal[maxelm_plus_maxbound + 2];
		milu0.zbuf2 = new doublereal[maxelm_plus_maxbound + 2];

		if ((milu0.alu_copy == NULL) || (milu0.jlu_copy == NULL) || (milu0.ju_copy == NULL) || (milu0.b_copy == NULL) || (milu0.x_copy == NULL) || (milu0.zbuf == NULL) || (milu0.zbuf2 == NULL)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for ILU0 decomposition: alu_copy, jlu_copy, ju_copy etc...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		// Построение ILU0 декомпозиции.
		integer ierr = 0;
	    ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
		if (ierr != 0) {
#if doubleintprecision == 1
			printf("ierr=%lld\n", ierr);
#else
			printf("ierr=%d\n", ierr);
#endif
			
			//getchar();
			system("PAUSE");
			exit(1);
		}

		if ((ierr == -2) || (ierr == -3)) {

			integer ipassage = 1;
			do {
				printf("\nPlease WAIT... ... ...\n");

				// задаче не хватило памяти, значит нужно перевыделить !
				if (milu0.alu != NULL) delete milu0.alu;
				if (milu0.jlu != NULL) delete milu0.jlu;
				if (milu0.alu_copy != NULL) delete milu0.alu_copy;
				if (milu0.jlu_copy != NULL) delete milu0.jlu_copy;

				// инициализация !
				milu0.alu = NULL;
				milu0.jlu = NULL;
				milu0.alu_copy = NULL;
				milu0.jlu_copy = NULL;

				// При использовании ILU0 новой памяти не требуется должно хватать размера исходной матрицы.
			    integer iwk = milu0.row_ptr[maxelm_plus_maxbound] + 2; // ИЗМЕНИТЬ ЭТУ СТРОКУ для увеличения памяти.
				milu0.iwk = iwk - 2;
				milu0.alu = new doublereal[iwk + 2]; // +2 запас по памяти.
				milu0.jlu = new integer[iwk + 2];
				milu0.alu_copy = new doublereal[iwk + 2]; // +2 запас по памяти.
				milu0.jlu_copy = new integer[iwk + 2];

				if ((milu0.alu_copy != NULL) && (milu0.jlu_copy != NULL) && (milu0.alu != NULL) && (milu0.jlu != NULL)) {
					ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
				}
				else {
					// недостаточно памяти на данном оборудовании.
					ipassage = 4;
					printf("Problem : not enough memory on your equipment...\n");
					printf("Please any key to exit...\n");
					exit(1);
				}

				ipassage++;
				// Пока просто контролируем, в добавок хорошо бы выводить информацию на каком уровне это произошло.
#if doubleintprecision == 1
				printf("control memory allocation for ilu0 in RUMBA0.14 in level=%lld\n", ilevel);
#else
				printf("control memory allocation for ilu0 in RUMBA0.14 in level=%d\n", ilevel);
#endif
				
				system("PAUSE");
			} while ((ierr != 0) && (ipassage<4));

			if (ipassage == 4) {
				printf("Error memory alloc !!!\n");
				printf("failed to obtain an expansion for the 4 approaches...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("PAUSE");
				exit(1);
			}
		}

		// По идее здесь уже можно освободить ОЗУ от milu0.val, milu0.col_ind, milu0.row_ptr.
		// 7 ноября 2016.

	}

	if (!flag) {
		printf("Error equation 3D to CRS: zero diagonal element...\n");
		//getchar();
		system("pause");
	}

	for (integer k = 0; k<n; k++) if (milu0.col_ind[k] == (-1)) {
		printf("Error equation3D to CRS.\n");
		//getchar();
		system("pause");
	}

	// Нумерация начинается с единицы (это важно).
	for (integer k = 0; k<maxelm_plus_maxbound; k++) {
		if (milu0.val[milu0.row_ptr[k] - 1]<nonzeroEPS) {
#if doubleintprecision == 1
			printf("negativ diagonal element equation3DtoCRS %lld\n", k);
#else
			printf("negativ diagonal element equation3DtoCRS %d\n", k);
#endif
			
			//getchar();
			system("pause");
		}
	}


} // equation3DtoCRSRUMBA0


// Выделение оперативной памяти.
void init_level_additional_data(LEVEL_ADDITIONAL_DATA* &milu2, integer max_levels) {
	if (milu2 == NULL) {
		milu2 = new LEVEL_ADDITIONAL_DATA[max_levels];
		if (milu2 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// Инициализация. 
		// Конкретное выделение оперативной памяти происходит внутри 
		// equation3DtoCRSRUMBA1.
#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			milu2[i].val = NULL;
			milu2[i].col_ind = NULL;
			milu2[i].row_ptr = NULL;
			// для хранения ilu2 декомпозиции.
			milu2[i].alu = NULL;
			milu2[i].jlu = NULL;
			milu2[i].ju = NULL;
			milu2[i].levs = NULL;
			milu2[i].w = NULL;
			milu2[i].jw = NULL;
			milu2[i].iwk = 0;
			//milu2[i].alu_copy = NULL;
			//milu2[i].jlu_copy = NULL;
			//milu2[i].ju_copy = NULL;
			milu2[i].b_copy = NULL;
			milu2[i].x_copy = NULL;
			milu2[i].zbuf = NULL;
			milu2[i].zbuf2 = NULL;
		}
	}
} // init_level_additional_data

// Освбождение оперативной памяти.
void free_level_additional_data(LEVEL_ADDITIONAL_DATA* &milu2, integer max_levels) {
	if (milu2 != NULL) {
#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			if (milu2[i].val != NULL) {
				//delete[] milu2[i].val;
				free(milu2[i].val);
				milu2[i].val = NULL;
			}
			if (milu2[i].col_ind != NULL) {
				///delete[] milu2[i].col_ind;
				free(milu2[i].col_ind);
				milu2[i].col_ind = NULL;
			}
			if (milu2[i].row_ptr != NULL) {
				//delete[] milu2[i].row_ptr;
				free(milu2[i].row_ptr);
				milu2[i].row_ptr = NULL;
			}
			// Освобождение оперативной памяти из под хранения ilu2 декомпозиции.
			if (milu2[i].alu != NULL) {
				//delete[] milu2[i].alu;
				free(milu2[i].alu);
				milu2[i].alu = NULL;
			}
			if (milu2[i].jlu != NULL) {
				//delete[] milu2[i].jlu;
				free(milu2[i].jlu);
				milu2[i].jlu = NULL;
			}
			if (milu2[i].ju != NULL) {
				//delete[] milu2[i].ju;
				free(milu2[i].ju);
				milu2[i].ju = NULL;
			}
			if (milu2[i].levs != NULL) {
				//delete[] milu2[i].levs;
				free(milu2[i].levs);
				milu2[i].levs = NULL;
			}
			if (milu2[i].w != NULL) {
				//delete[] milu2[i].w;
				free(milu2[i].w);
				milu2[i].w = NULL;
			}
			if (milu2[i].jw != NULL) {
				//delete[] milu2[i].jw;
				free(milu2[i].jw);
				milu2[i].jw = NULL;
			}
			milu2[i].iwk = 0;
			// Освобождение памяти из под копий объектов:
	        // 9 ноября 2016 память под alu_copy, jlu_copy, ju_copy 
			// теперь выделяется централизованно в буфере.
			//if (milu2[i].alu_copy != NULL) {
				//delete[] milu2[i].alu_copy;
				//milu2[i].alu_copy = NULL;
			//}
			//if (milu2[i].jlu_copy != NULL) {
				//delete[] milu2[i].jlu_copy;
				//milu2[i].jlu_copy = NULL;
			//}
			//if (milu2[i].ju_copy != NULL) {
				//delete[] milu2[i].ju_copy;
				//milu2[i].ju_copy = NULL;
			//}
			if (milu2[i].b_copy != NULL) {
				//delete[] milu2[i].b_copy;
				free(milu2[i].b_copy);
				milu2[i].b_copy = NULL;
			}
			if (milu2[i].x_copy != NULL) {
				//delete[] milu2[i].x_copy;
				free(milu2[i].x_copy);
				milu2[i].x_copy = NULL;
			}
			if (milu2[i].zbuf != NULL) {
				//delete[] milu2[i].zbuf;
				free(milu2[i].zbuf);
				milu2[i].zbuf = NULL;
			}
			if (milu2[i].zbuf2 != NULL) {
				//delete[] milu2[i].zbuf2;
				free(milu2[i].zbuf2);
				milu2[i].zbuf2 = NULL;
			}
		}
		delete[] milu2;
		milu2 = NULL;
	}
} // free_level_additional_data

// ILU0 4 ноября 2016.
// Выделение оперативной памяти.
void init_level_additional_data(LEVEL_ADDITIONAL_DATA0* &milu0, integer max_levels) {
	if (milu0 == NULL) {
		milu0 = new LEVEL_ADDITIONAL_DATA0[max_levels];
		if (milu0 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for ILU0...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// Инициализация. 
		// Конкретное выделение оперативной памяти происходит внутри 
		// equation3DtoCRSRUMBA1.
#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			milu0[i].val = NULL;
			milu0[i].col_ind = NULL;
			milu0[i].row_ptr = NULL;
			// для хранения ilu0 декомпозиции.
			milu0[i].alu = NULL;
			milu0[i].jlu = NULL;
			milu0[i].ju = NULL;
			milu0[i].iw = NULL;
			milu0[i].iwk = 0;
			
			milu0[i].alu_copy = NULL;
			milu0[i].jlu_copy = NULL;
			milu0[i].ju_copy = NULL;
			milu0[i].b_copy = NULL;
			milu0[i].x_copy = NULL;
			milu0[i].zbuf = NULL;
			milu0[i].zbuf2 = NULL;
		}
	}
} // init_level_additional_data ILU0

// ILU0 4 november 2016.
  // Освбождение оперативной памяти.
void free_level_additional_data(LEVEL_ADDITIONAL_DATA0* &milu0, integer max_levels) {
	if (milu0 != NULL) {

#pragma omp parallel for
		for (integer i = 0; i < max_levels; i++) {
			if (milu0[i].val != NULL) {
				delete[] milu0[i].val;
				milu0[i].val = NULL;
			}
			if (milu0[i].col_ind != NULL) {
				delete[] milu0[i].col_ind;
				milu0[i].col_ind = NULL;
			}
			if (milu0[i].row_ptr != NULL) {
				delete[] milu0[i].row_ptr;
				milu0[i].row_ptr = NULL;
			}
			// Освобождение оперативной памяти из под хранения ilu2 декомпозиции.
			if (milu0[i].alu != NULL) {
				delete[] milu0[i].alu;
				milu0[i].alu = NULL;
			}
			if (milu0[i].jlu != NULL) {
				delete[] milu0[i].jlu;
				milu0[i].jlu = NULL;
			}
			if (milu0[i].ju != NULL) {
				delete[] milu0[i].ju;
				milu0[i].ju = NULL;
			}
			
			if (milu0[i].iw != NULL) {
				delete[] milu0[i].iw;
				milu0[i].iw = NULL;
			}

			milu0[i].iwk = 0;
			// Освобождение памяти из под копий объектов:
			if (milu0[i].alu_copy != NULL) {
				delete[] milu0[i].alu_copy;
				milu0[i].alu_copy = NULL;
			}
			if (milu0[i].jlu_copy != NULL) {
				delete[] milu0[i].jlu_copy;
				milu0[i].jlu_copy = NULL;
			}
			if (milu0[i].ju_copy != NULL) {
				delete[] milu0[i].ju_copy;
				milu0[i].ju_copy = NULL;
			}
			if (milu0[i].b_copy != NULL) {
				delete[] milu0[i].b_copy;
				milu0[i].b_copy = NULL;
			}
			if (milu0[i].x_copy != NULL) {
				delete[] milu0[i].x_copy;
				milu0[i].x_copy = NULL;
			}
			if (milu0[i].zbuf != NULL) {
				delete[] milu0[i].zbuf;
				milu0[i].zbuf = NULL;
			}
			if (milu0[i].zbuf2 != NULL) {
				delete[] milu0[i].zbuf2;
				milu0[i].zbuf2 = NULL;
			}
		}
		delete[] milu0;
		milu0 = NULL;
	}
} // free_level_additional_data ILU0


static bool bfirst_now_speed = true;

static integer iglnumberSimpleit = 0;

// 3 ноября 2016.
// Вызывается единожды лишь в случае нехватки выделеной памяти под оператор 
// интерполляции.
// Это происходит очень редко - на узком классе задач.
// Здесь происходит перевыделение оперативной памяти и увеличение значения nsizePR.
void deallocate_prolongation(integer &nsizePR, // Память под P в количествах n.
	integer n, // Количество неизвестных в СЛАУ на нулевом уровне.
	Ak1* &R, // restriction
	Ak1* &P // prolongation
)
{

	// Синтакис вызова:
	//deallocate_prolongation(nsizePR,n,R,P);

	// Для большинства реальных задач нам достаточно объёма памяти в nsizePR==12.
	// Однако встречаются задачи для котрыхнужно существенно большее количество памяти.
	// В этом случае я предлагаю увеличить её количество до nsizePR==35.
	if (nsizePR < 13) {

		Ak1* R_copy = NULL; // restriction
		Ak1* P_copy = NULL; // prolongation

		// Увеличиваем количество памяти до nsizePR==35.
		//Ak1* &R_copy = new Ak1[nsizePR*n + 1];
		//Ak1* &P_copy = new Ak1[nsizePR*n + 1];
		//R = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		R_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (R_copy == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for R_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		P_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (P_copy == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for P_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}

		if ((R_copy != NULL) && (P_copy != NULL)) {
			for (integer i = 0; i <= (nsizePR * n); i++) {
				R_copy[i] = R[i];
				P_copy[i] = P[i];
			}
			if (R != NULL) {
				free(R);
			}
			if (P != NULL) {
				free(P);
			}
			R = NULL;
			P = NULL;
			integer nsizePR_old = nsizePR;
			nsizePR = 35; // Этого должно хватить с запасом.

			R = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (R == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for R matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
			//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
			P = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (P == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for P matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}

			if ((P != NULL) && (R != NULL)) {
				for (integer i = 0; i <= (nsizePR_old * n); i++) {
					R[i] = R_copy[i];
					P[i] = P_copy[i];
				}
			}

			// Обязательно освобождаем оперативную память.
			if (R_copy != NULL) {
				free(R_copy);
				R_copy = NULL;
			}
			if (P_copy != NULL) {
				free(P_copy);
				P_copy = NULL;
			}
		}
	}
	else {
#if doubleintprecision == 1
		printf("FATALL error!!! nsizePR=%lld\n", nsizePR);
#else
		printf("FATALL error!!! nsizePR=%d\n", nsizePR);
#endif
		
		printf("not enough memory for the interpolation operator.");
		printf("absolute fatal. see deallocate_prolongation in my_agregat_amg.cpp\n");
		system("PAUSE");
		exit(1);
	}

} // deallocate_prolongation



// 3 ноября 2016.
// Вызывается единожды лишь в случае нехватки выделеной памяти под оператор 
// интерполляции.
// Это происходит очень редко - на узком классе задач.
// Здесь происходит перевыделение оперативной памяти и увеличение значения nsizePR.
void deallocate_prolongation(integer &nsizePR, // Память под P в количествах n.
	integer n, // Количество неизвестных в СЛАУ на нулевом уровне.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	bool* &bamg_bound
)
{

	// Синтакис вызова:
	//deallocate_prolongation(nsizePR,n,R,P);

	// Для большинства реальных задач нам достаточно объёма памяти в nsizePR==12.
	// Однако встречаются задачи для котрыхнужно существенно большее количество памяти.
	// В этом случае я предлагаю увеличить её количество до nsizePR==35.
	if (nsizePR < 13) {

		Ak1* R_copy = NULL; // restriction
		Ak1* P_copy = NULL; // prolongation
		bool* bamg_bound_copy = NULL; // для граничных условий Дирихле.

							// Увеличиваем количество памяти до nsizePR==35.
							//Ak1* &R_copy = new Ak1[nsizePR*n + 1];
							//Ak1* &P_copy = new Ak1[nsizePR*n + 1];
							//R = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		R_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (R_copy == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for R_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
		P_copy = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
		if (P_copy == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for P_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		//bamg_bound_copy = (bool*)malloc(((nsizePR * n) + 1) * sizeof(bool));
		bamg_bound_copy = new bool[(nsizePR * n) + 1];
		if (bamg_bound_copy == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for bamg_bound_copy matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}

		if ((R_copy != NULL) && (P_copy != NULL)&&(bamg_bound_copy != NULL)) {
			for (integer i = 0; i <= (nsizePR * n); i++) {
				R_copy[i] = R[i];
				P_copy[i] = P[i];
				bamg_bound_copy[i] = bamg_bound[i];
			}
			if (R != NULL) {
				free(R);
			}
			if (P != NULL) {
				free(P);
			}
			if (bamg_bound != NULL) {
				//free(bamg_bound);
				delete[] bamg_bound;
			}
			R = NULL;
			P = NULL;
			bamg_bound = NULL;
			integer nsizePR_old = nsizePR;
			nsizePR = 35; // Этого должно хватить с запасом.

			R = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (R == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for R matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
			//P = new Ak1[(integer)(35 * n) + 1]; // 3*nnz 2.4 // 35
			P = (Ak1*)malloc(((nsizePR * n) + 1) * sizeof(Ak1));
			if (P == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for P matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
			bamg_bound = new bool[(nsizePR * n) + 1];
			if (bamg_bound == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for bamg_bound matrix in my_agregat_amg.cpp algorithm...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}

			if ((P != NULL) && (R != NULL)&&(bamg_bound!= NULL)) {
				for (integer i = 0; i <= (nsizePR_old * n); i++) {
					R[i] = R_copy[i];
					P[i] = P_copy[i];
					bamg_bound[i] = bamg_bound_copy[i];
				}
				for (integer i = (nsizePR_old * n) + 1; i <= (nsizePR * n); i++) {
					bamg_bound[i] = false;
				}
			}

			// Обязательно освобождаем оперативную память.
			if (R_copy != NULL) {
				free(R_copy);
				R_copy = NULL;
			}
			if (P_copy != NULL) {
				free(P_copy);
				P_copy = NULL;
			}
			if (bamg_bound_copy != NULL) {
				//free(bamg_bound_copy);
				delete[] bamg_bound_copy;
				bamg_bound_copy = NULL;
			}
		}
	}
	else {
#if doubleintprecision == 1
		printf("FATALL error!!! nsizePR=%lld\n", nsizePR);
#else
		printf("FATALL error!!! nsizePR=%d\n", nsizePR);
#endif
		
		printf("not enough memory for the interpolation operator.");
		printf("absolute fatal. see deallocate_prolongation in my_agregat_amg.cpp\n");
		system("PAUSE");
		exit(1);
	}

}

// 08.01.2018 Перенесено в отдельную функцию, т.к. используется неоднократно. Передаётся большое число параметров.
//  A*z76=s76; 891 строка.
template <typename doublerealT>
void V_cycle_solve(Ak1* &Amat, doublereal* &z76, doublereal* &s76, bool process_flow_logic, integer* &row_ptr_start, 
	integer* &row_ptr_end, doublerealT** &residual_fine, doublerealT** &diag, integer* n_a, bool bonly_serial, 
	doublerealT process_flow_beta, bool* &F_false_C_true, integer &nu1, integer &nu2, integer bILU2smoother, 
	integer ilevel, integer inumberVcyclelocbicgstab, integer imyinit, const integer idim_diag, 
	LEVEL_ADDITIONAL_DATA* &milu2, LEVEL_ADDITIONAL_DATA0* milu0, bool** &nested_desection,
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	integer* nnz_aRP, bool* &flag, doublerealT** &residual_coarse, integer igam, integer* nnz_a,
	doublerealT** &error_approx_coarse, doublerealT dapply_ilu_max_pattern_size,
	doublerealT process_flow_alpha, doublerealT** &error_approx_fine, 
	integer nFinestSweeps) {
	
	// Один V - цикл алгебраического многосеточного метода.
	// A*z76=s76;

	const integer ZERO_INIT = 0;
	const integer RANDOM_INIT = 1;// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.

	for (integer i_13 = 0; i_13<inumberVcyclelocbicgstab; i_13++)
	{


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
			R0_0 = norma(residual_fine[0], n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nu1; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
				//residualq(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
				residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
				Rnext_0 = norma(residual_fine[0], n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smoother
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1, nnz_a[0], z76, s76, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						// ILU0
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if ((bILU2smoother == 2) || (my_amg_manager.iFinnest_ilu == 1)) {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine[0] = new doublerealT[n_a[0] + 1];
			//residual<doublereal>(Amat, 1, nnz_a[0], z76, s76, flag, n_a[0], residual_fine[0]);
			//residualq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
		}



		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];
#pragma omp parallel for
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				residual_coarse[0][ii] = 0.0;
			}

			// restriction
			restriction(R, 1, nnz_aRP[0], flag, residual_fine[0], residual_coarse[0], n_a[0], n_a[1]);


			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			if ((imyinit == ZERO_INIT)) {
#pragma omp parallel for
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[0][ii] = 0.0;
				}
			}

			if ((imyinit == RANDOM_INIT)) {
				// (1,110); (0.8, 37); (0.7, 29); (0.6, 25); (0.5, 20); (0.4, 17); (0.3, 18); (0.0, 19);
#pragma omp parallel for
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[0][ii] = 0.4*fabs(residual_coarse[0][ii])*(rand() / ((doublerealT)RAND_MAX));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
				doublerealT R0_1 = 0.0;
				doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1]);
					residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);

					R0_1 = norma(residual_fine[1], n_a[1]);
					Rprev_1 = R0_1;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1]);
						residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);

						Rnext_1 = norma(residual_fine[1], n_a[1]);
						// this is process flow logic
						if (Rnext_1 > process_flow_beta*Rprev_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu1) {
						printf("level 1 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += milu0[1].zbuf2[i43 + 1];
								}


							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += milu2[1].zbuf2[i43 + 1];
								}


							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 0);
						}
					}
				}





				doublerealT* R0_21 = new doublerealT[idim_diag];
				doublerealT* Rprev_21 = new doublerealT[idim_diag];
				doublerealT* Rnext_21 = new doublerealT[idim_diag];

				//3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
				for (integer i_id_level_local = 2; i_id_level_local < idim_diag; i_id_level_local++) {

					move_down(nu1, nu2);


					if (ilevel > i_id_level_local) {
						// Впервые создан универсальный програмный код на произвольное количество уровней вложенности 
						// в solution phase.
						// Нужно только написать универсальный обработчик для R0_21.
						// 4 декабря 2016. 

						// residual
						if (!process_flow_logic) {
							integer in_a_loc = 0;
							for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
								// sum(n_a[0]+n_a[19];
								in_a_loc += n_a[i_72];
							}
							//doublerealT *residual_fine[i_id_level_local-1] = new doublerealT[n_a[i_id_level_local-1] + 1];
							//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16]+nnz_a[17]+nnz_a[18]+nnz_a[19], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16]+ nnz_a[17]+nnz_a[18]+nnz_a[19]+nnz_a[20], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], flag, n_a[i_id_level_local - 1], residual_fine[i_id_level_local - 1]);
							//residualq(Amat, 1, n_a[i_id_level_local-1], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], row_ptr_start, row_ptr_end,  in_a_loc , residual_fine[i_id_level_local - 1]);
							//residualq2(Amat, 1, n_a[i_id_level_local-1], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], row_ptr_start, row_ptr_end, in_a_loc, residual_fine[i_id_level_local - 1], diag[i_id_level_local - 1]);
							residualq2(Amat, 1, n_a[i_id_level_local - 1], error_approx_coarse[i_id_level_local - 2], residual_coarse[i_id_level_local - 2], row_ptr_start, row_ptr_end, in_a_loc, residual_fine[i_id_level_local - 1], diag[i_id_level_local - 1]);

						}

						//doublerealT *residual_coarse[i_id_level_local-1] = new doublerealT[n_a[i_id_level_local] + 1];

						// restriction

						integer innz_aRP_loc = 1;
						for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
							innz_aRP_loc += nnz_aRP[i_72];
						}
						//restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17] + nnz_aRP[18] + nnz_aRP[19], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17] + nnz_aRP[18] + nnz_aRP[19] + nnz_aRP[20], flag, residual_fine[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], n_a[i_id_level_local - 1], n_a[i_id_level_local]);
						restriction(R, innz_aRP_loc, innz_aRP_loc - 1 + nnz_aRP[i_id_level_local - 1], flag, residual_fine[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], n_a[i_id_level_local - 1], n_a[i_id_level_local]);



						// Amat*e=r;
						//doublerealT* error_approx_coarse[i_id_level_local-1] = new doublerealT[n_a[i_id_level_local] + 1];

						if (0) {
							//if (icount_V_cycle == 1) {
							//	for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
							// обнуление только на первом проходе.
							//		error_approx_coarse[i_id_level_local - 1][ii] = 0.0;
							//error_approx_coarse[i_id_level_local - 1][ii] = (rand() / ((doublerealT)RAND_MAX));
							//	}
							//}
							// На задаче BSK_Dmitrii random оптимизация оказалась гораздо хуже, но сходимость тоже присутствовала.
#pragma omp parallel for
							for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
								// 0.4*fabs(residual_coarse[i_id_level_local - 1][ii]) - амплитуда.
								// 0.4 - демпфирующий множитель.
								// diag[i_id_level_local]
								// (1,110); (0.8, 37); (0.7, 29); (0.6, 25); (0.5, 20); (0.4, 17); (0.3, 18); (0.0, 19);
								error_approx_coarse[i_id_level_local - 1][ii] = 0.4*fabs(residual_coarse[i_id_level_local - 1][ii])*(rand() / ((doublerealT)RAND_MAX));
							}
						}
						else {
							if (imyinit == ZERO_INIT) {
#pragma omp parallel for
								for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
									error_approx_coarse[i_id_level_local - 1][ii] = 0.0;
								}
							}
							if (imyinit == RANDOM_INIT) {
#pragma omp parallel for
								for (integer ii = 1; ii <= n_a[i_id_level_local]; ii++) {
									// (1,110); (0.8, 37); (0.7, 29); (0.6, 25); (0.5, 20); (0.4, 17); (0.3, 18); (0.0, 19);
									error_approx_coarse[i_id_level_local - 1][ii] = 0.4*fabs(residual_coarse[i_id_level_local - 1][ii])*(rand() / ((doublerealT)RAND_MAX));
								}
							}
						}


						//for (integer i_37 = 1; i_37 <= igam; i_37++)
						{
							// pre smothing
							//doublerealT R0_21 = 0.0;
							//doublerealT Rprev_21 = 0.0, Rnext_21 = 0.0;
							R0_21[i_id_level_local] = 0.0;
							Rprev_21[i_id_level_local] = 0.0;
							Rnext_21[i_id_level_local] = 0.0;
							if (process_flow_logic) {

								integer in_a_loc = 0;
								for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
									// sum(n_a[0]+n_a[19];
									in_a_loc += n_a[i_72];
								}

								// calculate initial residual.
								//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local-1], residual_coarse[i_id_level_local-1], row_ptr_start, row_ptr_end,in_a_loc + n_a[i_id_level_local-1] , residual_fine[i_id_level_local]);
								residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);



								R0_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
								Rprev_21[i_id_level_local] = R0_21[i_id_level_local];



								// smother
								integer iter = 0;
								integer nu1_count = nu1;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu1_count = 100;

									printf("Direct method is start.../n");

									IMatrix sparseS; // разреженная матрица в формате IMatrix
									initIMatrix(&sparseS, n_a[i_id_level_local]);

									integer istartpos = 1 + in_a_loc + n_a[i_id_level_local - 1];
									integer iendpos = n_a[i_id_level_local] + in_a_loc + n_a[i_id_level_local - 1];

									for (integer i56 = istartpos; i56 <= iendpos; i56++) {

										//setValueIMatrix(&sparseS, Amat[row_ptr_start[i56]].i - 1, Amat[row_ptr_start[i56]].i - 1, 1.0 / Amat[row_ptr_start[i56]].aij);
										setValueIMatrix(&sparseS, i56 - istartpos, i56 - istartpos, 1.0 / Amat[row_ptr_start[i56]].aij);//3.02.2019
										//if (Amat[row_ptr_start[i56]].i != i56 - istartpos + 1) {
											//printf("Amat[row_ptr_start[i56]].i=%lld i56 - istartpos + 1=%lld\n", Amat[row_ptr_start[i56]].i,i56 - istartpos + 1);
											//getchar();
										//}
										const doublerealT nonzeroEPS = 1e-37; // для отделения вещественного нуля

										integer is15 = row_ptr_start[i56] + 1;
										integer is25 = row_ptr_end[i56];

										for (integer ii17 = is15; ii17 <= is25; ii17++)
										{

											if ((fabs(Amat[ii17].aij) > nonzeroEPS)) {
												//setValueIMatrix(&sparseS, Amat[ii17].i - 1, Amat[ii17].j - 1, Amat[ii17].aij);
												setValueIMatrix(&sparseS, ii17- is15, Amat[ii17].j - 1, Amat[ii17].aij);
											}

										}
									}

									doublereal* dX025 = new doublereal[n_a[i_id_level_local]];
									doublereal* dV25 = new doublereal[n_a[i_id_level_local]];
#pragma omp parallel for
									for (integer i57 = 0; i57 < n_a[i_id_level_local]; i57++) {
										dX025[i57] = error_approx_coarse[i_id_level_local - 1][i57 + 1];
										dV25[i57] = residual_coarse[i_id_level_local - 1][i57 + 1];
									}

									// главный метод, возвращающий решение x,
									// принимает вектор свободных членов b и 
									// квадратную матрицу xO в специальном разреженном формате.
									// реализация без барьера и итерационного уточнения.
									calculateSPARSEgaussArray(&sparseS, dX025, dV25);
#pragma omp parallel for
									for (integer i57 = 0; i57 < n_a[i_id_level_local]; i57++) {
										error_approx_coarse[i_id_level_local - 1][i57 + 1] = dX025[i57];
									}

									delete[] dX025;
									delete[] dV25;


									freeIMatrix(&sparseS);

									//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local-1], residual_coarse[i_id_level_local-1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local]);
									residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);


									Rnext_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
									// this is process flow logic
									if (Rnext_21[i_id_level_local] > process_flow_beta*Rprev_21[i_id_level_local]) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_21[i_id_level_local] = Rnext_21[i_id_level_local];
									}
								}
								else {
									for (iter = 0; iter < nu1_count; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
										}

										//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local-1], residual_coarse[i_id_level_local-1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local]);
										residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);


										Rnext_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
										// this is process flow logic
										if (Rnext_21[i_id_level_local] > process_flow_beta*Rprev_21[i_id_level_local]) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_21[i_id_level_local] = Rnext_21[i_id_level_local];
										}
									}
								}

								if (iter == nu1) {
#if doubleintprecision == 1
									printf("level %lld limit presmother iteration is reached\n", i_id_level_local);
#else
									printf("level %d limit presmother iteration is reached\n", i_id_level_local);
#endif

								}

							}
							else {
								integer nu1_count = nu1;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu1_count = 100;
								}
								for (integer iter = 0; iter < nu1_count; iter++) {

									integer in_a_loc = 0;
									for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
										// sum(n_a[0]+n_a[19];
										in_a_loc += n_a[i_72];
									}

									if (bonly_serial) {

										bool bflag56 = false;
										if (my_amg_manager.iFinnest_ilu == 1) {
											if (my_amg_manager.b_ilu_smoothers_in_nnz_n_LE_6) {
												doublerealT dn = 1.0*n_a[i_id_level_local];
												doublerealT dnnz = 1.0*nnz_a[i_id_level_local];
												if (dnnz / dn <= dapply_ilu_max_pattern_size) {
													bflag56 = true;
												}
											}
										}

										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu0[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu0[i_id_level_local].zbuf, milu0[i_id_level_local].zbuf2, milu0[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += milu0[i_id_level_local].zbuf2[i43 + 1];
											}

										}
										else if (1 && ((bILU2smoother == 2) || bflag56)) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu2[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu2[i_id_level_local].zbuf, milu2[i_id_level_local].zbuf2, milu2[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += milu2[i_id_level_local].zbuf2[i43 + 1];
											}

										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
										}
									}
									else {
										seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 0);
									}
								}
							}
						}

					}

				}







				//center
				// ЭТО сердцевина SOLUTION PHASE.

				// TODO нижний 3.12.2016 (осталось один нижний и один верхний).


				// 21
				for (integer i_id_level_local = idim_diag - 1; i_id_level_local >= 2; i_id_level_local--) {

					if (ilevel > i_id_level_local) {

						{

							integer in_a_loc = 0;
							for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
								// sum(n_a[0]+n_a[19];
								in_a_loc += n_a[i_72];
							}

							// post smoothing
							// doublerealT R0_20 = 0.0;
							///doublerealT Rprev_20 = 0.0, Rnext_20 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc  + n_a[i_id_level_local - 1], residual_fine[i_id_level_local]);



								//Rprev_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);


								// smother
								integer iter = 0;
								integer nu2_count = nu2;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu2_count = 100;																												
								}
								else {
									for (iter = 0; iter < nu2_count; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
										}

										//residualq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local-1], residual_fine[i_id_level_local]);
										residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);


										Rnext_21[i_id_level_local] = norma(residual_fine[i_id_level_local], n_a[i_id_level_local]);
										// this is process flow logic
										if (Rnext_21[i_id_level_local] < process_flow_alpha*R0_21[i_id_level_local]) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_21[i_id_level_local] = Rnext_21[i_id_level_local];
										}
									}
								}

								if (iter == nu2) {
#if doubleintprecision == 1
									printf("level %lld limit postsmother iteration is reached\n", i_id_level_local);
#else
									printf("level %d limit postsmother iteration is reached\n", i_id_level_local);
#endif

								}

							}
							else {
								integer nu2_count = nu2;
								if (i_id_level_local == ilevel - 1) {
									// на самом грубом уровне нам требуется точное решение.
									//nu2_count = 100;																																					
								}
								for (integer iter = 0; iter < nu2_count; iter++) {
									if (bonly_serial) {

										bool bflag56 = false;
										if (my_amg_manager.iFinnest_ilu == 1) {
											if (my_amg_manager.b_ilu_smoothers_in_nnz_n_LE_6) {
												doublerealT dn = 1.0*n_a[i_id_level_local];
												doublerealT dnnz = 1.0*nnz_a[i_id_level_local];
												if (dnnz / dn <= dapply_ilu_max_pattern_size) {
													bflag56 = true;
												}
											}
										}

										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu0[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu0[i_id_level_local].zbuf, milu0[i_id_level_local].zbuf2, milu0[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += milu0[i_id_level_local].zbuf2[i43 + 1];
											}
										}
										else if (1 && ((bILU2smoother == 2) || bflag56)) {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
											residualq2(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], residual_fine[i_id_level_local], diag[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												milu2[i_id_level_local].zbuf[i43 + 1] = residual_fine[i_id_level_local][i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[i_id_level_local], milu2[i_id_level_local].zbuf, milu2[i_id_level_local].zbuf2, milu2[i_id_level_local]);
#pragma omp parallel for
											for (integer i43 = 0; i43 < n_a[i_id_level_local]; i43++) {
												error_approx_coarse[i_id_level_local - 1][i43 + 1] += milu2[i_id_level_local].zbuf2[i43 + 1];
											}
										}
										else {
											seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
										}
									}
									else {
										seidelq(Amat, 1, n_a[i_id_level_local], error_approx_coarse[i_id_level_local - 1], residual_coarse[i_id_level_local - 1], nested_desection[i_id_level_local], row_ptr_start, row_ptr_end, in_a_loc + n_a[i_id_level_local - 1], F_false_C_true, 1);
									}
								}
							}


						}

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine[i_id_level_local - 1] = new doublerealT[n_a[i_id_level_local - 1] + 1];
#pragma omp parallel for
						for (integer ii = 1; ii <= n_a[i_id_level_local - 1]; ii++) {
							error_approx_fine[i_id_level_local - 1][ii] = 0.0;
						}

						integer innz_aRP_loc = 1;
						for (integer i_72 = 0; i_72 < i_id_level_local - 1; i_72++) {
							innz_aRP_loc += nnz_aRP[i_72];
						}
						prolongation(P, innz_aRP_loc, innz_aRP_loc - 1 + nnz_aRP[i_id_level_local - 1], flag, error_approx_fine[i_id_level_local - 1], error_approx_coarse[i_id_level_local - 1], n_a[i_id_level_local - 1], n_a[i_id_level_local]);



						// correction
#pragma omp parallel for
						for (integer ii = 1; ii <= n_a[i_id_level_local - 1]; ii++) {
							error_approx_coarse[i_id_level_local - 2][ii] += error_approx_fine[i_id_level_local - 1][ii];
						}

						// free
						//delete[] error_approx_fine[i_id_level_local - 1];
						//delete[] error_approx_coarse[i_id_level_local - 1];
						//delete[] residual_coarse[i_id_level_local - 1];
						//delete[] residual_fine[i_id_level_local - 1];

					} // 21
				}



				


				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0] , residual_fine[1]);
						residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);


						Rnext_1 = norma(residual_fine[1], n_a[1]);
						// this is process flow logic
						if (Rnext_1 < process_flow_alpha*R0_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu2) {
						printf("level 1 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += milu0[1].zbuf2[i43 + 1];
								}
							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
								residualq2(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], residual_fine[1], diag[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine[1][i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
#pragma omp parallel for
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[0][i43 + 1] += milu2[1].zbuf2[i43 + 1];
								}
							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse[0], residual_coarse[0], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0], F_false_C_true, 1);
						}
					}
				}

				delete[] R0_21; 
				delete[] Rprev_21;
				delete[] Rnext_21;

				R0_21 = NULL;
				Rprev_21 = NULL;
				Rnext_21 = NULL;

			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine[0] = new doublerealT[n_a[0] + 1];
#pragma omp parallel for
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[0][ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine[0], error_approx_coarse[0], n_a[0], n_a[1]);

			// correction
#pragma omp parallel for
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				//if (row_ptr_start[ii] != row_ptr_end[ii]) {
					// Не условие Дирихле.
					z76[ii] += error_approx_fine[0][ii];
			//	}
			}

			// free
			//delete[] error_approx_fine[0];
			//delete[] error_approx_coarse[0];
			//delete[] residual_coarse[0];
			//delete[] residual_fine[0];
		}



		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
			Rprev_0 = norma(residual_fine[0], n_a[0]);

			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
				}
				//residualq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
				residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
				Rnext_0 = norma(residual_fine[0], n_a[0]);
				// this is process flow logic
				if (Rnext_0 < process_flow_alpha*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nFinestSweeps) {
				printf("level 0 limit postsmother iteration is reached\n");
			}

		}
		else {
			// nFinnestSweeps new logic 14 jan 2016.
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel<doublereal>(Amat, 1, nnz_a[0], z76, s76, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if ((bILU2smoother == 2) || (my_amg_manager.iFinnest_ilu == 1)) {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
						residualq2(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							z76[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], z76, s76, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 1);
				}
			}
		}

	}
}

// Функции необходимые для работы алгоритма FGMRes - гибкого варианта обобщённого метода минимальных невязок.
// FGMRes - Саад и Шульц 1986 год.
// Данные функции реализованы в файле gmres.cpp.
// НАЧАЛО. функции необходимые для работы FGMRes.
//void Update(doublereal* &x, integer k, integer n, doublereal** &h, doublereal* &s, doublereal** &v);
//void GeneratePlaneRotation(doublereal &dx, doublereal &dy, doublereal &cs, doublereal &sn);
//void ApplyPlaneRotation(doublereal &dx, doublereal &dy, doublereal &cs, doublereal &sn);
// Норма вектора
// как корень квадратный из суммы квадратов.
//doublereal NormaV_for_gmres( doublereal *dV, int isize);
// ОКОНЧАНИЕ. функции необходимые для работы FGMRes.

// Вычисление средних температур в К на границах вакуумных промежутков:
// Это нужно для surface - 2 - surface модели излучения внутри Prism Object.
// Модифицировано с учётом АЛИС сетки 20 сентября 2016.
void update_avg_temperatures(doublereal* &potent, BLOCK &b);

// Модификация матрицы СЛАУ для учёта влияния radiosity Prism Object.
//void radiosity_patch_for_vacuum_Prism_Object(equation3D* &sl, equation3D_bon* &slb, BLOCK* &b, integer lb, integer maxelm)
// 26.09.2016 Работает и для АЛИС сетки тоже.
void radiosity_patch_for_vacuum_Prism_Object_(doublereal* &rthdsd, BLOCK* &b, integer lb, integer maxelm);

// 19.04.2018 Печатает информацию о количестве контрольных объёмов.
// 04.06.2019
void print_control_volume_statistics(integer* &n_a, integer* &nnz_a, integer ilevel,
	bool bprint_mesage_diagnostic, bool debug_reshime)
{
#if doubleintprecision == 1

	if (bprint_mesage_diagnostic) {
		// level info.		

		if ((ilevel >= 2) && (ilevel <= 200)) {
			printf("number of levels=%lld\n", ilevel);
			printf("levels   unknowns   nonzeros  sample_pattern\n");
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("%3lld \t %8lld  %9lld \t %3lld\n", i_1, n_a[i_1],  nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if (ilevel > 200) {
			printf("very big matrix (mesh). no programming.\n");
			printf("you may send your message on mail kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
	}

#else

if (bprint_mesage_diagnostic) {
	// level info.
	if (ilevel == 2) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		printf("%2d \t %8d  %9d \t %3d\n", 0, n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
		printf("%2d \t %8d  %9d \t %3d\n", 1, n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
		if (debug_reshime) system("pause");
	}
	if (ilevel == 3) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		printf("%2d \t %8d  %9d \t %3d\n", 0, n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
		printf("%2d \t %8d  %9d \t %3d\n", 1, n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
		printf("%2d \t %8d  %9d \t %3d\n", 2, n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
		if (debug_reshime) system("pause");
	}
	if (ilevel == 4) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		printf("%2d \t %8d  %9d \t %3d\n", 0, n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
		printf("%2d \t %8d  %9d \t %3d\n", 1, n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
		printf("%2d \t %8d  %9d \t %3d\n", 2, n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
		printf("%2d \t %8d  %9d \t %3d\n", 3, n_a[3], nnz_a[3], (integer)(nnz_a[3] / n_a[3]));
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 21) || (ilevel == 22) || (ilevel == 23) || (ilevel == 24) || (ilevel == 25)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 26) || (ilevel == 27) || (ilevel == 28) || (ilevel == 29) || (ilevel == 30)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 31) || (ilevel == 32) || (ilevel == 33) || (ilevel == 34) || (ilevel == 35)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 36) || (ilevel == 37) || (ilevel == 38) || (ilevel == 39) || (ilevel == 40)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 41) || (ilevel == 42) || (ilevel == 43) || (ilevel == 44) || (ilevel == 45)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 46) || (ilevel == 47) || (ilevel == 48) || (ilevel == 49) || (ilevel == 50)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d  \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 51) || (ilevel == 52) || (ilevel == 53) || (ilevel == 54) || (ilevel == 55)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 56) || (ilevel == 57) || (ilevel == 58) || (ilevel == 59) || (ilevel == 60)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 61) || (ilevel == 62) || (ilevel == 63) || (ilevel == 64) || (ilevel == 65)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 66) || (ilevel == 67) || (ilevel == 68) || (ilevel == 69) || (ilevel == 70)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 71) || (ilevel == 72) || (ilevel == 73) || (ilevel == 74) || (ilevel == 75)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 76) || (ilevel == 77) || (ilevel == 78) || (ilevel == 79) || (ilevel == 80)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 81) || (ilevel == 82) || (ilevel == 83) || (ilevel == 84) || (ilevel == 85)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 86) || (ilevel == 87) || (ilevel == 88) || (ilevel == 89) || (ilevel == 90)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 91) || (ilevel == 92) || (ilevel == 93) || (ilevel == 94) || (ilevel == 95)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel == 96) || (ilevel == 97) || (ilevel == 98) || (ilevel == 99) || (ilevel == 100)) {
		printf("number of levels=%d\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%2d \t %8d  %9d \t %3d\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if ((ilevel >= 101) && (ilevel <= 200)) {
		printf("number of levels=%lld\n", ilevel);
		printf("levels   unknowns   nonzeros  sample_pattern\n");
		for (integer i_1 = 0; i_1 < ilevel; i_1++) {
			printf("%3lld \t %8lld  %9lld \t %3lld\n", i_1, n_a[i_1], nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		if (debug_reshime) system("pause");
	}

	if (ilevel > 200) {
		printf("very big matrix (mesh). no programming.\n");
		printf("you may send your message on mail kirill7785@mail.ru\n");
		system("pause");
		exit(1);
	}
}

#endif

}

// 19.04.2018 Печатает информацию о количестве контрольных объёмов.
void print_control_volume_statistics_old(integer*& n_a, integer*& nnz_a, integer ilevel,
	bool bprint_mesage_diagnostic, bool debug_reshime)
{
#if doubleintprecision == 1

	if (bprint_mesage_diagnostic) {
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld  nnz_a[0]=%lld  sample pattern=%lld\n", n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
			printf("n_a[1]=%lld  nnz_a[1]=%lld sample pattern=%lld\n", n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld  nnz_a[0]=%lld  sample pattern=%lld\n", n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
			printf("n_a[1]=%lld  nnz_a[1]=%lld sample pattern=%lld\n", n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
			printf("n_a[2]=%lld  nnz_a[2]=%lld sample pattern=%lld\n", n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%lld", ilevel);
			printf("n_a[0]=%lld  nnz_a[0]=%lld  sample pattern=%lld\n", n_a[0], nnz_a[0], (integer)(nnz_a[0] / n_a[0]));
			printf("n_a[1]=%lld  nnz_a[1]=%lld sample pattern=%lld\n", n_a[1], nnz_a[1], (integer)(nnz_a[1] / n_a[1]));
			printf("n_a[2]=%lld  nnz_a[2]=%lld sample pattern=%lld\n", n_a[2], nnz_a[2], (integer)(nnz_a[2] / n_a[2]));
			printf("n_a[3]=%lld  nnz_a[3]=%lld sample pattern=%lld\n", n_a[3], nnz_a[3], (integer)(nnz_a[3] / n_a[3]));
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld  sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 21) || (ilevel == 22) || (ilevel == 23) || (ilevel == 24) || (ilevel == 25)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 26) || (ilevel == 27) || (ilevel == 28) || (ilevel == 29) || (ilevel == 30)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 31) || (ilevel == 32) || (ilevel == 33) || (ilevel == 34) || (ilevel == 35)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 36) || (ilevel == 37) || (ilevel == 38) || (ilevel == 39) || (ilevel == 40)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 41) || (ilevel == 42) || (ilevel == 43) || (ilevel == 44) || (ilevel == 45)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 46) || (ilevel == 47) || (ilevel == 48) || (ilevel == 49) || (ilevel == 50)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 51) || (ilevel == 52) || (ilevel == 53) || (ilevel == 54) || (ilevel == 55)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 56) || (ilevel == 57) || (ilevel == 58) || (ilevel == 59) || (ilevel == 60)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 61) || (ilevel == 62) || (ilevel == 63) || (ilevel == 64) || (ilevel == 65)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 66) || (ilevel == 67) || (ilevel == 68) || (ilevel == 69) || (ilevel == 70)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 71) || (ilevel == 72) || (ilevel == 73) || (ilevel == 74) || (ilevel == 75)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 76) || (ilevel == 77) || (ilevel == 78) || (ilevel == 79) || (ilevel == 80)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 81) || (ilevel == 82) || (ilevel == 83) || (ilevel == 84) || (ilevel == 85)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 86) || (ilevel == 87) || (ilevel == 88) || (ilevel == 89) || (ilevel == 90)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 91) || (ilevel == 92) || (ilevel == 93) || (ilevel == 94) || (ilevel == 95)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 96) || (ilevel == 97) || (ilevel == 98) || (ilevel == 99) || (ilevel == 100)) {
			printf("ilevel=%lld\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%lld]=%lld nnz_a[%lld]=%lld  sample pattern=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], (integer)(nnz_a[i_1] / n_a[i_1]));
			}
			if (debug_reshime) system("pause");
		}


		if (ilevel > 99) {
			printf("very big matrix (mesh). no programming.\n");
			system("pause");
			exit(1);
		}
	}

#else

	if (bprint_mesage_diagnostic) {
		// level info.
		if (ilevel == 2) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d \n", n_a[0], n_a[1], nnz_a[0], nnz_a[1]);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 3) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d \n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2]);
			if (debug_reshime) system("pause");
		}
		if (ilevel == 4) {
			printf("ilevel=%d", ilevel);
			printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
			printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d \n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3]);
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 21) || (ilevel == 22) || (ilevel == 23) || (ilevel == 24) || (ilevel == 25)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 26) || (ilevel == 27) || (ilevel == 28) || (ilevel == 29) || (ilevel == 30)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 31) || (ilevel == 32) || (ilevel == 33) || (ilevel == 34) || (ilevel == 35)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 36) || (ilevel == 37) || (ilevel == 38) || (ilevel == 39) || (ilevel == 40)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 41) || (ilevel == 42) || (ilevel == 43) || (ilevel == 44) || (ilevel == 45)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 46) || (ilevel == 47) || (ilevel == 48) || (ilevel == 49) || (ilevel == 50)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 51) || (ilevel == 52) || (ilevel == 53) || (ilevel == 54) || (ilevel == 55)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 56) || (ilevel == 57) || (ilevel == 58) || (ilevel == 59) || (ilevel == 60)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 61) || (ilevel == 62) || (ilevel == 63) || (ilevel == 64) || (ilevel == 65)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 66) || (ilevel == 67) || (ilevel == 68) || (ilevel == 69) || (ilevel == 70)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 71) || (ilevel == 72) || (ilevel == 73) || (ilevel == 74) || (ilevel == 75)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 76) || (ilevel == 77) || (ilevel == 78) || (ilevel == 79) || (ilevel == 80)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 81) || (ilevel == 82) || (ilevel == 83) || (ilevel == 84) || (ilevel == 85)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 86) || (ilevel == 87) || (ilevel == 88) || (ilevel == 89) || (ilevel == 90)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 91) || (ilevel == 92) || (ilevel == 93) || (ilevel == 94) || (ilevel == 95)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}

		if ((ilevel == 96) || (ilevel == 97) || (ilevel == 98) || (ilevel == 99) || (ilevel == 100)) {
			printf("ilevel=%d\n", ilevel);
			for (integer i_1 = 0; i_1 < ilevel; i_1++) {
				printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
			}
			if (debug_reshime) system("pause");
		}


		if (ilevel > 99) {
			printf("very big matrix (mesh). no programming.\n");
			system("pause");
			exit(1);
		}
	}
#endif

}

// Интерполяционная процедура №10.
void my_interpolation_procedure_number10(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor, 
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA, 
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate)
{
// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

the_number_of_neighbors_that_are_not_C_nodes = 0;
number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
// Построение пролонгации для узлов которые составляют F nodes.
// Каждый F-nodes окружён C-nodes.
for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

	// Нам нужен разреженный оператор Галёркина.
	// 5 декабря 2015 года мы попробуем увеличить разреженность
	// оператора интерполляции а значит и оператора Галёркина.
	doublereal maxelem_threshold = -1.0;
	// O(log2(nnz))
	//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
	// O(1)
	integer ii1 = row_startA[i8];

	if (bpositive_connections) {
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
				//if (this_is_C_node[Amat[is0].j] == true) {
				if (fabs(Amat[is0].aij) > maxelem_threshold) {
					maxelem_threshold = fabs(Amat[is0].aij);
				}
				//}
			}
		}
	}
	else {
		// 23_10_2016 только negative connections.
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
				//if (this_is_C_node[Amat[is0].j] == true) {
				if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
					maxelem_threshold = fabs(Amat[is0].aij);
				}
				//}
			}
		}
	}
	// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

	// Найти соседей данного F-node которые C-node.
	integer icsos = 0;

	// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
	// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
	doublereal sumP = 0.0;
	if (bpositive_connections) {
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				if (this_is_C_node[Amat[is0].j] == true) {
					//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
						icsos++;
					}
				}
				else {
					// Подсчитываем количество соседей которые не являются С узлами.
					the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
				}
			}
		}
	}
	else {
		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				if (this_is_C_node[Amat[is0].j] == true) {
					//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
						sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
						icsos++;
					}
				}
				else {
					// Подсчитываем количество соседей которые не являются С узлами.
					the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
				}
			}
		}
	}
	if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.



	if ((false) && (icsos == 1)) {
		// 1 января 2016 Один сосед это недостаточно.
		// Поэтому в случае одного соседа делаем такой узел С узлом.
		this_is_F_node[i8] = false;
		this_is_C_node[i8] = true;
		bweSholdbeContinue = true;
	}
	else {



		for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			if (Amat[is0].j != Amat[ii1].i) {
				if (this_is_C_node[Amat[is0].j] == true) {

					if (fabs(sumP) < RealZERO) {
						//printf("error interpolation zero diagonal sumP.\n");
						//printf("Fnode all sosed is F");
						//system("pause");
						//printf("i8 is Dirichlet node\n");
						if (this_is_C_node[i8] == false) iadditionalCstatistic++;
						this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
						//exit(1);
						// здесь нужна непрямая интерполляция.
					}
					else {

						// Внедиагональный элемент из множества С узлов.

						if (bpositive_connections) {

							// Данная вставка должна существенно сохранять 
							// разреженность оператора Галёркина на глубоких 
							// сеточных уровнях.
							// Модификация 5 декабря 2015.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								P[icount1].j = i8;
								P[icount1].i = C_numerate[Amat[is0].j];
								P[icount1].aij = fabs(Amat[is0].aij) / sumP;
								icount1++;
								if (icount1 >= nsizePR*n) {
									printf("memory error!!!\n");
									printf("not enough memory for the interpolation operator.\n");
									//system("PAUSE");
									//exit(1);
									deallocate_prolongation(nsizePR, n, R, P);
								}
							}
						}
						else {
							// Данная вставка должна существенно сохранять 
							// разреженность оператора Галёркина на глубоких 
							// сеточных уровнях.
							// Модификация 5 декабря 2015.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								P[icount1].j = i8;
								P[icount1].i = C_numerate[Amat[is0].j];
								P[icount1].aij = fabs(Amat[is0].aij) / sumP;
								icount1++;
								if (icount1 >= nsizePR*n) {
									printf("memory error!!!\n");
									printf("not enough memory for the interpolation operator.\n");
									//system("PAUSE");
									//exit(1);
									deallocate_prolongation(nsizePR, n, R, P);
								}
							}
						}

					}

				}
			}
		}

	}

}
} // my_interpolation_procedure_number10

  // Интерполяционная процедура №7.
void my_interpolation_procedure_number7(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate)
{
	// Немного более экономичная по памяти. Коэффициент не превышал 3.

	// Прямая интерполляция с элементам непрямой.
	// Непрямая интерполляция применяется только для F узлов которые
	// не имеют С соседей.
	// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
	// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
	// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
	// в результате сканирования списка Strong F соседей.
	// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
	// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
	// Потом мы повторно запускаем алгоритм построения с учётом уже добавленных С узлов.


	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
	// Построение пролонгации для узлов которые составляют F nodes.
	// Каждый F-nodes окружён C-nodes.
	for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

		// Нам нужен разреженный оператор Галёркина.
		// 5 декабря 2015 года мы попробуем увеличить разреженность
		// оператора интерполляции а значит и оператора Галёркина.
		doublereal maxelem_threshold = -1.0;
		// O(log2(nnz))
		//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// O(1)
		integer ii1 = row_startA[i8];
		if (bpositive_connections) {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
		}
		else {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
		}
		// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

		// Найти соседей данного F-node которые C-node.
		integer icsos = 0;

		// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
		// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
		doublereal sumP = 0.0;
		doublereal SumPall = 0.0;
		integer icount_StronglyF = 0;
		if (bpositive_connections) {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
		}
		else {
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
		}
		if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.


		// 1 января 2015 Один сосед это недостаточно.
		// Поэтому в случае одного соседа делаем такой узел С узлом.
		if ((false) && (icsos == 1)) {
			this_is_F_node[i8] = false;
			this_is_C_node[i8] = true;
			bweSholdbeContinue = true;
		}
		else {

			if (fabs(sumP) < RealZERO) {
				//printf("error interpolation zero diagonal sumP.\n");
				//printf("Fnode all sosed is F");
				//system("pause");
				//printf("i8 is Dirichlet node\n");

				//exit(1);
				// здесь нужна непрямая интерполляция.
				bool* empty_interpol = NULL;
				//empty_interpol = new bool[icount_StronglyF];
				empty_interpol = (bool*)malloc(icount_StronglyF * sizeof(bool));
				char c1[27] = "classic_aglomerative_amg_4";
				char c2[15] = "empty_interpol";
				handle_error<bool>(empty_interpol, c2,  c1, icount_StronglyF);

				for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
					empty_interpol[i_38] = false; // initialization
				}

				integer i_38_count = 0;

				bool bCinsert = false;

				if (bpositive_connections) {

					// Сканируем сильных F соседей данного F узла для которого надо построить интерполляцию.
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

									integer iFpoint = Amat[is0].j;
									doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublereal maxelem_threshold_loc = -1.0;
									//O(log2(nnz))
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									// O(1)
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j] == true) {
											// Будем рассматривать только действительно сильных C кандидатов второго уровня.
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublereal sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j] == true) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполляция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										bCinsert = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

									}

									i_38_count++;

								}
							}
						}
					}

				}
				else {
					// Сканируем сильных F соседей данного F узла для которого надо построить интерполляцию.
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

									integer iFpoint = Amat[is0].j;
									doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublereal maxelem_threshold_loc = -1.0;
									//O(log2(nnz))
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									// O(1)
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j] == true) {
											// Будем рассматривать только действительно сильных C кандидатов второго уровня.
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublereal sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j] == true) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполляция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										bCinsert = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

									}

									i_38_count++;

								}
							}
						}
					}
				}

				if (!bCinsert) {
					// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

					bool bstandart_vjzov = true;
					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						// 3 января. На самом деле здесь хорошо бы посмотреть вариант
						// когда с не менее чем двух сторон интерполляция сработала, здесь 
						// же срабатывание было лишь с одной из сторон как минимум.
						if (empty_interpol[i_38] == true) {
							bstandart_vjzov = false;
						}
					}
					if (bstandart_vjzov) {
						if (this_is_C_node[i8] == false) iadditionalCstatistic++;
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
				}

				free(empty_interpol);

			}



			else {

				if (bpositive_connections) {
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									P[icount1].j = i8;
									P[icount1].i = C_numerate[Amat[is0].j];
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}
						}
					}

				}
				else {
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									P[icount1].j = i8;
									P[icount1].i = C_numerate[Amat[is0].j];
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}
						}
					}

				}
			} // standart

		} // i8

	}

} // my_interpolation_procedure_number7

  // Интерполяционная процедура №2.
void my_interpolation_procedure_number2(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF)
{
	// Немного более экономичная по памяти. Коэффициент не превышал 3.

	// Прямая интерполляция с элементам непрямой. Экспериментальный вариант. TODO.
	// Непрямая интерполляция применяется только для F узлов которые
	// не имеют С соседей или имеют недостаточное число С соседей.
	// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

	// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполляцию.
	// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
	// двух  C соседей учитывая эффект непрямой интерполляции.


	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
	number_of_F_nodes_with_one_single_strong_C_neighborF = 0;

	if (bpositive_connections) {
		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным C соседом и к тому-же не имеющих сильных F соседов.
			}


			// 1 января 2015 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (fabs(sumP) < RealZERO) {
					//printf("error interpolation zero diagonal sumP.\n");
					//printf("Fnode all sosed is F");
					//system("pause");
					//printf("i8 is Dirichlet node\n");

					//exit(1);
					// здесь нужна непрямая интерполляция.
					bool* empty_interpol = NULL;
					//empty_interpol = new bool[icount_StronglyF];
					empty_interpol = (bool*)malloc(icount_StronglyF * sizeof(bool));
					char c1[27] = "classic_aglomerative_amg_4";
					char c2[15] = "empty_interpol";
					handle_error<bool>(empty_interpol, c2,  c1, icount_StronglyF);

					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						empty_interpol[i_38] = false; // initialization
					}

					integer i_38_count = 0;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

									integer iFpoint = Amat[is0].j;
									doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublereal maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j] == true) {
											// Будем рассматривать только действительно сильных С кандидатов второго уровня.
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublereal sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j] == true) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполляция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне вложенности.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
									}

									i_38_count++;

								}
							}
						}
					}

					bool bstandart_vjzov = true;
					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						// 3 января. На самом деле здесь хорошо бы посмотреть вариант
						// когда с не менее чем двух сторон интерполляция сработала, здесь 
						// же срабатывание было лишь с одной из сторон как минимум.
						if (empty_interpol[i_38] == true) {
							bstandart_vjzov = false;
						}
					}
					if (bstandart_vjzov) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
					}

					free(empty_interpol);

				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j] == true) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									P[icount1].j = i8;
									P[icount1].i = C_numerate[Amat[is0].j];
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}



							}
						}
					}
				} // standart

			} // i8


		} ///
	}
	else {
		// Только negative connections:


		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}


			// 1 января 2015 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (fabs(sumP) < RealZERO) {
					//printf("error interpolation zero diagonal sumP.\n");
					//printf("Fnode all sosed is F");
					//system("pause");
					//printf("i8 is Dirichlet node\n");

					//exit(1);
					// здесь нужна непрямая интерполляция.
					bool* empty_interpol = NULL;
					//empty_interpol = new bool[icount_StronglyF];
					empty_interpol = (bool*)malloc(icount_StronglyF * sizeof(bool));
					char c1[27] = "classic_aglomerative_amg_4";
					char c2[15] = "empty_interpol";
					handle_error<bool>(empty_interpol, c2,  c1, icount_StronglyF);

					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						empty_interpol[i_38] = false; // initialization
					}

					integer i_38_count = 0;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_F_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

									integer iFpoint = Amat[is0].j;
									doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublereal maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											//if (this_is_C_node[Amat[is0_loc].j] == true) {
											// Будем рассматривать только действительно сильных С кандидатов второго уровня.
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
											}
											//}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;
									bool bvisit_sumPloc = false;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublereal sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j] == true) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
													bvisit_sumPloc = true;
													empty_interpol[i_38_count] = true;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}


									if (bvisit_sumPloc) {
										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}
									}
									else {
										// не было С соседей интерполляция может испытывать проблемы.
										// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
										// Данная проблема проявляется уже на втором уровне вложенности.
										//printf("problem situation");
										//getchar();
										this_is_F_node[iFpoint] = false;
										this_is_C_node[iFpoint] = true;
										bweSholdbeContinue = true;
										// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
										// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
										break;
										// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
									}

									i_38_count++;

								}
							}
						}
					}

					bool bstandart_vjzov = true;
					for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
						// 3 января. На самом деле здесь хорошо бы посмотреть вариант
						// когда с не менее чем двух сторон интерполляция сработала, здесь 
						// же срабатывание было лишь с одной из сторон как минимум.
						if (empty_interpol[i_38] == true) {
							bstandart_vjzov = false;
						}
					}
					if (bstandart_vjzov) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
					}

					free(empty_interpol);

				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j] == true) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {



								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									P[icount1].j = i8;
									P[icount1].i = C_numerate[Amat[is0].j];
									P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}



							}
						}
					}
				} // standart

			} // i8


		}

	}

} // my_interpolation_procedure_number2

#include "my_amg_interpolation.cpp"

  // Интерполяционная процедура №3.
void my_interpolation_procedure_number3(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublereal &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublereal &magic82, doublereal* &threshold_quick_all, 
	doublereal* &threshold_quick_only_negative)
{

	// 6 december 2016.
	// Подлежит удалению Refactoring.
	integer itypemodifyinterpol=0; // номер модификации интерполляции. // Подлежит удалению Refactoring.
	integer inumberadaptpass=0; // максимальное количество сканов-проходов с модификациями. // Подлежит удалению Refactoring.


	//theta = 0.24;
	// theta_strong_F iter_number time,s
	// 0.21 56 22.63
	// 0.22 55 21.769
	// 0.23 52 21.488
	// 0.24 52 21.741 == theta // optimum
	// 0.26 69 24.623
	doublereal theta_strong_F = 0.23; // оптимальный выбор.
	theta_strong_F = theta83; // 3 июля 2016


							  // четвёртая версия интерполяции.
	integer ioneStrongC_and_0_StrongF = 0;

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	//6interpolation 0.4 6.77 11 26 28.355
	//6interpolation 0.45 6.6 10 27 28.151
	//6interpolation 0.5 6.42 12 32 28.735
	//4interpolation 0.4 3.7  52 24.736 // best
	//4interpolation 0.3 3.78 13 59 27.525
	//4interpolation 0.5 3.61 12 55 25.533
	//4interpolation 0.45 3.65 10 63 30.24

	// the begining

	bool byes_add = false;
	// Быстрое добавление недостающих С узлов.
	if (1) {
		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum


		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {


			integer i8_candidate_count = 0;
			integer* i8_candidate_arr = NULL;
			i8_candidate_arr = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
			char c1[18] ="i8_candidate_arr";
			char c2[26] = "classic_aglomerative_amg4";
			handle_error<integer>(i8_candidate_arr,  c1, c2, (n_a[ilevel - 1] + 1));
			doublereal* i8_candidate_val_arr = NULL;
			i8_candidate_val_arr = (doublereal*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublereal));
			char c3[22] = "i8_candidate_val_arr";
			handle_error<doublereal>(i8_candidate_val_arr, c3, c2, (n_a[ilevel - 1] + 1));

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

#if doubleintprecision == 1
				//printf("i8=%lld n=%lld\n", i8, n_a[ilevel - 1]);
#else
				//printf("i8=%d n=%d\n", i8, n_a[ilevel - 1]);
#endif

				//getchar();


				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					maxelem_threshold = threshold_quick_all[Amat[ii1].i];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				doublereal maxelem_threshold_theta = maxelem_threshold*theta;
				doublereal maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
				for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF == 0)) {
						// Накапливаем информацию.
						if (itypemodifyinterpol > 0) {

							if (itypemodifyinterpol > 1) {
								// запоминаем позицию кандидата на С узел.
								i8_candidate_arr[i8_candidate_count] = i8;
								// Запоминаем силу внедиагональной связи, 
								// чтобы потом выбрать наиболее сильную.
								i8_candidate_val_arr[i8_candidate_count] = sumP;
								i8_candidate_count++;
							}

							if (itypemodifyinterpol == 1) {
								// Добавляем только в том случае если количество проходов меньше максмального.
								if (ifrom_re_operation_protection < inumberadaptpass) {
									// 3 december 2016 rundom
									// не более сотни случайных добавлений на каждом уровне.
									integer id_size_873 = (integer)(n_a[ilevel - 1] / 100);
									integer id_873 = rand() % id_size_873 + 1;
									if (id_873 == 1) {
										// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
										// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
										// модификация 2 декабря 2016 года.
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
									}
								}
							}
						}
					}
					else if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						//SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
									if (this_is_C_node[Amat[is0].j] == true) {

										// 20 января 2016.
										// По-моему этой ситуации вообще быть не может так как у нас 
										// заведомо один С сосед.
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true; // Были добавления узлов.
															 //exit(1);
															 // здесь нужна непрямая интерполляция.
										}


									}

								}
							}
						}
					}
					else {

						integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
						for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
							if (this_is_C_node[Amat[is0].j] == true) {
								if (Amat[is0].j != Amat[ii1].i) {


									// 20 jan 2016.
									// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


									if (fabs(sumP) < RealZERO) {
										// Это случай когда вообще нет сильных С соседей.


										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
									}


								}
							}
						}
					}

				}

			}
			/////
			if (itypemodifyinterpol > 0) {

				if (i8_candidate_arr != NULL) {
					i8_candidate_arr = (integer*)realloc(i8_candidate_arr, (i8_candidate_count + 2) * sizeof(integer));
				}
				if (i8_candidate_val_arr != NULL) {
					i8_candidate_val_arr = (doublereal*)realloc(i8_candidate_val_arr, (i8_candidate_count + 2) * sizeof(doublereal));
				}


				// Выбираем integer i_gold_i8 наиболее сильных.
				integer i_gold_i8 = i_my_min(i8_candidate_count/20, 100);// 100
				if (i8_candidate_count < 100) {
					i_gold_i8 = i8_candidate_count - 3;
				}
				if (1 && from_re_operation_protection0) {
					// Сортировка по возрастанию.
					// Сортировка Быстрая Ч. Хоара заимствована из модуля my_nested_dissection.cpp
					QuickSortnd(i8_candidate_arr, i8_candidate_val_arr, 0, i8_candidate_count - 1);

					if (itypemodifyinterpol == 2) {
						// minimum
						//for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
						for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
							// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
							// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
							// модификация 2 декабря 2016 года.
							this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8_candidate_arr[i_9]] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							byes_add = true; // Были добавления узлов.
						}
					}
					if (itypemodifyinterpol == 3) {
						// maximum
						for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
							//for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
							// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
							// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
							// модификация 2 декабря 2016 года.
							this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8_candidate_arr[i_9]] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							byes_add = true; // Были добавления узлов.
						}
					}

				}

				ifrom_re_operation_protection++;
				if (ifrom_re_operation_protection > inumberadaptpass) {
					from_re_operation_protection0 = false;
				}


			}

			if (i8_candidate_arr != NULL) {
				free(i8_candidate_arr);
				i8_candidate_arr = NULL;
			}
			if (i8_candidate_val_arr != NULL) {
				free(i8_candidate_val_arr);
				i8_candidate_val_arr = NULL;
			}

		}
		else {
			// only negative connections

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {



				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					maxelem_threshold = threshold_quick_only_negative[Amat[ii1].i];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				doublereal maxelem_threshold_theta = maxelem_threshold*theta;
				doublereal maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
				for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						//SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
									if (this_is_C_node[Amat[is0].j] == true) {

										// 20 января 2016.
										// По-моему этой ситуации вообще быть не может так как у нас 
										// заведомо один С сосед.
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true; // Были добавления узлов.
															 //exit(1);
															 // здесь нужна непрямая интерполляция.
										}


									}

								}
							}
						}
					}
					else {

						integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
						for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
							if (this_is_C_node[Amat[is0].j] == true) {
								if (Amat[is0].j != Amat[ii1].i) {


									// 20 jan 2016.
									// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


									if (fabs(sumP) < RealZERO) {
										// Это случай когда вообще нет сильных С соседей.


										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
									}


								}
							}
						}
					}

				}

			}


		}

	}



	if (!byes_add) {

		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//------>doublereal magic = 0.4; // 0.4 optimum
								 //magic = 0.3; // 3 июля 2016 для конвективных задач
								 // линейный прогноз не дает улучшений
								 // ни по быстрдействию ни по числу V циклов.
								 //magic = 0.5 - 0.2*ilevel / 12.0;
		const doublereal magic = magic82;// 0.4 is recomended.



		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				integer istr_etalon1 = Amat[ii1].i;
				integer iend_for1 = -1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
						if (Amat[is0].j != istr_etalon1) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
					}
					maxelem_threshold = threshold_quick_all[istr_etalon1];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				doublereal maxelem_threshold_theta = maxelem_threshold*theta;
				doublereal maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer is0 = ii1; is0 <= iend_for1; is0++) {
					if (Amat[is0].j != istr_etalon1) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
						//if (((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.


								if (this_is_C_node[Amat[is0].j] == true) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												if (fabs(SumPall) < 1.0e-33) {
													printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
													//getchar();
													system("PAUSE");
													exit(1);
												}
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}
									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F) {
											// Рассматриваем Strong F связи.

											// Смысл :
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

											integer iFpoint = Amat[is0].j;
											if (fabs(SumPall) < 1.0e-33) {
												printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublereal maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											integer istr_etalon = Amat[ii1_loc].i;
											integer iend_for = -1;
											integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
											for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
												iend_for = is0_loc;
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (Amat[is0_loc].j != istr_etalon) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}

											doublereal maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc = 0.0;
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// Будем отсекать сразу наибольшее число вариантов.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {






													if (this_is_C_node[Amat[is0_loc].j] == true) {

														if (Amat[is0_loc].j != istr_etalon) {

															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}

													}
													else {

														//if (Amat[is0_loc].j != istr_etalon) {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
														//}
													}

												}
											}

											doublereal maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

											// В общем это двойная интерполляционная сумма 
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
													//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (Amat[is0_loc].j != istr_etalon) {

															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															if (fabs(sumP_loc) < 1.0e-33) {
																printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
																//getchar();
																system("PAUSE");
																exit(1);
															}
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}

														}
													}
												}
											}


											//}
										}
									}
							}

						}
					}
					else {

						// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
						// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
						// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
						// bmodify_interpol4_amg = false;
						// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
						bool bmodify_interpol4_amg = false;
						doublereal magic2 = 0.5;
						//magic2 = magic83;

						// Подготовительный этап к усилению четвертой интерполяции 
						// Усиление интерполяции происходит без добавления новых С узлов.
						// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
						// имеется конечно.
						// Подготовительный этап заключается в определении положения is0_candidate самой сильной
						// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
						doublereal sum1 = 0.0;
						integer is0_candidate = -1;
						if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							if (sum1 / sumP < magic2) {
								// Если найденный элемент слишком слабый ничего не делаем с этим С,
								// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
								sum1 = 0.0;
								is0_candidate = -1;

								// Тогда ищем среди Weakly F узлов кандидата.
								for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
												if (fabs(Amat[is0].aij) > sum1) {
													sum1 = fabs(Amat[is0].aij);
													is0_candidate = is0;
												}
											}
										}
									}
								}

								// такой узел F должен стать новым С узлом.
								if (sum1 / sumP >= magic2) {
									this_is_F_node[i8] = false; // Этот узел  станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									byes_add = true;
									iadditionalCstatistic++;

								}
								// Обязательный сброс перед рестартом чтобы не было деления на ноль.
								sum1 = 0.0;
								is0_candidate = -1;

							}
						}


						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {



									if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
										// Мы усиливаем силу интерполяции без добавления новых узлов за
										// счёт одной дополнительной самой сильной Weakly C связи.
										// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

										ioneStrongC_and_0_StrongF++;
										if (is0_candidate != -1) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0_candidate].j];
											P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
									}
									else {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {

											// Интерполляция только по ближайшим С узлам.

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												if (fabs(sumP) < 1.0e-33) {
													// Несколько опорных С узлов, они являются главными опорами при интерполляции.
													// (fabs(Amat[is0].aij) / sumP) не может быть больше единицы по определению. 
													if ((fabs(sumP) < 1.0e-100) || ((fabs(sumP) >= 1.0e-100) && ((fabs(Amat[is0].aij) / sumP) < 0.1))) {
														printf("error 4.0 ! division by zero. sumP =%e\n", sumP);
														// Ситуация : fabs(Amat[is0].aij) / sumP==1.0, Amat[is0].aij<1.0e-33;
														printf("diagnostic: aij=%e aij/sumP=%e\n", Amat[is0].aij, fabs(Amat[is0].aij) / sumP);
														//getchar();
														system("PAUSE");
														exit(1);
													}
												}
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}

								}
							}
						}
					}

				}
			}
			////
		}
		else {
			// only negative connections.

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				integer istr_etalon1 = Amat[ii1].i;
				integer iend_for1 = -1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
						if (Amat[is0].j != istr_etalon1) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
				}
				else {
					for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
						iend_for1 = is0;
					}
					maxelem_threshold = threshold_quick_only_negative[istr_etalon1];
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				doublereal maxelem_threshold_theta = maxelem_threshold*theta;
				doublereal maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer is0 = ii1; is0 <= iend_for1; is0++) {
					if (Amat[is0].j != istr_etalon1) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.


								if (this_is_C_node[Amat[is0].j] == true) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												if (fabs(SumPall) < 1.0e-23) {
													printf("error 5.0 ! division by zero. SumPall =%e\n", SumPall);
													//getchar();
													system("PAUSE");
													exit(1);
												}
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}
									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
											// Рассматриваем Strong F связи.

											// Смысл :
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

											integer iFpoint = Amat[is0].j;
											doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublereal maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											integer istr_etalon = Amat[ii1_loc].i;
											integer iend_for = -1;
											integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
											for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
												iend_for = is0_loc;
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (Amat[is0_loc].j != istr_etalon) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}

											doublereal maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc = 0.0;
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// Будем отсекать сразу наибольшее число вариантов.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






													if (this_is_C_node[Amat[is0_loc].j] == true) {

														if (Amat[is0_loc].j != istr_etalon) {

															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}

													}
													else {

														//if (Amat[is0_loc].j != istr_etalon) {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
														//}
													}

												}
											}

											doublereal maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

											// В общем это двойная интерполляционная сумма 
											//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

												// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
													//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (Amat[is0_loc].j != istr_etalon) {

															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															if (fabs(sumP_loc) < 1.0e-23) {
																printf("error 6.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
																//getchar();
																system("PAUSE");
																exit(1);
															}
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}

														}
													}
												}
											}


											//}
										}
									}
							}

						}
					}
					else {

						// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
						// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
						// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
						// bmodify_interpol4_amg = false;
						// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
						bool bmodify_interpol4_amg = false;
						doublereal magic2 = 0.5;
						//magic2 = magic83;

						// Подготовительный этап к усилению четвертой интерполяции 
						// Усиление интерполяции происходит без добавления новых С узлов.
						// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
						// имеется конечно.
						// Подготовительный этап заключается в определении положения is0_candidate самой сильной
						// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
						doublereal sum1 = 0.0;
						integer is0_candidate = -1;
						if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							if (sum1 / sumP < magic2) {
								// Если найденный элемент слишком слабый ничего не делаем с этим С,
								// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
								sum1 = 0.0;
								is0_candidate = -1;

								// Тогда ищем среди Weakly F узлов кандидата.
								for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
											if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
												if (fabs(Amat[is0].aij) > sum1) {
													sum1 = fabs(Amat[is0].aij);
													is0_candidate = is0;
												}
											}
										}
									}
								}

								// такой узел F должен стать новым С узлом.
								if (sum1 / sumP >= magic2) {
									this_is_F_node[i8] = false; // Этот узел  станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									byes_add = true;
									iadditionalCstatistic++;

								}
								// Обязательный сброс перед рестартом чтобы не было деления на ноль.
								sum1 = 0.0;
								is0_candidate = -1;

							}
						}


						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {



									if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
										// Мы усиливаем силу интерполяции без добавления новых узлов за
										// счёт одной дополнительной самой сильной Weakly C связи.
										// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

										ioneStrongC_and_0_StrongF++;
										if (is0_candidate != -1) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0_candidate].j];
											P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
									}
									else {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												if (fabs(sumP) < 1.0e-23) {
													printf("error 7.0 ! division by zero. sumP =%e\n", sumP);
													//getchar();
													system("PAUSE");
													exit(1);
												}
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}

								}
							}
						}
					}

				}
			} // end only negative connections

		}

	}

#if doubleintprecision == 1
	//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
	//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif

	//system("pause");

	// marker END.
} // my_interpolation_procedure_number3

  // Интерполяционная процедура №1.
void my_interpolation_procedure_number1(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublereal &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublereal &magic82, doublereal* &threshold_quick_all,
	doublereal* &threshold_quick_only_negative)
{

	// 6 december 2016.
	// Подлежит удалению Refactoring.
	integer itypemodifyinterpol = 0; // номер модификации интерполляции. // Подлежит удалению Refactoring.
	integer inumberadaptpass = 0; // максимальное количество сканов-проходов с модификациями. // Подлежит удалению Refactoring.


	// 1.04.2017
	// Главная идея в том чтобы разделить интерполяцию по знакам,
	// отдельно положительные коэффициенты и отдельно положительные,
	// в итоге учитывается и то и то.


	//theta = 0.24;
	// theta_strong_F iter_number time,s
	// 0.21 56 22.63
	// 0.22 55 21.769
	// 0.23 52 21.488
	// 0.24 52 21.741 == theta // optimum
	// 0.26 69 24.623
	doublereal theta_strong_F = 0.23; // оптимальный выбор.
	theta_strong_F = theta83; // 3 июля 2016


							  // четвёртая версия интерполяции.
	integer ioneStrongC_and_0_StrongF = 0;

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	//6interpolation 0.4 6.77 11 26 28.355
	//6interpolation 0.45 6.6 10 27 28.151
	//6interpolation 0.5 6.42 12 32 28.735
	//4interpolation 0.4 3.7  52 24.736 // best
	//4interpolation 0.3 3.78 13 59 27.525
	//4interpolation 0.5 3.61 12 55 25.533
	//4interpolation 0.45 3.65 10 63 30.24

	// the begining

	bool byes_add = false;
	// Быстрое добавление недостающих С узлов.
	if (1) {
		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum


		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		integer i8_candidate_count = 0;
		integer* i8_candidate_arr = NULL;
		i8_candidate_arr = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		char c1[26] = "classic_aglomerative_amg4";
		char c2[17] = "i8_candidate_arr";
		char c3[21] = "i8_candidate_val_arr";
		handle_error<integer>(i8_candidate_arr, c2,  c1, (n_a[ilevel - 1] + 1));
		doublereal* i8_candidate_val_arr = NULL;
		i8_candidate_val_arr = (doublereal*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublereal));		
		handle_error<doublereal>(i8_candidate_val_arr, c3,  c1, (n_a[ilevel - 1] + 1));

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

#if doubleintprecision == 1
			//printf("i8=%lld n=%lld\n", i8, n_a[ilevel - 1]);
#else
			//printf("i8=%d n=%d\n", i8, n_a[ilevel - 1]);
#endif

			//getchar();


			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
			if (!btreshold_on_new_vetv) {
				for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j] == true) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
			}
			else {
				maxelem_threshold = threshold_quick_all[Amat[ii1].i];
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsos_pos = 0;
			integer icsosF = 0;
			integer icsosF_pos = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal sumP_pos = 0.0;
			doublereal SumPall = 0.0;
			doublereal SumPall_pos = 0.0;
			integer icount_StronglyF = 0;
			integer icount_StronglyF_pos = 0;

			doublereal maxelem_threshold_theta = maxelem_threshold*theta;
			doublereal maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
			for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			{

				if ((icsos == 1) && (icsosF == 0)) {



					// Накапливаем информацию.
					if (itypemodifyinterpol > 0) {



						if (itypemodifyinterpol > 1) {
							// запоминаем позицию кандидата на С узел.
							i8_candidate_arr[i8_candidate_count] = i8;
							// Запоминаем силу внедиагональной связи, 
							// чтобы потом выбрать наиболее сильную.
							i8_candidate_val_arr[i8_candidate_count] = sumP;
							i8_candidate_count++;
						}

						if (itypemodifyinterpol == 1) {
							// Добавляем только в том случае если количество проходов меньше максмального.
							if (ifrom_re_operation_protection < inumberadaptpass) {
								// 3 december 2016 rundom
								// не более сотни случайных добавлений на каждом уровне.
								integer id_size_873 = (integer)(n_a[ilevel - 1] / 100);
								integer id_873 = rand() % id_size_873 + 1;
								if (id_873 == 1) {
									// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
									// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
									// модификация 2 декабря 2016 года.
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
								}
							}
						}
					}
				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					//SumPall += sumP;

					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
								if (this_is_C_node[Amat[is0].j] == true) {

									// 20 января 2016.
									// По-моему этой ситуации вообще быть не может так как у нас 
									// заведомо один С сосед.
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
									}


								}

							}
						}
					}
				}
				else {

					integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (this_is_C_node[Amat[is0].j] == true) {
							if (Amat[is0].j != Amat[ii1].i) {


								// 20 jan 2016.
								// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


								if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
									// Это случай когда вообще нет сильных С соседей.


									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all sosed is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
													 //exit(1);
													 // здесь нужна непрямая интерполляция.
								}


							}
						}
					}
				}

			}

		}
		/////
		if (itypemodifyinterpol > 0) {

			if (i8_candidate_arr != NULL) {
				i8_candidate_arr = (integer*)realloc(i8_candidate_arr, (i8_candidate_count + 2) * sizeof(integer));
			}
			if (i8_candidate_val_arr != NULL) {
				i8_candidate_val_arr = (doublereal*)realloc(i8_candidate_val_arr, (i8_candidate_count + 2) * sizeof(doublereal));
			}


			// Выбираем integer i_gold_i8 наиболее сильных.
			integer i_gold_i8 = i_my_min(i8_candidate_count/20, 100);// 100
			if (i8_candidate_count < 100) {
				i_gold_i8 = i8_candidate_count - 3;
			}
			if (1 && from_re_operation_protection0) {
				// Сортировка по возрастанию.
				// Сортировка Быстрая Ч. Хоара заимствована из модуля my_nested_dissection.cpp
				QuickSortnd(i8_candidate_arr, i8_candidate_val_arr, 0, i8_candidate_count - 1);

				if (itypemodifyinterpol == 2) {
					// minimum
					//for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
					for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}
				if (itypemodifyinterpol == 3) {
					// maximum
					for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
						//for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}

			}

			ifrom_re_operation_protection++;
			if (ifrom_re_operation_protection > inumberadaptpass) {
				from_re_operation_protection0 = false;
			}


		}

		if (i8_candidate_arr != NULL) {
			free(i8_candidate_arr);
			i8_candidate_arr = NULL;
		}
		if (i8_candidate_val_arr != NULL) {
			free(i8_candidate_val_arr);
			i8_candidate_val_arr = NULL;
		}



	}



	if (!byes_add) {

		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//---->doublereal magic = 0.4; // 0.4 optimum
								 //magic = 0.3; // 3 июля 2016 для конвективных задач
								 // линейный прогноз не дает улучшений
								 // ни по быстрдействию ни по числу V циклов.
								 //magic = 0.5 - 0.2*ilevel / 12.0;
		const doublereal magic = magic82; // 0.4 is recomended.



		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			integer istr_etalon1 = Amat[ii1].i;
			integer iend_for1 = -1;
			if (!btreshold_on_new_vetv) {
				for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
					iend_for1 = is0;
					if (Amat[is0].j != istr_etalon1) {
						// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j] == true) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
			}
			else {
				for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
					iend_for1 = is0;
				}
				maxelem_threshold = threshold_quick_all[istr_etalon1];
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;
			integer icsos_pos = 0;
			integer icsosF_pos = 0;

			doublereal maxelem_threshold_theta = maxelem_threshold*theta;
			doublereal maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal SumPall = 0.0;
			integer icount_StronglyF = 0;
			doublereal sumP_pos = 0.0;
			doublereal SumPall_pos = 0.0;
			integer icount_StronglyF_pos = 0;

			//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			for (integer is0 = ii1; is0 <= iend_for1; is0++) {
				if (Amat[is0].j != istr_etalon1) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij > 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
					//if (((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;
					SumPall_pos += sumP_pos;


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.


							if (this_is_C_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall_pos) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											// Внимание !!! именно минус.
											P[icount1].aij = -fabs(Amat[is0].aij) / SumPall_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}


									}
								}

							}
							else
								if (this_is_F_node[Amat[is0].j] == true) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublereal maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j] == true) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublereal maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполляционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}
									// todo
									if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall_pos) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										// Внимание минус.
										doublereal multiplyer_nu = -fabs(Amat[is0].aij) / SumPall_pos;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublereal maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j] == true) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublereal maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполляционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}

								}
						}

					}
				}
				else {

					// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
					// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
					// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
					// bmodify_interpol4_amg = false;
					// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
					bool bmodify_interpol4_amg = false;
					// 01.04.2017 
					// bmodify_interpol4_amg = true совершенно не проработана
					// и её нельзя использовать.

					doublereal magic2 = 0.5;
					//magic2 = magic83;

					// Подготовительный этап к усилению четвертой интерполяции 
					// Усиление интерполяции происходит без добавления новых С узлов.
					// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
					// имеется конечно.
					// Подготовительный этап заключается в определении положения is0_candidate самой сильной
					// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
					doublereal sum1 = 0.0;
					integer is0_candidate = -1;
					if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
										if (fabs(Amat[is0].aij) > sum1) {
											sum1 = fabs(Amat[is0].aij);
											is0_candidate = is0;
										}
									}
								}
							}
						}

						if (sum1 / sumP < magic2) {
							// Если найденный элемент слишком слабый ничего не делаем с этим С,
							// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
							sum1 = 0.0;
							is0_candidate = -1;

							// Тогда ищем среди Weakly F узлов кандидата.
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if (fabs(Amat[is0].aij) <= maxelem_threshold_theta) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							// такой узел F должен стать новым С узлом.
							if (sum1 / sumP >= magic2) {
								this_is_F_node[i8] = false; // Этот узел  станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								byes_add = true;
								iadditionalCstatistic++;

							}
							// Обязательный сброс перед рестартом чтобы не было деления на ноль.
							sum1 = 0.0;
							is0_candidate = -1;

						}
					}


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {



								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
									// Мы усиливаем силу интерполяции без добавления новых узлов за
									// счёт одной дополнительной самой сильной Weakly C связи.
									// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

									ioneStrongC_and_0_StrongF++;
									if (is0_candidate != -1) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0_candidate].j];
										P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (fabs(Amat[is0].aij) > maxelem_threshold_theta) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}
								}
								else {

									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Интерполляция только по ближайшим С узлам.

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP =%e\n", sumP);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP_pos) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP_pos =%e\n", sumP_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = -fabs(Amat[is0].aij) / sumP_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}

							}
						}
					}
				}

			}
		}
		////

	}

#if doubleintprecision == 1
	//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
	//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif

	//system("pause");
	
} // my_interpolation_procedure_number1

  // Интерполяционная процедура №0.
void my_interpolation_procedure_number0(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublereal &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublereal &magic82, doublereal* &threshold_quick_all,
	doublereal* &threshold_quick_only_negative)
{

	// 6 december 2016.
	// Подлежит удалению Refactoring.
	integer itypemodifyinterpol = 0; // номер модификации интерполляции. // Подлежит удалению Refactoring.
	integer inumberadaptpass = 0; // максимальное количество сканов-проходов с модификациями. // Подлежит удалению Refactoring.


	// 1.04.2017; 28.04.2017;
	// Главная идея в том чтобы разделить интерполяцию по знакам, отдельно положительные коэффициенты и отдельно положительные,
	// в итоге учитывается и то и то.


	//theta = 0.24;
	// theta_strong_F iter_number time,s
	// 0.21 56 22.63
	// 0.22 55 21.769
	// 0.23 52 21.488
	// 0.24 52 21.741 == theta // optimum
	// 0.26 69 24.623

	// PIONER RS2
	// theta_interpol magic iter_number residual #levels
	// 0.24 0.24  0.4 21 1.850831e7 13
	// 0.24 0.23 0.4 21 1.661238e+07 14 
	// 0.24 0.22 0.4 21 1.268147e+07 14 optimum
	// 0.24 0.21 0.4 20 1.086504e+07 14
	// 0.24 0.2 0.4 21 2.116516e+07 14
	// 0.25 0.2 0.4 21 1.756896e+07 13
	// 0.25 0.2 0.4 21 1.631888e+07 10 RS1
	// 0.25 0.2 0.4 21 1.928085e+07 11 RS1
	// 0.25 0.2 0.35 21 1.426122e+07 11 RS1
	// 0.25 0.2 0.35 21 1.342786e+07 10 RS1 0.5pos con
	// 0.25 0.2 0.4 21 1.148286e+07 11 RS1 0.5pos con
	// 0.25 0.22 0.4 22 1.430474e+07 11 RS1 0.5pos con
	// 0.25 0.25 0.4


	doublereal theta_strong_C = 0.23;
	doublereal theta_strong_F = 0.23; // оптимальный выбор.
	theta_strong_F = theta83; // 3 июля 2016
	theta_strong_C = theta83;
	//theta_strong_F = 0.22; // 29 апреля 2017
	//theta_strong_C = 0.22;
	// четвёртая версия интерполяции.
	integer ioneStrongC_and_0_StrongF = 0;

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	//6interpolation 0.4 6.77 11 26 28.355
	//6interpolation 0.45 6.6 10 27 28.151
	//6interpolation 0.5 6.42 12 32 28.735
	//4interpolation 0.4 3.7  52 24.736 // best
	//4interpolation 0.3 3.78 13 59 27.525
	//4interpolation 0.5 3.61 12 55 25.533
	//4interpolation 0.45 3.65 10 63 30.24

	// the begining

	bool byes_add = false;
	// Быстрое добавление недостающих С узлов.
	if (1) {
		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublerealT magic = 0.4; // 0.4 optimum


		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		integer i8_candidate_count = 0;
		integer* i8_candidate_arr = NULL;
		i8_candidate_arr = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		char c1[26] = "classic_aglomerative_amg4";
		char c2[17] = "i8_candidate_arr";
		char c3[21] = "i8_candidate_val_arr";
		handle_error<integer>(i8_candidate_arr, c2,  c1, (n_a[ilevel - 1] + 1));
		doublereal* i8_candidate_val_arr = NULL;
		i8_candidate_val_arr = (doublereal*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublereal));
		handle_error<doublereal>(i8_candidate_val_arr, c3,  c1, (n_a[ilevel - 1] + 1));

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

#if doubleintprecision == 1
			//printf("i8=%lld n=%lld\n", i8, n_a[ilevel - 1]);
#else
			//printf("i8=%d n=%d\n", i8, n_a[ilevel - 1]);
#endif

			//getchar();


			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold_plus = -1.0;
			doublereal maxelem_threshold_minus = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
			for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if ((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_plus)) {
						maxelem_threshold_plus = fabs(Amat[is0].aij);
					}
					if ((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_minus)) {
						maxelem_threshold_minus = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsos_pos = 0;
			integer icsosF = 0;
			integer icsosF_pos = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal sumP_pos = 0.0;
			doublereal SumPall = 0.0;
			doublereal SumPall_pos = 0.0;
			integer icount_StronglyF = 0;
			integer icount_StronglyF_pos = 0;

			doublereal maxelem_threshold_theta_plus = maxelem_threshold_plus*theta_strong_C;
			doublereal maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*theta_strong_F;
			// сомнительно.
			//doublerealT maxelem_threshold_theta_plus = maxelem_threshold_plus*0.5;
			//doublerealT maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*0.5;
			doublereal maxelem_threshold_theta_minus = maxelem_threshold_minus*theta_strong_C;
			doublereal maxelem_threshold_theta_strong_F_minus = maxelem_threshold_minus*theta_strong_F;
			for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_minus)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_plus)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			{

				if ((icsos == 1) && (icsosF == 0)) {



					// Накапливаем информацию.
					if (itypemodifyinterpol > 0) {



						if (itypemodifyinterpol > 1) {
							// запоминаем позицию кандидата на С узел.
							i8_candidate_arr[i8_candidate_count] = i8;
							// Запоминаем силу внедиагональной связи, 
							// чтобы потом выбрать наиболее сильную.
							i8_candidate_val_arr[i8_candidate_count] = sumP;
							i8_candidate_count++;
						}

						if (itypemodifyinterpol == 1) {
							// Добавляем только в том случае если количество проходов меньше максмального.
							if (ifrom_re_operation_protection < inumberadaptpass) {
								// 3 december 2016 rundom
								// не более сотни случайных добавлений на каждом уровне.
								integer id_size_873 = (integer)(n_a[ilevel - 1] / 100);
								integer id_873 = rand() % id_size_873 + 1;
								if (id_873 == 1) {
									// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
									// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
									// модификация 2 декабря 2016 года.
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
								}
							}
						}
					}
				}
				else if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					//SumPall += sumP;

					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							if (((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) || (((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)))) {
								if (this_is_C_node[Amat[is0].j] == true) {

									// 20 января 2016.
									// По-моему этой ситуации вообще быть не может так как у нас 
									// заведомо один С сосед.
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true; // Были добавления узлов.
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
									}


								}

							}
						}
					}
				}
				else {

					integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
						if (this_is_C_node[Amat[is0].j] == true) {
							if (Amat[is0].j != Amat[ii1].i) {


								// 20 jan 2016.
								// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


								if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
									// Это случай когда вообще нет сильных С соседей.


									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all sosed is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
									byes_add = true; // Были добавления узлов.
													 //exit(1);
													 // здесь нужна непрямая интерполляция.
								}


							}
						}
					}
				}

			}

		}
		/////
		if (itypemodifyinterpol > 0) {


			if (i8_candidate_arr != NULL) {
				i8_candidate_arr = (integer*)realloc(i8_candidate_arr, (i8_candidate_count + 2) * sizeof(integer));
			}
			if (i8_candidate_val_arr != NULL) {
				i8_candidate_val_arr = (doublereal*)realloc(i8_candidate_val_arr, (i8_candidate_count + 2) * sizeof(doublereal));
			}


			// Выбираем integer i_gold_i8 наиболее сильных.
			integer i_gold_i8 = i_my_min(i8_candidate_count/20, 100);// 100
			if (i8_candidate_count < 100) {
				i_gold_i8 = i8_candidate_count - 3;
			}
			if (1 && from_re_operation_protection0) {
				// Сортировка по возрастанию.
				// Сортировка Быстрая Ч. Хоара заимствована из модуля my_nested_dissection.cpp
				QuickSortnd(i8_candidate_arr, i8_candidate_val_arr, 0, i8_candidate_count - 1);

				if (itypemodifyinterpol == 2) {
					// minimum
					//for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
					for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}
				if (itypemodifyinterpol == 3) {
					// maximum
					for (integer i_9 = i8_candidate_count - 1; i_9 >= i8_candidate_count - 1 - i_gold_i8; i_9--) {
						//for (integer i_9 = 0; i_9 < i_gold_i8; i_9++) {
						// В случае лишь одного сильного С соседа и отсутствия сильных F соседей
						// такой узел становится С узлом. Т.е. в безнадежном слуае узел становится С узлом.
						// модификация 2 декабря 2016 года.
						this_is_F_node[i8_candidate_arr[i_9]] = false; // Этот узел Дирихле станет С нодом.
						this_is_C_node[i8_candidate_arr[i_9]] = true;
						bweSholdbeContinue = true;
						iadditionalCstatistic++;
						byes_add = true; // Были добавления узлов.
					}
				}

			}

			ifrom_re_operation_protection++;
			if (ifrom_re_operation_protection > inumberadaptpass) {
				from_re_operation_protection0 = false;
			}


		}

		if (i8_candidate_arr != NULL) {
			free(i8_candidate_arr);
			i8_candidate_arr = NULL;
		}
		if (i8_candidate_val_arr != NULL) {
			free(i8_candidate_val_arr);
			i8_candidate_val_arr = NULL;
		}



	}



	if (!byes_add) {

		// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
		//doublereal magic = 0.4; // 0.4 optimum
								 //magic = 0.3; // 3 июля 2016 для конвективных задач
								 // линейный прогноз не дает улучшений
								 // ни по быстрдействию ни по числу V циклов.
								 //magic = 0.5 - 0.2*ilevel / 12.0;
		const doublereal magic = magic82; // 0.4 is recomended.
		//magic = 0.35;



		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;



		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold_plus = -1.0;
			doublereal maxelem_threshold_minus = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			integer istr_etalon1 = Amat[ii1].i;
			integer iend_for1 = -1;
			for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
				iend_for1 = is0;
				if (Amat[is0].j != istr_etalon1) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if ((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_plus)) {
						maxelem_threshold_plus = fabs(Amat[is0].aij);
					}
					if ((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_minus)) {
						maxelem_threshold_minus = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;
			integer icsos_pos = 0;
			integer icsosF_pos = 0;

			doublereal maxelem_threshold_theta_plus = maxelem_threshold_plus*theta_strong_C;
			doublereal maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*theta_strong_F;
			//doublereal maxelem_threshold_theta_plus = maxelem_threshold_plus*0.5;
			//doublereal maxelem_threshold_theta_strong_F_plus = maxelem_threshold_plus*0.5;
			doublereal maxelem_threshold_theta_minus = maxelem_threshold_minus*theta_strong_C;
			doublereal maxelem_threshold_theta_strong_F_minus = maxelem_threshold_minus*theta_strong_F;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal SumPall = 0.0;
			integer icount_StronglyF = 0;
			doublereal sumP_pos = 0.0;
			doublereal SumPall_pos = 0.0;
			integer icount_StronglyF_pos = 0;

			//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
			for (integer is0 = ii1; is0 <= iend_for1; is0++) {
				if (Amat[is0].j != istr_etalon1) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
						if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
							sumP_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos_pos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_minus)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
							if ((Amat[is0].aij > 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_plus)) {
								SumPall_pos += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF_pos++;
								icsosF_pos++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
					// так лучше всего.
					//if ((((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0))||(((icsos_pos == 1) || (icsos_pos == 2) || (icsos_pos == 3)) && (icsosF_pos != 0))) {
					//	if (((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) {
					//if ((((icsos == 1) || (icsos == 2) || (icsos == 3) || (icsos >= 4)) && (icsosF != 0)) || (((icsos_pos == 1) || (icsos_pos == 2) || (icsos_pos == 3) || (icsos_pos >= 4)) && (icsosF_pos != 0))) {

					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;
					SumPall_pos += sumP_pos;


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.


							if (this_is_C_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (((Amat[is0].aij<0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) || ((Amat[is0].aij>0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus))) {
									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}
										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall_pos) < 1.0e-33) {
												printf("error 1.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											// Внимание !!! именно минус.
											P[icount1].aij = -fabs(Amat[is0].aij) / SumPall_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}


									}
								}

							}
							else
								if (this_is_F_node[Amat[is0].j] == true) {
									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_minus)) {
										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublereal maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j] == true) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublereal maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполляционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}
									// todo
									if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_plus)) {
										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall_pos) < 1.0e-33) {
											printf("error 2.0 ! division by zero. SumPall_pos =%e\n", SumPall_pos);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										// Внимание минус.
										doublereal multiplyer_nu = -fabs(Amat[is0].aij) / SumPall_pos;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										integer istr_etalon = Amat[ii1_loc].i;
										integer iend_for = -1;
										integer iend_marker_position = row_startA[istr_etalon + 1] - 1;
										for (integer is0_loc = ii1_loc; (is0_loc <= iend_marker_position); is0_loc++) {
											iend_for = is0_loc;
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}

										doublereal maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// Будем отсекать сразу наибольшее число вариантов.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {






												if (this_is_C_node[Amat[is0_loc].j] == true) {

													if (Amat[is0_loc].j != istr_etalon) {

														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}

												}
												else {

													//if (Amat[is0_loc].j != istr_etalon) {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													//}
												}

											}
										}

										doublereal maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

										// В общем это двойная интерполляционная сумма 
										//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {

											// При многоуровневом сравнении в первую очередь надо отсекать наибольшее число вариантов.


											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
											//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
											if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
												//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {

												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (Amat[is0_loc].j != istr_etalon) {

														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-33) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}

													}
												}
											}
										}


										//}
									}

								}
						}

					}
				}
				else {

					// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
					// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
					// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
					// bmodify_interpol4_amg = false;
					// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
					bool bmodify_interpol4_amg = false;
					// 01.04.2017 
					// bmodify_interpol4_amg = true совершенно не проработана
					// и её нельзя использовать.

					doublereal magic2 = 0.5;
					//magic2 = magic83;

					// Подготовительный этап к усилению четвертой интерполяции 
					// Усиление интерполяции происходит без добавления новых С узлов.
					// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
					// имеется конечно.
					// Подготовительный этап заключается в определении положения is0_candidate самой сильной
					// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
					doublereal sum1 = 0.0;
					integer is0_candidate = -1;
					if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) <= maxelem_threshold_theta_minus)) {
										if (fabs(Amat[is0].aij) > sum1) {
											sum1 = fabs(Amat[is0].aij);
											is0_candidate = is0;
										}
									}
								}
							}
						}

						if (sum1 / sumP < magic2) {
							// Если найденный элемент слишком слабый ничего не делаем с этим С,
							// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
							sum1 = 0.0;
							is0_candidate = -1;

							// Тогда ищем среди Weakly F узлов кандидата.
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j] == true) {
										//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) <= maxelem_threshold_theta_minus)) {
											if (fabs(Amat[is0].aij) > sum1) {
												sum1 = fabs(Amat[is0].aij);
												is0_candidate = is0;
											}
										}
									}
								}
							}

							// такой узел F должен стать новым С узлом.
							if (sum1 / sumP >= magic2) {
								this_is_F_node[i8] = false; // Этот узел  станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								byes_add = true;
								iadditionalCstatistic++;

							}
							// Обязательный сброс перед рестартом чтобы не было деления на ноль.
							sum1 = 0.0;
							is0_candidate = -1;

						}
					}


					for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {



								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
									// Мы усиливаем силу интерполяции без добавления новых узлов за
									// счёт одной дополнительной самой сильной Weakly C связи.
									// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

									ioneStrongC_and_0_StrongF++;
									if (is0_candidate != -1) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0_candidate].j];
										P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

									//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}
								}
								else {

									if ((fabs(sumP) < RealZERO) && (fabs(sumP_pos) < RealZERO)) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Интерполляция только по ближайшим С узлам.

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_minus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP =%e\n", sumP);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_plus)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											if (fabs(sumP_pos) < 1.0e-33) {
												printf("error 4.0 ! division by zero. sumP_pos =%e\n", sumP_pos);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = -fabs(Amat[is0].aij) / sumP_pos;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}

							}
						}
					}
				}

			}
		}
		////

	}

#if doubleintprecision == 1
	//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
	//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif

	//system("pause");


} // my_interpolation_procedure_number0


  // Интерполяционная процедура №4.
void my_interpolation_procedure_number4(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublereal &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublereal &magic82, doublereal* &threshold_quick_all,
	doublereal* &threshold_quick_only_negative)
{
	// пятая попытка.
	// показывает время 1.22 против времени в 1.36 в четвертой попытке.

	// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
	// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
	// сильных F узлов.

	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

	if (bpositive_connections) {

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {



			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										if (this_is_C_node[i8] == false) iadditionalCstatistic++;
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-23) {
												printf("error 1.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 2.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j] == true) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 3.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							if (this_is_C_node[Amat[is0].j] == true) {

								if (fabs(sumP) < RealZERO) {
									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all sosed is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									if (this_is_C_node[i8] == false) iadditionalCstatistic++;
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									//exit(1);
									// здесь нужна непрямая интерполляция.
								}
								else {

									// Внедиагональный элемент из множества С узлов.

									// Данная вставка должна существенно сохранять 
									// разреженность оператора Галёркина на глубоких 
									// сеточных уровнях.
									// Модификация 5 декабря 2015.
									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 4.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
										//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

								}

							}
							else
								if (this_is_F_node[Amat[is0].j] == true) {

									// Рассматриваем Strong F связи.
									// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
									// Смысл :
									//



									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									// Это лишнее условие, ранее уже было проверено что мы имеем дело
									// с сильной F связью.
									if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 5.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpoint
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j] == true) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
												}
											}
										}

										// В общем это двойная интерполляционная сумма
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять
													// разреженность оператора Галёркина на глубоких
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 6.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
								}


						}
					}
				}

			}

		}
		//// positive connections
	}
	else {
		// only negative connections


		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;
			integer icsosF = 0;

			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			doublereal SumPall = 0.0;
			integer icount_StronglyF = 0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					if (this_is_C_node[Amat[is0].j] == true) {
						//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
							icsos++;
						}
					}
					else {
						if (this_is_F_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
								icount_StronglyF++;
								icsosF++;
							}
						}
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) {
				number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																	   // Следующий случай назван "безнадёжным".
																	   // Безнадёжный случай оставляется без изменений.
																	   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																	   // интерполляцию на этих уровнях можно улучшить.
				if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
			}



			// 1 января 2016 Один сосед это недостаточно.
			// Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {

				if ((icsos == 1) && (icsosF != 0)) {
					// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
					//
					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Нас интересуют только Strong связи.
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										if (this_is_C_node[i8] == false) iadditionalCstatistic++;
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {
										// Это как раз единственная Strong C связь. 
										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											if (fabs(SumPall) < 1.0e-23) {
												printf("error 7.0 ! division by zero. SumPall =%e\n", SumPall);
												//getchar();
												system("PAUSE");
												exit(1);
											}
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Рассматриваем Strong F связи.

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

										integer iFpoint = Amat[is0].j;
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 8.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpointeger 
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j] == true) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
												}
											}
										}

										// В общем это двойная интерполляционная сумма 
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 9.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
							}
						}
					}
				}
				else {

					SumPall += sumP;

					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							if (this_is_C_node[Amat[is0].j] == true) {

								if (fabs(sumP) < RealZERO) {
									//printf("error interpolation zero diagonal sumP.\n");
									//printf("Fnode all sosed is F");
									//system("pause");
									//printf("i8 is Dirichlet node\n");
									if (this_is_C_node[i8] == false) iadditionalCstatistic++;
									this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									//exit(1);
									// здесь нужна непрямая интерполляция.
								}
								else {

									// Внедиагональный элемент из множества С узлов.

									// Данная вставка должна существенно сохранять 
									// разреженность оператора Галёркина на глубоких 
									// сеточных уровнях.
									// Модификация 5 декабря 2015.
									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										if (fabs(SumPall) < 1.0e-23) {
											printf("error 10.0 ! division by zero. SumPall =%e\n", SumPall);
											//getchar();
											system("PAUSE");
											exit(1);
										}
										P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
										//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P);
										}
									}

								}

							}
							else
								if (this_is_F_node[Amat[is0].j] == true) {

									// Рассматриваем Strong F связи.
									// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
									// Смысл :
									//



									//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									// Это лишнее условие, ранее уже было проверено что мы имеем дело
									// с сильной F связью.
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

										integer iFpoint = Amat[is0].j;
										doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
										// сканируем всех соседей iFpoint
										// чтобы найти среди них С узлы.

										// Идентифицируем локальный порог.
										doublereal maxelem_threshold_loc = -1.0;
										//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
										integer ii1_loc = row_startA[iFpoint];
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
														maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
													}
												}
											}
										}


										// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

										// Найти соседей данного F-node которые C-node.
										integer icsos_loc = 0;

										// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
										// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
										doublereal sumP_loc = 0.0;
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {




												if (this_is_C_node[Amat[is0_loc].j] == true) {
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
														icsos_loc++;
													}
												}
												else {
													// Подсчитываем количество соседей которые не являются С узлами.
													//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
												}
											}
										}

										// В общем это двойная интерполляционная сумма
										for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
											if (Amat[is0_loc].j != Amat[ii1_loc].i) {
												if (this_is_C_node[Amat[is0_loc].j] == true) {
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять
													// разреженность оператора Галёркина на глубоких
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
													if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0_loc].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														if (fabs(sumP_loc) < 1.0e-23) {
															printf("error 11.0 ! division by zero. sumP_loc =%e\n", sumP_loc);
															//getchar();
															system("PAUSE");
															exit(1);
														}
														P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P);
														}
													}
												}
											}
										}


										//}
									}
								}


						}
					}
				}

			}

		}

	} // end only negative connections

} // my_interpolation_procedure_number4

  // Интерполяционная процедура №5.
void my_interpolation_procedure_number5(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublereal &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublereal &magic82, doublereal* &threshold_quick_all,
	doublereal* &threshold_quick_only_negative)
{
	bool byes_add = false;
	//  быстрая проверка на добавление.
	if (1) {
		// шестая попытка.
		// CGHV1J amg1r5 time 0.26
		// cl_agl_amg_v0_14 time :
		// magic  time number V cycles grid complexity
		// 0.25   0:48  29  6.55A
		// 0.3    0:45  28  6.19A 
		// 0.35  0:43   28  5.98A
		// 0.4   0:41   27  5.77A // отыграно 14% производительности.
		// tgf2023_10 amg1r5 time 1:00
		// cl_agl_amg_v0_14 time
		// magic  time number V cycles grid complexity
		// 0.25 1:49 27 3.61
		// 0.3 1:47 26 3.47
		// 0.35 1:46 27 3.51
		// 0.4 1:44 28 3.413 // отыграно 5% производительности.
		// Electric potencial in FET2 amg1r5 time 1:38
		// cl_agl_amg_v0_14 time :
		// magic  time number V cycles grid complexity
		// 0.25 3:19 36 6.65
		// 0.3 3:02 34 6.34
		// 0.35 2:52 33 6.091
		// 0.4 2:46 33 5.91 // отыграно 20% производительности.

		// magic=0.4 is optimum.11 jan 2016
		doublereal magic = 0.4; // 0.4

								 // Здесь узел F не имеющий Strong С соседей сам становится С узлом.
								 // Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
								 // сильных F узлов.

		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {

			// positive connections:

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j] == true) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (this_is_C_node[Amat[is0].j] == true) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}


									}

								}
							}
						}
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}


								}



							}
						}



					}

				}

			}

			/////
		}
		else {
			// only negative connections:

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j] == true) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				{

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									if (this_is_C_node[Amat[is0].j] == true) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											byes_add = true;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}


									}

								}
							}
						}
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										byes_add = true;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}


								}



							}
						}



					}

				}

			}


		} // end only negative connecions.
	}


	// Проверка на добавление пройдена успешно, 
	// добавлений не было и можно интерполировать !!!.
	if (byes_add == false) {

		// шестая попытка.
		// CGHV1J amg1r5 time 0.26
		// cl_agl_amg_v0_14 time :
		// magic  time number V cycles grid complexity
		// 0.25   0:48  29  6.55A
		// 0.3    0:45  28  6.19A 
		// 0.35  0:43   28  5.98A
		// 0.4   0:41   27  5.77A // отыграно 14% производительности.
		// tgf2023_10 amg1r5 time 1:00
		// cl_agl_amg_v0_14 time
		// magic  time number V cycles grid complexity
		// 0.25 1:49 27 3.61
		// 0.3 1:47 26 3.47
		// 0.35 1:46 27 3.51
		// 0.4 1:44 28 3.413 // отыграно 5% производительности.
		// Electric potencial in FET2 amg1r5 time 1:38
		// cl_agl_amg_v0_14 time :
		// magic  time number V cycles grid complexity
		// 0.25 3:19 36 6.65
		// 0.3 3:02 34 6.34
		// 0.35 2:52 33 6.091
		// 0.4 2:46 33 5.91 // отыграно 20% производительности.

		// magic=0.4 is optimum.11 jan 2016
		doublereal magic = 0.4; // 0.4

								 // Здесь узел F не имеющий Strong С соседей сам становится С узлом.
								 // Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
								 // сильных F узлов.

		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

		if (bpositive_connections) {

			// positive connections :

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j] == true) {
						if (fabs(Amat[is0].aij) > maxelem_threshold) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным  C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					//if ((icsos == 1) && (icsosF != 0)) {
					// 28.01.2017
					if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									if (this_is_C_node[Amat[is0].j] == true) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}
									else
										if (this_is_F_node[Amat[is0].j] == true) {

											// Рассматриваем Strong F связи.

											// Смысл :
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublereal maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполляционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}
														}
													}
												}
											}


											//}
										}
								}
							}
						}
					}
					else {

						SumPall += sumP;
						doublereal sum_ok = 0.0;
						bool bbackreturn = false;
						integer icount1_mem = icount1;
						bool* bbackrarr = NULL;
						//bbackrarr = new bool[icount_StronglyF];
						bbackrarr = (bool*)malloc(icount_StronglyF * sizeof(bool));
						char c1[27] = "classic_aglomerative_amg_4";
						char c2[10] = "bbackrarr";
						handle_error<bool>(bbackrarr, c2,  c1, icount_StronglyF);

						for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
							bbackrarr[i_63] = false;
						}
						integer icounter_bbackarr = -1;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											P[icount1].aij = fabs(Amat[is0].aij);
											sum_ok += fabs(Amat[is0].aij);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Рассматриваем Strong F связи.
										// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
										// Смысл :
										//



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											icounter_bbackarr++;

											integer iFpoint = Amat[is0].j;
											//doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											doublereal mult1 = fabs(Amat[is0].aij);
											// сканируем всех соседей iFpoint
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublereal maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											icsos_loc = 0;
											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc1 = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
															//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
															sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
															//	}
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											if (icsos_loc > 0) {
												// В общем это двойная интерполляционная сумма
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять
															// разреженность оператора Галёркина на глубоких
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																P[icount1].j = i8;
																P[icount1].i = C_numerate[Amat[is0_loc].j];
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P);
																}
															}
															//}
														}
													}
												}
											}
											else {
												//bbackreturn = true;
												bbackrarr[icounter_bbackarr] = true;
											}


											//}
										}
									}


							}
						}


						//bbackreturn = true;
						//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
						//if (!bbackrarr[i_63]) {
						//	bbackreturn = false;
						//}
						//}

						//if (bbackreturn) {
						// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
						// варианту интерполяции.
						//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
						//P[i_95].aij = P[i_95].aij*SumPall / sumP;
						//}
						//}

						// Апосториорная корекция
						for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
							P[i_95].aij = P[i_95].aij / sum_ok;
						}

						free(bbackrarr);

					}

				}

			}

			////
		}
		else {
			// only negative connections

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

				// Нам нужен разреженный оператор Галёркина.
				// 5 декабря 2015 года мы попробуем увеличить разреженность
				// оператора интерполляции а значит и оператора Галёркина.
				doublereal maxelem_threshold = -1.0;
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				integer ii1 = row_startA[i8];
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
						//if (this_is_C_node[Amat[is0].j] == true) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
							maxelem_threshold = fabs(Amat[is0].aij);
						}
						//}
					}
				}
				// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				integer icsosF = 0;

				// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
				// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
				doublereal sumP = 0.0;
				doublereal SumPall = 0.0;
				integer icount_StronglyF = 0;
				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {
							//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
								icsos++;
							}
						}
						else {
							if (this_is_F_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
									icount_StronglyF++;
									icsosF++;
								}
							}
							// Подсчитываем количество соседей которые не являются С узлами.
							the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
						}
					}
				}
				if (icsos == 1) {
					number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.
																		   // Следующий случай назван "безнадёжным".
																		   // Безнадёжный случай оставляется без изменений.
																		   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
																		   // интерполляцию на этих уровнях можно улучшить.
					if (icsosF == 0) number_of_F_nodes_with_one_single_strong_C_neighborF++; // Количество F узлов с одним единственным сильным C соседом и к тому-же не имеющих сильных F соседов.
				}



				// 1 января 2016 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					this_is_F_node[i8] = false;
					this_is_C_node[i8] = true;
					bweSholdbeContinue = true;
				}
				else {

					if ((icsos == 1) && (icsosF != 0)) {
						// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
						//
						SumPall += sumP;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Нас интересуют только Strong связи.
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									if (this_is_C_node[Amat[is0].j] == true) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//	printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {
											// Это как раз единственная Strong C связь. 
											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}

										}

									}
									else
										if (this_is_F_node[Amat[is0].j] == true) {

											// Рассматриваем Strong F связи.

											// Смысл :
											// 



											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											// Это лишнее условие, ранее уже было проверено что мы имеем дело
											// с сильной F связью.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

											integer iFpoint = Amat[is0].j;
											doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublereal maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполляционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P);
															}
														}
													}
												}
											}


											//}
										}
								}
							}
						}
					}
					else {

						SumPall += sumP;
						doublereal sum_ok = 0.0;
						bool bbackreturn = false;
						integer icount1_mem = icount1;
						bool* bbackrarr = NULL;
						//bbackrarr = new bool[icount_StronglyF];
						bbackrarr = (bool*)malloc(icount_StronglyF * sizeof(bool));
						char c1[27] = "classic_aglomerative_amg_4";
						char c2[10] = "bbackrarr";
						handle_error<bool>(bbackrarr,c2 ,  c1, icount_StronglyF);

						for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
							bbackrarr[i_63] = false;
						}
						integer icounter_bbackarr = -1;

						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {

								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											P[icount1].aij = fabs(Amat[is0].aij);
											sum_ok += fabs(Amat[is0].aij);
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Рассматриваем Strong F связи.
										// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
										// Смысл :
										//



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										// Это лишнее условие, ранее уже было проверено что мы имеем дело
										// с сильной F связью.
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

											icounter_bbackarr++;

											integer iFpoint = Amat[is0].j;
											//doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											doublereal mult1 = fabs(Amat[is0].aij);
											// сканируем всех соседей iFpoint
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublereal maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											icsos_loc = 0;
											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublereal sumP_loc1 = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
														if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
															//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
															sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
															//	}
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции
													}
												}
											}

											if (icsos_loc > 0) {
												// В общем это двойная интерполляционная сумма
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять
															// разреженность оператора Галёркина на глубоких
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
															if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																P[icount1].j = i8;
																P[icount1].i = C_numerate[Amat[is0_loc].j];
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P);
																}
															}
															//}
														}
													}
												}
											}
											else {
												//bbackreturn = true;
												bbackrarr[icounter_bbackarr] = true;
											}


											//}
										}
									}


							}
						}


						//bbackreturn = true;
						//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
						//if (!bbackrarr[i_63]) {
						//	bbackreturn = false;
						//}
						//}

						//if (bbackreturn) {
						// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
						// варианту интерполяции.
						//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
						//P[i_95].aij = P[i_95].aij*SumPall / sumP;
						//}
						//}

						// Апосториорная корекция
						for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
							P[i_95].aij = P[i_95].aij / sum_ok;
						}

						free(bbackrarr);

					}

				}

			}


		} // end only negative connections 

	}

} // my_interpolation_procedure_number5


  // Интерполяционная процедура №6.
void my_interpolation_procedure_number6(integer &the_number_of_neighbors_that_are_not_C_nodes,
	integer &number_of_F_nodes_with_one_single_strong_C_neighbor,
	integer* &n_a, bool* &this_is_F_node, integer* &row_startA,
	integer* &nnz_a, bool &bpositive_connections, Ak1* &Amat,
	bool &bweSholdbeContinue, bool* &this_is_C_node, integer &iadditionalCstatistic,
	const doublereal RealZERO, integer &icount1, Ak1* &P, integer &nsizePR, integer &ilevel,
	integer &iadd, doublereal &theta, integer &n, Ak1* &R, integer* &C_numerate,
	integer &number_of_F_nodes_with_one_single_strong_C_neighborF,
	doublereal &theta83, bool &btreshold_on_new_vetv, integer& ifrom_re_operation_protection,
	bool &from_re_operation_protection0, doublereal &magic82, doublereal* &threshold_quick_all,
	doublereal* &threshold_quick_only_negative)
{
	// INTERPOLATION SIX

	// Экспериментальная интерполляция 1 января 2016.
	printf("interpolation SIX: experimental version 1 jan 2016\n");
	system("PAUSE");

	the_number_of_neighbors_that_are_not_C_nodes = 0;
	number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

	if (bpositive_connections) {

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if (fabs(Amat[is0].aij) > maxelem_threshold) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;

			doublereal SumPall = 0.0;
			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {

					// Сумма вообще всех внедиагональных элементов.
					//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
						SumPall += fabs(Amat[is0].aij);
					}


					if (this_is_C_node[Amat[is0].j] == true) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
							icsos++;
						}
					}
					else {
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.


																				   // 1 января 2015 Один сосед это недостаточно.
																				   // Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {



				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//	printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполляция.
							}
							else {

								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
									P[icount1].j = i8;
									P[icount1].i = C_numerate[Amat[is0].j];
									//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}

						}
						else
							if (this_is_F_node[Amat[is0].j] == true) {

								// Смысл :
								// 



								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

									integer iFpoint = Amat[is0].j;
									doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublereal maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j] == true) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc) {
													maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
												}
											}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublereal sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j] == true) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}

									// В общем это двойная интерполляционная сумма 
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j] == true) {
												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0_loc].j];
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P);
													}
												}
											}
										}
									}


								}
							}
					}
				}

			}


		}
		////
	}
	else {
		// only negative connections

		// Построение пролонгации для узлов которые составляют F nodes.
		// Каждый F-nodes окружён C-nodes.
		for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

			// Нам нужен разреженный оператор Галёркина.
			// 5 декабря 2015 года мы попробуем увеличить разреженность
			// оператора интерполляции а значит и оператора Галёркина.
			doublereal maxelem_threshold = -1.0;
			//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			integer ii1 = row_startA[i8];
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {
					// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
					//if (this_is_C_node[Amat[is0].j] == true) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
						maxelem_threshold = fabs(Amat[is0].aij);
					}
					//}
				}
			}
			// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

			// Найти соседей данного F-node которые C-node.
			integer icsos = 0;

			doublereal SumPall = 0.0;
			// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
			// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
			doublereal sumP = 0.0;
			for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				if (Amat[is0].j != Amat[ii1].i) {

					// Сумма вообще всех внедиагональных элементов.
					//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
					if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
						SumPall += fabs(Amat[is0].aij);
					}


					if (this_is_C_node[Amat[is0].j] == true) {
						//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
						if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
							sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
							icsos++;
						}
					}
					else {
						// Подсчитываем количество соседей которые не являются С узлами.
						the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					}
				}
			}
			if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.


																				   // 1 января 2015 Один сосед это недостаточно.
																				   // Поэтому в случае одного соседа делаем такой узел С узлом.
			if ((false) && (icsos == 1)) {
				this_is_F_node[i8] = false;
				this_is_C_node[i8] = true;
				bweSholdbeContinue = true;
			}
			else {



				for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					if (Amat[is0].j != Amat[ii1].i) {
						if (this_is_C_node[Amat[is0].j] == true) {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//	printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполляция.
							}
							else {

								// Внедиагональный элемент из множества С узлов.

								// Данная вставка должна существенно сохранять 
								// разреженность оператора Галёркина на глубоких 
								// сеточных уровнях.
								// Модификация 5 декабря 2015.
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									P[icount1].j = i8;
									P[icount1].i = C_numerate[Amat[is0].j];
									//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
									P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
									icount1++;
									if (icount1 >= nsizePR*n) {
										printf("memory error!!!\n");
										printf("not enough memory for the interpolation operator.\n");
										//system("PAUSE");
										//exit(1);
										deallocate_prolongation(nsizePR, n, R, P);
									}
								}

							}

						}
						else
							if (this_is_F_node[Amat[is0].j] == true) {

								// Смысл :
								// 



								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

									integer iFpoint = Amat[is0].j;
									doublereal multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
									// сканируем всех соседей iFpointeger 
									// чтобы найти среди них С узлы.

									// Идентифицируем локальный порог.
									doublereal maxelem_threshold_loc = -1.0;
									//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
									integer ii1_loc = row_startA[iFpoint];
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j] == true) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
													maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
												}
											}
										}
									}


									// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

									// Найти соседей данного F-node которые C-node.
									integer icsos_loc = 0;

									// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
									// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
									doublereal sumP_loc = 0.0;
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {




											if (this_is_C_node[Amat[is0_loc].j] == true) {
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
													icsos_loc++;
												}
											}
											else {
												// Подсчитываем количество соседей которые не являются С узлами.
												//the_number_of_neighbors_that_are_not_C_nodes_loc++; // подсчитываем проблемы интерполяции 
											}
										}
									}

									// В общем это двойная интерполляционная сумма 
									for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
										if (Amat[is0_loc].j != Amat[ii1_loc].i) {
											if (this_is_C_node[Amat[is0_loc].j] == true) {
												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
												if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0_loc].j];
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P);
													}
												}
											}
										}
									}


								}
							}
					}
				}

			}


		}

	} // end only negative connections

	 
} // my_interpolation_procedure_number6

#include "classic_aglomerative_amg6_2018year.cpp" // amg6 версия кода 2018 года.

// 25.04.2018 Версия четыре classic_aglomerative_amg4 это основная поддерживаемая версия.
// Пятая версия classic_aglomerative_amg5 давно не поддерживается (заморожена).
// июнь 2017 - добавлен Рунге-Кутта smoother, улучшена поддержка ilu0 разложения в алгоритме. 
// июнь 2017 - Поддерживается максимальное количество уровней вложенности 100 и менее. 
// зимние каникулы 2016-2017 года - добавлен bicgStab.
// Лето 2017 - алгебраический многосеточный метод теперь всё чаще и чаще используется как
// предобуславливатель
// к алгоритму Хенка ван дер Ворста BiCGStab. Эта связка показывает более стабильную и
// надежную работу чем просто отдельно amg.
// 4-6 ноября 2016. Добавлен ILU0. Полностью удалён устаревший код из Solution Phase.
// 9 августа 2016. Зейдель не справляется с большими спектральными радиусами матриц даже 
// в составе данного amg,
// это же проявляется и на классическом amg1r5. 9 августа решено уменьшить спектральный 
// радиус в Зейделе 
// на каждом уровне вложенности с помощью ILU2 декомпозиции. Это подтверждает статья 
// Е.М.Андреева, Г.В.Муратова
// "Многосеточный метод решения сильно нессиметричных систем" ЮГИНФО РГУ, Ростов-на-Дону,
// Россия. Там они
// показывают расходимость мультигрида на основе Зейделя для задач с существенным спектральным
/// радиусом и
// рекомендуют заменить Зейделя на ТКМ2 метод (треугольный кососимметричный метод). В данной 
//программе у нас есть 
// успешный опыт использования ILU2 предобуславливателя из библиотеки SPARSKIT2 Ю.Саада 
// поэтому вместо ТКМ2 у нас 
// будет ILU2.
// 22 января текущий работоспособный вариант кода.
// Планы : 1. сделать версию amg3. 
// В ней : 2. заменить все проверки на невыделение оперативной памяти на универсальную 
// функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить
// direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
// 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C-F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C-F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С-F разбиения 
// учитывается уже построеннная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведеия Галёркина получена самая оптимальная по 
// быстродествию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C-F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполляции будут сделаны заново на основе статьи 
// К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
// Возвращает divergence detected.
template <typename doublerealT>
bool classic_aglomerative_amg4(Ak1* &Amat,
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer &nsizePR, // Память под P в количествах n.
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	doublerealT &theta, doublerealT &theta83,
	doublerealT &magic82, doublerealT &magic83,
	doublerealT &ret74,	integer iVar,
	bool bmemory_savings,
	BLOCK* &my_body, integer &lb, integer maxelm_out
) {


	// 0 - используем сбалансированное дерево поиска.
	// 1 - используем хеш таблицу.
	integer btree_vs_hash = 1;
	if (btree_vs_hash == 1) {
		construct_hash_table_Gus_struct01(n);
	}

	// 23.12.2016 ускорение счёта нелинейных задач :
	// лучистые потоки обновляются после каждого V цикла,
	// для этого внутрь передаётся 
	// b и lb.

	integer iaddFCcolor = 0;
	integer nsize;
	integer istart4;
	integer iend4;
	integer* row_ind_PE = NULL;
	integer* row_ind_PS = NULL;
	integer istart2;
	integer* row_ind_AS = NULL;
	integer* row_ind_AE = NULL;
	integer istartAnew2;
	integer index_size = 0;
	integer* index_visit = NULL;
	doublerealT* vector_sum = NULL;
	integer istartAnew_mem;
	integer istart3;
	integer iend3;
	integer* row_ind_SA = NULL;
	integer* row_ind_EA = NULL;
	integer istart1;
	integer iend1;
	integer* row_ind_ER = NULL;
	integer* row_ind_SR = NULL;
	integer iend_marker_position;
	doublerealT* ap_coarse = NULL;
	integer icounter = 1;
	integer icount1;
	integer numberofcoarcenodes;
	integer* C_numerate = NULL;
	const bool FUTURE_INJECTION = false; // раскоментировать если это будет реализовано.
	Ak1* P_injection = NULL;
	Ak1* R_injection = NULL;
	bool bweSholdbeContinue = true;
	integer the_number_of_neighbors_that_are_not_C_nodes = 0;
	integer number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
	integer number_of_F_nodes_with_one_single_strong_C_neighborF = 0;

	integer iadditionalCstatistic = 0;
	node_AVL_Gus* root_Gus_set = 0;

	integer newCcount = 0;

	bool bAVL = true;
	bool bAVL_deb = false;
	node_AVL* root = 0;
	Tree_splay* root_splay = 0;
	size_splay_Tree = 0;
	TreapNode* random_tree_root = NULL;
	RBtree RBroot; // Корень Красно-Чёрного дерева.

	integer istartflag_scan = 1;
	bool *bmarkervisit = NULL;

	integer n_coarce = 1; // начальный номер C узла.

	const integer NULL_SOSED = -1;
	integer vacant = NULL_SOSED;
	bool bcontinue = true;

	// Построение C-F разбиения.
	//while (icandidate != 0)
	integer icountprohod = 0;

	integer maxsosed = 0;
	integer icandidate = 0;

	integer* row_startA = NULL;
	integer* count_sosed = NULL;

	bool identiti = true;
	

	// Вершина технологии решения плохообусловленных разреженных СЛАУ : BiCGStab + camg(РУМБА).
	// 1. многосеточные технологии.
	// 2. предобуславливание.
	// 3. стабилизация.
	// Если my_amg_manager.istabilization == 1 то мы используем метод бисопряженных градиентов со стабилизацией с предобуславливанием 
	// классическим алгебраическим многосеточным методом РУМБА.
	// Начало реализации 5.01.2017.(more robust).
	// Если my_amg_manager.istabilization == 0 - То просто используется 
	// многосеточный решатель без какого либо метода Крыловского подпространства.
	// Если my_amg_manager.istabilization == 2 - То используется fgmres - 
	// алгоритм Саада и Шульца (гибкий вариант обобщённого метода минимальных невязок) в котором 
	// на каждой итерации алгоритма fgmres делается одно многосеточное предобуславливание (один V цикл). 
	//bool bBiCGStab_plus_RUMBA_camg = true;
	//if (my_amg_manager.istabilization == 0) {
	    // Просто многосеточный метод без какого-либо Крыловского подпространства.
		// none
		//bBiCGStab_plus_RUMBA_camg = false;
	//}


	bfirst_jacoby_start = true;

	bool from_re_operation_protection0 = true;
	integer ifrom_re_operation_protection = 0;

	// Универсальные сглаживающие процедуры. 4 ноября 2016.
	// ILU2 smoother
	// 0 - ILU не используется. используется Gaus-Seidel.
	// 1 - ILU0 используется.
	// 2 - ILU2 используется.
	integer bILU2smoother = 0;
	if (my_amg_manager.ilu2_smoother == 1) {
		// Включаем ILU0 сглаживатель. 
		// он ест больше памяти но более быстро сходится.
		// Есть надежда что он справится с гораздо более плохообусловленными матрицами.

		bILU2smoother = 1; // ILU0

						   // По - видимому алгоритм 
						   // ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
						   // является дефектным. Я не получил с ним сходимости как ни пытался. Зато алгоритм iluk с lfil=0 проявил себя наилучшим 
						   // образом и я его рекомендую к использованию. Это реализовано в ветке кода my_amg_manager.ilu2_smoother == 2.
						   // Причём iluk с lfil=0 работает на всех уровнях и прекрасно себя провляет.

						   // Перенаправление.
		bILU2smoother = 2; // ILU0
	}
	if (my_amg_manager.ilu2_smoother == 2) {
		// Включаем ILU2 сглаживатель. 
		// он ест больше памяти но более быстро сходится.

		// Его рекомендуется применять только для исходной матрицы - уровень ноль.
		// Если его применять на более глубоких уровнях то сходимость лишь замедляется.

		bILU2smoother = 2; // ILU2

						   // ILU2 ест слишком много оперативной памяти и я его заменил на ILU0 сглаживатель на каждом уровне : iluk с lfil=0.
						   // Возможно я ещё вернусь к ilu2 хотябы на нулевом уровне, т.к. там он особенно хорош.
	}
	//bILU2smoother = 0; // only seidel sor smoother.
	const doublerealT dapply_ilu_max_pattern_size = 9.2;

	// Параметры отвечающие за автоматическую настройку SOR.
	// По трём точкам мы построим параболу и на её основе 
	// спрогнозируем улучшенный параметр релаксации omega_optimal.
	// Парабола представляется намного лучшей чем простая линейная экстрополяция.
	bproblem_amg_convergence1 = false;
	bproblem_amg_convergence2 = false;
	bproblem_amg_convergence3 = false;
	gold_const = 0.2;

	bool bprint_mesage_diagnostic = true;
	if (my_amg_manager.iprint_log == 0) {
		bprint_mesage_diagnostic = false;
	}


	bool bpositive_connections_CF_decomp = true;
	integer memo_icoarseningtype = my_amg_manager.icoarseningtype;
	if (my_amg_manager.icoarseningtype >= 4) {
		// only negative connections 
		// Внедиагональные положительные связи игнорируются при создании C-F разбиения.
		bpositive_connections_CF_decomp = false;
		my_amg_manager.icoarseningtype -= 4;
	}
	// 19.01.2016 Для построения C-F разбиения и интерполляции используется разная логика
	// в области игнорирования и не игнорирования positive connections.
	// Требует обсуждения следующий вопрос: 
	// 1. При построениии процедуры интерполляции важны все связи как позитив так и негатив.
	// 2. При построении C-F декомпозиции важны только негатив связи. 
	// Это гипотеза требующая подтверждения.
	// Разделение между bpositive_connections_CF_decomp используемом при построении C-F декомпозиции и bpositive_connections
	// Произошло 19.01.2017.


	bool bpositive_connections = true;
	// 23 октября 2016
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		//bprint_mesage_diagnostic = false;

		// Гипотеза в том, что positive connections 
		// ускоряющие задачи теплопередачи в твёрдом теле приводят 
		// к расходимости в гидродинамических задачах:
		// гипотеза неверна, с убранными positive connections сходимость только хуже.
		//bpositive_connections = false;
	}

	// Задача 12mm hfet thermal resistance. 1.7млн неизвестных.
	// AVL_TREE_ID   3мин 29с 590мс      {5}
	// SPLAY_TREE_ID  3мин 16с 430мс {2}
	// BINARY_HEAP 3мин 4с 0мс {1 *самая быстрая.}
	// RANDOM_TREE_ID (Деамида) 3мин 28с 90мс {4}
	// RED_BLACK_TREE_ID 3мин 27с 210мс {3}


	const integer AVL_TREE_ID = 0;   // АВЛ дерево поиска. 12.12.2015.
	const integer SPLAY_TREE_ID = 1; // Скошенное дерево поиска.
	const integer BINARY_HEAP = 2; // Двоичная куча. 16.06.2017.
	const integer RANDOM_TREE_ID = 3; // (Деамида) Рандомизированное дерево поиска. 24.08.2017.
	const integer RED_BLACK_TREE_ID = 4; // Красно-Чёрное дерево поиска. 22.06.2018.
	const integer FIBONACCI_HEAP_ID = 5; // Фиббоначиева куча. 11.07.2018.
	const integer VAN_EMDE_BOAS_TREE_ID = 6; // ван Эмде Боас дерево поиска. 30.06.2018
	//integer id_tree = BINARY_HEAP; // AVL_TREE_ID; // SPLAY_TREE_ID; // BINARY_HEAP; // RANDOM_TREE_ID; // RED_BLACK_TREE_ID;
	// 28.01.2018 На выбор пользователя.
	integer id_tree = my_amg_manager.iCFalgorithm_and_data_structure;
	
	// Выделяем память под двоичную кучу.
	// Деструктор вызывается автоматом при уходе из области видимости области определения.
	const integer isize_priority_queue01 = (integer)(0.4*n); // 0.238
	integer ikonst1=isize_priority_queue01, ikonst2=n;
	if (id_tree!=BINARY_HEAP) {
	    ikonst1=0;
	    ikonst2=0;
	}
	PQ<integer> binary_heap(ikonst1, ikonst2); // 500K для 2.1M

	FibonacciHeap<integer> fibo_heap;

	if (id_tree == FIBONACCI_HEAP_ID) {
		fibo_heap.WakeUp2(n+1);// alloc memory hash table
		//if (id_tree == FIBONACCI_HEAP_ID) {
			//fibo_heap.~FibonacciHeap(); // Очистка
			//fibo_heap.WakeUp();
			//fibo_heap.Clear();
		//}
	}

	

	// Для вычисления grid complexity оператора интерполляции:
	integer nnz_P_memo_0 = 0;
	integer nnz_P_memo_all = 0;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	// 22 10 2016. первый  barjer полностью отключён.
	doublerealT barjer = 1.0e-7; // 1.0e-7 
	// 22 10 2016. Второй барьер можно использовать и у него большой потенциал,
	// но надо им правильно пользоваться в соответствии с теорией, это не просто импирическое изменение константы.
	// Если барьер А не используется то его значение отрицательно.
	// значение без барьера А называется мультигридом Галёркина.
	doublerealT barjerA = -1.0e-7; // 1.0e-7

	//if (iVar == PAM) {
	//barjer = 1.0e-10; // 1.0e-7 
	//barjerA = 1.0e-10; // 1.0e-7
	//}

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	
	//const integer QUICK_SORT_ALG = 1; // Быстрая сортировка Хоара.
	// Использовать ли quicksort qs and qsj.
	// Сортировка с подсчётом быстрее quickSort.
	// Использовать ли сортировку подсчётом которая 
	//жрёт килотонну памяти (Короче для машин у которых море оперативки).
	//const integer COUNTING_SORT_ALG = 0; // Сортировка с подсчётом лучший выбор.
    // Сортировка с посчётом подходит потому что ключи целочисленны и 
	// лежат в заданном интервале непрерывно.
	//const integer HEAP_SORT_ALG = 2; // пирмидальная сортировка.
	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	//bmemory_savings =false при QUICK_SORT_ALG и HEAP_SORT_ALG;
	integer imy_sort_algorithm = my_amg_manager.imySortAlgorithm;// COUNTING_SORT_ALG;

	const doublereal RealZERO = 1.0e-300;// 1.0e-10;
	const doublereal divisionZERO = 1.0e-300;
	const doublereal RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_sosed = 111400;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumsosedcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C-F разбиения.
	bool bmaxsosedinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = NULL;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 101; // (51 до 5.06.2017) 30
	integer ilevel = 1;
	integer *n_a = new integer[maxlevel];
	integer *nnz_a = new integer[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;

	const int iKnumber_thread = 8;

	char c1[27] = "classic_aglomerative_amg_4";

//#ifdef _NONAME_STUB29_10_2017
#ifdef _OPENMP 
	// Данные используемые для частичного формирователя суммы.
	// 8 - Это число потоков.
	
	Ak1** AccumulqtorA_m = NULL;
	AccumulqtorA_m = new Ak1*[iKnumber_thread];
	doublerealT** vector_sum_m = NULL;
	vector_sum_m = new doublerealT*[iKnumber_thread];
	integer** index_visit_m = NULL;
	index_visit_m = new integer*[iKnumber_thread];
	bool** hash_table_m = new bool*[iKnumber_thread];
	integer* index_size_m = NULL;
	integer*  istartAnew_m = new integer[iKnumber_thread];
	index_size_m = new integer[iKnumber_thread];
	for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {
		AccumulqtorA_m[i_9] = new Ak1[(integer)(0.125*4.55*nnz + 1)];
		//vector_sum_m[i_9] = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum_m[i_9] = (doublerealT*)malloc((n + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum_m[i_9], "vector_sum_m[i_9]", "classic_aglomerative_amg_4", (n + 1));

		//index_visit_m[i_9] = new integer[n_a[ilevel - 1] + 1];
		index_visit_m[i_9] = (integer*)malloc((n + 1) * sizeof(integer));
		handle_error<integer>(index_visit_m[i_9], "index_visit_m[i_9]", "classic_aglomerative_amg_4", (n + 1));

		hash_table_m[i_9] = (bool*)malloc((10 * n + 1) * sizeof(bool));
		handle_error<bool>(hash_table_m[i_9], "hash_table_m[i_9]", "classic_aglomerative_amg_4", (10 * n + 1));

		for (integer i_91 = 0; i_91 < 10 * n + 1; i_91++) hash_table_m[i_9][i_91] = false;// inicialization
		index_size_m[i_9] = 0;
		istartAnew_m[i_9] = 0;
	}
#endif

	doublerealT* threshold_quick_all = NULL;
	threshold_quick_all = (doublerealT*)malloc((n + 1) * sizeof(doublerealT));
	handle_error<doublerealT>(threshold_quick_all, "threshold_quick_all", "classic_aglomerative_amg_4", (n + 1));

	doublerealT* threshold_quick_only_negative = NULL;
	threshold_quick_only_negative = (doublerealT*)malloc((n + 1) * sizeof(doublerealT));
	handle_error<doublerealT>(threshold_quick_only_negative, "threshold_quick_only_negative", "classic_aglomerative_amg_4", (n + 1));
	bool btreshold_on_new_vetv = true; // false откат изменений назад на старую стабильную ветвь кода.
	

	//bool* flag = new bool[n + 1];
	bool* flag = NULL;
	flag = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_4", (n + 1));

	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = NULL;
	flag_shadow = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_4", (n + 1));

	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = NULL;
	hash_table = (bool*)malloc((nnz + 1) * sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_4", (nnz + 1));

	// Огромный размер поэтому инициализация делается лишь единожды.
#pragma omp parallel for
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n + 1; // 128000
											 //integer ipool[ipool_size_limit];
	integer* istack = NULL;
	//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit) * sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_4", (istack_size_limit));

	// Для построения C-F декомпозиции нам тоже потребуется хеш таблица
	// и стек для очистки хеш таблицы.
	bool* hash_table2 = NULL;
	hash_table2 = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_4", (n + 1));

	// Инициализация.
#pragma omp parallel for
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш таблицы.
	integer* istack2 = NULL;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1) * sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_4", (n + 1));


	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue_global = true;
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = NULL;
	this_is_C_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_4", (n + 1));

	bool* this_is_F_node = NULL;
	this_is_F_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_4", (n + 1));

	const integer isize_row_ptr_1 = 4 * n + 1;
	bool* F_false_C_true = NULL;
	F_false_C_true = (bool*)malloc((isize_row_ptr_1) * sizeof(bool));
	handle_error<bool>(F_false_C_true, "F_false_C_true", "classic_aglomerative_amg_4", (isize_row_ptr_1));

	for (integer i_1 = 0; i_1 <  isize_row_ptr_1; i_1++) F_false_C_true[i_1] = false; // инициализация.

	bool bStrongTransposeON = true; // Как в литературе используем Strong Transpose.
	if ((my_amg_manager.icoarseningtype == 0) || (my_amg_manager.icoarseningtype == 1)) {
		bStrongTransposeON = false;
	}
	bool bAVLST_ON = false;
	node_AVLST** hash_StrongTranspose_collection = NULL;
	Taccumulqtor_list** hash_StrongTranspose_collection1 = NULL;
	integer isize_memory_alloc_hash_StrongTranspose_collection1=-1;
	integer *isize_hash_StrongTranspose_collection = NULL;

	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue_global)) {


		RBroot.Clear();
		if (id_tree == FIBONACCI_HEAP_ID) {
			//fibo_heap.~FibonacciHeap(); // Очистка
			//fibo_heap.WakeUp();
			//fibo_heap.Clear();
			fibo_heap.UpdateSize(n_a[ilevel -1]+1);
		}

		// защита от повторного срабатывания на добавление в интерполляции.
		from_re_operation_protection0 = true;
		ifrom_re_operation_protection = 0;

		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumsosedcount = -1;
		bmaxsosedinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		//if (ilevel > 10) {
			// 5.01.2017 сделал менее 10.
			// до этого стоял break при менее 300.
			//if (n_a[ilevel - 1] < 10) break;
		//}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

		// 19.04.2018
		print_control_volume_statistics(n_a, nnz_a, ilevel, bprint_mesage_diagnostic, debug_reshime); 

		//nnzR = 1;

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

#pragma omp parallel for
		for (integer ii = n_a[ilevel - 1] + 1; ii <= n; ii++) {
#if doubleintprecision == 1
			//printf("warning: n!=n_a[ilevel-1] : n=%lld, n_a=%lld, ilevel=%lld\n", n, n_a[ilevel - 1], ilevel);
#else
			//printf("warning: n!=n_a[ilevel-1] : n=%d, n_a=%d, ilevel=%d\n", n, n_a[ilevel - 1], ilevel);
#endif
			
			//getchar();
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
			
			// 7 января 2016. Обязательно нужна эта сортировка.
			switch (imy_sort_algorithm) {
			case COUNTING_SORT_ALG :
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, bmemory_savings);
				break;
			case HEAP_SORT_ALG :
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				break;
			case QUICK_SORT_ALG :
				// quicksort
				qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Библиотечный алгоритм. O(nlog(n)).
				// Не использует лишней памяти.
				//std::sort(Amat + (1 + iadd) * sizeof(Ak1), Amat + (nnz_a[ilevel - 1] + iadd + 1) * sizeof(Ak1), compAi);

				//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				break;
			default :
				Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, bmemory_savings);
				break;
			}	
			
		} // ilevel == 1


		if (my_amg_manager.bMatrixPortrait == 1) {
			// Печать портрета матрицы.

			FILE* fp_portrait=NULL;
			errno_t err_portrait=0;
#ifdef MINGW_COMPILLER
			fp_portrait = fopen64("matrix_load.txt", "w");
			fprintf(fp_portrait, "%lld %lld\n", n_a[ilevel - 1], nnz_a[ilevel - 1]);
			for (integer i58 = 1 + iadd; i58 <= nnz_a[ilevel - 1] + iadd; i58++) {
				fprintf(fp_portrait, "%lld %lld\n", Amat[i58].i, Amat[i58].j);
		    }
#else
			err_portrait = fopen_s(&fp_portrait, "matrix_load.txt", "w");
			fprintf_s(fp_portrait, "%lld %lld\n", n_a[ilevel - 1], nnz_a[ilevel - 1]);
			for (integer i58 = 1 + iadd; i58 <= nnz_a[ilevel - 1] + iadd; i58++) {
				fprintf_s(fp_portrait, "%lld %lld\n", Amat[i58].i, Amat[i58].j);
			}
#endif
			
			fclose(fp_portrait);
			printf("matrix portrait in level export\n");
			system("pause");
		}
		


		if (bji) {
			//  УСТАРЕВШИЙ КОД.

			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			switch (imy_sort_algorithm) {
			case COUNTING_SORT_ALG :
				// Сортировка с подсчётом за линейное время.
				Counting_Sortj(Atemp, 1, nnz_a[ilevel - 1]);
				break;
			case HEAP_SORT_ALG :
				HeapSort_j(Atemp, 1, nnz_a[ilevel - 1]);
				break;
			case QUICK_SORT_ALG :
				// Быстрая сортировка Чарльза Хоара.
				qsj(Atemp, 1, nnz_a[ilevel - 1]);
				// Библиотечный алгоритм. O(nlog(n)).
				// Не использует лишней памяти.
				//std::sort(Atemp + 1 * sizeof(Ak1), Atemp + (nnz_a[ilevel - 1]+1) * sizeof(Ak1), compAj);
				break;
			default :
				// Сортировка с подсчётом за линейное время.
				Counting_Sortj(Atemp, 1, nnz_a[ilevel - 1]);
				break;
			}
		} // if (bji)

#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		row_startA = NULL;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 2) * sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 2));

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}
		row_startA[n_a[ilevel - 1] + 1] = nnz_a[ilevel - 1] + iadd + 1; // заглушка на окончание матрицы.

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		count_sosed = NULL;
		//count_sosed = new integer[n_a[ilevel - 1] + 1];
		count_sosed = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(count_sosed, "count_sosed", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_sosed[ii] = 0; // нет соседей.
		}



		/*
		// При таком коде узел Дирихле тоже имеет соседа, сосед это
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		integer ic = -1;
		integer cand[max_sosed];
		if (0) {
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		else {
		// 12 января 2016.
		// Учитываем только Strong соседей.
		doublerealT threshold = -1.0;
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > threshold) {
		// Определяем максимальный внедиагональный элемент.
		threshold = fabs(Amat[is0].aij);
		}
		}
		}
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > theta*threshold) {
		// Учитываем только сильно связанных соседей.
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		}
		}
		integer len_sosed = ic;
		// Найти столбец j который равен индексу Amat[ii].i
		//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
		//if (Amat[ii1].i != Amat[ii].i) {
		//	if (Amat[ii1].j == Amat[ii].i) {
		// j,i
		//		bool foundsosed = false;
		//		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
		//			if (Amat[ii1].j == cand[i_1]) foundsosed = true;
		//		}
		//		if (!foundsosed) {
		//			ic++;
		//			cand[ic] = Amat[ii1].j;
		//			len_sosed++;
		//		}
		//	}
		//}
		//}
		if (bji) {
		// Ускоренная версия с бинарным поиском по j.
		integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
		for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
		if (Atemp[ii1].i != Amat[ii].i) {
		// j,i
		bool foundsosed = false;
		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
		if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
		}
		if (!foundsosed) {
		ic++;
		cand[ic] = Atemp[ii1].j;
		len_sosed++;
		}
		}
		}
		}


		count_sosed[Amat[ii].i] = ic;
		if (ic > Maximumsosedcount) {
		Maximumsosedcount = ic;
		bmaxsosedinfoactive = true;
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/

		if (bStrongTransposeON) {
			// Освобождение ОЗУ.
			if (bAVLST_ON) {
				if (hash_StrongTranspose_collection != NULL) {
#pragma omp parallel for
					for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++) clear_AVL(hash_StrongTranspose_collection[i_1]);
					delete[] hash_StrongTranspose_collection;
					hash_StrongTranspose_collection = NULL;
				}
				if (isize_hash_StrongTranspose_collection != NULL) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = NULL;
				}
				// Выделяем память под лес АВЛ деревьев.
				hash_StrongTranspose_collection = new node_AVLST*[n_a[ilevel - 1] + 1];
				isize_hash_StrongTranspose_collection = new integer[n_a[ilevel - 1] + 1];
#pragma omp parallel for
				for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
					hash_StrongTranspose_collection[i_1] = NULL;
					isize_hash_StrongTranspose_collection[i_1] = 0;
				}
			}
			else {
				// Эта ветвь активна лес АВЛ деревьев ненужен.

				// Обычный накопитель - линейный список с быстрой вставкой.
				if (hash_StrongTranspose_collection1 != NULL) {
#pragma omp parallel for
					//for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++)
					//isize_memory_alloc_hash_StrongTranspose_collection1
					for (integer i_1 = 0; i_1 <= isize_memory_alloc_hash_StrongTranspose_collection1; i_1++)
					{
					 clear_list(hash_StrongTranspose_collection1[i_1]);
					}
					delete[] hash_StrongTranspose_collection1;
					hash_StrongTranspose_collection1 = NULL;
				}
				if (isize_hash_StrongTranspose_collection != NULL) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = NULL;
				}
				// Выделяем память под лес линейных однонаправденных списков.
				hash_StrongTranspose_collection1 = new Taccumulqtor_list*[n_a[ilevel - 1] + 1];
				isize_memory_alloc_hash_StrongTranspose_collection1=n_a[ilevel - 1];
				isize_hash_StrongTranspose_collection = new integer[n_a[ilevel - 1] + 1];
#pragma omp parallel for
				for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
					hash_StrongTranspose_collection1[i_1] = NULL;
					isize_hash_StrongTranspose_collection[i_1] = 0;
				}
			}
		}

		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				//integer cand[max_sosed];
				node_AVL_Gus* root_Gus_cand = 0;
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						//cand[ic] = Amat[is0].j;
						if (btree_vs_hash == 1) {
							insert_hash_table_Gus_struct01(Amat[is0].j);
						}
						else if (btree_vs_hash == 0) {
							root_Gus_cand = insert_Gus(root_Gus_cand, Amat[is0].j);
						}
					}
				}
				else {
					if (1) {
						// Новейшая ветвь кода: 11.06.2017.
						// Введение новой ветви вызвано желанием ускорить код избегая повторных массовых вычислений threshold.
						// Ни в коем случае не ставить 0 в if.
						// Это новая едиственно верная ветка. Её убирание приводит к неработоспособности всего приложения.
						threshold_quick_all[Amat[ii].i] = -1.0;
						threshold_quick_only_negative[Amat[ii].i] = -1.0;
						for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (fabs(Amat[is0].aij) > threshold_quick_all[Amat[ii].i]) {
									// Определяем максимальный внедиагональный элемент.
									threshold_quick_all[Amat[ii].i] = fabs(Amat[is0].aij);
								}
							}
						}
						for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (Amat[is0].aij < 0.0) {
									if (fabs(Amat[is0].aij) > threshold_quick_only_negative[Amat[ii].i]) {
										// Определяем максимальный внедиагональный элемент.
										threshold_quick_only_negative[Amat[ii].i] = fabs(Amat[is0].aij);
									}
								}
							}
						}
					}
					else {
						// Безнадёжно устаревшая ветвь кода начиная с 11.06.2017.

						// 12 января 2016.
						// 12 февраля 2016. матрица отсортирована по i.
						// Учитываем только Strong соседей.
						doublerealT threshold = -1.0;

						if (bpositive_connections_CF_decomp) {
							for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii].i) {
									if (fabs(Amat[is0].aij) > threshold) {
										// Определяем максимальный внедиагональный элемент.
										threshold = fabs(Amat[is0].aij);
									}
								}
							}
						}
						else {
							for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii].i) {
									if (Amat[is0].aij < 0.0) {
										if (fabs(Amat[is0].aij) > threshold) {
											// Определяем максимальный внедиагональный элемент.
											threshold = fabs(Amat[is0].aij);
										}
									}
								}
							}
						}
					}
					if (bpositive_connections_CF_decomp) {
						//doublerealT theta_threshold3 = theta*threshold;
						doublerealT theta_threshold3 = theta*threshold_quick_all[Amat[ii].i];
						integer istopmarker3 = row_startA[Amat[ii].i + 1] - 1;
						for (integer is0 = ii; (is0 <= istopmarker3); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (fabs(Amat[is0].aij) > theta_threshold3) {
									// Учитываем только сильно связанных соседей.
									ic++; //i,j
									//cand[ic] = Amat[is0].j;
									if (btree_vs_hash == 1) {
										insert_hash_table_Gus_struct01(Amat[is0].j);
									}
									else if (btree_vs_hash == 0) {
										root_Gus_cand = insert_Gus(root_Gus_cand, Amat[is0].j);
									}

									if (bStrongTransposeON) {
										data_BalTreeST d32;
										d32.i = Amat[ii].i;
										if (bAVLST_ON) {
											hash_StrongTranspose_collection[Amat[is0].j] = insert(hash_StrongTranspose_collection[Amat[is0].j], d32);
										}
										else {
											// O(1) вставка в начало линейного списка.
											insert_list(hash_StrongTranspose_collection1[Amat[is0].j], Amat[ii].i);
										}
										isize_hash_StrongTranspose_collection[Amat[is0].j]++;
									}
								}
							}
						}
					}
					else {
						for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii].i) {
								if (Amat[is0].aij < 0.0) {
									if (fabs(Amat[is0].aij) > theta*threshold_quick_only_negative[Amat[ii].i]) {
										// Учитываем только сильно связанных соседей.
										ic++; //i,j
										//cand[ic] = Amat[is0].j;
										if (btree_vs_hash == 1) {
											insert_hash_table_Gus_struct01(Amat[is0].j);
										}
										else if (btree_vs_hash == 0) {
											root_Gus_cand = insert_Gus(root_Gus_cand, Amat[is0].j);
										}

										if (bStrongTransposeON) {
											data_BalTreeST d32;
											d32.i = Amat[ii].i;
											if (bAVLST_ON) {
												hash_StrongTranspose_collection[Amat[is0].j] = insert(hash_StrongTranspose_collection[Amat[is0].j], d32);
											}
											else {
												// O(1) вставка в начало линейного списка.
												insert_list(hash_StrongTranspose_collection1[Amat[is0].j], Amat[ii].i);
											}
											isize_hash_StrongTranspose_collection[Amat[is0].j]++;
										}
									}
								}
							}
						}
					}
				}
				integer len_sosed = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundsosed = false;
				//		//for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
				//			//if (Amat[ii1].j == cand[i_1]) foundsosed = true;
				//		//}
				//if (btree_vs_hash == 1) {
					//foundsosed = isfound_hash_table_Gus_struct01(Amat[ii1].j);
					//if (!foundsosed) {
						//			ic++;
						//			//cand[ic] = Amat[ii1].j;
						//         	insert_hash_table_Gus_struct01(Amat[ii1].j);
						//			len_sosed++;
						//		}
					
				//}
				//else if (btree_vs_hash == 0) {
					//      foundsosed = isfound_Gus(root_Gus_cand, Amat[ii1].j);
					//		if (!foundsosed) {
					//			ic++;
					//			//cand[ic] = Amat[ii1].j;
					//          root_Gus_cand = insert_Gus(root_Gus_cand, Amat[ii1].j);
					//			len_sosed++;
					//		}
				//}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= row_startA[Amat[ii2].i + 1] - 1); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundsosed = false;
							//for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
								//if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
							//}
							if (btree_vs_hash == 1) {
								foundsosed = isfound_hash_table_Gus_struct01(Atemp[ii1].j);
								if (!foundsosed) {
									ic++;
									//cand[ic] = Atemp[ii1].j;
									insert_hash_table_Gus_struct01(Atemp[ii1].j);
									len_sosed++;
								}
							}
							else if (btree_vs_hash == 0) {
								foundsosed = isfound_Gus(root_Gus_cand, Atemp[ii1].j);
								if (!foundsosed) {
									ic++;
									//cand[ic] = Atemp[ii1].j;
									root_Gus_cand = insert_Gus(root_Gus_cand, Atemp[ii1].j);
									len_sosed++;
								}
							}
						}
					}
				}


				count_sosed[Amat[ii].i] = ic;
				// 22_12_2016
				if (ic == 0) {
					// Большой вопрос уместно ли так делать 8.апреля 2017 ???

					// До начала работы алгоритма все условия Дирихле становятся F узлами.
					this_is_C_node[Amat[ii].i] = false;
					this_is_F_node[Amat[ii].i] = true;

					// До начала работы алгоритма все условия Дирихле становятся C узлами.
					// Внимание так не работает.
					//this_is_C_node[Amat[ii].i] = true;
					//this_is_F_node[Amat[ii].i] = false;
				}
				if (ic > Maximumsosedcount) {
					Maximumsosedcount = ic;
					bmaxsosedinfoactive = true;
				}
				flag[Amat[ii].i] = true;

				if (btree_vs_hash == 1) {
					clear_hash_table_Gus_struct01();
				}
				else if (btree_vs_hash == 0) {
					clear_AVL_Gus(root_Gus_cand);
					root_Gus_cand = 0;
				}
			}
		}

		if (bStrongTransposeON) {
			// 5.01.2017. StrongTranspose.
			// Счётчик labda инициализирован согласно литературным описаниям через Strong Transpose.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
#if doubleintprecision == 1
				//printf("%lld ", count_sosed[i_1]);
#else
				//printf("%d ", count_sosed[i_1]);
#endif
				
				//if (hash_StrongTranspose_collection[i_1] == NULL) {
					//printf(" NULL");
					//system("PAUSE");
					// Присутствуют элементы с NULL у которых count_sosed[i_1] =0;
				//}
				// 20.05.2017 Добавлен быстрый доступ по ключу для количества элементов в дереве.
				//count_sosed[i_1] = getnumber_AVL_node_global(hash_StrongTranspose_collection[i_1]);
				count_sosed[i_1] = isize_hash_StrongTranspose_collection[i_1];
				if (count_sosed[i_1]==0) {
					// 14.04.2017 Важнейшая положительная модификация 
					// сокращающая количество итераций:
					// # задача; число ит. до; число ит. после;
					// 1. passiv_module6 (APPARAT); 179; 97;
					// 2. CGHV 12mm HFET; 18, 8, 6, 3, 2; 17, 8, 6, 3, 2;
					// 3. PIONER; 77; 73;

					// До начала работы алгоритма все условия Дирихле становятся F узлами.
					this_is_C_node[i_1] = false;
					this_is_F_node[i_1] = true;

				}
#if doubleintprecision == 1
				//printf("%lld \n", count_sosed[i_1]);
#else
				//printf("%d \n", count_sosed[i_1]);
#endif
				
				//system("PAUSE");
			}
		}


		maxsosed = 0;
		icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		/*
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		if (count_sosed[Amat[ii].i] > maxsosed) {
		maxsosed = count_sosed[Amat[ii].i];
		icandidate = ii;
		if (bmaxsosedinfoactive) {
		// организуем досрочный выход из цикла for.
		// Это должно сильно сокращать количество сканирований.
		if (maxsosed == Maximumsosedcount) break;
		}
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/
		for (integer i7 = 1; i7 <= n_a[ilevel - 1]; i7++) {
			if (count_sosed[i7] > maxsosed) {
				maxsosed = count_sosed[i7];
				icandidate = row_startA[i7];
				if (bmaxsosedinfoactive) {
					// организуем досрочный выход из цикла for.
					// Это должно сильно сокращать количество сканирований.
					if (maxsosed == Maximumsosedcount) break;
				}
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		
		vacant = NULL_SOSED;
		bcontinue = true;

		// Построение C-F разбиения.
		//while (icandidate != 0)
		icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bmarkervisit = NULL;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n + 1) * sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_4", (n + 1));

		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;



		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bAVL = true;
		bAVL_deb = false;
		root = 0;
		root_splay = 0;
		size_splay_Tree = 0;
		random_tree_root = NULL;
		
		if (id_tree == BINARY_HEAP) {
			binary_heap.clear();
		}

#if VEB_FLAG
		int64_t res_vanEMDE_BOAS_Tree;
		int64_t universe = 4294967296; // 2 ^32=2^(2^5) (4294 млн)
		TvEB * vanEMDE_BOAS_Tree = NULL;

		if (id_tree == VAN_EMDE_BOAS_TREE_ID) {
			vanEMDE_BOAS_Tree = new TvEB(universe);
		}
#endif

		newCcount = 0;

		// 4 июля 2016.
		// это случай когда следующий уровень вложенности просто не из чего строить и это 
		// становится понятно только здесь.
		if ((icandidate == 0) && (maxsosed == 0)) {
#if doubleintprecision == 1
			//printf("maxsosed==%lld\n",maxsosed);
#else
			//printf("maxsosed==%d\n",maxsosed);
#endif
			
			//getchar();
			// уровень построить нельзя поэтому досрочный выход из цикла.
			break;
		}


		// Нехорошо постоянно выделять и уничтожать память в длинном цикле, 
		// более быстро выделить её один раз. См. выделение памяти под set.
		// 23.04.2017

		//integer set[max_sosed]; // не более 20 узлов в одном агрегате.
		//integer* set = new integer[max_sosed];
		root_Gus_set = 0;
		// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
		//for (integer js = 0; js < max_sosed; js++) {
		//set[js] = NULL_SOSED;
		//}

		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			
			integer ic = 0;
			integer ic_end_F_SiTranspose = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				if (btree_vs_hash == 0) {
					if (root_Gus_set != 0) {
						clear_AVL_Gus(root_Gus_set);
						root_Gus_set = 0;
					}
				}

				ic_end_F_SiTranspose = 0;
				integer set0= Amat[ii].i;
				



				//A20.05.2017//this_is_C_node[set[0]] = true;
				//A20.05.2017//bmarkervisit[set[0]] = true;
				this_is_C_node[set0] = true;
				bmarkervisit[set0] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
												   // добавляем диагональный элемент.
												   // узел set[0]==Amat[is0].i.
												   // Нахождение значения максимального внедиагольного элемента, с 
												   // учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
												   // 17 января 2016 правильное определение максимального внедиагонального элемента.
												   // Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set0)) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0e30;
				doublerealT min_vnediagonal1 = 1.0e30;
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				if (bpositive_connections_CF_decomp) {
					// 23_10_2016
					for (integer is0 = ii_back; (is0 <= row_startA[set0 + 1] - 1); is0++) {
						if (Amat[is0].j != set0) {
							counter_vnediagonal = counter_vnediagonal + 1.0;
							avg_vnediagonal1 += fabs(Amat[is0].aij);
							if (fabs(Amat[is0].aij) > max_vnediagonal1) {
								max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
																	 // Большое количество элементов на грубых уровнях,
																	 // очень медленная сходимость.
																	 //if (Amat[is0].j == set[0]) break; 
							}
							if (fabs(Amat[is0].aij) < min_vnediagonal1) {
								min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

							}
						}
					}
				}
				else {
					for (integer is0 = ii_back; (is0 <= row_startA[set0 + 1] - 1); is0++) {
						if (Amat[is0].j != set0) {
							if (Amat[is0].aij < 0.0) {
								counter_vnediagonal = counter_vnediagonal + 1.0;
								avg_vnediagonal1 += fabs(Amat[is0].aij);
								if (fabs(Amat[is0].aij) > max_vnediagonal1) {
									max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
																		 // Большое количество элементов на грубых уровнях,
																		 // очень медленная сходимость.
																		 //if (Amat[is0].j == set[0]) break; 
								}
								if (fabs(Amat[is0].aij) < min_vnediagonal1) {
									min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

								}
							}
						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				//max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				max_vnediagonal = -1.0e30;  // все связи!!!
				

										 /*
										 // Лишний код 19 января 2016.
										 for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set0); is0++) {
										 if (Amat[is0].j == set0) {

										 // Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
										 // поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
										 break;
										 }
										 else {
										 if (fabs(Amat[is0].aij) > max_vnediagonal) {
										 // При стабильной версии требуется расскоментировать
										 // 19 jan 2016.
										 //max_vnediagonal = fabs(Amat[is0].aij); //i,j
										 }
										 }

										 // Этот цикл является добавочным.
										 // Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
										 // Медленный линейный поиск.
										 //for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
										 //if (Amat[ii1].i != set0) {
										 //if (!flag[Amat[ii1].i]) {
										 //	if (Amat[ii1].j == set0) {
										 //		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
										 //			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
										 //		}
										 //	}
										 //}
										 //}
										 //}

										 if (bji) {
										 // Этот цикл является добавочным.
										 // Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
										 // Ускоренная версия на основе двоичного поиска.
										 integer ii2 = BinarySearchAj(Atemp, set0, 1, nnz_a[ilevel - 1]);
										 for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set0); ii1++)
										 {
										 if (Atemp[ii1].i != set0) {
										 if (!flag[Atemp[ii1].i]) {
										 if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
										 max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
										 }
										 }
										 }
										 }
										 }


										 }
										 */

				ic++;

			

				if ((my_amg_manager.ipatch_number == 3)||(my_amg_manager.ipatch_number == 4)) {
					// Делает только сильно хуже
					// 25.01.2017 
					// F узлы берутся из множества Si transpose.
					integer imarker75_scan = 0;
					if (my_amg_manager.ipatch_number == 3) {
						//formirate_F_SiTranspose(hash_StrongTranspose_collection[Amat[ii].i], set, imarker75_scan);
						// из дерева в дерево.
						if (btree_vs_hash == 1) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_hash_table_Gus_struct01(hash_StrongTranspose_collection[Amat[ii].i], imarker75_scan);
							}
							else {
								formirate_F_SiTranspose_hash_table_Gus_struct02(hash_StrongTranspose_collection1[Amat[ii].i], imarker75_scan);
							}
						}
						else if (btree_vs_hash == 0) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_AVL_Gus(hash_StrongTranspose_collection[Amat[ii].i], root_Gus_set, imarker75_scan);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_AVL_Gus(hash_StrongTranspose_collection1[Amat[ii].i], root_Gus_set, imarker75_scan);
							}
						}
						ic = imarker75_scan+1;
					}
					if (my_amg_manager.ipatch_number == 4) {
						// 28.01.2017
						// Мы берем F узлы из SiTranspose только в пересечении с U так пишут в книге.
					    if (btree_vs_hash == 1) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_hash_table_Gus2_struct01(hash_StrongTranspose_collection[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// Обычный односвязный линейный список.
								formirate_F_SiTranspose_hash_table_Gus2_struct02(hash_StrongTranspose_collection1[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
					    else if (btree_vs_hash == 0) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection1[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
						ic = imarker75_scan+1;

						/*
						// 21.05.2017 Устаревший код, его полностью заменяет 
						// formirate_F_SiTranspose_AVL_Gus2.

						//integer set_s[max_sosed];
						// ic+2 точно должно хватить, к томуже ic+2 в большинстве случаев 
						// существенно меньше по размеру чем max_sosed. 
						// Всегда лучше выделять памяти ровно столько сколько потребуется если 
						// точно известно сколько нужно.
						integer* set_s = new integer[ic+2];
						set_s[0] = set0;
						integer i98 = 1;
						for (integer i97 = 1; i97 < ic; i97++) {
							if ((this_is_F_node[set[i97]] == false) && (this_is_C_node[set[i97]] == false)) {
								// Если они из Strong Transpose в пересечении с U. 
								set_s[i98] = set[i97];
								i98++;
							}
						}
						ic = i98;
						for (integer i97 = 1; i97 < ic; i97++) {
							set[i97] = set_s[i97];
						}
						if (set_s != NULL) {
							delete[] set_s;
							set_s = NULL;
						}
						*/
					}
				}
				else {


					

					//  В set начиная с единицы и до <ic лежат кандидаты чтобы стать F.
					// 5.01.2017
					// 01.04.2017 Дополняемся F узлами из Si_Transpose связей.
					if ((my_amg_manager.ipatch_number == 7) && (bStrongTransposeON)) {

						integer imarker75_scan = 0;
						if (btree_vs_hash == 1) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_hash_table_Gus2_struct01(hash_StrongTranspose_collection[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_hash_table_Gus2_struct02(hash_StrongTranspose_collection1[Amat[ii].i], imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
						else if (btree_vs_hash == 0) {
							if (bAVLST_ON) {
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
							else {
								// обычный линейный список.
								formirate_F_SiTranspose_AVL_Gus2(hash_StrongTranspose_collection1[Amat[ii].i], root_Gus_set, imarker75_scan, this_is_F_node, this_is_C_node);
							}
						}
						ic = imarker75_scan+1; 

						/*

						hashlist_i* set_formirate = NULL;
						getlist_AVL_node_global(hash_StrongTranspose_collection[Amat[ii].i], set_formirate);
						hashlist_i* set_formirate_marker = set_formirate;

						while (set_formirate_marker != NULL) {
							// именно так рекомендуют в литературе.
							if ((this_is_F_node[set_formirate_marker->item] == false) && (this_is_C_node[set_formirate_marker->item] == false)) {
								// Если они из Strong Transpose в пересечении с U.
								vacant = set_formirate_marker->item;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant; // Si_Transpose связи.
									ic++;

									// А есть ли они в природе ?
									//printf("found Si_Transpose F candidate. my_amg_manager.ipatch_number == 7");
									#if doubleintprecision == 1
										//printf("%lld ", set[0]);
									#else
										//printf("%d ", set[0]);
									#endif
									
									//getchar();

								}
							}
							set_formirate_marker = set_formirate_marker->next;
						}

						set_formirate_marker = NULL;
						clear_hash_list_i(set_formirate);
						set_formirate = NULL;
						*/

					}

					ic_end_F_SiTranspose = ic; // С этой позиции заканчиваются F которые из Si_Transpose.

					// если узел j ещё не был добавлен в агрегат.
					if (bpositive_connections_CF_decomp) {
						if (flag[Amat[ii].j] == false) {
							if ((Amat[ii].j != set0) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
								// 21.05.2017
								bool bfound_vacant = false;
								if (btree_vs_hash == 1) {
									bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii].j);
									if (!bfound_vacant) {
										insert_hash_table_Gus_struct01(Amat[ii].j);
										ic++;
									}
								}
								else if (btree_vs_hash == 0) {
									bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii].j);
									if (!bfound_vacant) {
										root_Gus_set = insert_Gus(root_Gus_set, Amat[ii].j);
										ic++;
									}
								}
								/*
								vacant = Amat[ii].j;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant;

									ic++;
								}
								*/
							}
						}
					}
					else {
						if (flag[Amat[ii].j] == false) {
							if ((Amat[ii].j != set0) && (Amat[ii].aij < 0.0) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
								// 21.05.2017
								bool bfound_vacant = false;
								if (btree_vs_hash == 1) {
									bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii].j);
									if (!bfound_vacant) {
										insert_hash_table_Gus_struct01(Amat[ii].j);
										ic++;
									}
								}
								else if (btree_vs_hash == 0) {
									bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii].j);
									if (!bfound_vacant) {
										root_Gus_set = insert_Gus(root_Gus_set, Amat[ii].j);
										ic++;
									}
								}
								/*
								vacant = Amat[ii].j;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant;

									ic++;
								}
								*/
							}
						}
					}

					//printf("sboi start");

					integer iscan = ii + 1;
					iscan = ii_back + 1; // важная модификация 19 января 2016г.
										 // TODO 19 jan 2016.

					if (bpositive_connections_CF_decomp) {
						while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set0)) {
							// 14 февраля 2016 код иногда приводящий к сбою.
							//while (iscan <= row_startA[set0 + 1] - 1) { // код иногда приводящий к сбою по непонятной причине.
							// если узел j ещё не был добавлен в агрегат.
							if (flag[Amat[iscan].j] == false) {
								if ((Amat[iscan].j != set0) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
									// 21.05.2017
									bool bfound_vacant = false;
									if (btree_vs_hash == 1) {
										bfound_vacant = isfound_hash_table_Gus_struct01(Amat[iscan].j);
										if (!bfound_vacant) {
											insert_hash_table_Gus_struct01(Amat[iscan].j);
											ic++;
										}
									}
									else if (btree_vs_hash == 0) {
										bfound_vacant = isfound_Gus(root_Gus_set, Amat[iscan].j);
										if (!bfound_vacant) {
											root_Gus_set = insert_Gus(root_Gus_set, Amat[iscan].j);
											ic++;
										}
									}
									/*
									// Медленная версия с линейным поиском.
									vacant = Amat[iscan].j;
									for (integer js = 0; js < ic; js++) {
										if (vacant == set[js]) {
											vacant = NULL_SOSED;
										}
									}
									if (vacant != NULL_SOSED) {
										set[ic] = vacant;

										ic++;

									}
									*/
								}
							}

							iscan++;

						} // while
					}
					else {
						while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set0)) {
							// 14 февраля 2016 код иногда приводящий к сбою.
							//while (iscan <= row_startA[set0 + 1] - 1) { // код иногда приводящий к сбою по непонятной причине.
							// если узел j ещё не был добавлен в агрегат.
							if (flag[Amat[iscan].j] == false) {
								if ((Amat[iscan].j != set0) && (Amat[iscan].aij < 0.0) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
									// 21.05.2017
									bool bfound_vacant = false;
									if (btree_vs_hash == 1) {
										bfound_vacant = isfound_hash_table_Gus_struct01(Amat[iscan].j);
										if (!bfound_vacant) {
											insert_hash_table_Gus_struct01(Amat[iscan].j);
											ic++;
										}
									}
									else if (btree_vs_hash == 0) {
										bfound_vacant = isfound_Gus(root_Gus_set, Amat[iscan].j);
										if (!bfound_vacant) {
											root_Gus_set = insert_Gus(root_Gus_set, Amat[iscan].j);
											ic++;
										}
									}
									/*									
									vacant = Amat[iscan].j;
									for (integer js = 0; js < ic; js++) {
										if (vacant == set[js]) {
											vacant = NULL_SOSED;
										}
									}
									if (vacant != NULL_SOSED) {
										set[ic] = vacant;

										ic++;

									}
									*/
								}
							}

							iscan++;

						} // while
					}

					//printf("sboi end");
					// Это была учтена только связь i,j


					if (1&&(my_amg_manager.ipatch_number == 7) && (bStrongTransposeON)) {
					}
					else {

						// Связи j,i это фактически и есть связи из Si_Transpose.

						// Учёт свяи j,i
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
						//if ((Amat[ii1].i != set0) && (Amat[ii1].j == set0)) {
						//if (!flag[Amat[ii1].i]) {
						//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
						//   
						//   // 21.05.2017
						//   bool bfound_vacant = false;
						//if (btree_vs_hash == 1) {
						//	bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii1].i);
						//	if (!bfound_vacant) {
						//		insert_hash_table_Gus_struct01(Amat[ii1].i);
						//		ic++;
						//	}
						//}
						//else if (btree_vs_hash == 0) {
							//   bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii1].i);
							//   if (!bfound_vacant) {
							//   	root_Gus_set = insert_Gus(root_Gus_set, Amat[ii1].i);
							//  	ic++;
							//   }
						//}
						//
						//   Устаревший код.
						//	vacant = Amat[ii1].i;
						//	for (integer js = 0; js < ic; js++) {
						//		if (vacant == set[js]) {
						//			vacant = NULL_SOSED;
						//		}
						//	}
						//	if (vacant != NULL_SOSED) {
						//		set[ic] = vacant; // j,i связь.

						//		ic++;
						//	}
						//
						//
						//	}
						//}
						//}
						//}

						// Учёт связи j,i
						// Медленная версия на основе линейного поиска.
						//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
						//if ((Amat[ii1].i != set0) && (Amat[ii1].j == set0)) {
						//if (!flag[Amat[ii1].i]) {
						//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
						//  
						//   21.05.2017
						//   bool bfound_vacant = false;
						//if (btree_vs_hash == 1) {
						//	bfound_vacant = isfound_hash_table_Gus_struct01(Amat[ii1].i);
						//	if (!bfound_vacant) {
						//		insert_hash_table_Gus_struct01(Amat[ii1].i);
						//		ic++;
						//	}
						//}
						//else if (btree_vs_hash == 0) {
							//   bfound_vacant = isfound_Gus(root_Gus_set, Amat[ii1].i);
							//   if (!bfound_vacant) {
							//   	root_Gus_set = insert_Gus(root_Gus_set, Amat[ii1].i);
							//  	ic++;
							//   }
						//}
						//
						//  Устаревший код.
						//	vacant = Amat[ii1].i;
						//	for (integer js = 0; js < ic; js++) {
						//		if (vacant == set[js]) {
						//			vacant = NULL_SOSED;
						//		}
						//	}
						//	if (vacant != NULL_SOSED) {
						//		set[ic] = vacant; // j,i связь.

						//		ic++;
						//	}
						//}
						//}
						//}
						//}

						if (bpositive_connections_CF_decomp) {
							if (bji) {
								// Учёт свяи j,i
								// Более быстрая версия на основе двоичного поиска.
								integer ii1 = BinarySearchAj(Atemp, set0, 1, nnz_a[ilevel - 1]);
								for (integer ii2 = ii1; (ii2 <= row_startA[set0 + 1] - 1); ii2++) {
									if ((Atemp[ii2].i != set0) && (!flag[Atemp[ii2].i])) {
										if (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal) {

											// 21.05.2017
											bool bfound_vacant = false;
											if (btree_vs_hash == 1) {
												bfound_vacant = isfound_hash_table_Gus_struct01(Atemp[ii2].i);
												if (!bfound_vacant) {
													insert_hash_table_Gus_struct01(Atemp[ii2].i);
													ic++;
												}
											}
											else
											if (btree_vs_hash == 0) {
												bfound_vacant = isfound_Gus(root_Gus_set, Atemp[ii2].i);
												if (!bfound_vacant) {
													root_Gus_set = insert_Gus(root_Gus_set, Atemp[ii2].i);
													ic++;
												}
											}
											/*
											vacant = Atemp[ii2].i;
											for (integer js = 0; js < ic; js++) {
												if (vacant == set[js]) {
													vacant = NULL_SOSED;
												}
											}
											if (vacant != NULL_SOSED) {
												set[ic] = vacant; // j,i связь.
												ic++;
											}
											*/
										}
									}
								}


							}
						}
						else {
							if (bji) {
								// Учёт свяи j,i
								// Более быстрая версия на основе двоичного поиска.
								integer ii1 = BinarySearchAj(Atemp, set0, 1, nnz_a[ilevel - 1]);
								for (integer ii2 = ii1; (ii2 <= row_startA[set0 + 1] - 1); ii2++) {
									if ((Atemp[ii2].i != set0) && (!flag[Atemp[ii2].i])) {
										if ((Atemp[ii2].aij < 0.0) && (fabs(Atemp[ii2].aij) >= theta*max_vnediagonal)) {

											// 21.05.2017
											bool bfound_vacant = false;
											if (btree_vs_hash == 1) {
												bfound_vacant = isfound_hash_table_Gus_struct01(Atemp[ii2].i);
												if (!bfound_vacant) {
													insert_hash_table_Gus_struct01(Atemp[ii2].i);
													ic++;
												}
											}
											else if (btree_vs_hash == 0) {
												bfound_vacant = isfound_Gus(root_Gus_set, Atemp[ii2].i);
												if (!bfound_vacant) {
													root_Gus_set = insert_Gus(root_Gus_set, Atemp[ii2].i);
													ic++;
												}
											}

											/*
											vacant = Atemp[ii2].i;
											for (integer js = 0; js < ic; js++) {
												if (vacant == set[js]) {
													vacant = NULL_SOSED;
												}
											}
											if (vacant != NULL_SOSED) {
												set[ic] = vacant; // j,i связь.
												ic++;
											}
											*/
										}
									}
								}


							}
						}
					}

					
				}

				
				/*
				if (my_amg_manager.ipatch_number == 5) {
					// Делает только сильно хуже 

					// 28.01.2017
					// Мы берем узлы из SiTranspose только в пересечении с U так пишут в книге.

					//integer set_s[max_sosed];
					//integer* set_s = new integer[max_sosed];
					integer* set_s = new integer[ic + 2];
					set_s[0] = set0;
					integer i98 = 1;
					for (integer i97 = 1; i97 < ic; i97++) {
						if ((this_is_F_node[set[i97]] == false) && (this_is_C_node[set[i97]] == false)) {
							// Если они из Strong Transpose в пересечении с U. 
							set_s[i98] = set[i97];
							i98++;
						}
					}
					ic = i98;
					for (integer i97 = 1; i97 < ic; i97++) {
						set[i97] = set_s[i97];
					}

					if (set_s != NULL) {
						delete[] set_s;
						set_s = NULL;
					}
				}
				*/

				// В этом месте множество set успешно сформировано:
				// 1. Перепаковка из root_Gus_set в set.
				// 2. root_Gus_set больше не используется.
				// 3. Именно здесь надо выделить данные под set.
				//integer* set = new integer[max_sosed];
				integer* set = NULL;
				set = new integer[ic + 2];
				if (set == NULL) {
					printf("error!!! memory for set is NULL. Problem allocate detected.\n");
					printf("in function classic_aglomerative_amg4.\n");
					system("pause");
					exit(1);
				}

				integer ic_986 = 1;
				set[0] = set0;

				if (btree_vs_hash == 1) {

					formirate_hash_table_Gus_struct01__2__set(set, ic_986);

					clear_hash_table_Gus_struct01();
				}
				else if (btree_vs_hash == 0) {

					formirate_root_Gus_set__2__set(root_Gus_set, set, ic_986);

					clear_AVL_Gus(root_Gus_set);
					root_Gus_set = 0;

				}

				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					TreapNode* nrt_temp = NULL;
					TreapNode* save_root = NULL;

					/*
					if (id_tree == FIBONACCI_HEAP_ID) {
						if (!fibo_heap.isEmpty()) {
							fibo_heap.removeMinimum();
						}
					}
					*/
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.countsosed = count_sosed[set[js]];
						// Уникальный ключ для дерева ван Эмде Боаса.
						integer  veb_del_key = (count_sosed[set[js]])*(n_a[ilevel - 1]+1) + (set[js] );
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						case BINARY_HEAP:
							// Уникальным ключём удаления является set[js].
							binary_heap.remove(set[js]);
							break;
						case RANDOM_TREE_ID: 
							save_root = random_tree_root;
							nrt_temp = search(random_tree_root, ddel);
							random_tree_root = save_root;
							save_root = NULL;
							if (nrt_temp != NULL) {
								nrt_temp = NULL;
								random_tree_root=deleteNode(random_tree_root, ddel);
							}
							break;
						case RED_BLACK_TREE_ID:
							RBroot.Remove(ddel);
							break;
						case FIBONACCI_HEAP_ID:
							if (!fibo_heap.isEmpty()) {
								//fibo_heap.deleteKey(-veb_del_key);
								fibo_heap.deleteKey(ddel);
							}
							//RBroot.Remove(ddel);
							break;


						case VAN_EMDE_BOAS_TREE_ID :
#if VEB_FLAG
							// Если элемент присутствует то мы его удалим.
							res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_del_key);
							if (!res_vanEMDE_BOAS_Tree) {

							}
							else {
								res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_del_key);
								if (!res_vanEMDE_BOAS_Tree) {
									printf("nevozmochno udalit post factum delete %lld %lld\n", ddel.countsosed, ddel.i);
									system("pause");
								}
							}
#endif
							break;

						default: root = remove_AVL(root, ddel);
							break;
						}

						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}


				//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				//flag_shadow[i_1] = flag[i_1];
				//}



				//integer i3 = 1;
				//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
				//integer i4 = n_a[ilevel - 1];
				//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


				// Ищем только среди ближайшего окружения вновь добавленного F узла.
				//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

				// Старая реализация которой присуща большая нагрузка на операторы new && delete.
				if (0) {
					for (integer js = 1; js < ic; js++) {

						// см. новый вариант от 10 января 2016.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						List *lsos = NULL;
						List *lsos_head = NULL;
						lsos = new List;
						lsos->prev = NULL;
						lsos_head = lsos;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_11;
							//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
							//istart2++;
							istart2 = row_startA[Amat[ii_11].i];
							bool bvisitsos = false;
							for (integer is0 = istart2; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
								if (flag[Amat[is0].j] == false) {
									lsos->next = NULL;
									lsos->i = Amat[is0].j;
									lsos->ii = row_startA[lsos->i];
									// lsos->countsosed // не используется.
									List *newnodesos = new List;
									newnodesos->prev = lsos;
									lsos->next = newnodesos;
									newnodesos->next = NULL;
									lsos = lsos->next;
									newnodesos = NULL;
									bvisitsos = true;
								}
							}
							if (bvisitsos) {

								List *delsos = lsos;
								lsos = lsos->prev;
								lsos->next = NULL;
								delsos->prev = NULL;
								delete delsos;
								delsos = NULL;
							}
							else {
								// Нет ни одного соседа
								lsos_head = NULL;
								delete lsos;
								lsos = NULL;
							}
						}

						lsos = lsos_head;
						// ищем соседа узла set[js].
						//for (integer i5 = i3; i5 <= i4; i5++) {
						while (lsos != NULL) {


							//integer isc = Amat[ii_2].i;
							//integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//integer isc = i5;

							integer isc = lsos->i;
							integer ii_2 = lsos->ii;


							//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
							//if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend7 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend7) && (Amat[is0].i == Amat[ii_2].i); is0++) {
								if (Amat[is0].j == set[js]) {
									ic2++;
								}
							}

							data_BalTree dsearch;
							dsearch.countsosed = count_sosed[isc];
							//dsearch.ii = ii_2;
							dsearch.i = isc;
							count_sosed[isc] += ic2;
							data_BalTree dadd;
							dadd.countsosed = count_sosed[isc];
							//dadd.ii = ii_2;
							dadd.i = isc;

							//node<integer>* fibo_n;
							if (bmaxsosedinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_sosed[isc] >= Maximumsosedcount) {
									Maximumsosedcount = count_sosed[isc];
								}

								// Добавляем соседа в любом случае
								// позволило существенным образом 
								// ускорить алгоритм. Если раньше 
								// old = 48595  | 21229
								// new = 433315 | 63031
								// new2 = 19434 | 3698
								// и основное время уходило на old
								// то теперь
								// old = 1449 | 1466
								// new = 472600 | 64525
								// new2= 56544 | 18431
								// Время решения 3D задачи с 1M неизвестными 
								// сократилось с 6мин 48с до 4мин 45с.
								//node<integer>* fibo_n;

								if (bAVL) {

									TreapNode* nrt_temp = NULL;
									TreapNode* save_root = NULL;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1]+1) + (dadd.i );
									integer  veb_dsearch_key = (dsearch.countsosed )*(n_a[ilevel - 1]+1) + (dsearch.i );

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree) {
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									case BINARY_HEAP:
										if (binary_heap.isfound(isc)) {
											// Найден
											// Удаляем существующий элемент и вставляем новый.
											binary_heap.remove(isc);
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_sosed[isc], isc);
										}
										else {
											// отсутствует.
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_sosed[isc], isc);
										}
										break;
									case RANDOM_TREE_ID:
										nrt_temp = NULL;
										save_root = random_tree_root;
										nrt_temp = search(random_tree_root, dsearch);
										random_tree_root = save_root;
										save_root = NULL;
										if (nrt_temp == NULL) {
											// Элемент в дереве отсутствует.
											random_tree_root=insert(random_tree_root, dadd);
										}
										else {
											nrt_temp = NULL;
											// Удаление
											random_tree_root=deleteNode(random_tree_root, dsearch);
											// Вставка
											random_tree_root=insert(random_tree_root, dadd);
										}
										break;
									case RED_BLACK_TREE_ID:
										RBroot.InsertAndModify(dadd, dsearch);
										break;
									case FIBONACCI_HEAP_ID:
										fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
										//RBroot.InsertAndModify(dadd, dsearch);
										break;
									case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
										res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
										if (!res_vanEMDE_BOAS_Tree) {
											// не найден
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
										}
										else {
											res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
												system("pause");
											}
											// найден, удален м вставлен == заменен.
											res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
										}
#endif
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}


							}
							//}
							lsos = lsos->next;
						}

						// Уничтожение lsos
						// Список постепенно уничтожается с головы.
						lsos = lsos_head;
						while (lsos != NULL) {
							lsos_head = lsos_head->next;
							if (lsos_head != NULL) {
								lsos_head->prev = NULL;
							}
							lsos->next = NULL;
							delete lsos;
							lsos = lsos_head;
						}

					}
				}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

						// см.ниже  новый вариант от 10 января 2016.
						// 7 января 2016.
						// Новая версия в которой я избавился от лишних оператров new&&delete.
						// Никаких дублирующих линейных списков, никаких операторов new && delete.
						// Код стал намного понятнее.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_sosed[isc] += ic2;
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1] + 1) + (dadd.i);
									integer  veb_dsearch_key = (dsearch.countsosed)*(n_a[ilevel - 1] + 1) + (dsearch.i);

									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.
										//node<integer>* fibo_n;

										if (bAVL) {

											TreapNode* nrt_temp = NULL;
											TreapNode* save_root = NULL;

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
											case BINARY_HEAP:
												if (binary_heap.isfound(isc)) {
													// Найден
													// Удаляем существующий элемент и вставляем новый.
													binary_heap.remove(isc);
													// Осуществляем вставку нового элемента.
													binary_heap.insert(count_sosed[isc], isc);
												}
												else {
													
													// отсутствует.
													// Осуществляем вставку нового элемента.
													binary_heap.insert(count_sosed[isc], isc);
												}
												break;
											case RANDOM_TREE_ID:
												nrt_temp = NULL;
												save_root = random_tree_root;
												nrt_temp = search(random_tree_root, dsearch);
												random_tree_root = save_root;
												save_root = NULL;
												if (nrt_temp == NULL) {
													// Элемент в дереве отсутствует.
													random_tree_root=insert(random_tree_root, dadd);
												}
												else {
													nrt_temp = NULL;
													// Удаление
													random_tree_root = deleteNode(random_tree_root, dsearch);
													// Вставка
													random_tree_root=insert(random_tree_root, dadd);
												}
												break;
											case RED_BLACK_TREE_ID:
												RBroot.InsertAndModify(dadd, dsearch);
												break;
											case FIBONACCI_HEAP_ID:
												fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);											
												
												//RBroot.InsertAndModify(dadd, dsearch);
												break;
											case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
												res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
												if (!res_vanEMDE_BOAS_Tree) {
													// не найден
													res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) {
														// не найден
														res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
														if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
													}
												}
												else {
													res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
													if (!res_vanEMDE_BOAS_Tree) {
														printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
														system("pause");
													}
													// найден, удален м вставлен == заменен.
													res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
												}

#endif
												break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}

											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}


									}

								}
							}

						}
					}

				}
				else if (0) {
					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								// При таком подходе некоторые соседи инкрементируются дважды и это
								// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
								// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
								// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.countsosed = count_sosed[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_sosed[isc] += ic2;
								data_BalTree dadd;
								dadd.countsosed = count_sosed[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;

								// Уникальный ключ для дерева ван Эмде Боаса.
								integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1] + 1) + (dadd.i);
								integer  veb_dsearch_key = (dsearch.countsosed)*(n_a[ilevel - 1] + 1) + (dsearch.i);

								//node<integer>* fibo_n;

								if (bAVL) {

									TreapNode* nrt_temp = NULL;
									TreapNode* save_root = NULL;

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree)
									{
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
										break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									case BINARY_HEAP:
										if (binary_heap.isfound(isc)) {
											// Найден
											// Удаляем существующий элемент и вставляем новый.
											binary_heap.remove(isc);
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_sosed[isc], isc);
										}
										else {
											// отсутствует.
											// Осуществляем вставку нового элемента.
											binary_heap.insert(count_sosed[isc], isc);
										}
										break;
									case RANDOM_TREE_ID:
										nrt_temp = NULL;
										save_root = random_tree_root;
										nrt_temp = search(random_tree_root, dsearch);
										random_tree_root = save_root;
										save_root = NULL;
										if (nrt_temp == NULL) {
											// Элемент в дереве отсутствует.
											random_tree_root=insert(random_tree_root, dadd);
										}
										else {
											nrt_temp = NULL;
											// Удаление
											random_tree_root = deleteNode(random_tree_root, dsearch);
											// Вставка
											random_tree_root=insert(random_tree_root, dadd);
										}
										break;
									case RED_BLACK_TREE_ID:
										RBroot.InsertAndModify(dadd, dsearch);
										break;
									case FIBONACCI_HEAP_ID:
										fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
										
										//RBroot.InsertAndModify(dadd, dsearch);
										break;
									case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
										res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
										if (!res_vanEMDE_BOAS_Tree) {
											// не найден
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
										}
										else {
											res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
												system("pause");
											}
											// найден, удален м вставлен == заменен.
											res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
											if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
										}
#endif
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}

								if (bmaxsosedinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_sosed[isc] >= Maximumsosedcount) {
										Maximumsosedcount = count_sosed[isc];
									}
								}

							}

						}
					}
				}
				else if (1) {
					//printf("additional and modify new neighbour\n");

					// 10 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
					// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
					// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
					integer itop_stack2 = 0;

					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						//integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						//while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						//istart3++;
						istart3 = row_startA[Amat[ii_11].i];
						bool bvisitsos = false;
						for (integer is0 = istart3; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
							//for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							// В пересечении с U!!!
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;

								if ((my_amg_manager.ipatch_number==1)||(my_amg_manager.ipatch_number == 2)) {
								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах :
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
									hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;
									// закомментированный лучше.
								}
								if (1) {
									//21_12_2016
									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									//istart2++;
									istart2 = row_startA[Amat[ii_2].i];
									integer istopmarker2 = row_startA[Amat[ii_2].i + 1] - 1;

									if (0) {
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j == set[js]) {
												ic2++;
											}
										}
									}
									else if (0) {
										// 21 _12_2016
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if (fabs(Amat[is01].aij) > max_vnediagonal33) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (fabs(Amat[is01].aij) > theta*max_vnediagonal33) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else if ((my_amg_manager.ipatch_number == 2)) {
										// 22 _12_2016
										// Это лучший вариант : обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > theta*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else {
										// 22 _12_2016
										// Это лучший вариант : обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											// 0.2375 импирически подобрана для passive module 6.
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > 0.2375*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									// Увеличиваем на количество связей с новыми F узлами.
									count_sosed[isc] += ic2;
									//if (ic2 > 0) {
									//count_sosed[isc] += 1;
									//}
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1] + 1) + (dadd.i);
									integer  veb_dsearch_key = (dsearch.countsosed)*(n_a[ilevel - 1] + 1) + (dsearch.i);

									//node<integer>* fibo_n;

									if (bAVL) {

										TreapNode* nrt_temp = NULL;
										TreapNode* save_root = NULL;

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										case BINARY_HEAP:
											if (binary_heap.isfound(isc)) {
												// Найден
												binary_heap.modify(isc, count_sosed[isc]);
												// Удаляем существующий элемент и вставляем новый.
												//binary_heap.remove(isc);
												// Осуществляем вставку нового элемента.
												//binary_heap.insert(count_sosed[isc], isc);
											}
											else {
												// отсутствует.
												// Осуществляем вставку нового элемента.
												binary_heap.insert(count_sosed[isc], isc);
											}
											break;
										case RANDOM_TREE_ID:
											nrt_temp = NULL;
											save_root = random_tree_root;
											nrt_temp = search(random_tree_root, dsearch);
											random_tree_root = save_root;
											save_root = NULL;
											if (nrt_temp == NULL) {
												// Элемент в дереве отсутствует.
												random_tree_root=insert(random_tree_root, dadd);
											}
											else {
												nrt_temp = NULL;
												// Удаление
												random_tree_root = deleteNode(random_tree_root, dsearch);
												// Вставка
												random_tree_root=insert(random_tree_root, dadd);
											}
											break;
										case RED_BLACK_TREE_ID:
											RBroot.InsertAndModify(dadd, dsearch);
											break;
										case FIBONACCI_HEAP_ID:
											fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
											//RBroot.InsertAndModify(dadd, dsearch);
											break;
										case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) {
													// не найден
													res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
												}
											}
											else {
												res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
												if (!res_vanEMDE_BOAS_Tree) {
													printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
													system("pause");
												}
												// найден, удален м вставлен == заменен.
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
#endif
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}
									}
								}
							}
							else {
								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах :
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
								    hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;
									// закомментированный лучше.
									//}
									//if (1) {
									//21_12_2016
									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									//istart2++;
									istart2 = row_startA[Amat[ii_2].i];
									integer istopmarker2 = row_startA[Amat[ii_2].i + 1] - 1;

									if (0) {
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j == set[js]) {
												ic2++;
											}
										}
									}
									else if (0) {
										// 21 _12_2016
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if (fabs(Amat[is01].aij) > max_vnediagonal33) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (fabs(Amat[is01].aij) > theta*max_vnediagonal33) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else if (0) {
										// 22 _12_2016
										// Это лучший вариант : обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > theta*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}
									else {
										// 22 _12_2016
										// Это лучший вариант : обеспечивает корректное построение иерархии
										// уровней на задаче passive module 6 в то время как все остальные 
										// отличные от этого способа давали сбой.
										doublerealT max_vnediagonal33 = -1.0e30;
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											if (Amat[is01].j != Amat[is01].i) {
												if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > max_vnediagonal33)) {
													max_vnediagonal33 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= istopmarker2); is01++) {
											// 0.2375 импирически подобрана для passive module 6.
											if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > 0.2375*max_vnediagonal33)) {
												if (Amat[is01].j == set[js]) {
													if ((my_amg_manager.ipatch_number == 7) && (bStrongTransposeON)) {
														if (js < ic_end_F_SiTranspose) {
															// Увеличиваем счётчики только тех соседей F узлов которые
															// являются соседями F узлов которые были получены из Si_Transpose связей.
															// Именно так написано у Руге и Стубена.
															ic2++;
														}
													}
													else {
														ic2++;
													}
													//ic2++;
												}
											}
											// уменьшить счетчик weakly соседа ?
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									// Увеличиваем на количество связей с новыми F узлами.
									count_sosed[isc] += ic2;
									//if (ic2 > 0) {
									//count_sosed[isc] += 1;
									//}
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									// Уникальный ключ для дерева ван Эмде Боаса.
									integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1] + 1) + (dadd.i);
									integer  veb_dsearch_key = (dsearch.countsosed)*(n_a[ilevel - 1] + 1) + (dsearch.i);

									//node<integer>* fibo_n;

									if (bAVL) {

										TreapNode* nrt_temp = NULL;
										TreapNode* save_root = NULL;

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										case BINARY_HEAP:
											if (binary_heap.isfound(isc)) {
												// Найден
												// Удаляем существующий элемент и вставляем новый.
												binary_heap.remove(isc);
												// Осуществляем вставку нового элемента.
												binary_heap.insert(count_sosed[isc], isc);
											}
											else {
												// отсутствует.
												// Осуществляем вставку нового элемента.
												binary_heap.insert(count_sosed[isc], isc);
											}
											break;
										case RANDOM_TREE_ID:
											nrt_temp = NULL;
											save_root = random_tree_root;
											nrt_temp = search(random_tree_root, dsearch);
											random_tree_root = save_root;
											save_root = NULL;
											if (nrt_temp == NULL) {
												// Элемент в дереве отсутствует.
												random_tree_root=insert(random_tree_root, dadd);
											}
											else {
												nrt_temp = NULL;
												// Удаление
												random_tree_root = deleteNode(random_tree_root, dsearch);
												// Вставка
												random_tree_root=insert(random_tree_root, dadd);
											}
											break;
										case RED_BLACK_TREE_ID:
											RBroot.InsertAndModify(dadd, dsearch);
											break;
										case FIBONACCI_HEAP_ID:
											fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
											//RBroot.InsertAndModify(dadd, dsearch);
											break;
										case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
											res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
											if (!res_vanEMDE_BOAS_Tree) {
												// не найден
												res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) {
													// не найден
													res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
													if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
												}
											}
											else {
												res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
												if (!res_vanEMDE_BOAS_Tree) {
													printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
													system("pause");
												}
												// найден, удален м вставлен == заменен.
												res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
												if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
											}
#endif
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}
									}
								}
							}

							}

						}
					}

					// Очистка (восстановление хеш таблицы).
                     // НИ в коем случае не параллелить по OPENMP в этом месте.!!!
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				} // the end
				else {
					// 13 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
					// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
					// Это было при magic=0.4
					// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
					integer itop_stack2 = 0;

					if (bpositive_connections_CF_decomp) {

						// На основе  старого варианта просто очищенного от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							doublerealT threshold9 = -1.0;
							if (!btreshold_on_new_vetv) {
								for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
									if (Amat[is0].j != Amat[ii_11].i) {
										if (fabs(Amat[is0].aij) > threshold9) {
											threshold9 = fabs(Amat[is0].aij);
										}
									}
								}
							}
							else {
								// Новейшая ветвь кода: 11.06.2017.
								threshold9 = threshold_quick_all[Amat[ii_11].i];
							}



							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (fabs(Amat[is0].aij) > theta*threshold9) {
									if (flag[Amat[is0].j] == false) {


										integer isc = Amat[is0].j;

										// Избавляемся от повторных инкрементаций.
										// В 2D на пятиточечном шаблоне повторные инкрементации составляют
										// около 33%.
										// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
										// на ряде тестовых задач при таком подходе агломерация проходила очень
										// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
										// Эта проблема проявилась на задачах :
										// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
										// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
										// Проблема не в этом месте кода.
										if (hash_table2[isc] == false) {
											hash_table2[isc] = true;
											istack2[itop_stack2] = isc;
											itop_stack2++;

											integer ii_2 = row_startA[isc];


											integer ic2 = 0;
											integer iend2loc = nnz_a[ilevel - 1] + iadd;
											integer istart2 = ii_2;
											while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
											istart2++;
											// Определяем модуль максимального внедиагонального элемента.
											doublerealT threshold_loc1 = -1.0; // инициализация порога.
											if (!btreshold_on_new_vetv) {
												for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
													// Только внедиагональные элементы.
													if (Amat[is01].j != Amat[ii_2].i) {
														if (fabs(Amat[is01].aij) > threshold_loc1) {
															threshold_loc1 = fabs(Amat[is01].aij);
														}
													}
												}
											}
											else {
												// Новейшая ветвь кода: 11.06.2017.
												threshold_loc1 = threshold_quick_all[Amat[ii_2].i];
											}
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (Amat[is01].j == set[js]) {
														// только Strong связи
														// по крайней мере именно так рекомендуют в литературе.
														if (fabs(Amat[is01].aij) > theta*threshold_loc1) {
															ic2++;
														}
													}
												}
											}

											if (ic2 > 0) {
												// Только если были Strong связи приводящие к инкрементации счётчика ic2.


												data_BalTree dsearch;
												dsearch.countsosed = count_sosed[isc];
												//dsearch.ii = ii_2;
												dsearch.i = isc;
												count_sosed[isc] += ic2;
												data_BalTree dadd;
												dadd.countsosed = count_sosed[isc];
												//dadd.ii = ii_2;
												dadd.i = isc;

												// Уникальный ключ для дерева ван Эмде Боаса.
												integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1] + 1) + (dadd.i);
												integer  veb_dsearch_key = (dsearch.countsosed)*(n_a[ilevel - 1] + 1) + (dsearch.i);

												//node<integer>* fibo_n;

												if (bAVL) {

													TreapNode* nrt_temp = NULL;
													TreapNode* save_root = NULL;

													// добавляем элемент в АВЛ дерево,
													// причём если элемент уже находился в дереве то он модифицируется.
													// 12 декабря 2015.
													// Добавление узла происходит за логарифмическое по основанию 2 время,
													// причём после добавления дерево остаётся сбалансированным.
													// Адельсон-Вельский и Ландис 1962.
													switch (id_tree)
													{
													case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
														break;
													case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
														break;
													case BINARY_HEAP:
														if (binary_heap.isfound(isc)) {
															// Найден
															// Удаляем существующий элемент и вставляем новый.
															binary_heap.remove(isc);
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_sosed[isc], isc);
														}
														else {
															// отсутствует.
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_sosed[isc], isc);
														}
														break;
													case RANDOM_TREE_ID:
														nrt_temp = NULL;
														save_root = random_tree_root;
														nrt_temp = search(random_tree_root, dsearch);
														random_tree_root = save_root;
														save_root = NULL;
														if (nrt_temp == NULL) {
															// Элемент в дереве отсутствует.
															random_tree_root=insert(random_tree_root, dadd);
														}
														else {
															nrt_temp = NULL;
															// Удаление
															random_tree_root = deleteNode(random_tree_root, dsearch);
															// Вставка
															random_tree_root=insert(random_tree_root, dadd);
														}
														break;
													case RED_BLACK_TREE_ID:
														RBroot.InsertAndModify(dadd, dsearch);
														break;
													case FIBONACCI_HEAP_ID:
														fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
														//RBroot.InsertAndModify(dadd, dsearch);
														break;
													case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
														res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
														if (!res_vanEMDE_BOAS_Tree) {
															// не найден
															res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) {
																// не найден
																res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
																if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
															}
														}
														else {
															res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
															if (!res_vanEMDE_BOAS_Tree) {
																printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
																system("pause");
															}
															// найден, удален м вставлен == заменен.
															res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
														}
#endif
														break;
													default: root = insert_and_modify(root, dadd, dsearch);
														break;
													}
													if (bAVL_deb)
													{
														printf("insert and modify\n");
													}
												}
											}

											if (bmaxsosedinfoactive) {
												// Обновляем информацию о максимальном количестве соседей.
												if (count_sosed[isc] >= Maximumsosedcount) {
													Maximumsosedcount = count_sosed[isc];
												}
											}
										}

									}
								}

							}


						}
					}
					else {

						// На основе  старого варианта просто очищенного от устаревшего кода.
						for (integer js = 1; js < ic; js++) {

							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							doublerealT threshold9 = -1.0;
							if (!btreshold_on_new_vetv) {
								for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
									if (Amat[is0].j != Amat[ii_11].i) {
										if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > threshold9)) {
											threshold9 = fabs(Amat[is0].aij);
										}
									}
								}
							}
							else {
								// Новейшая ветвь кода: 11.06.2017.
								threshold9 = threshold_quick_only_negative[Amat[ii_11].i];
							}



							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > theta*threshold9)) {
									if (flag[Amat[is0].j] == false) {


										integer isc = Amat[is0].j;

										// Избавляемся от повторных инкрементаций.
										// В 2D на пятиточечном шаблоне повторные инкрементации составляют
										// около 33%.
										// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
										// на ряде тестовых задач при таком подходе агломерация проходила очень
										// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
										// Эта проблема проявилась на задачах :
										// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
										// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
										// Проблема не в этом месте кода.
										if (hash_table2[isc] == false) {
											hash_table2[isc] = true;
											istack2[itop_stack2] = isc;
											itop_stack2++;

											integer ii_2 = row_startA[isc];


											integer ic2 = 0;
											integer iend2loc = nnz_a[ilevel - 1] + iadd;
											integer istart2 = ii_2;
											while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
											istart2++;
											// Определяем модуль максимального внедиагонального элемента.
											doublerealT threshold_loc1 = -1.0; // инициализация порога.
											if (!btreshold_on_new_vetv) {
												for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
													// Только внедиагональные элементы.
													if (Amat[is01].j != Amat[ii_2].i) {
														if ((Amat[is01].aij < 0.0) && (fabs(Amat[is01].aij) > threshold_loc1)) {
															threshold_loc1 = fabs(Amat[is01].aij);
														}
													}
												}
											}
											else {
												// Новейшая ветвь кода: 11.06.2017.
												threshold_loc1 = threshold_quick_only_negative[Amat[ii_2].i];
											}
											for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
												// Только внедиагональные элементы.
												if (Amat[is01].j != Amat[ii_2].i) {
													if (Amat[is01].j == set[js]) {
														// только Strong связи
														// по крайней мере именно так рекомендуют в литературе.
														if ((Amat[is01].aij<0.0) && (fabs(Amat[is01].aij) > theta*threshold_loc1)) {
															ic2++;
														}
													}
												}
											}

											if (ic2 > 0) {
												// Только если были Strong связи приводящие к инкрементации счётчика ic2.


												data_BalTree dsearch;
												dsearch.countsosed = count_sosed[isc];
												//dsearch.ii = ii_2;
												dsearch.i = isc;
												count_sosed[isc] += ic2;
												data_BalTree dadd;
												dadd.countsosed = count_sosed[isc];
												//dadd.ii = ii_2;
												dadd.i = isc;

												// Уникальный ключ для дерева ван Эмде Боаса.
												integer  veb_dadd_key = (dadd.countsosed)*(n_a[ilevel - 1] + 1) + (dadd.i);
												integer  veb_dsearch_key = (dsearch.countsosed)*(n_a[ilevel - 1] + 1) + (dsearch.i);

												//node<integer>* fibo_n;

												if (bAVL) {

													TreapNode* nrt_temp = NULL;
													TreapNode* save_root = NULL;

													// добавляем элемент в АВЛ дерево,
													// причём если элемент уже находился в дереве то он модифицируется.
													// 12 декабря 2015.
													// Добавление узла происходит за логарифмическое по основанию 2 время,
													// причём после добавления дерево остаётся сбалансированным.
													// Адельсон-Вельский и Ландис 1962.
													switch (id_tree)
													{
													case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
														break;
													case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
														break;
													case BINARY_HEAP:
														if (binary_heap.isfound(isc)) {
															// Найден
															// Удаляем существующий элемент и вставляем новый.
															binary_heap.remove(isc);
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_sosed[isc], isc);
														}
														else {
															// отсутствует.
															// Осуществляем вставку нового элемента.
															binary_heap.insert(count_sosed[isc], isc);
														}
														break;
													case RANDOM_TREE_ID:
														nrt_temp = NULL;
														save_root = random_tree_root;
														nrt_temp = search(random_tree_root, dsearch);
														random_tree_root = save_root;
														save_root = NULL;
														if (nrt_temp == NULL) {
															// Элемент в дереве отсутствует.
															random_tree_root=insert(random_tree_root, dadd);
														}
														else {
															nrt_temp = NULL;
															// Удаление
															random_tree_root=deleteNode(random_tree_root, dsearch);
															// Вставка
															random_tree_root=insert(random_tree_root, dadd);
														}
														break;
													case RED_BLACK_TREE_ID:
														RBroot.InsertAndModify(dadd, dsearch);
														break;
													case FIBONACCI_HEAP_ID:
														fibo_heap.insert_and_modify(-veb_dsearch_key, -veb_dadd_key);
														
														//RBroot.InsertAndModify(dadd, dsearch);
														break;
													case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
														res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dsearch_key);
														if (!res_vanEMDE_BOAS_Tree) {
															// не найден
															res_vanEMDE_BOAS_Tree = vEB_find(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) {
																// не найден
																res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
																if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
															}
														}
														else {
															res_vanEMDE_BOAS_Tree = vEB_delete(vanEMDE_BOAS_Tree, veb_dsearch_key);
															if (!res_vanEMDE_BOAS_Tree) {
																printf("nevozmochno udalit post factum delete %lld\n", veb_dsearch_key);
																system("pause");
															}
															// найден, удален м вставлен == заменен.
															res_vanEMDE_BOAS_Tree = vEB_insert(vanEMDE_BOAS_Tree, veb_dadd_key);
															if (!res_vanEMDE_BOAS_Tree) printf("insert problem veb %lld\n", veb_dadd_key);
														}
#endif
														break;
													default: root = insert_and_modify(root, dadd, dsearch);
														break;
													}
													if (bAVL_deb)
													{
														printf("insert and modify\n");
													}
												}
											}

											if (bmaxsosedinfoactive) {
												// Обновляем информацию о максимальном количестве соседей.
												if (count_sosed[isc] >= Maximumsosedcount) {
													Maximumsosedcount = count_sosed[isc];
												}
											}
										}

									}
								}

							}


						}


					}

					// Очистка (восстановление хеш таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				}

				if (set != NULL) {
					delete[] set;
					set = NULL;
				}

				n_coarce++; // Увеличено количество С узлов.

							// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
						   //if (maxsosed == -1) {
#if doubleintprecision == 1
						   //printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
						   //printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
						   
						   //system("pause");
						   //}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxsosed = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

			// На основе линейного поиска (медленный вариант на больших размерностях).

			const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			integer* ipool = new integer[ipool_size_limit];

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			if (i_7 < ipool_size_limit) {
			if (ipool[i_7] == icandidateq) {
			found1 = true;
			}
			}
			else {
			#if doubleintprecision == 1
				printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;
			if (isize_p < ipool_size_limit) {
			ipool[isize_p] = icandidateq;
			}
			else {
			#if doubleintprecision == 1
				printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			ii_c++;
			}
			}
			delete[] ipool;

			}
			else if (0){

			// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

			// На основе АВЛ дерева.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			node_AVL_Gus* root_Gus = 0;

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			found1 = isfound_Gus(root_Gus, icandidateq);
			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			root_Gus = insert_Gus(root_Gus, icandidateq);

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

			// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

			// На основе hash таблицы.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			//node_AVL_Gus* root_Gus = 0;
			// Нельзя это вызывать это очень медленно.
			//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
			integer itop = 0; // указатель на вершину стека.

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			//found1 = isfound_Gus(root_Gus, icandidateq);
			found1 = hash_table[icandidateq - iadd];

			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			//root_Gus = insert_Gus(root_Gus, icandidateq);
			hash_table[icandidateq - iadd] = true;
			if (itop < istack_size_limit ) {
			istack[itop] = icandidateq - iadd;
			itop++;
			}
			else {
			printf("itop>=istack_size_limit nado uvelichit istack_size_limit");
			}

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			//clear_AVL_Gus(root_Gus);
			//root_Gus = 0;

			for (integer isc = itop - 1; isc >= 0; isc--) {
			hash_table[istack[isc]] = false;
			}
			itop = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			*/




			//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxsosedinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				TreapNode* emax_random_tree = NULL;
				TreapNode* save_root = NULL;
				data_BalTree dbt_emax;// , dbt_emax2;

				integer ui_emax;

				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				case BINARY_HEAP:
					if (!binary_heap.empty()) {
						// Куча не пуста.
						icandidate = row_startA[binary_heap.readkeymaxelm()];
					}
					else {
						size_splay_Tree = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;
					}
					break;
				case RANDOM_TREE_ID:  
					save_root = random_tree_root;
					if (emax_random_tree!=NULL) {
					   delete[] emax_random_tree;
					   emax_random_tree=NULL;
					}
 					emax_random_tree = findmax_random_tree(random_tree_root);
					random_tree_root = save_root;
					save_root = NULL;

					break;
				case RED_BLACK_TREE_ID:
					dbt_emax = RBroot.GetMaxElm();
					break;
				case FIBONACCI_HEAP_ID:
					if (fibo_heap.isEmpty()) {
						dbt_emax.i = -1;
					//	fibo_heap.~FibonacciHeap();
					}
					else {
						ui_emax = -fibo_heap.getMinimum();
						dbt_emax.i = ((ui_emax) % (n_a[ilevel - 1] + 1));
						dbt_emax.countsosed = ((ui_emax) / (n_a[ilevel - 1] + 1));

						//if (dbt_emax.countsosed < 4) {
							//printf("Hipo\n");
							///getchar();
						//}

						//dbt_emax2 = RBroot.GetMaxElm();
						//if ((dbt_emax.countsosed != dbt_emax2.countsosed) || (dbt_emax.i!= dbt_emax2.i)) {
						  //  printf("%d %d %d %d\n", dbt_emax.countsosed, dbt_emax.i, dbt_emax2.countsosed, dbt_emax2.i);
						    //getchar();
						//}

						//if ((flag[Amat[row_startA[dbt_emax.i]].i] == true)) dbt_emax.i = -1;

						//printf(" %d %d\n",  dbt_emax.countsosed, dbt_emax.i);
						//getchar();
					}
					break;
				case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
					if (!((vanEMDE_BOAS_Tree == NULL) || (vanEMDE_BOAS_Tree->summary == NULL) || (vanEMDE_BOAS_Tree->cluster == NULL))) {
						vEB_max(vanEMDE_BOAS_Tree, ui_emax);
						if (ui_emax <= 0) {
							// дерево ван Эмде Боаса пустое.
							dbt_emax.i = -1;
							dbt_emax.countsosed = -1;
						}
						else {
							dbt_emax.i = ((ui_emax) % (n_a[ilevel - 1] + 1));
							dbt_emax.countsosed = ((ui_emax) / (n_a[ilevel - 1] + 1));
						}

					}
					else {
						// дерево ван Эмде Боаса пустое.
						dbt_emax.i = -1;
						dbt_emax.countsosed = -1;
					}
#endif
					break;
				default: emax = findmax(root);
					break;
				}


				switch (id_tree) {
				case AVL_TREE_ID:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = NULL;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				case BINARY_HEAP:
					break;
				case RANDOM_TREE_ID:
					// Random TREE
					if (emax_random_tree != NULL) {
						icandidate = row_startA[emax_random_tree->key.i];
						if (emax_random_tree!=NULL) {
					        delete emax_random_tree;
					        emax_random_tree=NULL;
					    }
						emax_random_tree = NULL;
					}
					else {
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = NULL;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;
					}
					break;
				case RED_BLACK_TREE_ID:
					if (RBroot.Find(dbt_emax)) {
						icandidate = row_startA[dbt_emax.i];
					}
					else {
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = NULL;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;
					}
					break;
				case FIBONACCI_HEAP_ID:
					if (dbt_emax.i == -1)
					{
						// Дерево пусто.
						RBroot.Clear();
						root_splay = 0;
						size_splay_Tree = 0;
						random_tree_root = NULL;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;
					}
					else {
						// искомый узел и дерево ван Эмде Боаса не пусто.
						icandidate = row_startA[dbt_emax.i];
						//printf("row_startA = %d %d\n", icandidate, dbt_emax.i);

					}
					break;
				case VAN_EMDE_BOAS_TREE_ID:
					if (dbt_emax.i == -1)
				    {
						// Дерево пусто.
					    RBroot.Clear();
					    root_splay = 0;
					    size_splay_Tree = 0;
					    random_tree_root = NULL;
					    icandidate = 0;
					    maxsosed = -1;
					    bcontinue = false;
				    }
					else {
						// искомый узел и дерево ван Эмде Боаса не пусто.
						icandidate = row_startA[dbt_emax.i];
						//printf("row_startA = %d\n", icandidate);
					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				}


				

			}

		
#if doubleintprecision == 1
			//printf("maximum number of sosed=%lld\n",maxsosed);
#else
			//printf("maximum number of sosed=%d\n",maxsosed);
#endif
			
			if (maxsosed == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxsosed == -1)) {
				bcontinue = false;
			}
			// 4 june 2016
#if doubleintprecision == 1
			//printf("icandidate=%lld, maxsosed=%lld\n",icandidate, maxsosed);
#else
			//printf("icandidate=%d, maxsosed=%d\n",icandidate, maxsosed);
#endif
			

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C-F разбиения. создано.

		/*
		if (set != NULL) {
			delete[] set;
			set = NULL;
		}
		*/

		  //delete[] count_sosed;
		if (count_sosed != NULL) {
			free(count_sosed);
			count_sosed = NULL;
		}

		  //delete[] bmarkervisit;
		if (bmarkervisit != NULL) {
			free(bmarkervisit);
			bmarkervisit = NULL;
		}

		if (bprint_mesage_diagnostic) {
			if (n_a[ilevel - 1] == 0) {
				printf("n_a is zero\n");
				system("pause");
			}
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			case BINARY_HEAP :
				binary_heap.clear();
				break;
			case RANDOM_TREE_ID:
				clear_random_tree(random_tree_root);
				random_tree_root = NULL;
				break;
			case RED_BLACK_TREE_ID:
				RBroot.Clear();
				break;
			case VAN_EMDE_BOAS_TREE_ID:
#if VEB_FLAG
				if (!((vanEMDE_BOAS_Tree == NULL) || (vanEMDE_BOAS_Tree->summary == NULL) || (vanEMDE_BOAS_Tree->cluster == NULL))) {
					vanEMDE_BOAS_Tree->~TvEB();
				}
				//vanEMDE_BOAS_Tree = NULL;
				//vanEMDE_BOAS_Tree = new TvEB(universe);
#endif
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}

		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		the_number_of_neighbors_that_are_not_C_nodes = 0;
		number_of_F_nodes_with_one_single_strong_C_neighbor = 0;
		number_of_F_nodes_with_one_single_strong_C_neighborF = 0;

		iadditionalCstatistic = 0;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			bool *bvacant_candidates = NULL;
			bvacant_candidates = new bool[n_a[ilevel - 1] + 1];
			if (bvacant_candidates == NULL) {
				printf("error memory alloc in bvacant_candidates\n");
				system("pause");
				exit(1);
			}
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) bvacant_candidates[i_1] = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (this_is_F_node[i_1] == true) {
					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;
					// старая версия до 10 января 2016.
					//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
					// 10 января 2016. на основе хеширования.
					integer i_2 = row_startA[i_1];

					bool bvisit = false;
					//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							bvisit = true;
							if (this_is_C_node[Amat[is0].j] == true) {
								icsos++;
							}
							else {
								//the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					//if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным С соседом.
												   // Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
					if ((icsos == 0) && (bvisit)) {

						// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
						// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
						// поглощены агломератами внутренних узлов и всё было впорядке.
						// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

						// Нет С соседей, этот узел станет С узлом.
						bvacant_candidates[i_1] = true;
					}
				}
			}

			if (0)
			{

				// Однопоточная версия.

				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.

				for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1] == true) {

					

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;
					// старая версия до 10 января 2016.
					//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
					// 10 января 2016. на основе хеширования.
					integer i_2 = row_startA[i_1];

					bool bvisit = false;
					//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
					integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							bvisit = true;
							if (this_is_C_node[Amat[is0].j] == true) {
								icsos++;
							}
							else {
								the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
								
							}
						}
					}
					if (icsos == 1) {
							number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным С соседом.
						
					}
					// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
					if ((icsos == 0) && (bvisit)) {

						// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
						// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
						// поглощены агломератами внутренних узлов и всё было впорядке.
						// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

						integer i_5 = 0;
						for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
							if (Amat[is0].j != Amat[i_2].i) {
								if (bvacant_candidates[Amat[is0].j]) i_5++;
							}
						}

						if (i_5 > 0) {
							// Была сделана проверка в коде и соседних узлов с признаком
							// bvacant_candidates не было обнаружено.
#if doubleintprecision == 1
							printf("problem string %lld %lld\n", Amat[i_2].i, i_1);
#else
							printf("problem string %d %d\n", Amat[i_2].i, i_1);
#endif
							
							//system("pause");
						}

						// Нет С соседей, этот узел станет С узлом.
						this_is_F_node[i_1] = false;
						this_is_C_node[i_1] = true;
						// F node стал C_node!!! Идея стандартной интерполяции 
						// приводит к уменьшению разреженности оператора Галёркина.
						bweSholdbeContinue = true;
						newCcount++;
						
					}

					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						// bvisit и так true т.к. icsos==1.
						this_is_F_node[i_1] = false;
						this_is_C_node[i_1] = true;
						bweSholdbeContinue = true;
					}



				}
			}
			else {


#ifdef _OPENMP

				// Параллельное исполнение не более чем в 40 потоков
				integer newCcount_arr[40];
				integer the_number_of_neighbors_that_are_not_C_nodes_arr[40];
				integer number_of_F_nodes_with_one_single_strong_C_neighbor_arr[40];
				bool bweSholdbeContinue_arr[40];

				for (integer i_1 = 0; i_1 < 40; i_1++) {
					newCcount_arr[i_1] = 0;
					the_number_of_neighbors_that_are_not_C_nodes_arr[i_1] = 0;
					number_of_F_nodes_with_one_single_strong_C_neighbor_arr[i_1] = 0;
					bweSholdbeContinue_arr[i_1] = false;
				}

				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) 
				{
					if (this_is_F_node[i_1] == true) {

						integer tid = omp_get_thread_num();

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						// старая версия до 10 января 2016.
						//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
						// 10 января 2016. на основе хеширования.
						integer i_2 = row_startA[i_1];

						bool bvisit = false;
						//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
						integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
						for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
							if (Amat[is0].j != Amat[i_2].i) {
								bvisit = true;
								if (this_is_C_node[Amat[is0].j] == true) {
									icsos++;
								}
								else {
									//the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
									the_number_of_neighbors_that_are_not_C_nodes_arr[tid]++;
								}
							}
						}
						if (icsos == 1) {
							//	number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
							number_of_F_nodes_with_one_single_strong_C_neighbor_arr[tid]++;
						}
						// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
						if ((icsos == 0) && (bvisit)) {

							// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
							// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
							// поглощены агломератами внутренних узлов и всё было впорядке.
							// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

							integer i_5 = 0;
							for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
								if (Amat[is0].j != Amat[i_2].i) {
									if (bvacant_candidates[Amat[is0].j]) i_5++;
								}
							}

							if (i_5 > 0) {
								// Была сделана проверка в коде и соседних узлов с признаком
								// bvacant_candidates не было обнаружено.
#if doubleintprecision == 1
								printf("problem string %lld %lld\n", Amat[i_2].i, i_1);
#else
								printf("problem string %d %d\n", Amat[i_2].i, i_1);
#endif
								
								//system("pause");
							}

							// Нет С соседей, этот узел станет С узлом.
							this_is_F_node[i_1] = false;
							this_is_C_node[i_1] = true;
							// F node стал C_node!!! Идея стандартной интерполяции 
							// приводит к уменьшению разреженности оператора Галёркина.
							//bweSholdbeContinue = true;
							//newCcount++;
							bweSholdbeContinue_arr[tid] = true;
							newCcount_arr[tid]++;
						}

						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							// bvisit и так true т.к. icsos==1.
							this_is_F_node[i_1] = false;
							this_is_C_node[i_1] = true;
							//bweSholdbeContinue = true;
							bweSholdbeContinue_arr[tid] = true;
						}

					}

				}

				for (integer i_1 = 0; i_1 < 40; i_1++) {
					newCcount += newCcount_arr[i_1];
					the_number_of_neighbors_that_are_not_C_nodes += the_number_of_neighbors_that_are_not_C_nodes_arr[i_1];
					number_of_F_nodes_with_one_single_strong_C_neighbor += number_of_F_nodes_with_one_single_strong_C_neighbor_arr[i_1];
					if (bweSholdbeContinue_arr[i_1]) {
						bweSholdbeContinue = true;
					}
				}

#else

// Параллельное исполнение не более чем в 40 потоков
integer newCcount_arr = 0;
integer the_number_of_neighbors_that_are_not_C_nodes_arr = 0;
integer number_of_F_nodes_with_one_single_strong_C_neighbor_arr = 0;
bool bweSholdbeContinue_arr = false;


// Построение пролонгации для узлов которые составляют F nodes.
// Каждый F-nodes окружён C-nodes.
for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++)
{
	if (this_is_F_node[i_1] == true) {


		// Найти соседей данного F-node которые C-node.
		integer icsos = 0;
		// старая версия до 10 января 2016.
		//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
		// 10 января 2016. на основе хеширования.
		integer i_2 = row_startA[i_1];

		bool bvisit = false;
		//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
		integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
		for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
			if (Amat[is0].j != Amat[i_2].i) {
				bvisit = true;
				if (this_is_C_node[Amat[is0].j] == true) {
					icsos++;
				}
				else {
					//the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
					the_number_of_neighbors_that_are_not_C_nodes_arr++;
				}
			}
		}
		if (icsos == 1) {
			//	number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.
			number_of_F_nodes_with_one_single_strong_C_neighbor_arr++;
		}
		// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
		if ((icsos == 0) && (bvisit)) {

			// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
			// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
			// поглощены агломератами внутренних узлов и всё было впорядке.
			// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.							

			// Нет С соседей, этот узел станет С узлом.
			this_is_F_node[i_1] = false;
			this_is_C_node[i_1] = true;
			// F node стал C_node!!! Идея стандартной интерполяции 
			// приводит к уменьшению разреженности оператора Галёркина.
			bweSholdbeContinue_arr = true;
			newCcount_arr++;
		}

		// 1 января 2015 Один сосед это недостаточно.
		// Поэтому в случае одного соседа делаем такой узел С узлом.
		if ((false) && (icsos == 1)) {
			// bvisit и так true т.к. icsos==1.
			this_is_F_node[i_1] = false;
			this_is_C_node[i_1] = true;
			//bweSholdbeContinue = true;
			bweSholdbeContinue_arr = true;
		}

	}

}

newCcount += newCcount_arr;
the_number_of_neighbors_that_are_not_C_nodes += the_number_of_neighbors_that_are_not_C_nodes_arr;
number_of_F_nodes_with_one_single_strong_C_neighbor += number_of_F_nodes_with_one_single_strong_C_neighbor_arr;
if (bweSholdbeContinue_arr) {
	bweSholdbeContinue = true;
}


#endif


			}


			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("newCcount=%lld, n_a=%lld %e\n", newCcount, n_a[ilevel - 1], 100.0*newCcount / n_a[ilevel - 1]);
#else
				printf("newCcount=%d, n_a=%d %e\n", newCcount, n_a[ilevel - 1], 100.0*newCcount / n_a[ilevel - 1]);
#endif
				
			}
			if (bvacant_candidates != NULL) {
				delete[] bvacant_candidates;
			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}


		// 01.01.2017 Алгоритм улучшения качества C-F разбиения. Проход 2. 
		// Цикл по всем F переменным, полученным после первого прохода.
		// Пусть Fi текущая F переменная и у неё множество соседей не пусто.
		// Сканируем строку элементов где Fi есть диагональный элемент.
		// Amat. Определяем порог - threshold для каждой строки.
		// В. Заносим всех сильных С соседей в специальный линейный список.
		// C. Еслимы встретили сильного F соседа  (Fj), так что Fi и Fj сильно связаны,
		// то ищем всех сильных С соседей узла Fj и формируем из них линейный список.
		// С помощью алгоритма слияния за линейное время сравниваем два предварительно отсортированных линейных
		// списка на предмет общих С узлов.
		// D. Если общий С узел есть то ничего не меняем.
		// E. Если общего сильного С узла не обнаружено то один из узлов Fi или Fj становится С узлом.
		// Среди Fi и Fj тот становится С узлом у которого больше сильных F соседей. Если С узлом стал Fj 
		// то линейный список С соседей узла Fi обновляется. Если С узлом стал узел Fi то мы заканчиваем обработку Fi 
		// возвращая всех помеченных Fj снова в F тип.
		//  30.12.2016
		// 11.06.2017 Здесь для сортировки используется библиотечный std::sort на массиве.
		if ((my_amg_manager.icoarseningtype==1)||(my_amg_manager.icoarseningtype == 3)) { // RS2 Проход 2.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1] == true) {
				// i_1 это F переменная Fi.
				//Amat.Определяем порог - threshold для каждой строки.
				doublerealT thresholdRS = -1.0;
				integer i_2 = row_startA[i_1];
				if (!bAVLST_ON) {
					// Очистка хеш таблицы.
					clear_hash_table_Gus_struct01();
					// занесение данных из линейного списка в хеш таблицу для дерева с корнем в Amat[i_2].i.
					integer imarker75_scan = 0;
					formirate_F_SiTranspose_hash_table_Gus_struct02(hash_StrongTranspose_collection1[Amat[i_2].i], imarker75_scan);
				}

				integer iend_merker_position = row_startA[Amat[i_2].i + 1] - 1;
				if (!btreshold_on_new_vetv) {
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > thresholdRS) thresholdRS = fabs(Amat[is0].aij);
							}
						}
					}
				}
				else {
					// Новейшая ветвь кода: 11.06.2017.
					thresholdRS = threshold_quick_only_negative[Amat[i_2].i];
				}
				if (thresholdRS > 0.0) {
					// Множество соседей не пусто а порог равен thresholdRS.
					hashlist_i* ivacant_F2C = NULL;
					//  В. Заносим всех сильных С соседей в специальный линейный список.
					hashlist_i* ibuffer_strongC = NULL;
					//integer ibuffer_strongC[1000];
					integer ibuffer_strongC_marker = -1;
					integer inumber_strongF_count_Fi = 0;
					//integer ibuffer_strongF[1000];
					hashlist_i* ibuffer_strongF = NULL;
					integer ibuffer_strongF_marker = -1;
					for (integer is0 = i_2; (is0 <= iend_merker_position); is0++) {
						if (Amat[is0].j != Amat[i_2].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > theta*thresholdRS) {
									if (this_is_C_node[Amat[is0].j] == true) {
										ibuffer_strongC_marker++;
										//if (ibuffer_strongC_marker < 1000) {
											//ibuffer_strongC[ibuffer_strongC_marker] = Amat[is0].j;
										//}
										//else {
											//printf("Error!!! ibuffer_strongC : buffer overflow.\n");
											//system("PAUSE");
											//exit(1);
										//}
										insertion_list_i(ibuffer_strongC, Amat[is0].j);
									}
									if (this_is_F_node[Amat[is0].j] == true) {

										if (1) {
											// Добавок 19.01.2017
											if (!bAVLST_ON) {
												if (hash_StrongTranspose_collection != NULL) {
													data_BalTreeST dat_key;
													dat_key.i = Amat[is0].j;
													if (isfound(hash_StrongTranspose_collection[Amat[is0].i], dat_key)) {
														// конец добавка 19.01.2017

															// Сильный Fj сосед найден.
															// Элементы Fi и Fj сильно связаны.
														inumber_strongF_count_Fi++;
														ibuffer_strongF_marker++;
														//if (ibuffer_strongF_marker < 1000) {
															//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
														//}
														//else {
															//printf("Error!!! ibuffer_strongF : buffer overflow.\n");
															//system("PAUSE");
															//exit(1);
														//}
														insertion_list_i(ibuffer_strongF, Amat[is0].j);
													}
												}
												else {
													// Сильный Fj сосед найден.
													// Элементы Fi и Fj сильно связаны.
													inumber_strongF_count_Fi++;
													ibuffer_strongF_marker++;
													//if (ibuffer_strongF_marker < 1000) {
													//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
													//}
													//else {
													//printf("Error!!! ibuffer_strongF : buffer overflow.\n");
													//system("PAUSE");
													//exit(1);
													//}
													insertion_list_i(ibuffer_strongF, Amat[is0].j);
												}
											}
											else {
												// Обычный линейный список.
												if (hash_StrongTranspose_collection1 != NULL) {
													data_BalTreeST dat_key;
													dat_key.i = Amat[is0].j;
													//if (isfound(hash_StrongTranspose_collection[Amat[is0].i], dat_key)) {
													if (isfound_hash_table_Gus_struct01(Amat[is0].j)) {
													    // конец добавка 19.01.2017

														// Сильный Fj сосед найден.
														// Элементы Fi и Fj сильно связаны.
														inumber_strongF_count_Fi++;
														ibuffer_strongF_marker++;
														//if (ibuffer_strongF_marker < 1000) {
														//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
														//}
														//else {
														//printf("Error!!! ibuffer_strongF : buffer overflow.\n");
														//system("PAUSE");
														//exit(1);
														//}
														insertion_list_i(ibuffer_strongF, Amat[is0].j);
													}
												}
												else {
													// Сильный Fj сосед найден.
													// Элементы Fi и Fj сильно связаны.
													inumber_strongF_count_Fi++;
													ibuffer_strongF_marker++;
													//if (ibuffer_strongF_marker < 1000) {
													//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
													//}
													//else {
													//printf("Error!!! ibuffer_strongF : buffer overflow.\n");
													//system("PAUSE");
													//exit(1);
													//}
													insertion_list_i(ibuffer_strongF, Amat[is0].j);
												}
											}
										}
										else {
											// Сильный Fj сосед найден.
											// Элементы Fi и Fj сильно связаны.
											inumber_strongF_count_Fi++;
											ibuffer_strongF_marker++;
											//if (ibuffer_strongF_marker < 1000) {
											//ibuffer_strongF[ibuffer_strongF_marker] = Amat[is0].j;
											//}
											//else {
											//printf("Error!!! ibuffer_strongF : buffer overflow.\n");
											//system("PAUSE");
											//exit(1);
											//}
											insertion_list_i(ibuffer_strongF, Amat[is0].j);
										}
									}
								}
							}
						}
					}
					// Очистка хеш таблицы.
					clear_hash_table_Gus_struct01();
					// Сортировка буффера ibuffer_strongC по возрастанию.
					integer* ibuffer_strong_C_bs = NULL;
					// рекомендуется использовать iusage_old_version = 0
					// при котором активируется использование быстродействующей хеш таблицы.
					// Достигается ускорение полного цикла решения задачи при включённом RS2 coarsening
					// на 7.5% по сравнению с двоичным поиском на массиве. 
					// Полностью отпадает необходимость в использовании алгоритма сортировки.
					// 11.06.2017.
					integer iusage_old_version = 0; // 1 старая рабочая версия. // 0 новая версия на основе хеш таблицы.
					integer i_5 = 0;
					if (iusage_old_version) {
						// Выделяем память сразу с запасом, чтобы избежать перевыделений и уничтожений.
						//ibuffer_strong_C_bs = (integer*)malloc((ibuffer_strongC_marker + ibuffer_strongF_marker + 1) * sizeof(integer));
						//handle_error<integer>(ibuffer_strong_C_bs, "ibuffer_strong_C_bs", "classic_aglomerative_amg_4", (ibuffer_strongC_marker + ibuffer_strongF_marker + 1));
						// iend_merker_position - i_2 +3
						ibuffer_strong_C_bs = (integer*)malloc((iend_merker_position - i_2 + 3) * sizeof(integer));
						handle_error<integer>(ibuffer_strong_C_bs, "ibuffer_strong_C_bs", "classic_aglomerative_amg_4", (iend_merker_position - i_2 + 3));
						hashlist_i* ibuffer_strongC_scan = ibuffer_strongC;
						i_5 = 0;
						while (ibuffer_strongC_scan != NULL) {
							ibuffer_strong_C_bs[i_5] = ibuffer_strongC_scan->item;
							i_5++;
							ibuffer_strongC_scan = ibuffer_strongC_scan->next;
						}
						ibuffer_strongC_scan = NULL;
					}
					else {
						// Вместо сортировки и двоичного поиска используем хеш таблицу.
						clear_hash_table_Gus_struct01();
						hashlist_i* ibuffer_strongC_scan = ibuffer_strongC;
						while (ibuffer_strongC_scan != NULL) {
							insert_hash_table_Gus_struct01(ibuffer_strongC_scan->item);
							ibuffer_strongC_scan = ibuffer_strongC_scan->next;
						}
						ibuffer_strongC_scan = NULL;
					}
					
					// Сортировка целочисленного массива при индексации с нуля!!!
					if (iusage_old_version) {
						/*
						if ((i_5 - 1 <= 7)) {
							// Сортировка по возрастанию.
							// Сортировка вставками до  10 элементов чрезвычайно эффективна.
							for (integer i_8 = 1; i_8 <= i_5 - 1; i_8++) {
								integer i_7 = i_8;
								while ((i_7>0)&&(ibuffer_strong_C_bs[i_7] < ibuffer_strong_C_bs[i_7 - 1])) {
									integer ibuf31 = ibuffer_strong_C_bs[i_7];
									ibuffer_strong_C_bs[i_7] = ibuffer_strong_C_bs[i_7 - 1];
									ibuffer_strong_C_bs[i_7 - 1] = ibuf31;
									i_7--;
								}
							}
						}
						else {
							// Сюда подключим библиотечную быструю сортировку
							// Это стандартная функция языка СИ.
							qsort(ibuffer_strong_C_bs, i_5, sizeof(integer), intcompare);

						}
						*/
						// 3 января 2017.
						std::sort(ibuffer_strong_C_bs, ibuffer_strong_C_bs + i_5);
					}
					// Все сильные F соседи занесены в буффер ibuffer_strongF. 
					hashlist_i* ibuffer_strongF_current = ibuffer_strongF;
					for (integer i_3 = 0; i_3 <= ibuffer_strongF_marker; i_3++) {
						if (ibuffer_strongF_current!=NULL) {
						// Сканируем всех сильных F соседей последовательно.
						//1. Определяем threshold для Fj.
						doublerealT thresholdRS1 = -1.0;
						integer i_4 = row_startA[ibuffer_strongF_current->item];
						integer iend_merker_position1 = row_startA[Amat[i_4].i + 1] - 1;
						if (!btreshold_on_new_vetv) {
							for (integer is01 = i_4; (is01 <= iend_merker_position1); is01++) {
								if (Amat[is01].j != Amat[i_4].i) {
									if (Amat[is01].aij < 0.0) {
										if (fabs(Amat[is01].aij) > thresholdRS1) thresholdRS1 = fabs(Amat[is01].aij);
									}
								}
							}
						}
						else {
							// Новейшая ветвь кода: 11.06.2017.
							thresholdRS1 = threshold_quick_only_negative[Amat[i_4].i];
						}
						integer inumber_strongF_count_Fj = 0;
						// искомый порог thresholdRS1.
						//integer ibuffer_strongCFj[1000];
						hashlist_i* ibuffer_strongCFj = NULL;
						integer ibuffer_strongCFj_marker = -1;
						for (integer is01 = i_4; (is01 <= iend_merker_position1); is01++) {
							if (Amat[is01].j != Amat[i_4].i) {
								if (Amat[is01].aij < 0.0) {
									if (fabs(Amat[is01].aij) > theta*thresholdRS1) {
										if (this_is_C_node[Amat[is01].j] == true) {
											ibuffer_strongCFj_marker++;
											insertion_list_i(ibuffer_strongCFj, Amat[is01].j);
											//if (ibuffer_strongCFj_marker < 1000) {
											//	ibuffer_strongCFj[ibuffer_strongCFj_marker] = Amat[is01].j;
											//}
											//else {
											//	printf("Error!!! ibuffer_strongCFj : buffer overflow.\n");
											//	system("PAUSE");
											//	exit(1);
											//}
										}
										if (this_is_F_node[Amat[is01].j] == true) {
											inumber_strongF_count_Fj++;
										}
									}
								}
							}
						}
						// В ibuffer_strongCFj список сильных С соседей.

						// Есть ли общие С узлы за линейное время.
						// Создаём на основе списка ibuffer_strongC
						// целочисленный массив.
						// Сортируем его. Делаем  ibuffer_strongCFj_marker 
						// двоичных поисков в этом отсортированном массиве 
						// до тех пор пока не встретится успешный поиск.
						bool bfound_32 = false;
						hashlist_i* ibuffer_strongCFj_scan = ibuffer_strongCFj;
						if (iusage_old_version) {
							while ((bfound_32 == false) && (ibuffer_strongCFj_scan != NULL)) {
								if (BinarySearch(ibuffer_strong_C_bs, ibuffer_strongCFj_scan->item, i_5 - 1) > -1) {
									// Совпадение найдено мы ничего не делаем.
									bfound_32 = true;
								}
								ibuffer_strongCFj_scan = ibuffer_strongCFj_scan->next;
							}
						}
						else {
							// Версия на основе хеш таблицы.
							while ((bfound_32 == false) && (ibuffer_strongCFj_scan != NULL)) {
								// Совпадение найдено мы ничего не делаем.
								bfound_32 = isfound_hash_table_Gus_struct01(ibuffer_strongCFj_scan->item);
								ibuffer_strongCFj_scan = ibuffer_strongCFj_scan->next;
							}
						}
						ibuffer_strongCFj_scan = NULL;
						if (bfound_32 == false) {
							// Один из них станет С узлом.
							if ((ibuffer_strongF_current->item > i_1) && (inumber_strongF_count_Fj >= inumber_strongF_count_Fi)) {
								// Если Fj находится в ещё непросмотренной части списка F узлов и
								// унего по сравнению с F узлом Fi больше сильных F связей.								

								// Fj становится С.
								insertion_list_i(ivacant_F2C, ibuffer_strongF_current->item);
								this_is_C_node[ibuffer_strongF_current->item] = true;
								this_is_F_node[ibuffer_strongF_current->item] = false;
								ibuffer_strongC_marker++;
								inumber_strongF_count_Fi--;
								insertion_list_i(ibuffer_strongC, ibuffer_strongF_current->item);
								// Переформировываем налету массив в котором делаем двоичные поиски.
								// Мы сразу выделили весь необходимый объём оперативной памяти, 
								// заранее поэтому частые malloc и free вовсе ненужны.
								// 2.01.2017
								//if (ibuffer_strong_C_bs != NULL) {
									//free(ibuffer_strong_C_bs);
								//}
								//ibuffer_strong_C_bs = (integer*)malloc((ibuffer_strongC_marker + 1) * sizeof(integer));
								//handle_error<integer>(ibuffer_strong_C_bs, "ibuffer_strong_C_bs", "classic_aglomerative_amg_4", (ibuffer_strongC_marker + 1));

								hashlist_i* ibuffer_strongC_scan = ibuffer_strongC;
								integer i_5 = 0;
								
								if (iusage_old_version) {
									
									while (ibuffer_strongC_scan != NULL) {
										ibuffer_strong_C_bs[i_5] = ibuffer_strongC_scan->item;
										i_5++;
										ibuffer_strongC_scan = ibuffer_strongC_scan->next;
									}
								}
								else {
									// Очищаем хеш таблицу и заполняем её по новой.
									clear_hash_table_Gus_struct01();
									while (ibuffer_strongC_scan != NULL) {
										insert_hash_table_Gus_struct01(ibuffer_strongC_scan->item);
										ibuffer_strongC_scan = ibuffer_strongC_scan->next;
									}
								}
									
								
								ibuffer_strongC_scan = NULL;
								// Сортировка целочисленного массива при индексации с нуля!!!
								if (iusage_old_version) {
									/*
									if ((i_5 - 1 <= 7)) {
										// Сортировка по возрастанию.
										// Сортировка вставками до  10 элементов чрезвычайно эффективна.
										for (integer i_8 = 1; i_8 <= i_5 - 1; i_8++) {
											integer i_7 = i_8;
											while ((i_7>0)&&(ibuffer_strong_C_bs[i_7] < ibuffer_strong_C_bs[i_7 - 1])) {
												integer ibuf31 = ibuffer_strong_C_bs[i_7];
												ibuffer_strong_C_bs[i_7] = ibuffer_strong_C_bs[i_7 - 1];
												ibuffer_strong_C_bs[i_7 - 1] = ibuf31;
												i_7--;
											}
										}
									}
									else {
										// Сюда подключим библиотечную быструю сортировку
										// Это стандартная функция языка СИ.
										qsort(ibuffer_strong_C_bs, i_5, sizeof(integer), intcompare);

									}
									*/
									// 3 января 2017.
									std::sort(ibuffer_strong_C_bs, ibuffer_strong_C_bs + i_5);
								}
							}
							else {
								// Fi становится С.
								this_is_C_node[i_1] = true;
								this_is_F_node[i_1] = false;
								// Возвращаем все Fj с С на F.
								hashlist_i* ivacant_F2C_marker = ivacant_F2C;
								while (ivacant_F2C_marker != NULL) {
									this_is_F_node[ivacant_F2C_marker->item] = true;
									this_is_C_node[ivacant_F2C_marker->item] = false;
									ivacant_F2C_marker = ivacant_F2C_marker->next;
								}
								ivacant_F2C_marker = NULL;
								if (ivacant_F2C != NULL) {
									clear_hash_list_i(ivacant_F2C);
									ivacant_F2C = NULL;
								}
								ivacant_F2C = NULL;
								// Очищаем ОЗУ.
								if (ibuffer_strongCFj != NULL) {
									clear_hash_list_i(ibuffer_strongCFj);
									ibuffer_strongCFj = NULL;
								}
								ibuffer_strongCFj = NULL;
								// Досрочно прерываем текущее сканирование 
								// списка сильных F узлов.
								break;
							}

						}


						// Очищаем ОЗУ.
						if (ibuffer_strongCFj != NULL) {
							clear_hash_list_i(ibuffer_strongCFj);
							ibuffer_strongCFj = NULL;
						}
						ibuffer_strongCFj = NULL;
						// Переход к следующему кандидату.
						ibuffer_strongF_current = ibuffer_strongF_current->next;
					}
					}

					// Освобождение ОЗУ.
					if (ibuffer_strong_C_bs != NULL) {
						free(ibuffer_strong_C_bs);
						ibuffer_strong_C_bs = NULL;
					}
					if (ibuffer_strongC != NULL) {
						clear_hash_list_i(ibuffer_strongC);
						ibuffer_strongC = NULL;
					}
					ibuffer_strongC = NULL;
					if (ibuffer_strongF != NULL) {
						clear_hash_list_i(ibuffer_strongF);
						ibuffer_strongF = NULL;
					}
					ibuffer_strongF = NULL;
					if (ivacant_F2C != NULL) {
						clear_hash_list_i(ivacant_F2C);
						ivacant_F2C = NULL;
					}
					ivacant_F2C = NULL;

				}
			}
		} // Алгоритм улучшения качества C-F разбиения. Проход 2.

		// TODO 22_10_2016
		
		P_injection = NULL;
		R_injection = NULL;


		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).


		C_numerate = NULL;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(C_numerate, "C_numerate", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		icounter = 1;
		ap_coarse = NULL;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			integer n_coarce15 = 0;
#pragma omp parallel for reduction(+:n_coarce15)
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (this_is_C_node[i_1]) {
					n_coarce15++;
				}
			}
			n_coarce += n_coarce15;
			n_coarce--;


			// debug
			// проверка качества C-F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");



			// C-F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполляции : 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				C_numerate[i_1] = icounter;
				icounter++;
			}

			// TODO 22_10_2016
			integer icount1_injection = 1 + iaddR;

			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
				P[icount1].aij = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;
				if (icount1 >= nsizePR*n) {
					printf("memory error!!!\n");
					printf("not enough memory for the interpolation operator.\n");
					//system("PAUSE");
					//exit(1);
					deallocate_prolongation(nsizePR, n, R, P);
				}
			}


			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			if (FUTURE_INJECTION) {
				// Это нужно для регуляции барьера barjerA.
				if (P_injection != NULL) {
					delete[] P_injection;
					P_injection = NULL;
				}
				if (R_injection != NULL) {
					delete[] R_injection;
					R_injection = NULL;
				}
				P_injection = new Ak1[numberofcoarcenodes]; // нумерация с нуля.
				R_injection = new Ak1[numberofcoarcenodes]; // нумерация с нуля.
				integer i_21 = 0;
				for (integer i_22 = icount1_injection; i_22 < icount1; i_22++) {
					P_injection[i_21] = P[i_22];
					R_injection[i_21] = P[i_22];
					i_21++;
				}
			}

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			if (ap_coarse != NULL) {
				free(ap_coarse);
				ap_coarse = NULL;
			}
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

			ap_coarse[0] = 0.0;




			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
#pragma omp parallel for
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) {
				if (this_is_C_node[i8] == true) {
					// Старая версия до 10 января 2016. Время O(log2(nnz))
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					// 10 января 2016 новая версия на основе хеширования. Время O(1).
					integer ii1 = row_startA[i8];
					// бинарный поиск должен гарантирует нахождение самого левого представителя.
					//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
					integer iend_marker_position = row_startA[Amat[ii1].i + 1] - 1;
					for (integer is0 = ii1; (is0 <= iend_marker_position); is0++) {
#if doubleintprecision == 1
						//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
						//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
						
						if (Amat[is0].j == Amat[ii1].i) {

							if (fabs(Amat[is0].aij) > RealMAXIMUM) {
								printf("perepolnenie error!");
								//getchar();
								system("pause");
							}
							ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
							//printf("find = %e", fabs(Amat[is0].aij));
						}
					}
				}
				//printf("\n");
				//getchar();
			}

#if doubleintprecision == 1
			//printf("incoming=%lld\n", my_amg_manager.number_interpolation_procedure);
#else
			//printf("incoming=%d\n", my_amg_manager.number_interpolation_procedure);
#endif
			
			//getchar();

			// верно 2 октября.

			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполляция.
				// К тому же чрезвычайно простая.

				//my_amg_manager.number_interpolation_procedure == 0
				// 0
				if (my_amg_manager.number_interpolation_procedure == 10) {
					
					// Интерполяционная процедура №10. 
					my_interpolation_procedure_number10(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel, iadd, theta, n, R, C_numerate);
				}
				//my_amg_manager.number_interpolation_procedure == 1
				// 0
				if (my_amg_manager.number_interpolation_procedure == 7) {

					// Прямая интерполляция с элементам непрямой.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если нам встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторно запускаем алгоритм построения с учётом уже добавленных С узлов.


					// Интерполяционная процедура №7. 
					my_interpolation_procedure_number7(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate);
				}
				//my_amg_manager.number_interpolation_procedure == 2
				// 0
				if (my_amg_manager.number_interpolation_procedure == 2) {
					

					// Интерполяционная процедура №2.
					my_interpolation_procedure_number2(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate, number_of_F_nodes_with_one_single_strong_C_neighborF);

				}
				//my_amg_manager.number_interpolation_procedure == 3
				// 1
				if (my_amg_manager.number_interpolation_procedure == 3) 
				{
					// Базовая, наиболее часто используемая интерполяционная процедура.

					// Интерполяционная процедура №3.
					my_interpolation_procedure_number3(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
				}

				//my_amg_manager.number_interpolation_procedure == 7
				// 1
				if (my_amg_manager.number_interpolation_procedure == 1) {
					
					// 1.04.2017
					// Главная идея в том чтобы разделить интерполяцию по знакам,
					// отдельно положительные коэффициенты и отдельно положительные,
					// в итоге учитывается и то и то.

					// Интерполяционная процедура №1.
					/*
					my_interpolation_procedure_number1(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
						*/

						// Интерполяционная процедура №3.amg1r5 Ruge-Stuben
					my_interpolation_procedure_number3B(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
				}

				if (my_amg_manager.number_interpolation_procedure == 0) {

					// 1.04.2017; 28.04.2017;
					// Главная идея в том чтобы разделить интерполяцию по знакам, отдельно положительные коэффициенты и отдельно положительные,
					// в итоге учитывается и то и то.

					// Интерполяционная процедура №0.
					/*
					my_interpolation_procedure_number0(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
					*/

					// Интерполяционная процедура №3.
					// Улучшенный базовый вариант.
					my_interpolation_procedure_number3A(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);

				}

				//my_amg_manager.number_interpolation_procedure == 4
				// 0
				if (my_amg_manager.number_interpolation_procedure == 4) {
					
					// пятая попытка (Рабочая).
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					// Интерполяционная процедура №4.
					my_interpolation_procedure_number4(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);

				}
				//my_amg_manager.number_interpolation_procedure == 5
				// 0
				if (my_amg_manager.number_interpolation_procedure == 5) {

					// Рабочая.

					// Интерполяционная процедура №5.
					my_interpolation_procedure_number5(the_number_of_neighbors_that_are_not_C_nodes,
						number_of_F_nodes_with_one_single_strong_C_neighbor,
						n_a, this_is_F_node, row_startA,
						nnz_a, bpositive_connections, Amat,
						bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
						RealZERO, icount1, P, nsizePR, ilevel,
						iadd, theta, n, R, C_numerate,
						number_of_F_nodes_with_one_single_strong_C_neighborF,
						theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
						from_re_operation_protection0, magic82, threshold_quick_all,
						threshold_quick_only_negative);
				}

			}
			else if (true) {

				// INTERPOLATION SIX

				// Экспериментальная интерполляция 1 января 2016.

				// Интерполяционная процедура №6.
				my_interpolation_procedure_number6(the_number_of_neighbors_that_are_not_C_nodes,
					number_of_F_nodes_with_one_single_strong_C_neighbor,
					n_a, this_is_F_node, row_startA,
					nnz_a, bpositive_connections, Amat,
					bweSholdbeContinue, this_is_C_node, iadditionalCstatistic,
					RealZERO, icount1, P, nsizePR, ilevel,
					iadd, theta, n, R, C_numerate,
					number_of_F_nodes_with_one_single_strong_C_neighborF,
					theta83, btreshold_on_new_vetv, ifrom_re_operation_protection,
					from_re_operation_protection0, magic82, threshold_quick_all,
					threshold_quick_only_negative);
			}
			else {
				// От интерполляции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполляции.
				// Эта интерполляция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.

				printf("interpolation SIX: Theoretical approach in Montenegro.\n");
				system("PAUSE");

				the_number_of_neighbors_that_are_not_C_nodes = 0;
				number_of_F_nodes_with_one_single_strong_C_neighbor = 0;

				if (bpositive_connections) {

					// positive connections.

					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if (fabs(Amat[is0].aij) > maxelem_threshold) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						//integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT sumPindicator = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									else {
										sumPindicator += fabs(Amat[is0].aij);
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
								}
							}
							else {
								// Диагональный элемент.
								sumP += fabs(Amat[is0].aij);
							}
						}
						//if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным  С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						//if ((false) && (icsos == 1)) {
						//this_is_F_node[i8] = false;
						//this_is_C_node[i8] = true;
						//bweSholdbeContinue = true;
						//}
						//else
						{

							if (fabs(sumPindicator) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполляция.

								// Мы не будем добалять С узлы, мы будем использовать непрямую интерполляцию.



							}
							else {

								integer icount1_frozen = icount1;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												// Strongly C connectors.

												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}


										}
									}
								}

								integer ilength_n = icount1 - icount1_frozen;
								integer* jposition_in_P = NULL;
								//jposition_in_P = new integer[ilength_n];
								jposition_in_P = (integer*)malloc(ilength_n * sizeof(integer));
								handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_4", ilength_n);



								integer i_97 = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												// Strongly C connections j position.
												jposition_in_P[i_97] = Amat[is0].j;
												i_97++;
											}
										}
									}
								}


								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {
											if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												// Strong F connections
												doublerealT my_mult = fabs(Amat[is0].aij);
												integer iFpoint = Amat[is0].j;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];

												// Смотрим всех соседей узла iFpoint
												// если среди них окажутся сильные С соседи 
												// первоначально рассматриваемого узла Amat[ii1].i
												// то мы будем накапливать в сумматоре sum23 
												// модули значеий матрицы.
												doublerealT sum23 = 0.0;
												bool bvisit23 = false;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	sum23 += fabs(Amat[is0_loc].aij);
																	bvisit23 = true;
																	break;
																}
															}
														}
													}
												}

												//if (fabs(sum23) > RealZERO) {
												if (bvisit23) {
													// мы точно не делим на ноль.

													// Сканируем всех соседей узла F.
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																for (i_97 = 0; i_97 < ilength_n; i_97++) {
																	if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																		//P[icount1_frozen + i_97].j = i8;
																		//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																		P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																		break;
																	}
																}
															}
														}
													}
												}


											}
										}
									}
								}

								//delete[] jposition_in_P;
								free(jposition_in_P);

							}

						}


					}

				}
				else {
					// only negative connections

					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						//integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT sumPindicator = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									else {
										sumPindicator += fabs(Amat[is0].aij);
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									if ((Amat[is0].aij>0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
										// Weak connectors
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																  //icsos++;
									}
									the_number_of_neighbors_that_are_not_C_nodes++; // подсчитываем проблемы интерполяции 
								}
							}
							else {
								// Диагональный элемент.
								sumP += fabs(Amat[is0].aij);
							}
						}
						//if (icsos == 1) number_of_F_nodes_with_one_single_strong_C_neighbor++; // количество F узлов с одним единственным сильным С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						//if ((false) && (icsos == 1)) {
						//this_is_F_node[i8] = false;
						//this_is_C_node[i8] = true;
						//bweSholdbeContinue = true;
						//}
						//else
						{

							if (fabs(sumPindicator) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");
								this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
								iadditionalCstatistic++;
								//exit(1);
								// здесь нужна непрямая интерполляция.

								// Мы не будем добалять С узлы, мы будем использовать непрямую интерполляцию.



							}
							else {

								integer icount1_frozen = icount1;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												// Strongly C connectors.

												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P);
												}
											}


										}
									}
								}

								integer ilength_n = icount1 - icount1_frozen;
								integer* jposition_in_P = NULL;
								//jposition_in_P = new integer[ilength_n];
								jposition_in_P = (integer*)malloc(ilength_n * sizeof(integer));
								handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_4", ilength_n);



								integer i_97 = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												// Strongly C connections j position.
												jposition_in_P[i_97] = Amat[is0].j;
												i_97++;
											}
										}
									}
								}


								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												// Strong F connections
												doublerealT my_mult = fabs(Amat[is0].aij);
												integer iFpoint = Amat[is0].j;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];

												// Смотрим всех соседей узла iFpoint
												// если среди них окажутся сильные С соседи 
												// первоначально рассматриваемого узла Amat[ii1].i
												// то мы будем накапливать в сумматоре sum23 
												// модули значеий матрицы.
												doublerealT sum23 = 0.0;
												bool bvisit23 = false;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	sum23 += fabs(Amat[is0_loc].aij);
																	bvisit23 = true;
																	break;
																}
															}
														}
													}
												}

												//if (fabs(sum23) > RealZERO) {
												if (bvisit23) {
													// мы точно не делим на ноль.

													// Сканируем всех соседей узла F.
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																for (i_97 = 0; i_97 < ilength_n; i_97++) {
																	if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																		//P[icount1_frozen + i_97].j = i8;
																		//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																		P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																		break;
																	}
																}
															}
														}
													}
												}


											}
										}
									}
								}

								//delete[] jposition_in_P;
								free(jposition_in_P);

							}

						}


					}


				} // end only negatyive connections

			}



			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				if (ap_coarse != NULL) {
					free(ap_coarse);
					ap_coarse = NULL;
				}
				if (bprint_mesage_diagnostic) {
					printf("obratnaq svqz restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes procent %3.1f", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");


		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		iend_marker_position = iaddR + nnzR - 1;

		// truncation of interpolation.
		// 30.04.2017.
		if (my_amg_manager.itruncation_interpolation==1) {

			/*
			// Однопоточный вариант работает и без сортировки, 
			// что говорит о том что оператор интерполляции уже предварительно был отсортирован по j.
			switch (imy_sort_algorithm ) {
			case COUNTING_SORT_ALG :
			   //Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1, false);
			   qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			   //HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
			case QUICK_SORT_ALG :
			        qsj(P, 1 + iaddR, iaddR + nnzR - 1);
					// Библиотечный алгоритм. O(nlog(n)).
					// Не использует лишней памяти.
					//std::sort(P + (1 + iaddR) * sizeof(Ak1), P + (iaddR + nnzR - 1+1) * sizeof(Ak1), compAi);
			break;
			case HEAP_SORT_ALG :
			    HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
			default :
			   //Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1, false);
			   qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			   //HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
			}
			*/


			// Большое число связей увеличивает сложность оператора Галеркина.
			// Наличие слабых связей в процедуре интерполляции, приводит к замедлению 
			// сходимости или расходимости.
			// Алгоритм усранения слабых связей:
			//doublerealT const alpha_truncation = 0.2;
			doublerealT alpha_truncation = my_amg_manager.truncation_interpolation;
			// Рассмотрим каждую строку оператора интерполляции.
			// Найдем сумму элементов данной строки каждого знака.
			// Найдём максимальный по модулю элемент каждого знака.
			// Удалим все элементы в операторе интерполляции каждого знака 
			// которые меньше максимального по модулю того-же знака * на alpha_truncation.
			// Проведём перемасштабирование чтобы сумма осталась неизменной.
			// Сделаем это в памяти R.
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n; i_1++) {
				flag[i_1] = false; // init flag.
			}
			integer icounter_truncation = 1 + iaddR;

			if (1) {
				// Многопоточная версия.

				integer i_size_75 = 0;
				// Это нельзя распараллелить.
				for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
					if (flag[P[ii].j] == false) {
						//row_ind_SRloc[P[ii].j] = ii;
						flag[P[ii].j] = true;
						//i_size_75++;
						if (P[ii].j > i_size_75) i_size_75 = P[ii].j;
					}
				}

#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= n; i_1++) {
					flag[i_1] = false; // init flag.
				}

				integer* row_ind_SRloc = NULL;
				//row_ind_SR = new integer[numberofcoarcenodes + 1];
				//row_ind_SRloc = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
				//handle_error<integer>(row_ind_SRloc, "row_ind_SRloc", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));
				row_ind_SRloc = (integer*)malloc((i_size_75 + 1) * sizeof(integer));
				handle_error<integer>(row_ind_SRloc, "row_ind_SRloc", "classic_aglomerative_amg_4", (i_size_75 + 1));

#if doubleintprecision == 1
				//printf("numberofcoarcenodes=%lld i_size_75=%lld\n", numberofcoarcenodes, i_size_75);
#else
				//printf("numberofcoarcenodes=%d i_size_75=%d\n", numberofcoarcenodes, i_size_75);
#endif
				
				//system("pause");
/*
#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
					row_ind_SRloc[i_1] = -1;
				}
				*/
				// inicialization
#pragma omp parallel for
				for (integer i_1 = 1; i_1 <= i_size_75; i_1++) {
					row_ind_SRloc[i_1] = -1;
				}

				
				// Это нельзя распараллелить.
				for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
					if (flag[P[ii].j] == false) {
						row_ind_SRloc[P[ii].j] = ii;
						flag[P[ii].j] = true;
					}
				}

				//for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
#pragma omp parallel for
				for (integer i_75=1; i_75<=i_size_75; i_75++) {
					if (row_ind_SRloc[i_75]!=-1) {
						integer ii = row_ind_SRloc[i_75];

					//if (flag[P[ii].j] == false) {
						//flag[P[ii].j] = true;
						integer istr_65 = P[ii].j;
						integer ii_65 = ii;
						doublerealT dsum_plus = 0.0;
						doublerealT dsum_minus = 0.0;
						doublerealT dmax_plus = -1.0;
						doublerealT dmax_minus = -1.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if (P[ii_65].aij > 0) {
								dsum_plus += P[ii_65].aij;
								if (P[ii_65].aij > dmax_plus) dmax_plus = P[ii_65].aij;
							}
							if (P[ii_65].aij < 0) {
								dsum_minus += fabs(P[ii_65].aij);
								if (fabs(P[ii_65].aij) > dmax_minus) dmax_minus = fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						ii_65 = ii;
						doublerealT dsum_plus_new = 0.0;
						doublerealT dsum_minus_new = 0.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								dsum_plus_new += fabs(P[ii_65].aij);
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								dsum_minus_new += fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						// заполнение перемасштабированными.
						ii_65 = ii;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_plus / dsum_plus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_minus / dsum_minus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							ii_65++;
						}

					}
				}

				free(row_ind_SRloc);
			    row_ind_SRloc = NULL;
			}
			else {

				// Однопоточная версия.

				for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
					if (flag[P[ii].j] == false) {
						flag[P[ii].j] = true;
						integer istr_65 = P[ii].j;
						integer ii_65 = ii;
						doublerealT dsum_plus = 0.0;
						doublerealT dsum_minus = 0.0;
						doublerealT dmax_plus = -1.0;
						doublerealT dmax_minus = -1.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if (P[ii_65].aij > 0) {
								dsum_plus += P[ii_65].aij;
								if (P[ii_65].aij > dmax_plus) dmax_plus = P[ii_65].aij;
							}
							if (P[ii_65].aij < 0) {
								dsum_minus += fabs(P[ii_65].aij);
								if (fabs(P[ii_65].aij) > dmax_minus) dmax_minus = fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						ii_65 = ii;
						doublerealT dsum_plus_new = 0.0;
						doublerealT dsum_minus_new = 0.0;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								dsum_plus_new += fabs(P[ii_65].aij);
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								dsum_minus_new += fabs(P[ii_65].aij);
							}
							ii_65++;
						}
						// заполнение перемасштабированными.
						ii_65 = ii;
						while ((ii_65 <= iend_marker_position) && (P[ii_65].j == istr_65)) {
							if ((P[ii_65].aij > 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_plus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_plus / dsum_plus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							if ((P[ii_65].aij < 0) && (fabs(P[ii_65].aij) > alpha_truncation*dmax_minus)) {
								R[icounter_truncation] = P[ii_65];
								R[icounter_truncation].aij = fabs(dsum_minus / dsum_minus_new)*P[ii_65].aij;
								icounter_truncation++;
							}
							ii_65++;
						}

					}
				}
			}

			//iend_marker_position = iaddR + nnzR - 1;
		
			iend_marker_position = icounter_truncation - 1;
			nnzR = iend_marker_position - iaddR + 1;
			//nnzR = icount1 - iaddR;
			icount1 = nnzR + iaddR;

#pragma omp parallel for
			for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
				P[ii] = R[ii];
			}

#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= n; i_1++) {
				flag[i_1] = false; // init flag.
			}
		}

#pragma omp parallel for
		for (integer ii = 1 + iaddR; ii <= iend_marker_position; ii++) {
			R[ii] = P[ii];
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// Этот оператор нужен для вычисления grid complexity для оператора 
		// интерполляции и проекции. Данная информация важна для оптимизации количества выделяемой памяти.
		if (ilevel - 1 == 0) {
			nnz_P_memo_0 = iend_marker_position - (iaddR + 1) + 1;
		}
		else {
			nnz_P_memo_all = iend_marker_position;
		}

		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		switch (imy_sort_algorithm) {
		case COUNTING_SORT_ALG :
		     Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case HEAP_SORT_ALG :
		     HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case QUICK_SORT_ALG :
		    // Быстрая сортировка Хоара.
		    qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		    // Библиотечный алгоритм. O(nlog(n)).
		    // Не использует лишней памяти.
		    //std::sort(P+(1+iaddR)*sizeof(Ak1), P+(iaddR+ nnzR-1)*sizeof(Ak1), compAj);
		break;
		default :
		    Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		}		
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????  
		// НЕТ делить НЕ НАДО!!! т.к. в теории R=transpose(P).
		


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);

		switch (imy_sort_algorithm) {
		case COUNTING_SORT_ALG:
			Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, false);
			break;
		case QUICK_SORT_ALG:
			qs(R, 1 + iaddR, iaddR + nnzR - 1);
			// Библиотечный алгоритм. O(nlog(n)).
			// Не использует лишней памяти.
			//std::sort(R + (1 + iaddR) * sizeof(Ak1), R + (iaddR + nnzR - 1+1) * sizeof(Ak1), compAi);
			break;
		case HEAP_SORT_ALG:
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1);
			break;
		default:
			Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, false);
			break;
		}

		

		// TODO 22_10_2016.
		if (FUTURE_INJECTION) {
			switch (imy_sort_algorithm) {
			case COUNTING_SORT_ALG:
				Counting_Sort(R_injection, 0, numberofcoarcenodes - 1, false);
				break;
			case QUICK_SORT_ALG:
				qs(R_injection, 0, numberofcoarcenodes - 1);
				// Библиотечный алгоритм. O(nlog(n)).
				// Не использует лишней памяти.
				//std::sort(R_injection, R_injection + (numberofcoarcenodes - 1+1) * sizeof(Ak1), compAi);
				break;
			case HEAP_SORT_ALG:
				HeapSort(R_injection, 0, numberofcoarcenodes - 1);
				break;
			default:
				Counting_Sort(R_injection, 0, numberofcoarcenodes - 1, false);
				break;
			}
		}
		



		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Проверка Restriction нет ли пропусков строк при интерполляции: 
		if (1) {
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}
			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					doublerealT dsum27 = 0.0;
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						dsum27 += fabs(R[i_2].aij);
					}
					if (dsum27 < 1.0e-37) {
#if doubleintprecision == 1
						printf("fatal error!!! zero string R[%lld][j]=%e\n", R[i_1].i, dsum27);
#else
						printf("fatal error!!! zero string R[%d][j]=%e\n", R[i_1].i, dsum27);
#endif
						
						system("PAUSE");
					}
					flag[R[i_1].i] = true;
				}
			}
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				if (flag[i_1] == false) {
					// пропуск строки номер i_1
#if doubleintprecision == 1
					printf("fatal error!!! string number %lld propushena\n", i_1);
#else
					printf("fatal error!!! string number %d propushena\n", i_1);
#endif
					
					system("PAUSE");
				}
			}
#pragma omp parallel for
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = 0.5*ap_coarse[R[i_1].i];
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		if (ap_coarse != NULL) {
			free(ap_coarse);
			ap_coarse = NULL;
		}




		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закоментировано.
		switch ( imy_sort_algorithm ) {
		case COUNTING_SORT_ALG :
		    Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		case QUICK_SORT_ALG:
		    qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
	    	// Библиотечный алгоритм. O(nlog(n)).
	    	// Не использует лишней памяти.
	    	//std::sort(Amat + (1 + iadd)*sizeof(Ak1), Amat + (nnz_a[ilevel - 1] + iadd)*sizeof(Ak1), compAj);
		break;
		case HEAP_SORT_ALG  :
		    HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		default:
		    Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		}
		*/

		// MARKER GUSTAVSON

		// Нахождение матрицы грубосеточного уровня :
		// Acorse=R*Afine*P;
		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		switch (imy_sort_algorithm) {
		case COUNTING_SORT_ALG :
		  Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		case QUICK_SORT_ALG  :
     		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
	    	// Библиотечный алгоритм. O(nlog(n)).
	    	// Не использует лишней памяти.
	    	//std::sort(Amat + (1 + iadd)*sizeof(Ak1), Amat + (nnz_a[ilevel - 1] + iadd)*sizeof(Ak1), compAi);
		break;
		case HEAP_SORT_ALG:
		     HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		default:
		  Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		}
		*/
		// Преобразование к формату CRS.

		row_ind_SR = NULL;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		 row_ind_ER = NULL;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		istart1 = 1 + iaddR;
		iend1 = nnzR - 1 + iaddR;
#pragma omp parallel for
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}

		if (0) {
			for (integer ii = istart1; ii <= iend1; ii++) {
				if (flag[R[ii].i] == false) {
					integer istr = R[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend1) && (R[kf].i == istr)) {
						kf++;
					}
					kf--;
					row_ind_SR[istr] = ic;
					row_ind_ER[istr] = kf;
					flag[R[ii].i] = true;
				}
			}
		}
		else {
			integer i_size_75 = 0;
			// Это нельзя распараллелить.
			for (integer ii = istart1; ii <= iend1; ii++) if (flag[R[ii].i] == false) {
				row_ind_SR[R[ii].i] = ii; 
				flag[R[ii].i] = true;
				i_size_75++;
			}
#pragma omp parallel for
			for (integer istr = 1; istr <= i_size_75; istr++) {
				integer kf = row_ind_SR[istr];
				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_ER[istr] = kf;
			}
		}

		// Пустые строки просто отсутствуют.
#if doubleintprecision == 1
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//if (row_ind_SR[i_1] == -1) {
				//printf("empty string %lld\n", row_ind_ER[i_1]);
			//}
		//}
#else
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//if (row_ind_SR[i_1] == -1) {
				//printf("empty string %d\n", row_ind_ER[i_1]);
			//}
		//}
#endif
		

		row_ind_SA = NULL;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		row_ind_EA = NULL;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		istart3 = 1 + iadd;
		iend3 = nnz_a[ilevel - 1] + iadd;
#pragma omp parallel for
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}

		if (0) {
			// Однопоточная версия.

			// Базовая верная версия цикла :
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[Amat[ii].i] == false) {
					integer istr = Amat[ii].i;
					integer ic = ii;
					integer kf = ic;

					while ((kf <= iend3) && (Amat[kf].i == istr)) {
						kf++;
					}
					kf--;
					row_ind_SA[istr] = ic;
					row_ind_EA[istr] = kf;
					flag[Amat[ii].i] = true;
					// Ускорение 22_10_2016 : 
					ii = kf;
				}
			}
		}
		else {
			// Многопоточная версия.

			integer i_size_75 = 0;
			// Это нельзя распараллелить.
			for (integer ii = istart3; ii <= iend3; ii++) {
				if (flag[Amat[ii].i] == false) {
					row_ind_SA[Amat[ii].i] = ii;
					flag[Amat[ii].i] = true;
					i_size_75++;
				}
			}
#pragma omp parallel for
			for (integer istr = 1; istr <= i_size_75; istr++) {
				integer kf = row_ind_SA[istr];
				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_EA[istr] = kf;

			}
		}





		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;
		istartAnew_mem = istartAnew;

		// Данные используемые для частичного формирователя суммы.
		vector_sum = NULL;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		index_visit = NULL;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		index_size = 0;



//#ifdef _NONAME_STUB29_10_2017
#ifdef _OPENMP

		// Данные используемые для частичного формирователя суммы.
		
		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {

			for (integer i_91 = 0; i_91 < 10*n + 1; i_91++) hash_table_m[i_9][i_91] = false;// inicialization
			index_size_m[i_9] = 0;
			istartAnew_m[i_9] = 0;
		}

		// Сканируем первый операнд построчно.
		// глобальные переменные не перечисляются.
#pragma omp parallel for 
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {
			int tid = omp_get_thread_num();
			
			// на основе hash таблицы. 

			// Сканируем текущую i-ую строку поэлементно
			for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
				integer col_ind = R[ii].j;
				// Сканируем col_ind строку второго операнда

				// Общую переменную объяим на уровень выше.
				doublerealT left_operand = R[ii].aij;
				for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {

					doublerealT right_operand = Amat[i_1].aij;
					integer iaddind = Amat[i_1].j;
					bool foundnow = false;
					

					foundnow = hash_table_m[tid][iaddind];
					

					if (foundnow) {

							vector_sum_m[tid][iaddind] += left_operand*right_operand;
					}
					else {
						// Первое добавление.

							index_size_m[tid]++;
							index_visit_m[tid][index_size_m[tid]] = iaddind;

							hash_table_m[tid][iaddind] = true;

							vector_sum_m[tid][iaddind] = left_operand*right_operand;
						
					}
				}
			}

			doublerealT maxth = -1.0;
			// 22 октября 2016 Мы искоренили барьер из части P*Amat.
			for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {
				integer jstr = index_visit_m[tid][i_6];
				hash_table_m[tid][jstr] = false; // инициализируем hash таблицу для следующих проходов.
			}

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
			integer istartAnew_8 = istartAnew; // запоминаем для вылечивания строки.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size_m[tid]) {
				for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {
					integer jstr = index_visit_m[tid][i_6];

					doublerealT vs1 = vector_sum_m[tid][jstr];

					if ((istr == jstr) && (vs1 > 1.0e-20)) {
						bCheck_ok = true;
					}

					

					// 7 ноября 2016 игнорируем чистые нули:
					if (fabs(vs1) > 1.0e-37) {
						// Мы не записываем в матрицу чистый ноль.
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;


					
						AccumulqtorA_m[tid][istartAnew_m[tid]++] = Atemp;
					
					}


				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			

			index_size_m[tid] = 0; // Сброс индикатора, строка обработана.			

		}

		

		printf("oK. Counting Sort start.\n");
		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++)
		{
			for (integer i_92 = 0; i_92 < istartAnew_m[i_9]; i_92++) {
				Amat[istartAnew++] = AccumulqtorA_m[i_9][i_92];
			}
		}

		Counting_Sort(Amat, istartAnew_mem, istartAnew-1, false);
		printf("Counting Sort End. \n");
		
		//getchar();

#else

		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// Закоментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполляции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else {

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					// Общую переменную объяим на уровень выше.
					doublerealT left_operand = R[ii].aij;
					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {

						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}


			doublerealT maxth = -1.0;
			if (0) {

				// 22 октября 2016 Мы искоренили барьер из части P*Amat.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
					if (istr != jstr) {
						// 14 января 2016.
						// Правильнее определить величину барьера только по внедиагональным элементам.
						if (fabs(vector_sum[jstr]) > maxth) maxth = fabs(vector_sum[jstr]);
					}
				}
			}
			else {
				// 22 октября 2016 Мы искоренили барьер из части P*Amat.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015. threshold.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjer*maxth) {
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			else {
			// диагональный элемент записываем обязательно.
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
			integer istartAnew_8 = istartAnew; // запоминаем для вылечивания строки.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];

					doublerealT vs1 = vector_sum[jstr];

					if ((istr == jstr) && (vs1 > 1.0e-20)) {
						bCheck_ok = true;
					}

					// 22 октября 2016. Полностью искоренён барьер из части P*Amat произведения.
					//if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
					//Amat[istartAnew].aij = vs1;
					//Amat[istartAnew].i = istr;
					//Amat[istartAnew].j = jstr;
					//istartAnew++;

					// 7 ноября 2016 игнорируем чистые нули:
					if (fabs(vs1) > 1.0e-37) {
						// Мы не записываем в матрицу чистый ноль.
						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;
						Amat[istartAnew++] = Atemp;
					}
#if doubleintprecision == 1
					//if (fabs(vs1) < 1.0e-37) {
					//  	printf("error!!! i=%lld j=%lld val=%e\n",istr,jstr,vs1);
					//}

					//}
#else
					//if (fabs(vs1) < 1.0e-37) {
					//  	printf("error!!! i=%d j=%d val=%e\n",istr,jstr,vs1);
					//}

					//}
#endif
					
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			if (!bCheck_ok) {
#if doubleintprecision == 1
				/*
				printf("bad string %lld\n",istr);
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];

				doublerealT vs1 = vector_sum[jstr];
				printf("%lld %lld %e\n",istr,jstr,vs1);
				}
				*/
#else
				/*
				printf("bad string %d\n",istr);
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];

				doublerealT vs1 = vector_sum[jstr];
				printf("%d %d %e\n",istr,jstr,vs1);
				}
				*/
#endif
				
				// Ненадо ничего лечить здесь, т.к. даже на правильно 
				// рассчитываемых тестах диагональ либо отрицательна либо вообще отсутствует.
				// С этим надо детально разбираться 25_11_2016.
				/*
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];

				doublerealT vs1 = vector_sum[jstr];
				#if doubleintprecision == 1
					//printf("%lld %lld %e\n", istr, jstr, vs1);
				#else
					//printf("%d %d %e\n", istr, jstr, vs1);
				#endif
				
				// Здесь мы как бы делаем из этой плохой строки С узел.
				if (istr == jstr) {
				Amat[istartAnew_8++].aij = 1.0;
				}
				else {
				Amat[istartAnew_8++].aij = 0.0;
				}
				}
				system("pause");
				*/
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}

#endif

		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		index_visit = NULL;
		free(row_ind_SR);
		row_ind_SR = NULL;
		free(row_ind_ER);
		row_ind_ER = NULL;
		free(row_ind_SA);
		row_ind_SA = NULL;
		free(row_ind_EA);
		row_ind_EA = NULL;
		free(vector_sum);
		vector_sum = NULL;


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		switch (imy_sort_algorithm ) {
		case COUNTING_SORT_ALG :
		    Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		case QUICK_SORT_ALG :
		    qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		    // Библиотечный алгоритм. O(nlog(n)).
		    // Не использует лишней памяти.
		    //std::sort(Amat + (1 + iadd)*sizeof(Ak1), Amat + (nnz_a[ilevel - 1] + iadd)*sizeof(Ak1), compAi);
		break;
		case HEAP_SORT_ALG :
		     HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		default :
		    Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		break;
		}		
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error : negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		// Обязательно нужна сортировка.
		switch (imy_sort_algorithm ) {
		case COUNTING_SORT_ALG :
		    Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		break;
		case QUICK_SORT_ALG :
		    qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
	    	// Библиотечный алгоритм. O(nlog(n)).
	    	// Не использует лишней памяти.
	    	//std::sort(Amat + (nnz_a[ilevel - 1] + 1 + iadd)*sizeof(Ak1), Amat + (istartAnew - 1)*sizeof(Ak1), compAi);
		break;
		case HEAP_SORT_ALG :
		     HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		break;
		default :
		     Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		break;
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error : negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}




		/*
		// 10 января 2016. Данная сортировка не требуется.
		switch (imy_sort_algorithm ) {
		case COUNTING_SORT_ALG :
		    Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case QUICK_SORT_ALG :
		    qs(P, 1 + iaddR, iaddR + nnzR - 1);
		    // Библиотечный алгоритм. O(nlog(n)).
		    // Не использует лишней памяти.
		    //std::sort(P +  (1 + iaddR)*sizeof(Ak1), P + (iaddR + nnzR - 1)*sizeof(Ak1), compAi);
		break;
		case HEAP_SORT_ALG :
		      HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		default:
		    Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		}

		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода :
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно сумирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		switch (imy_sort_algorithm) {
		case COUNTING_SORT_ALG:
			Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
		case QUICK_SORT_ALG:
			qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			// Библиотечный алгоритм. O(nlog(n)).
			// Не использует лишней памяти.
			//std::sort(P + (1 + iaddR) * sizeof(Ak1), P + (iaddR + nnzR - 1+1) * sizeof(Ak1), compAj);
			break;
		case HEAP_SORT_ALG:
			HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
		default :
			Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			break;
		}
		

		row_ind_AS = NULL;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		row_ind_AE = NULL;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1) * sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2_glob = istartAnew - 1;
#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		//int istr_memo = -1;
		for (integer ii = istart2; ii <= iend2_glob; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;
				//istr_memo = istr;
				integer kf = ic;

				while ((kf <= iend2_glob) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				//if (ii > istart2) {
					//row_ind_AE[istr - 1] = ic - 1;
				//}
				flag[Amat[ii].i] = true;
				ii = kf;

			}
		}
		//row_ind_AE[istr_memo] = iend2_glob;

		row_ind_PS = NULL;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		 row_ind_PE = NULL;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));


		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
#pragma omp parallel for
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		istart4 = 1 + iaddR;
		iend4 = nnzR - 1 + iaddR;
#pragma omp parallel for
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;
				ii = kf;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		if (vector_sum != NULL) {
			free(vector_sum);
			vector_sum = NULL;
		}
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_4", (numberofcoarcenodes + 1));

		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		if (index_visit != NULL) {
			free(index_visit);
			index_visit = NULL;
		}
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1) * sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_4", (n_a[ilevel - 1] + 1));

		index_visit[0] = 0;
		index_size = 0;

//#ifdef _NONAME_STUB29_10_2017
#ifdef _OPENMP

		// Данные используемые для частичного формирователя суммы.

		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {

			for (integer i_91 = 0; i_91 < 10 * n + 1; i_91++) hash_table_m[i_9][i_91] = false;// inicialization
			index_size_m[i_9] = 0;
			istartAnew_m[i_9] = 0;
		}
		

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		// Сканируем первый операнд построчно.
		// глобальные переменные не перечисляются.
#pragma omp parallel for 
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			int tid = omp_get_thread_num();			

			// На основе hash таблицы.
			// сканируем все элементы строки левого операнда.
			for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
				integer col_ind = Amat[ii1].j;
				doublerealT left_operand = Amat[ii1].aij;

				// Сканируем col_ind строку правого операнда накапливая сумму.
				for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {

					doublerealT right_operand = P[ii2].aij;

					integer iaddind = P[ii2].i;
					bool foundnow = false;
					
					// мгновенный поиск за O(1).
					foundnow = hash_table_m[tid][iaddind];

					if (foundnow) {
						//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
						vector_sum_m[tid][iaddind] += left_operand*right_operand;
					}
					else {
						// Первое добавление.
						index_size_m[tid]++;
						index_visit_m[tid][index_size_m[tid]] = iaddind;
						
						// Мгновенная вставка в hash table за O(1).
						hash_table_m[tid][iaddind] = true;

						//ifoundind = index_size;
						//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
						vector_sum_m[tid][iaddind] = left_operand*right_operand;
					}
					// требуется реализовать следующую логику :
					// 1. поиск элемента по ключу 
					// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
					// Если элемент найден то нужно просто изменить foundnow на true. 
					// Т.е. достаточно просто поиска и вставки.
					// 3. В конце дерево необходимо ликвидировать.
					// Тип данных целочисленный ключ.


					//vector_sum[P[ii2].i] += rleft*rright;
				}
			}

			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {
				integer jstr = index_visit_m[tid][i_6];
				hash_table_m[tid][jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum_m[tid][jstr]) > maxth) maxth = fabs(vector_sum_m[tid][jstr]);
				}
			}
			
			// huck : 16.04.2017

			for (integer i_61 = 1; i_61 <= index_size_m[tid]; i_61++) {

				integer jstr61 = index_visit_m[tid][i_61];
				doublerealT vs161 = vector_sum_m[tid][jstr61];
#if doubleintprecision == 1
				//printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
				//printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif


				if ((istr == jstr61) && (vs161 < 1.0e-20)) {
					// отрицательный элемент на диагонали.

					printf("Negative diagonal coefficient found. No panic. Upwind patching. 16.04.2017. \n");

					printf("bad string: \n");
					for (integer i_63 = 1; i_63 <= index_size_m[tid]; i_63++) {

						integer jstr63 = index_visit_m[tid][i_63];
						doublerealT vs163 = vector_sum_m[tid][jstr63];
#if doubleintprecision == 1
						printf("i=%lld j=%lld aij=%e\n", istr, jstr63, vs163);
#else
						printf("i=%d j=%d aij=%e\n", istr, jstr63, vs163);
#endif

					}


					// Адаптированные три правила бак-труба:
					// Amat. Диагонали присваиваем сумма модулей только отрицательных внедиагональных коэффициентов +
					// вычитаем из этого отрицательную диагональ. Потом умножаем на два.
					// B. Удвоение отрицательных внедиагональных коэффициентов.
					// C. Полное зануление положительных внедиагональных коэффициентов (игнорирование).
					printf("patching string 16.04.2017 : \n");
					for (integer i_62 = 1; i_62 <= index_size_m[tid]; i_62++) {
						integer jstr62 = index_visit_m[tid][i_62];
						if (istr != jstr62) {
							if (vector_sum_m[tid][jstr62] > 0.0) {
								index_visit_m[tid][i_62] = -1; // не существует такого элемента (игнорирование).
								vector_sum_m[tid][jstr61] += vector_sum_m[tid][jstr62];
								vector_sum_m[tid][jstr62] = 0.0;
							}
						}
					}

					if (vector_sum_m[tid][jstr61] < 0.0) {
						vector_sum_m[tid][jstr61] = 0.0;
						for (integer i_62 = 1; i_62 <= index_size_m[tid]; i_62++) {
							integer jstr62 = index_visit_m[tid][i_62];
							if (jstr62 > -1) {
								if (istr != jstr62) {
									if (vector_sum_m[tid][jstr62] < 0.0) {
										vector_sum_m[tid][jstr61] += fabs(vector_sum_m[tid][jstr62]);
									}
								}
							}
						}
					}

					// Выход из цикла for по переменной i_61.
					break;
				}


			}


			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
									// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size_m[tid]) {
				for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {

					integer jstr = index_visit_m[tid][i_6];
					doublerealT vs1 = vector_sum_m[tid][jstr];
					//if (fabs(vs1) < 1.0e-37) {
#if doubleintprecision == 1
					//printf("zero vs1=%e, i==%lld j==%lld\n",vs1,istr,jstr);
#else
					//printf("zero vs1=%e, i==%d j==%d\n",vs1,istr,jstr);
#endif

					//}
					// 7 ноября 2016 игнорируем чистые нули:
					if ((jstr>-1) && (fabs(vs1) > 1.0e-37)) {
						// Мы игнорируем чистые нули. 
						// Но вообще говоря непонятно почему они появляются.

						if (barjerA < 0.0) {
							// алгебраический мультигрид Галёркина.
							// 22_10_2016.
							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;

							if (istr == jstr) bCheck_ok = true;

							if ((istr == jstr) && (vs1 < 1.0e-20)) {
								// Ошибка проявляется в отсутствии диагонального элемента в результирующей матрице первого
								// произведения Галеркина. Надо смотреть ситуацию выше по коду.
								// 22737
								// сканируем все элементы строки левого операнда.
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//if (Amat[ii1_8].i == 22737) {
#if doubleintprecision == 1
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#else
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#endif

								//}
								//integer col_ind = Amat[ii1_8].j;
								//}
#if doubleintprecision == 1
								printf("bad string %lld\n", istr);
#else
								printf("bad string %d\n", istr);
#endif

								printf("error : diagonal element is negative...\n");
								switch (iVar) {
								case PAM: printf("PAM equation\n"); break;
								case VX: printf("VX equation\n"); break;
								case VY: printf("VY equation\n"); break;
								case VZ: printf("VZ equation\n"); break;
								case TEMP: printf("TEMP equation\n"); break;
								case TOTALDEFORMATIONVAR: printf("STRESS system equation\n"); break;
								}
#if doubleintprecision == 1
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#else
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#endif

								for (integer i_61 = 1; i_61 <= index_size_m[tid]; i_61++) {

									integer jstr61 = index_visit_m[tid][i_61];
									doublerealT vs161 = vector_sum_m[tid][jstr61];
#if doubleintprecision == 1
									printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
									printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif

								}
								//getchar();
								system("pause");
								// прекращаем строить иерархию уровней.
								bcontinue_global = false;
								//goto BAD_STRING_MARKER;
								printf("fatall error bad string: goto BAD_STRING_MARKER;\n");
								system("pause");
								exit(1);

								doublerealT sum_dia = 0.0;
								for (integer i_8 = 1; i_8 <= index_size_m[tid]; i_8++) {
									if (i_8 != i_6) {
										integer jstr_8 = index_visit_m[tid][i_8];
										doublerealT vs1_8 = vector_sum_m[tid][jstr_8];
										sum_dia += fabs(vs1_8);
									}
								}
								// принудительное сильнейшее усиление диагонали.
								Atemp.aij = sum_dia;
								// ошибка признана не являющейся фатальной.
								// 22 декабря 2016
								//system("pause");
							}

							//Amat[istartAnew2].aij = vs1;
							//Amat[istartAnew2].i = istr;
							//Amat[istartAnew2].j = jstr;
							//istartAnew2++;

							//Amat[istartAnew2++] = Atemp;
							AccumulqtorA_m[tid][istartAnew_m[tid]++] = Atemp;
						}
						else {
							// TODO non Galerking amg.
							if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
								Ak1 Atemp;
								Atemp.aij = vs1;
								Atemp.i = istr;
								Atemp.j = jstr;

								//Amat[istartAnew2].aij = vs1;
								//Amat[istartAnew2].i = istr;
								//Amat[istartAnew2].j = jstr;
								//istartAnew2++;

								//Amat[istartAnew2++] = Atemp;
								AccumulqtorA_m[tid][istartAnew_m[tid]++] = Atemp;

							}
						}
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			if (!bCheck_ok) {
#if doubleintprecision == 1
				printf("bad string %lld\n", istr);
#else
				printf("bad string %d\n", istr);
#endif

				// прекращаем строить иерархию уровней.
				bcontinue_global = false;
				//goto BAD_STRING_MARKER;
				printf("fatall error bad string: goto BAD_STRING_MARKER 2;\n");
				system("pause");
				exit(1);

				for (integer i_6 = 1; i_6 <= index_size_m[tid]; i_6++) {

					integer jstr = index_visit_m[tid][i_6];
					doublerealT vs1 = vector_sum_m[tid][jstr];
#if doubleintprecision == 1
					printf("%lld %lld %e\n", istr, jstr, vs1);
#else
					printf("%d %d %e\n", istr, jstr, vs1);
#endif

				}
				system("pause");
			}

			index_size_m[tid] = 0;
			
		}

	    integer istartAnew_mem2;
		istartAnew_mem2 = istartAnew2;
		printf("oK2. Counting Sort start.\n");
		for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++)
		{
			for (integer i_92 = 0; i_92 < istartAnew_m[i_9]; i_92++) {
				Amat[istartAnew2++] = AccumulqtorA_m[i_9][i_92];
			}
		}

		Counting_Sort(Amat, istartAnew_mem2, istartAnew2 - 1, false);
		printf("Counting Sort End. \n");

#else

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;
					doublerealT left_operand = Amat[ii1].aij;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						// здесь объявляем только текущий локальный множитель.
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;
					doublerealT left_operand = Amat[ii1].aij;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {

						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}


			doublerealT maxth = -1.0;
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
				integer jstr = index_visit[i_6];
				hash_table[jstr] = false; // initialization hash.
				if (istr != jstr) {
					// 14 января 2016 года.
					// Правильно определить барьер только по внедиагональным элементам.
					if (fabs(vector_sum[jstr]) > maxth) maxth = fabs(vector_sum[jstr]);
				}
			}

			/*
			if (nsizeA > istartAnew2 + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			// 15 декабря 2015.
			// Если не принять специальных мер элементы не будут упорядочены
			// и двоичным поиском воспользоваться нельзя.
			//if (index_visit[i_6] < index_visit[i_6 - 1]) {
			//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
			//system("pause");
			//}

			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015 года. Сохранение разреженности.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjerA*maxth) {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			else {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// huck : 16.04.2017

			for (integer i_61 = 1; i_61 <= index_size; i_61++) {

				integer jstr61 = index_visit[i_61];
				doublerealT vs161 = vector_sum[jstr61];
#if doubleintprecision == 1
				//printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
				//printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif
				

				if ((istr == jstr61) && (vs161 < 1.0e-20)) {
					// отрицательный элемент на диагонали.

					printf("Negative diagonal coefficient found. No panic. Upwind patching. 16.04.2017. \n");

					printf("bad string: \n");
					for (integer i_63 = 1; i_63 <= index_size; i_63++) {

						integer jstr63 = index_visit[i_63];
						doublerealT vs163 = vector_sum[jstr63];
#if doubleintprecision == 1
						printf("i=%lld j=%lld aij=%e\n", istr, jstr63, vs163);
#else
						printf("i=%d j=%d aij=%e\n", istr, jstr63, vs163);
#endif
						
					}


					// Адаптированные три правила бак-труба:
					// Amat. Диагонали присваиваем сумма модулей только отрицательных внедиагональных коэффициентов +
					// вычитаем из этого отрицательную диагональ. Потом умножаем на два.
					// B. Удвоение отрицательных внедиагональных коэффициентов.
					// C. Полное зануление положительных внедиагональных коэффициентов (игнорирование).
					printf("patching string 16.04.2017 : \n");
					for (integer i_62 = 1; i_62 <= index_size; i_62++) {
						integer jstr62 = index_visit[i_62];
						if (istr != jstr62) {
							if (vector_sum[jstr62] > 0.0) {
								index_visit[i_62] = -1; // не существует такого элемента (игнорирование).
								vector_sum[jstr61] += vector_sum[jstr62];
								vector_sum[jstr62] = 0.0;
							}
						}
					}

					if (vector_sum[jstr61] < 0.0) {
						vector_sum[jstr61] = 0.0;
						for (integer i_62 = 1; i_62 <= index_size; i_62++) {
							integer jstr62 = index_visit[i_62];
							if (jstr62 > -1) {
								if (istr != jstr62) {
									if (vector_sum[jstr62] < 0.0) {
										vector_sum[jstr61] += fabs(vector_sum[jstr62]);
									}
								}
							}
						}
					}

					// Выход из цикла for по переменной i_61.
					break;
				}


			}


			bool bCheck_ok = false; // прооверяет наличие диагонали в строке матрицы.
									// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					//if (fabs(vs1) < 1.0e-37) {
#if doubleintprecision == 1
					//printf("zero vs1=%e, i==%lld j==%lld\n",vs1,istr,jstr);
#else
					//printf("zero vs1=%e, i==%d j==%d\n",vs1,istr,jstr);
#endif
					
					//}
					// 7 ноября 2016 игнорируем чистые нули:
					if ((jstr>-1)&&(fabs(vs1) > 1.0e-37)) {
						// Мы игнорируем чистые нули. 
						// Но вообще говоря непонятно почему они появляются.

						if (barjerA < 0.0) {
							// алгебраический мультигрид Галёркина.
							// 22_10_2016.
							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;

							if (istr == jstr) bCheck_ok = true;

							if ((istr == jstr) && (vs1 < 1.0e-20)) {
								// Ошибка проявляется в отсутствии диагонального элемента в результирующей матрице первого
								// произведения Галеркина. Надо смотреть ситуацию выше по коду.
								// 22737
								// сканируем все элементы строки левого операнда.
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//if (Amat[ii1_8].i == 22737) {
#if doubleintprecision == 1
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#else
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
#endif
								
								//}
								//integer col_ind = Amat[ii1_8].j;
								//}
#if doubleintprecision == 1
								printf("bad string %lld\n", istr);
#else
								printf("bad string %d\n", istr);
#endif
								
								printf("error : diagonal element is negative...\n");
								switch (iVar) {
								case PAM: printf("PAM equation\n"); break;
								case VX: printf("VX equation\n"); break;
								case VY: printf("VY equation\n"); break;
								case VZ: printf("VZ equation\n"); break;
								case TEMP: printf("TEMP equation\n"); break;
								case TOTALDEFORMATIONVAR: printf("STRESS system equation\n"); break;
								}
#if doubleintprecision == 1
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%lld j=%lld aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#else
								//for (integer ii1_8 = row_ind_AS[istr]; ii1_8 <= row_ind_AE[istr]; ii1_8++) {
								//printf("i=%d j=%d aij=%e\n", Amat[ii1_8].i, Amat[ii1_8].j, Amat[ii1_8].aij);
								//}
#endif
								
								for (integer i_61 = 1; i_61 <= index_size; i_61++) {

									integer jstr61 = index_visit[i_61];
									doublerealT vs161 = vector_sum[jstr61];
#if doubleintprecision == 1
									printf("i=%lld j=%lld aij=%e\n", istr, jstr61, vs161);
#else
									printf("i=%d j=%d aij=%e\n", istr, jstr61, vs161);
#endif
									
								}
								// Принимаем меры.
								doublerealT sum_dia = 0.0;
								for (integer i_8 = 1; i_8 <= index_size; i_8++) {
									if (i_8 != i_6) {
										integer jstr_8 = index_visit[i_8];
										doublerealT vs1_8 = vector_sum[jstr_8];
										sum_dia += fabs(vs1_8);
									}
								}
								// принудительное сильнейшее усиление диагонали.
								Atemp.aij = sum_dia;
								// ошибка признана не являющейся фатальной.
								// 22 декабря 2016
								//system("pause");
								//getchar();
								system("pause");
								// прекращаем строить иерархию уровней.
								bcontinue_global = false;
								//goto BAD_STRING_MARKER;
							}

							//Amat[istartAnew2].aij = vs1;
							//Amat[istartAnew2].i = istr;
							//Amat[istartAnew2].j = jstr;
							//istartAnew2++;

							Amat[istartAnew2++] = Atemp;
						}
						else {
							// TODO non Galerking amg.
							if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
								Ak1 Atemp;
								Atemp.aij = vs1;
								Atemp.i = istr;
								Atemp.j = jstr;

								//Amat[istartAnew2].aij = vs1;
								//Amat[istartAnew2].i = istr;
								//Amat[istartAnew2].j = jstr;
								//istartAnew2++;

								Amat[istartAnew2++] = Atemp;

							}
						}
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			if (!bCheck_ok) {
#if doubleintprecision == 1
				printf("bad string %lld\n", istr);
#else
				printf("bad string %d\n", istr);
#endif
				
				
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
#if doubleintprecision == 1
					printf("%lld %lld %e\n", istr, jstr, vs1);
#else
					printf("%d %d %e\n", istr, jstr, vs1);
#endif
					
				}
				system("pause");

				// прекращаем строить иерархию уровней.
				bcontinue_global = false;
				//goto BAD_STRING_MARKER;
			}

			index_size = 0;
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
		}

#endif

		//delete[] vector_sum;
		//delete[] index_visit;
		if (vector_sum != NULL) {
			free(vector_sum);
			vector_sum = NULL;
		}
		if (index_visit != NULL) {
			free(index_visit);
			index_visit = NULL;
		}



		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		if (row_ind_AS != NULL) {
			free(row_ind_AS);
			row_ind_AS = NULL;
		}
		if (row_ind_AE != NULL) {
			free(row_ind_AE);
			row_ind_AE = NULL;
		}
		if (row_ind_PS != NULL) {
			free(row_ind_PS);
			row_ind_PS = NULL;
		}
		if (row_ind_PE != NULL) {
			free(row_ind_PE);
			row_ind_PE = NULL;
		}

		// TODO 22_10_2016
		// Это нужно для регуляции барьера barjerA.
		if (P_injection != NULL) {
			delete[] P_injection;
			P_injection = NULL;
		}
		if (R_injection != NULL) {
			delete[] R_injection;
			R_injection = NULL;
		}

		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		switch (imy_sort_algorithm ) {
		case COUNTING_SORT_ALG  :
		    Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		case QUICK_SORT_ALG:
		    // Быстрая сортировка Хоара.
		   qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		   // Библиотечный алгоритм. O(nlog(n)).
		   // Не использует лишней памяти.
		   //std::sort(P + (1 + iaddR)*sizeof(Ak1), P + (iaddR + nnzR - 1)*sizeof(Ak1), compAj);
		break;
		case HEAP_SORT_ALG :
		     HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		default :
		    Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		break;
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
			// Общее количество узлов не являющихся соседемя, но не С соседями 
#if doubleintprecision == 1
			printf("diagnostic: the number of neighbors that are not Coarse (C) nodes %lld\n", the_number_of_neighbors_that_are_not_C_nodes);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor=%lld \n", number_of_F_nodes_with_one_single_strong_C_neighbor);
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor\n");
			printf("and to the same not having strong Fine(F) neighbors %lld\n", number_of_F_nodes_with_one_single_strong_C_neighborF);
			//system("pause");
#else
			printf("diagnostic: the number of neighbors that are not Coarse (C) nodes %d\n", the_number_of_neighbors_that_are_not_C_nodes);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor=%d \n", number_of_F_nodes_with_one_single_strong_C_neighbor);
			printf("diagnostic: the number of Fine (F) nodes with one single strong Coarse (C) neighbor\n");
			printf("and to the same not having strong Fine(F) neighbors %d\n", number_of_F_nodes_with_one_single_strong_C_neighborF);
			//system("pause");
#endif
			
		}
		if (debug_reshime) system("pause");


		//delete[] C_numerate;
		if (C_numerate != NULL) {
			free(C_numerate);
			C_numerate = NULL;
		}

		// Использование упорядочивания типа F-C ускоряет сходимость вычислительного процесса,
		// сокращая число V циклов требуемых для достижения сходимости.
	    iaddFCcolor = 0;
		for (integer i_71 = 0; i_71 < ilevel - 1; i_71++) iaddFCcolor += n_a[i_71];
		for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
			F_false_C_true[iaddFCcolor+i_1] = true;
		}

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];

		

		if (bcontinue_global) {
			// если bad string не встречалось.
			ilevel++;

			if (bStrongTransposeON) {
				// Освобождение ОЗУ.
				if (bAVLST_ON) {
					if (hash_StrongTranspose_collection != NULL) {
						for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++) clear_AVL(hash_StrongTranspose_collection[i_1]);
						delete[] hash_StrongTranspose_collection;
						hash_StrongTranspose_collection = NULL;
					}
				}
				else {
					// Обычный линейный список.
					if (hash_StrongTranspose_collection1 != NULL) {
						// otkl_parr_aug2017
#pragma omp parallel for
						//for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++) {
						//isize_memory_alloc_hash_StrongTranspose_collection1
						for (integer i_1 = 0; i_1 <= isize_memory_alloc_hash_StrongTranspose_collection1; i_1++) {
							clear_list(hash_StrongTranspose_collection1[i_1]);
						}
						delete[] hash_StrongTranspose_collection1;
						hash_StrongTranspose_collection1 = NULL;
					}
				}
				if (isize_hash_StrongTranspose_collection != NULL) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = NULL;
				}
			}
		}
		else {
			if (bStrongTransposeON) {
				// Освобождение ОЗУ.
				if (bAVLST_ON) {
					if (hash_StrongTranspose_collection != NULL) {
						for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) clear_AVL(hash_StrongTranspose_collection[i_1]);
						delete[] hash_StrongTranspose_collection;
						hash_StrongTranspose_collection = NULL;
					}
				}
				else {
					// Обычный линейный список.
					if (hash_StrongTranspose_collection1 != NULL) {
						//for (integer i_1 = 0; i_1 <= n_a[ilevel - 2]; i_1++)
						//isize_memory_alloc_hash_StrongTranspose_collection1
						for (integer i_1 = 0; i_1 <= isize_memory_alloc_hash_StrongTranspose_collection1; i_1++)
						{
						 clear_list(hash_StrongTranspose_collection1[i_1]);
						}
						delete[] hash_StrongTranspose_collection1;
						hash_StrongTranspose_collection1 = NULL;
					}
				}
				if (isize_hash_StrongTranspose_collection != NULL) {
					delete[] isize_hash_StrongTranspose_collection;
					isize_hash_StrongTranspose_collection = NULL;
				}
			}
		}

		//delete[] count_sosed;
		if (count_sosed != NULL) {
			free(count_sosed);
			count_sosed = NULL;
		}
		//delete[] row_startA;
		if (row_startA != NULL) {
			free(row_startA);
			row_startA = NULL;
		}


		// построение иерархии уровней досрочно прекращено.
		//BAD_STRING_MARKER : 

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = NULL;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		}

		for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
		if (flag[Amat[ii77].i] == false) {
		integer istr77 = Amat[ii77].i;
		integer ic77 = ii77;
		//integer icdiag = ii77;
		doublerealT ap = 0.0;
		//x[istr] = b[istr];
		while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
		if (Amat[ic77].j != istr77) {
		//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
		}
		else {
		ap = Amat[ic77].aij;
		//icdiag = ic77;
		}
		ic77++;
		}
		if (fabs(ap) < RealZERO) {
		#if doubleintprecision == 1
			printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
		#else
			printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
		#endif
		
		system("PAUSE");
		//exit(1);
		}

		flag[Amat[ii77].i] = true;

		}
		}
		}
		*/

		//проверка конец

		

	}// иерархия сеток построена.

	ilevel--; // 4.01.2017
	if (n_a[ilevel] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	// Вычисляем и запоминаем grid complexity
	// Операторная сложность.
	doublerealT dr_grid_complexity = (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0])));
	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f %1.2f\n", (doublerealT)(nnz_P_memo_all / nnz_P_memo_0), (doublerealT)(nnz_P_memo_all / n_a[0]));
		doublerealT sizegb = 16 * iadd / 1.0e9;
		printf("memory usage is %e Gb. reserved %e Gb. ratio is equal = %e\n", sizegb, 16 * nsizeA / 1.0e9, sizegb / (16 * nsizeA / 1.0e9));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = NULL;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

#if doubleintprecision == 1
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%lld\n", ilevel);
		// <= ilevel 4.01.2017
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld nnz_a[%lld]/n_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#else
	if (bprint_mesage_diagnostic) {
		printf("ilevel=%d\n", ilevel);
		// <= ilevel 4.01.2017
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d nnz_a[%d]/n_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
#endif
	
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);

	if (bprint_mesage_diagnostic) {
		printf("memory optimization 13 november 2016.\n");
		printf("ierarhion matrix Amat...");
	}
	// Уменьшение памяти отводимой под хранение матрицы А.
	// Матрица должна занимать в памяти не более чем под неё нужно и не мегабайтом больше.
	if (Amat != NULL) {
		Amat = (Ak1*)realloc(Amat, (iadd + 2) * sizeof(Ak1));
	}
	if (Amat == NULL) {
		printf("application crash for Amat. Please send message on email: kirill7785@mail.ru\n");
		system("pause");
		exit(1);
	}
	if (bprint_mesage_diagnostic) {
		printf(" 1 of 3 compleated.  OK!! ierarhion matrix Amat realloc successfully...\n");
	}

	if (bprint_mesage_diagnostic) {
		printf("Prolongation ierarhion...\n");
	}
	if (P != NULL) {
		P = (Ak1*)realloc(P, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
	}
	if (P == NULL) {
		printf("application crash for P. Please send message on email: kirill7785@mail.ru\n");
		system("pause");
		exit(1);
	}
	if (bprint_mesage_diagnostic) {
		printf("2 of 3 compleated. OK!! ierarhion matrix Prolongation realloc successfully...\n");
	}

	if (bprint_mesage_diagnostic) {
		printf("Restriction ierarhion...\n");
	}
	if (R != NULL) {
		R = (Ak1*)realloc(R, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
	}
	if (R == NULL) {
		printf("application crash for R. Please send message on email: kirill7785@mail.ru\n");
		system("pause");
		exit(1);
	}
	if (bprint_mesage_diagnostic) {
		printf("3 of 3 compleated. OK!! ierarhion matrix Restriction realloc successfully...\n");
		printf("memory optimization successfully.\n");
	}

	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel


	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=NULL;
	if (ilevel > 1) {
	diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=NULL;
	if (ilevel > 2) {
	diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = NULL;
	if (ilevel > 3) {
	diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = NULL;
	if (ilevel > 4) {
	diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = NULL;
	if (ilevel > 5) {
	diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = NULL;
	if (ilevel > 6) {
	diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = NULL;
	if (ilevel > 7) {
	diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = NULL;
	if (ilevel > 8) {
	diag8 = new doublerealT[n_a[8] + 1];
	}
	doublerealT *diag9 = NULL;
	if (ilevel > 9) {
	diag9 = new doublerealT[n_a[9] + 1];
	}
	doublerealT *diag10 = NULL;
	if (ilevel > 10) {
	diag10 = new doublerealT[n_a[10] + 1];
	}
	doublerealT *diag11 = NULL;
	if (ilevel > 11) {
	diag11 = new doublerealT[n_a[11] + 1];
	}
	doublerealT *diag12 = NULL;
	if (ilevel > 12) {
	diag12 = new doublerealT[n_a[12] + 1];
	}
	doublerealT *diag13 = NULL;
	if (ilevel > 13) {
	diag13 = new doublerealT[n_a[13] + 1];
	}
	doublerealT *diag14 = NULL;
	if (ilevel > 14) {
	diag14 = new doublerealT[n_a[14] + 1];
	}
	doublerealT *diag15 = NULL;
	if (ilevel > 15) {
	diag15 = new doublerealT[n_a[15] + 1];
	}
	doublerealT *diag16 = NULL;
	if (ilevel > 16) {
	diag16 = new doublerealT[n_a[16] + 1];
	}
	*/

	// 4-5-6 30-31 dec 2016 Поддерживается не более 50 уровней вложенности
    //  5.06.2017 Поддерживается не более 100 уровней вложенности.
    // включительно.
	const integer idim_diag = 101;
	doublerealT **diag = NULL;
	diag = new doublerealT*[idim_diag];
	if (diag == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for diag my_gregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer i_id_level_local = 0; i_id_level_local < idim_diag; i_id_level_local++) {
		diag[i_id_level_local] = NULL; // инициализация.
		if (i_id_level_local == 0) {
			// Т.к. деление очень медленное то мы поделим лишь один раз.
			//doublerealT *diag0 = NULL;
			//diag[0] = new doublerealT[n_a[0] + 1];
			diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(diag[i_id_level_local], "diag[0]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
		}
		else if (i_id_level_local == 1) {
			//doublerealT *diag1 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[1] = new doublerealT[n_a[1] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[1]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 2) {
			//doublerealT *diag2 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[2] = new doublerealT[n_a[2] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[2]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 3) {
			//doublerealT *diag3 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[3] = new doublerealT[n_a[3] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[3]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 4) {
			//doublerealT *diag4 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[4] = new doublerealT[n_a[4] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[4]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 5) {
			//doublerealT *diag5 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[5] = new doublerealT[n_a[5] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[5]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 6) {
			//doublerealT *diag6 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[6] = new doublerealT[n_a[6] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[6]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 7) {
			//doublerealT *diag7 = NULL;
			if (ilevel > i_id_level_local) {
				//diag[7] = new doublerealT[n_a[7] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[7]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 8) {
			//doublerealT *diag8 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[8] = new doublerealT[n_a[8] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[8]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 9) {
			//doublerealT *diag9 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[9] = new doublerealT[n_a[9] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[9]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 10) {
			//doublerealT *diag10 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[10] = new doublerealT[n_a[10] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[10]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 11) {
			//doublerealT *diag11 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[11] = new doublerealT[n_a[11] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[11]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 12) {
			//doublerealT *diag12 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[12] = new doublerealT[n_a[12] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[12]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 13) {
			//doublerealT *diag13 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[13] = new doublerealT[n_a[13] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[13]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 14) {
			//doublerealT *diag14 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[14] = new doublerealT[n_a[14] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[14]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 15) {
			//doublerealT *diag15 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[15] = new doublerealT[n_a[15] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[15]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 16) {
			//doublerealT *diag16 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[16] = new doublerealT[n_a[16] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[16]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 17) {
			//doublerealT *diag17 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[17] = new doublerealT[n_a[17] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[17]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 18) {
			//doublerealT *diag18 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[18] = new doublerealT[n_a[18] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[18]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 19) {
			//doublerealT *diag19 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[19] = new doublerealT[n_a[19] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[19]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 20) {
			//doublerealT *diag20 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[20] = new doublerealT[n_a[20] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[20]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 21) {
			//doublerealT *diag21 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[21] = new doublerealT[n_a[21] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[21]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 22) {
			//doublerealT *diag22 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[22] = new doublerealT[n_a[22] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[22]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 23) {
			//doublerealT *diag23 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[23] = new doublerealT[n_a[23] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[23]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 24) {
			//doublerealT *diag24 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[24] = new doublerealT[n_a[24] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[24]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 25) {
			//doublerealT *diag25 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[25] = new doublerealT[n_a[25] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[25]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 26) {
			//doublerealT *diag26 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[26] = new doublerealT[n_a[26] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[26]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 27) {
			//doublerealT *diag27 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[27] = new doublerealT[n_a[27] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[27]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 28) {
			//doublerealT *diag28 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[28] = new doublerealT[n_a[28] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[28]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 29) {
			//doublerealT *diag29 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[29] = new doublerealT[n_a[29] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[29]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 30) {
			//doublerealT *diag30 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[30] = new doublerealT[n_a[30] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[30]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 31) {
			//doublerealT *diag31 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[31] = new doublerealT[n_a[31] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[31]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 32) {
			//doublerealT *diag32 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[32] = new doublerealT[n_a[32] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[32]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 33) {
			//doublerealT *diag33 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[33] = new doublerealT[n_a[33] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[33]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 34) {
			//doublerealT *diag34 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[34] = new doublerealT[n_a[34] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[34]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 35) {
			//doublerealT *diag35 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[35] = new doublerealT[n_a[35] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[35]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 36) {
			//doublerealT *diag36 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[36] = new doublerealT[n_a[36] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[36]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 37) {
			//doublerealT *diag37 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[37] = new doublerealT[n_a[37] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[37]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 38) {
			//doublerealT *diag38 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[38] = new doublerealT[n_a[38] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[38]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 39) {
			//doublerealT *diag39 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[39] = new doublerealT[n_a[39] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[39]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 40) {
			//doublerealT *diag40 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[40] = new doublerealT[n_a[40] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[40]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 41) {
			//doublerealT *diag41 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[41] = new doublerealT[n_a[41] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[41]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 42) {
			//doublerealT *diag42 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[42] = new doublerealT[n_a[42] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[42]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 43) {
			//doublerealT *diag43 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[43] = new doublerealT[n_a[43] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[43]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 44) {
			//doublerealT *diag44 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[44] = new doublerealT[n_a[44] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[44]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 45) {
			//doublerealT *diag45 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[45] = new doublerealT[n_a[45] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[45]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 46) {
			//doublerealT *diag46 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[46] = new doublerealT[n_a[46] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[46]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 47) {
			//doublerealT *diag47 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[47] = new doublerealT[n_a[47] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[47]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 48) {
			//doublerealT *diag48 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[48] = new doublerealT[n_a[48] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[48]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 49) {
			//doublerealT *diag49 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[49] = new doublerealT[n_a[49] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[49]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 50) {
			//doublerealT *diag50 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[50] = new doublerealT[n_a[50] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[50]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 51) {
			//doublerealT *diag51 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[51] = new doublerealT[n_a[51] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[51]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 52) {
			//doublerealT *diag52 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[52] = new doublerealT[n_a[52] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[52]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 53) {
			//doublerealT *diag53 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[53] = new doublerealT[n_a[53] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[53]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 54) {
			//doublerealT *diag54 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[54] = new doublerealT[n_a[54] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[54]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 55) {
			//doublerealT *diag55 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[55] = new doublerealT[n_a[55] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[55]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 56) {
			//doublerealT *diag56 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[56] = new doublerealT[n_a[56] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[56]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 57) {
			//doublerealT *diag57 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[57] = new doublerealT[n_a[57] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[57]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 58) {
			//doublerealT *diag58 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[58] = new doublerealT[n_a[58] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[58]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 59) {
			//doublerealT *diag59 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[59] = new doublerealT[n_a[59] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[59]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 60) {
			//doublerealT *diag60 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[60] = new doublerealT[n_a[60] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[60]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 61) {
			//doublerealT *diag61 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[61] = new doublerealT[n_a[61] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[61]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 62) {
			//doublerealT *diag62 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[62] = new doublerealT[n_a[62] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[62]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 63) {
			//doublerealT *diag63 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[63] = new doublerealT[n_a[63] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[63]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 64) {
			//doublerealT *diag64 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[64] = new doublerealT[n_a[64] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[64]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 65) {
			//doublerealT *diag65 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[65] = new doublerealT[n_a[65] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[65]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 66) {
			//doublerealT *diag66 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[66] = new doublerealT[n_a[66] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[66]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 67) {
			//doublerealT *diag67 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[67] = new doublerealT[n_a[67] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[67]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 68) {
			//doublerealT *diag68 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[68] = new doublerealT[n_a[68] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[68]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 69) {
			//doublerealT *diag69 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[69] = new doublerealT[n_a[69] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[69]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 70) {
			//doublerealT *diag70 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[70] = new doublerealT[n_a[70] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[70]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 71) {
			//doublerealT *diag71 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[71] = new doublerealT[n_a[71] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[71]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 72) {
			//doublerealT *diag72 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[72] = new doublerealT[n_a[72] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[72]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 73) {
			//doublerealT *diag73 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[73] = new doublerealT[n_a[73] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[73]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 74) {
			//doublerealT *diag74 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[74] = new doublerealT[n_a[74] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[74]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 75) {
			//doublerealT *diag75 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[75] = new doublerealT[n_a[75] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[75]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 76) {
			//doublerealT *diag76 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[76] = new doublerealT[n_a[76] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[76]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 77) {
			//doublerealT *diag77 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[77] = new doublerealT[n_a[77] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[77]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		if (i_id_level_local == 78) {
			//doublerealT *diag78 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[78] = new doublerealT[n_a[78] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[78]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 79) {
			//doublerealT *diag79 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[79] = new doublerealT[n_a[79] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[79]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 80) {
			//doublerealT *diag80 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[80] = new doublerealT[n_a[80] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[80]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 81) {
			//doublerealT *diag81 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[81] = new doublerealT[n_a[81] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[81]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 82) {
			//doublerealT *diag82 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[82] = new doublerealT[n_a[82] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[82]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 83) {
			//doublerealT *diag83 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[83] = new doublerealT[n_a[83] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[83]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 84) {
			//doublerealT *diag84 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[84] = new doublerealT[n_a[84] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[84]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 85) {
			//doublerealT *diag85 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[85] = new doublerealT[n_a[85] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[85]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 86) {
			//doublerealT *diag86 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[86] = new doublerealT[n_a[86] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[86]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 87) {
			//doublerealT *diag87 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[87] = new doublerealT[n_a[87] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[87]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 88) {
			//doublerealT *diag88 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[88] = new doublerealT[n_a[88] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[88]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 89) {
			//doublerealT *diag89 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[89] = new doublerealT[n_a[89] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[89]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 90) {
			//doublerealT *diag90 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[90] = new doublerealT[n_a[90] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[90]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 91) {
			//doublerealT *diag91 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[91] = new doublerealT[n_a[91] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[91]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 92) {
			//doublerealT *diag92 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[92] = new doublerealT[n_a[92] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[92]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 93) {
			//doublerealT *diag93 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[93] = new doublerealT[n_a[93] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[93]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 94) {
			//doublerealT *diag94 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[94] = new doublerealT[n_a[94] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[94]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 95) {
			//doublerealT *diag95 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[95] = new doublerealT[n_a[95] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[95]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 96) {
			//doublerealT *diag96 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[96] = new doublerealT[n_a[96] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[96]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 97) {
			//doublerealT *diag97 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[97] = new doublerealT[n_a[97] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[97]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 98) {
			//doublerealT *diag98 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[98] = new doublerealT[n_a[98] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[98]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 99) {
			//doublerealT *diag99 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[99] = new doublerealT[n_a[99] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[99]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
		else if (i_id_level_local == 100) {
			//doublerealT *diag100 = NULL;
			if (ilevel > i_id_level_local) {
				// diag[100] = new doublerealT[n_a[100] + 1];
				diag[i_id_level_local] = (doublerealT*)malloc((n_a[i_id_level_local] + 1) * sizeof(doublerealT));
				handle_error<doublerealT>(diag[i_id_level_local], "diag[100]", "classic_aglomerative_amg_4", (n_a[i_id_level_local] + 1));
			}
		}
	}


	bnested_desection_global_amg = NULL;
	bool **nested_desection = NULL;
	nested_desection = new bool*[idim_diag];
	if (nested_desection == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for nested_desection my_gregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer i_id_level_local = 0; i_id_level_local < idim_diag; i_id_level_local++) {
		nested_desection[i_id_level_local] = NULL;
	}

	if (!bonly_serial) {
		// nested desection start
		bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1) * sizeof(bool));
		handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_4", (n_a[0] + 1));


		nested_desection[0] = (bool*)malloc((n_a[0] + 1) * sizeof(bool));
		handle_error<bool>(nested_desection[0], "nested_desection[0]", "classic_aglomerative_amg_4", (n_a[0] + 1));


		if (ilevel > 1) {
			nested_desection[1] = (bool*)malloc((n_a[1] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[1], "nested_desection[1]", "classic_aglomerative_amg_4", (n_a[1] + 1));
		}

		if (ilevel > 2) {
			nested_desection[2] = (bool*)malloc((n_a[2] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[2], "nested_desection[2]", "classic_aglomerative_amg_4", (n_a[2] + 1));
		}

		if (ilevel > 3) {
			nested_desection[3] = (bool*)malloc((n_a[3] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[3], "nested_desection[3]", "classic_aglomerative_amg_4", (n_a[3] + 1));
		}

		if (ilevel > 4) {
			nested_desection[4] = (bool*)malloc((n_a[4] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[4], "nested_desection[4]", "classic_aglomerative_amg_4", (n_a[4] + 1));
		}

		if (ilevel > 5) {
			nested_desection[5] = (bool*)malloc((n_a[5] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[5], "nested_desection[5]", "classic_aglomerative_amg_4", (n_a[5] + 1));
		}

		if (ilevel > 6) {
			nested_desection[6] = (bool*)malloc((n_a[6] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[6], "nested_desection[6]", "classic_aglomerative_amg_4", (n_a[6] + 1));
		}

		if (ilevel > 7) {
			nested_desection[7] = (bool*)malloc((n_a[7] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[7], "nested_desection[7]", "classic_aglomerative_amg_4", (n_a[7] + 1));
		}

		if (ilevel > 8) {
			nested_desection[8] = (bool*)malloc((n_a[8] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[8], "nested_desection[8]", "classic_aglomerative_amg_4", (n_a[8] + 1));
		}

		if (ilevel > 9) {
			nested_desection[9] = (bool*)malloc((n_a[9] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[9], "nested_desection[9]", "classic_aglomerative_amg_4", (n_a[9] + 1));
		}

		if (ilevel > 10) {
			nested_desection[10] = (bool*)malloc((n_a[10] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[10], "nested_desection[10]", "classic_aglomerative_amg_4", (n_a[10] + 1));
		}

		if (ilevel > 11) {
			nested_desection[11] = (bool*)malloc((n_a[11] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[11], "nested_desection[11]", "classic_aglomerative_amg_4", (n_a[11] + 1));
		}

		if (ilevel > 12) {
			nested_desection[12] = (bool*)malloc((n_a[12] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[12], "nested_desection[12]", "classic_aglomerative_amg_4", (n_a[12] + 1));
		}

		if (ilevel > 13) {
			nested_desection[13] = (bool*)malloc((n_a[13] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[13], "nested_desection[13]", "classic_aglomerative_amg_4", (n_a[13] + 1));
		}

		if (ilevel > 14) {
			nested_desection[14] = (bool*)malloc((n_a[14] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[14], "nested_desection[14]", "classic_aglomerative_amg_4", (n_a[14] + 1));
		}

		if (ilevel > 15) {
			nested_desection[15] = (bool*)malloc((n_a[15] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[15], "nested_desection[15]", "classic_aglomerative_amg_4", (n_a[15] + 1));
		}

		if (ilevel > 16) {
			nested_desection[16] = (bool*)malloc((n_a[16] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[16], "nested_desection[16]", "classic_aglomerative_amg_4", (n_a[16] + 1));
		}

		if (ilevel > 17) {
			nested_desection[17] = (bool*)malloc((n_a[17] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[17], "nested_desection[17]", "classic_aglomerative_amg_4", (n_a[17] + 1));
		}

		if (ilevel > 18) {
			nested_desection[18] = (bool*)malloc((n_a[18] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[18], "nested_desection[18]", "classic_aglomerative_amg_4", (n_a[18] + 1));
		}
		if (ilevel > 19) {
			nested_desection[19] = (bool*)malloc((n_a[19] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[19], "nested_desection[19]", "classic_aglomerative_amg_4", (n_a[19] + 1));
		}
		if (ilevel > 20) {
			nested_desection[20] = (bool*)malloc((n_a[20] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[20], "nested_desection[20]", "classic_aglomerative_amg_4", (n_a[20] + 1));
		}
		if (ilevel > 21) {
			nested_desection[21] = (bool*)malloc((n_a[21] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[21], "nested_desection[21]", "classic_aglomerative_amg_4", (n_a[21] + 1));
		}
		if (ilevel > 22) {
			nested_desection[22] = (bool*)malloc((n_a[22] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[22], "nested_desection[22]", "classic_aglomerative_amg_4", (n_a[22] + 1));
		}
		if (ilevel > 23) {
			nested_desection[23] = (bool*)malloc((n_a[23] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[23], "nested_desection[23]", "classic_aglomerative_amg_4", (n_a[23] + 1));
		}
		if (ilevel > 24) {
			nested_desection[24] = (bool*)malloc((n_a[24] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[24], "nested_desection[24]", "classic_aglomerative_amg_4", (n_a[24] + 1));
		}
		if (ilevel > 25) {
			nested_desection[25] = (bool*)malloc((n_a[25] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[25], "nested_desection[25]", "classic_aglomerative_amg_4", (n_a[25] + 1));
		}
		if (ilevel > 26) {
			nested_desection[26] = (bool*)malloc((n_a[26] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[26], "nested_desection[26]", "classic_aglomerative_amg_4", (n_a[26] + 1));
		}
		if (ilevel > 27) {
			nested_desection[27] = (bool*)malloc((n_a[27] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[27], "nested_desection[27]", "classic_aglomerative_amg_4", (n_a[27] + 1));
		}
		if (ilevel > 28) {
			nested_desection[28] = (bool*)malloc((n_a[28] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[28], "nested_desection[28]", "classic_aglomerative_amg_4", (n_a[28] + 1));
		}
		if (ilevel > 29) {
			nested_desection[29] = (bool*)malloc((n_a[29] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[29], "nested_desection[29]", "classic_aglomerative_amg_4", (n_a[29] + 1));
		}
		if (ilevel > 30) {
			nested_desection[30] = (bool*)malloc((n_a[30] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[30], "nested_desection[30]", "classic_aglomerative_amg_4", (n_a[30] + 1));
		}
		if (ilevel > 31) {
			nested_desection[31] = (bool*)malloc((n_a[31] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[31], "nested_desection[31]", "classic_aglomerative_amg_4", (n_a[31] + 1));
		}
		if (ilevel > 32) {
			nested_desection[32] = (bool*)malloc((n_a[32] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[32], "nested_desection[32]", "classic_aglomerative_amg_4", (n_a[32] + 1));
		}
		if (ilevel > 33) {
			nested_desection[33] = (bool*)malloc((n_a[33] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[33], "nested_desection[33]", "classic_aglomerative_amg_4", (n_a[33] + 1));
		}
		if (ilevel > 34) {
			nested_desection[34] = (bool*)malloc((n_a[34] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[34], "nested_desection[34]", "classic_aglomerative_amg_4", (n_a[34] + 1));
		}
		if (ilevel > 35) {
			nested_desection[35] = (bool*)malloc((n_a[35] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[35], "nested_desection[35]", "classic_aglomerative_amg_4", (n_a[35] + 1));
		}
		if (ilevel > 36) {
			nested_desection[36] = (bool*)malloc((n_a[36] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[36], "nested_desection[36]", "classic_aglomerative_amg_4", (n_a[36] + 1));
		}
		if (ilevel > 37) {
			nested_desection[37] = (bool*)malloc((n_a[37] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[37], "nested_desection[37]", "classic_aglomerative_amg_4", (n_a[37] + 1));
		}
		if (ilevel > 38) {
			nested_desection[38] = (bool*)malloc((n_a[38] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[38], "nested_desection[38]", "classic_aglomerative_amg_4", (n_a[38] + 1));
		}
		if (ilevel > 39) {
			nested_desection[39] = (bool*)malloc((n_a[39] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[39], "nested_desection[39]", "classic_aglomerative_amg_4", (n_a[39] + 1));
		}
		if (ilevel > 40) {
			nested_desection[40] = (bool*)malloc((n_a[40] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[40], "nested_desection[40]", "classic_aglomerative_amg_4", (n_a[40] + 1));
		}
		if (ilevel > 41) {
			nested_desection[41] = (bool*)malloc((n_a[41] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[41], "nested_desection[41]", "classic_aglomerative_amg_4", (n_a[41] + 1));
		}
		if (ilevel > 42) {
			nested_desection[42] = (bool*)malloc((n_a[42] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[42], "nested_desection[42]", "classic_aglomerative_amg_4", (n_a[42] + 1));
		}
		if (ilevel > 43) {
			nested_desection[43] = (bool*)malloc((n_a[43] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[43], "nested_desection[43]", "classic_aglomerative_amg_4", (n_a[43] + 1));
		}
		if (ilevel > 44) {
			nested_desection[44] = (bool*)malloc((n_a[44] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[44], "nested_desection[44]", "classic_aglomerative_amg_4", (n_a[44] + 1));
		}
		if (ilevel > 45) {
			nested_desection[45] = (bool*)malloc((n_a[45] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[45], "nested_desection[45]", "classic_aglomerative_amg_4", (n_a[45] + 1));
		}
		if (ilevel > 46) {
			nested_desection[46] = (bool*)malloc((n_a[46] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[46], "nested_desection[46]", "classic_aglomerative_amg_4", (n_a[46] + 1));
		}
		if (ilevel > 47) {
			nested_desection[47] = (bool*)malloc((n_a[47] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[47], "nested_desection[47]", "classic_aglomerative_amg_4", (n_a[47] + 1));
		}
		if (ilevel > 48) {
			nested_desection[48] = (bool*)malloc((n_a[48] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[48], "nested_desection[48]", "classic_aglomerative_amg_4", (n_a[48] + 1));
		}
		if (ilevel > 49) {
			nested_desection[49] = (bool*)malloc((n_a[49] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[49], "nested_desection[49]", "classic_aglomerative_amg_4", (n_a[49] + 1));
		}
		if (ilevel > 50) {
			nested_desection[50] = (bool*)malloc((n_a[50] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection[50], "nested_desection[50]", "classic_aglomerative_amg_4", (n_a[50] + 1));
		}
	
		//idim_diag==101
		for (integer i_17 = 51; i_17 <= idim_diag-1; i_17++) {
			if (ilevel > i_17) {
				nested_desection[i_17] = (bool*)malloc((n_a[i_17] + 1) * sizeof(bool));
				handle_error<bool>(nested_desection[i_17], "nested_desection[i_17]", "classic_aglomerative_amg_4", (n_a[i_17] + 1));
			}
		}

	}
	// nested_desection_end

	integer *row_ptr_start = NULL;
	const integer isize_row_ptr = 4 * n_a[0] + 1;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	row_ptr_start = (integer*)malloc((isize_row_ptr) * sizeof(integer));
	handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_4", (isize_row_ptr));

	integer *row_ptr_end = NULL;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((isize_row_ptr) * sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_4", (isize_row_ptr));

	// ILU2
	LEVEL_ADDITIONAL_DATA* milu2 = NULL;
	// инициализация.
	init_level_additional_data(milu2, ilevel);

	// ILU0
	LEVEL_ADDITIONAL_DATA0* milu0 = NULL;
	// инициализация.
	init_level_additional_data(milu0, ilevel);

	// Освобождение общей памяти в ILU буффере.
	if (milu_gl_buffer.alu_copy != NULL) delete[] milu_gl_buffer.alu_copy;
	if (milu_gl_buffer.jlu_copy != NULL) delete[] milu_gl_buffer.jlu_copy;
	if (milu_gl_buffer.ju_copy != NULL) delete[] milu_gl_buffer.ju_copy;
	milu_gl_buffer.alu_copy = NULL;
	milu_gl_buffer.jlu_copy = NULL;
	milu_gl_buffer.ju_copy = NULL;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
#pragma omp parallel for
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("nado uvelichit isize_row_ptr %lld", istr);
#else
				printf("nado uvelichit isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
								 //x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					// Все внедиагональные элементы должны быть строго отрицательны.
					// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
					if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
						//printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %lld...\n", Amat[ic].aij, istr);
#else
						//printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %d...\n", Amat[ic].aij, istr);
#endif
						
						// Вдруг это не страшно 26 октября 2016.
						// Ну да на задача с конвекцией встречается даже и на нулевом уровне вложенности.
						//system("PAUSE");
					}
				}
				else {
					// дмагональный элемент строго положителен.
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("nado uvelichit isize_row_ptr %lld", istr);
#else
				printf("nado uvelichit isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			if (bmemory_savings) {
				// По исходному номеру получаем текущий,
				// но теперь два текущих поменялись.
				the_original_order_of_values[the_original_order_of_values_reverse[ii]] = icdiag;
				the_original_order_of_values[the_original_order_of_values_reverse[icdiag]] = ii;
			}

			diag[0][Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	if (bILU2smoother == 2) {
		// ILU2
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	else if (bILU2smoother == 1) {
		// ILU0
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA0(milu0[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	else if (my_amg_manager.iFinnest_ilu == 1) {
		// ILU0 но только на самой подробной сетке.
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	bool bstop = false;


	// 14 сентября 2015 понедельник четвёртый уровень вложенности.
	// Уровни вложенности с первого по седьмой сразу. 12.07.2016.

	// Заголовок 29.10.2016.
	if (bprint_mesage_diagnostic) {
		printf("1. positive connections %%, 2. max positive/ diagonal %%\n");
	}

	for (integer ilevel_detector = 1; ilevel_detector <= idim_diag - 1; ilevel_detector++) {

		// Обработка матрицы действует до 99 уровня включительно, но
		// сбор статистики желательно сделать для всех уровней.
		const integer istop_level_scan = idim_diag - 2;

		if (ilevel > ilevel_detector) {

			doublerealT inum_vnediagonal_all = 0.0;
			doublerealT inum_only_positive_vnediagonal = 0.0;
			doublerealT memo_diagonal_element = 0.0;
			doublerealT max_positive_connections_element = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement_avg = 0.0;
			bool b_ne_menee_2_positive_con_in_string = false;
			doublerealT inum_only_positive_vnediagonal_ne_menee2_in_string = 0.0;

			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			integer ist = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				ist += nnz_a[ilev];
			}
			integer iend = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iend += nnz_a[ilev];
			}
			integer istPR = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				istPR += nnz_aRP[ilev];
			}
			integer iendPR = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iendPR += nnz_aRP[ilev];
			}
			double dn_num = 0.0;
			for (integer ii = ist; ii <= iend; ii++) {
				if (flag[Amat[ii].i] == false) {

					integer istr = Amat[ii].i;
					integer ic = ii;
					integer icdiag = ii;
					integer istart_row_ptr = istr;
					for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
						istart_row_ptr += n_a[ilev];
					}

					

					max_positive_connections_element = -1.0;
					dn_num += 1.0;

					bool b_bad_string = false;
					max_positive_connections_element = -1.0;
					
					
					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("nado uvelichit isize_row_ptr %lld", istart_row_ptr);
#else
						printf("nado uvelichit isize_row_ptr %d", istart_row_ptr);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_start[istart_row_ptr] = ii;
					}
					doublerealT ap = 0.0;
					doublerealT sum_4 = 0.0;
					
					


					const doublerealT theta7 = theta; // передаётся в функцию извне.
					b_ne_menee_2_positive_con_in_string = false;
					integer inum_pos_con_in_string = 0;
					doublerealT threshold7 = -1.0;
					integer ic7 = ic;
					while ((ic7 <= iend) && (Amat[ic7].i == istr)) {
						if (Amat[ic7].j != istr) {
							if (Amat[ic7].aij >= 0.0) {
								inum_pos_con_in_string++;
								if (fabs(Amat[ic7].aij) > threshold7) threshold7 = fabs(Amat[ic7].aij);
							}
						}
						ic7++;
					}
					// мы обнаружили не менее двух положительных связей в данной строке.
					if (inum_pos_con_in_string >= 2) {
						inum_pos_con_in_string = 0;
						ic7 = ic;
						while ((ic7 <= iend) && (Amat[ic7].i == istr)) {
							if (Amat[ic7].j != istr) {
								if ((Amat[ic7].aij >= 0.0) && (fabs(Amat[ic7].aij) >= theta7*threshold7)) {
									inum_pos_con_in_string++;
								}
							}
							ic7++;
						}

						if (inum_pos_con_in_string >= 2) {
							b_ne_menee_2_positive_con_in_string = true;
						}
					}

					
						//x[istr] = b[istr];
					while ((ic <= iend) && (Amat[ic].i == istr)) {
						if (Amat[ic].j != istr) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
							inum_vnediagonal_all += 1.0;
							// Все внедиагональные элементы должны быть строго отрицательны.
							// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
							if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
								//printf("polochitelnji vnediagonalnj element %e in matrix level %lld in string %lld...\n", Amat[ic].aij, ilevel_detector, istr);
#else
								//printf("polochitelnji vnediagonalnj element %e in matrix level %d in string %d...\n", Amat[ic].aij, ilevel_detector, istr);
#endif
								//system("PAUSE");
								inum_only_positive_vnediagonal += 1.0;

								if (b_ne_menee_2_positive_con_in_string) {
									if (fabs(Amat[ic7].aij) >= theta7*threshold7) {
										inum_only_positive_vnediagonal_ne_menee2_in_string += 1.0;
									}
								}

								// Определение величины максимальной внедиагональной связи.
								if (max_positive_connections_element < Amat[ic].aij) {
									max_positive_connections_element = Amat[ic].aij;
								}
							}
						}
						else {
							ap = Amat[ic].aij;
							memo_diagonal_element = ap;
							icdiag = ic;
							if (ap < 1.0e-20) {
								b_bad_string = true;
								// прекращаем строить иерархию уровней.
								bcontinue_global = false;
								//goto BAD_STRING_MARKER;
								printf("FATAL ERROR !!! amg4 function string 60806");
								system("PAUSE");
								exit(1);
								integer ic_4 = ii;
								printf("bad string:\n");

								while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
									if (Amat[ic_4].j != istr) {
										sum_4 += fabs(Amat[ic_4].aij);
									}
									printf("%e ", Amat[ic_4].aij);
									ic_4++;
								}
								printf("\n");
								ic_4 = ii;
#if doubleintprecision == 1
								printf("i==%lld\n", istr);
								while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
									printf("%lld ", Amat[ic_4].j);
									ic_4++;
								}
#else
								printf("i==%d\n", istr);
								while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
									printf("%d ", Amat[ic_4].j);
									ic_4++;
								}
#endif

								printf("\n");
								printf("sum_4=%e\n", sum_4);




								system("pause");
							}
						}
						ic++;
					}

					if (b_bad_string) {

						integer ic_4 = ii;
#if doubleintprecision == 1
						printf("cure line %lld:\n", istr);
#else
						printf("cure line %d:\n", istr);
#endif

						// прекращаем строить иерархию уровней.
						bcontinue_global = false;
						//goto BAD_STRING_MARKER;
						printf("FATAL ERROR !!! amg4 function string 60859");
						system("PAUSE");
						exit(1);

						while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
							if (Amat[ic_4].j != istr) {
								//sum_4 += fabs(Amat[ic_4].aij);
								Amat[ic_4].aij = 0.0;
							}
							//printf("%e ", Amat[ic_4].aij);
							ic_4++;
						}
						for (integer ii_5 = istPR; ii_5 <= iendPR; ii_5++) {
							if (P[ii_5].i == istr) {
								if (P[ii_5].j == istr) {
									P[ii_5].aij = 1.0;
								}
								else {
									P[ii_5].aij = 0.0;
								}
							}
							if (R[ii_5].i == istr) {
								if (R[ii_5].j == istr) {
									R[ii_5].aij = 1.0;
								}
								else {
									R[ii_5].aij = 0.0;
								}
							}
						}

						// лечим строку, хотя возможно проблема истинная проблема сидит гораздо выше по коду.
						// Делаем очень сильное диагональное преобладание в этой дефектной строке.
						sum_4 = 1.0;
						Amat[icdiag].aij = sum_4;
						memo_diagonal_element = sum_4;
						ap = sum_4;

						// лечим строку, хотя возможно проблема истинная проблема сидит гораздо выше по коду.
						/*
						ic_4 = ii;
						while ((ic_4 <= iend) && (Amat[ic_4].i == istr)) {
						if (Amat[ic_4].j != istr) {
						//sum_4 += fabs(Amat[ic_4].aij);
						Amat[ic_4].aij = 0.0;
						}
						//printf("%e ", Amat[ic_4].aij);
						ic_4++;
						}
						*/

						//Amat[icdiag].aij = 1.0;
						//memo_diagonal_element = 1.0;
						//ap = 1.0;
					}
					

					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("nado uvelichit isize_row_ptr %lld", istart_row_ptr);
#else
						printf("nado uvelichit isize_row_ptr %d", istart_row_ptr);
#endif

						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_end[istart_row_ptr] = ic - 1;
					}
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal elements in string %lld in level %lld matrix", istr, ilevel);
#else
						printf("zero diagonal elements in string %d in level %d matrix", istr, ilevel);
#endif

						system("PAUSE");
						exit(1);
					}
					else {
						//x[istr] /= ap;
					}
					

					ratio_positive_connections_by_diagonalelement_avg += fabs(max_positive_connections_element / memo_diagonal_element);
					if (ratio_positive_connections_by_diagonalelement < fabs(max_positive_connections_element / memo_diagonal_element)) {
						ratio_positive_connections_by_diagonalelement = fabs(max_positive_connections_element / memo_diagonal_element);
					}
					flag[Amat[ii].i] = true;
					if (ilevel_detector <= istop_level_scan) {
						Ak1 temp = Amat[ii];
						Amat[ii] = Amat[icdiag];
						Amat[icdiag] = temp;
						switch (ilevel_detector) {
						case 1: diag[1][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 2: diag[2][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 3: diag[3][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 4: diag[4][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 5: diag[5][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 6: diag[6][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 7: diag[7][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 8: diag[8][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 9: diag[9][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 10: diag[10][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 11: diag[11][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 12: diag[12][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 13: diag[13][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 14: diag[14][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 15: diag[15][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 16: diag[16][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 17: diag[17][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 18: diag[18][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 19: diag[19][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 20: diag[20][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 21: diag[21][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 22: diag[22][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 23: diag[23][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 24: diag[24][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 25: diag[25][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 26: diag[26][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 27: diag[27][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 28: diag[28][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 29: diag[29][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 30: diag[30][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 31: diag[31][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 32: diag[32][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 33: diag[33][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 34: diag[34][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 35: diag[35][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 36: diag[36][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 37: diag[37][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 38: diag[38][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 39: diag[39][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 40: diag[40][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 41: diag[41][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 42: diag[42][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 43: diag[43][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 44: diag[44][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 45: diag[45][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 46: diag[46][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 47: diag[47][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 48: diag[48][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 49: diag[49][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 50: diag[50][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 51: diag[51][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 52: diag[52][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 53: diag[53][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 54: diag[54][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 55: diag[55][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 56: diag[56][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 57: diag[57][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 58: diag[58][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 59: diag[59][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 60: diag[60][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 61: diag[61][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 62: diag[62][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 63: diag[63][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 64: diag[64][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 65: diag[65][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 66: diag[66][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 67: diag[67][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 68: diag[68][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 69: diag[69][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 70: diag[70][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 71: diag[71][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 72: diag[72][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 73: diag[73][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 74: diag[74][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 75: diag[75][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 76: diag[76][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 77: diag[77][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 78: diag[78][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 79: diag[79][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 80: diag[80][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 81: diag[81][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 82: diag[82][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 83: diag[83][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 84: diag[84][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 85: diag[85][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 86: diag[86][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 87: diag[87][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 88: diag[88][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 89: diag[89][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 90: diag[90][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 91: diag[91][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 92: diag[92][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 93: diag[93][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 94: diag[94][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 95: diag[95][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 96: diag[96][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 97: diag[97][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 98: diag[98][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 99: diag[99][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 100: diag[100][Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						default: printf("ilevel_detector incorrect\n");
							//getchar();
							system("PAUSE");
							break;
						}

						Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
					}


				}
			}

			integer iadd_now = 0;
			for (integer i54 = 1; i54 <= ilevel_detector; i54++) {
				iadd_now += n_a[i54 - 1];
			}
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 2) {
#if doubleintprecision == 1
					printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
					printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
					
					equation3DtoCRSRUMBA1(milu2[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 1) {
#if doubleintprecision == 1
					// ILU0
					printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
					// ILU0
					printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
					
					// iadd_now=n_a[0]+...+n_a[ilevel_detector-1];
					equation3DtoCRSRUMBA0(milu0[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}
			if (ilevel_detector <= istop_level_scan) {
				if (my_amg_manager.iFinnest_ilu == 1) {
					if (my_amg_manager.b_ilu_smoothers_in_nnz_n_LE_6) {
						doublerealT dn = 1.0*n_a[ilevel_detector];
						doublerealT dnnz = 1.0*nnz_a[ilevel_detector];
						if (dnnz / dn <= dapply_ilu_max_pattern_size) {
							// маленький (компактный) шаблон.
#if doubleintprecision == 1
							printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
							printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
							
							equation3DtoCRSRUMBA1(milu2[ilevel_detector], true,
								Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
						}
					}
				}
			}


			// statistic log :
			if (bprint_mesage_diagnostic) {
				//printf("procent positive connections %e \n", 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all);
				//printf("the ratio of the maximum positive connections to the diagonal\n");
				//printf("element in the row, in procent %e\n", 100.0*ratio_positive_connections_by_diagonalelement);
				//printf("\n");
#if doubleintprecision == 1
				printf("%lld %2.1f %% [ %2.2f %% ] %3.1f  [%2.2f ]\n", ilevel_detector, 1.00*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100 * inum_only_positive_vnediagonal_ne_menee2_in_string / inum_vnediagonal_all, 1e-4*ratio_positive_connections_by_diagonalelement, 1e-4*ratio_positive_connections_by_diagonalelement_avg / dn_num);

#else
				printf("%d %2.1f %% [ %2.2f %% ] %3.1f  [%2.2f ]\n", ilevel_detector, 1.00*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100 * inum_only_positive_vnediagonal_ne_menee2_in_string / inum_vnediagonal_all, 1e-4*ratio_positive_connections_by_diagonalelement, 1e-4*ratio_positive_connections_by_diagonalelement_avg / dn_num);

#endif
							}
		}


	}


	


	if (bstop) exit(1);
	if (bILU2smoother > 0) {
		// Пауза только в случае применения ILU декомпозиции.
		//system("PAUSE");
		if (bILU2smoother == 2) {
			// Осторожно возможно код быстро устареет.
			// Выделение оперативной памяти под централизованное хранилище 
			// для ILU.
			memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1);
			//memory_allocation_apostoriory_buffer_ilu(milu2, ilevel-1);// 4.01.2017
		}
	}
	else if (my_amg_manager.iFinnest_ilu == 1) {
		// ILU0 но только на самой подробной сетке.
		memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1); // 7.06.2017.
	}


	// ЗАКОМЕНТИРОВАННЫЙ КОД ОТНОСИТСЯ К УСТАРЕВШЕМУ. 
	// 4 ноября 2016 прописано 15 уровней вложенности.
	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
	integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
	for (integer ii = ist; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	integer icdiag = ii;
	row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
	doublerealT ap = 0.0;
	//x[istr] = b[istr];
	while ((ic <= iend) && (Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else {
	ap = Amat[ic].aij;
	icdiag = ic;
	}
	ic++;
	}
	row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld in level 7 matrix", istr);
	#else
		printf("zero diagonal elements in string %d in level 7 matrix", istr);
	#endif
	
	system("PAUSE");
	exit(1);
	}
	else {
	//x[istr] /= ap;
	}

	flag[Amat[ii].i] = true;
	Ak1 temp = Amat[ii];
	Amat[ii] = Amat[icdiag];
	Amat[icdiag] = temp;
	diag[8][Amat[ii].i] = ap; // для ускорения вычисления невязки.
	Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
	}
	}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection[0]
		nested_desection_patch(Amat, n_a[0], nested_desection[0], row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection[1]
		if (ilevel > 1) {
			nested_desection_patch(Amat, n_a[1], nested_desection[1], row_ptr_start, row_ptr_end, n_a[0]);
			if (bprint_mesage_diagnostic) {
				printf("part2\n");
			}
		}
		if (ilevel > 2) {
			nested_desection_patch(Amat, n_a[2], nested_desection[2], row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
			if (bprint_mesage_diagnostic) {
				printf("part3\n");
			}
		}
		if (ilevel > 3) {
			nested_desection_patch(Amat, n_a[3], nested_desection[3], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
			if (bprint_mesage_diagnostic) {
				printf("part4\n");
			}
		}
		if (ilevel > 4) {
			nested_desection_patch(Amat, n_a[4], nested_desection[4], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
			if (bprint_mesage_diagnostic) {
				printf("part5\n");
			}
		}
		if (ilevel > 5) {
			nested_desection_patch(Amat, n_a[5], nested_desection[5], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
			if (bprint_mesage_diagnostic) {
				printf("part6\n");
			}
		}
		if (ilevel > 6) {
			nested_desection_patch(Amat, n_a[6], nested_desection[6], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
			if (bprint_mesage_diagnostic) {
				printf("part7\n");
			}
		}
		if (ilevel > 7) {
			nested_desection_patch(Amat, n_a[7], nested_desection[7], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
			if (bprint_mesage_diagnostic) {
				printf("part8 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 8) {
			nested_desection_patch(Amat, n_a[8], nested_desection[8], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
			if (bprint_mesage_diagnostic) {
				printf("part9 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 9) {
			nested_desection_patch(Amat, n_a[9], nested_desection[9], row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
			if (bprint_mesage_diagnostic) {
				printf("part10 \n");
				printf("nested desection is finish\n");
			}
		}
		
		// idim_diag==101
		for (integer i_17 = 10; i_17 <= idim_diag - 1; i_17++) {
			if (ilevel > i_17) {
				integer inasum = 0;
				for (integer i_18 = 0; i_18 < i_17; i_18++) inasum += n_a[i_18];
				nested_desection_patch(Amat, n_a[i_17], nested_desection[i_17], row_ptr_start, row_ptr_end, inasum);
				if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
					printf("part%lld \n", i_17);
#else
					printf("part%d \n", i_17);
#endif
					
					printf("nested desection is finish\n");
				}
			}
		}


	}


	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=NULL) {
	   free(this_is_C_node);
	   this_is_C_node=NULL;
	}
	if (this_is_F_node!=NULL) {
	   free(this_is_F_node);
	   this_is_F_node=NULL;
	}
	//delete[] hash_table;
	if (hash_table != NULL) {
		free(hash_table);
		hash_table = NULL;
	}
	if (hash_table2 != NULL) {
		free(hash_table2);
		hash_table2 = NULL;
	}
	//delete[] istack;
	//delete[] istack2;
	if (istack != NULL) {
		free(istack);
		istack = NULL;
	}
	if (istack2 != NULL) {
		free(istack2);
		istack2 = NULL;
	}


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

					 // на задаче Finned Heat Sync из первого туториала Icepak была обнаружена расходимость 
					 // для Y скорости и поправки давления. При этом обтекание куба отлично считалось на равномерной
					 // сетки с nu1=1, nu2=2 даже при весьма больших числах Рейнольдса.
					 // при nu1=10, nu2=10 скорости разрешаются хорошо и проблем с ними нет, но поправка давления по прежнему даёт сбой.
					 // при nu==20 сбой всё равно есть.
					 // не помогло.
					 //nu1 = 40;
					 //nu2 = 40;

	integer nFinestSweeps = 2;


	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	nu1 = my_amg_manager.nu1;
	nu2 = my_amg_manager.nu2;
	nFinestSweeps = my_amg_manager.nFinnest;

	//if (iVar == PAM) {
	//nFinestSweeps = 300;
	//nu1 = 0;
	//nu2 = 20;
	//}
	// для Finner Heat Sink надо усилить сглаживания.
	// Это не помогает будет перенаправление на другой алгоритм.
	//if (iVar == PAM) {
	//nu1 = 3;
	//nu2 = 3;
	//nFinestSweeps = 6;
	//}
	const bool btheoryGuideANSYSFluent = false;
	if (iVar != PAM) {
		if (btheoryGuideANSYSFluent) {
			// Так написано в Theory Guide ANSYS Fluent.
			nu1 = 0;
			nu2 = 1;
			nFinestSweeps = 1;
		}
	}



	// Двойной вакуумный промежуток вызывает проблемы сходимости :
	//nu1 = 10;
	//nu2 = 20;

	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = 0.7;
	doublerealT process_flow_alpha = 0.1;
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f  %1.2f\n", (doublerealT)(nnz_P_memo_all / nnz_P_memo_0), (doublerealT)(nnz_P_memo_all / n_a[0]));
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	doublerealT tolerance = 0.0001; // точность выхода по классическому определению L2 нормы.
								   // 23 октября 2016
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		tolerance = 1.0e-8;
	}

	doublerealT **residual_fine = NULL;
	residual_fine = new doublerealT*[idim_diag];
	if (residual_fine == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for residual_fine my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublerealT **residual_coarse = NULL;
	residual_coarse = new doublerealT*[idim_diag];
	if (residual_coarse == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for residual_coarse my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublerealT **error_approx_coarse = NULL;
	error_approx_coarse = new doublerealT*[idim_diag];
	if (error_approx_coarse == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for error_approx_coarse my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublerealT **error_approx_fine = NULL;
	error_approx_fine = new doublerealT*[idim_diag];
	if (error_approx_fine == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for error_approx_fine my_gregat_amg4.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	for (integer i_id_level_local = 0; i_id_level_local < idim_diag; i_id_level_local++) {
		residual_fine[i_id_level_local] = NULL;
		residual_coarse[i_id_level_local] = NULL;
		error_approx_coarse[i_id_level_local] = NULL;
		error_approx_fine[i_id_level_local] = NULL;
	}

	
	// Устаревший код инициализации значением NULL 4 декабря 2016. 
	
	// Закоментированный код безнадёжно устарел. В данный момент 
	//5.06.2017 поддерживается 100 уровней вложенности.

	// 25.04.2018 На этом месте удалён большой фрагмент устаревшего кода.

	// лучше выделять оперативную память небольшими блоками т.к.
	// оперативная память фрагментирована системными dll и
	// большого свободного блока может не найтись.


	

	// idim_diag==101
	for (integer i_17 = 1; i_17 <= idim_diag-1; i_17++) {
		// 05.06.2017
		integer i_17_prev = i_17 - 1;

		if (ilevel+1 > i_17) {

		    // residual
		    //residual_fine[i_17_prev] = new doublerealT[n_a[i_17_prev] + 1];
		    residual_fine[i_17_prev] = (doublerealT*)malloc((n_a[i_17_prev] + 1) * sizeof(doublerealT));
		    handle_error<doublerealT>(residual_fine[i_17_prev], "residual_fine[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17_prev] + 1));

		
			//residual_coarse[i_17_prev] = new doublerealT[n_a[i_17] + 1];
			residual_coarse[i_17_prev] = (doublerealT*)malloc((n_a[i_17] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse[i_17_prev], "residual_coarse[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17] + 1));

			//error_approx_coarse[i_17_prev] = new doublerealT[n_a[i_17] + 1];
			error_approx_coarse[i_17_prev] = (doublerealT*)malloc((n_a[i_17] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse[i_17_prev], "error_approx_coarse[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17] + 1));

			//error_approx_fine[i_17_prev] = new doublerealT[n_a[i_17_prev] + 1];
			error_approx_fine[i_17_prev] = (doublerealT*)malloc((n_a[i_17_prev] + 1) * sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine[i_17_prev], "error_approx_fine[",i_17_prev,"]", "classic_aglomerative_amg_4", (n_a[i_17_prev] + 1));
		}
	}




	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	const integer ZERO_INIT = 0;
	const integer RANDOM_INIT = 1;// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	integer imyinit = ZERO_INIT; // ZERO_INIT optimum

	doublerealT* x_copy = NULL;
	x_copy = (doublerealT*)malloc((n_a[0] + 1) * sizeof(doublerealT));
	handle_error<doublerealT>(x_copy, "x_copy", "classic_aglomerative_amg_4", (n_a[0] + 1));

	// для ускорения счёта в вакуумном промежутке.
	doublerealT* x_old = NULL;
	x_old = (doublerealT*)malloc((n_a[0] + 1) * sizeof(doublerealT));
	handle_error<doublerealT>(x_old, "x_old", "classic_aglomerative_amg_4", (n_a[0] + 1));

#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_copy[i47] = x[i47];
		x_old[i47] = x[i47];
		//x_copy[i47] = 0.0; // 28.07.2016
	}

	doublereal* x_best_search = NULL;
	x_best_search = (doublereal*)malloc((n_a[0] + 1) * sizeof(doublereal));
	handle_error<doublereal>(x_best_search, "x_best_search", "classic_aglomerative_amg_4", (n_a[0] + 1));

	doublerealT res_best_search = 1e40;
#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		//x_best_search[i47] = 0.0; // 28.07.2016
	}


	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;
	integer istop_porog_reconst = 5000;// 50

	bool ret_value = false;
	doublerealT dres_previos = 1.0e40;
	integer icount_bad_convergence_Vcycles = 0;
	integer i_count_stagnation = 0;
	doublerealT res0start = 1.0e-40;
	bool bfirst_divergence = true;

	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
	doublerealT dres_initial = norma(residual_fine[0], n_a[0]);
	if (((iVar == VX) || (iVar == VY) || (iVar == VZ)) && (dres_initial > 20.0)) {
		// Это признак ошибки в сборке матрицы СЛАУ на компоненты скорости.
		printf("my be problem convergence : very big dres0=%e\n", dres_initial);
		printf("run residualq2 analysys.\n");
		residualq2_analysys(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
	}

	/*
	// код заимствованный из amg5:
	integer iflag_cont = 1;
	if (iVar != PAM) {
	dres = fabs(dres_initial);

	if (iVar != TEMP) {
	if (dres < dterminatedTResudual) {
	// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
	iflag_cont = 0;
	}
	}
	else {
	if (dres < 1.0e-4*dterminatedTResudual) {
	// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
	iflag_cont = 0;
	}
	}
	}
	iflag_cont = 1;
	*/

	if (bprint_mesage_diagnostic) {
		// start residual.
#if doubleintprecision == 1
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#else
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#endif
		
	}

	// TODO 25 10 2016
	integer iflag_cont = 1;
	if (iVar != PAM) {
		dres = fabs(dres_initial);
	}


	integer count_iter_for_film_coef = 0;
	// Если число расходимостей превысит оговорённую константу то произойдёт выход из алгоритма.
	integer i_signal_break_pam_opening = 0;
	// x хорошее значение.
	const integer i_limit_signal_pam_break_opening = 1000; // 8
	doublerealT delta_old_iter = 1.0e10;



	//if (iVar == PAM) {// бред
	//for (integer iter = 0; iter < 2; iter++) {
	//seidelq(Amat, 1, n_a[0], b, x, row_ptr_start, row_ptr_end, 0);
	//}
	//}
	integer icount_V_cycle = 0;

	doublerealT dres_initial_ = 1e-6;


	doublerealT maxold = -1.0e30;
	for (integer i = 1; i <= n_a[0]; i++) {
		if (x[i] > maxold) maxold = x[i];
	}

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	// Отсекаем уровни которые выше порогового значения указанного пользователем.
	//if (ilevel > my_amg_manager.maximum_levels) {
	//ilevel = my_amg_manager.maximum_levels;
	//}
	ilevel -= my_amg_manager.maximum_delete_levels;



	doublereal* x_best_search2 = NULL;
	x_best_search2 = new doublereal[n_a[0] + 1];
	if (x_best_search2 == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for x_best_search2 my_agregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
	doublereal* x_best_search_init = NULL;
	x_best_search_init = new doublereal[n_a[0] + 1];
	if (x_best_search_init == NULL) {
		// недостаточно памяти на данном оборудовании.
		printf("Problem : not enough memory on your equipment for x_best_search_init my_agregat_amg.cpp...\n");
		printf("Please any key to exit...\n");
		exit(1);
	}
#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search_init[i47] = x[i47];
		x_best_search2[i47] = x[i47];
	}


	integer istop_speed_cycling = 10;

	if ((my_amg_manager.istabilization == 0)||((iVar==TEMP)&&(my_amg_manager.istabilization == 3))) {


		// ((iVar==TEMP)&&(my_amg_manager.istabilization == 3)) - нелинейное граничное условие в уравнении теплопередачи.

		// Только алгебраический многосеточный метод.
		
		if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) tolerance *= 1e-11;
		if (iVar == PAM) tolerance *= 1e-14;
		if (iVar == TEMP) tolerance *= 1e-6;
		if (iVar == TOTALDEFORMATIONVAR) tolerance = 1.0e-17;
		doublereal minx_gl = 1.0e40;
		doublereal maxx_gl = -1.0e40;
	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	//while ((iflag_cont == 1) && ((dres>tolerance) || ((iVar != TEMP) && (icount_V_cycle<5)))) {
	///	while ((iflag_cont == 1) && ((dres>tolerance) )) {
	while (((iflag_cont == 1) && ((dres>tolerance))) || ((iVar == TEMP) && bSIMPLErun_now_for_temperature && (icount_V_cycle<9))||((iVar== TOTALDEFORMATIONVAR)&&(icount_V_cycle<9))) {

		// Обеспечивает коллосальное быстродействие без потери сходимости.
		
		if (bSIMPLErun_now_for_temperature) {
			// гидродинамика.

			//  Этот код непонятен, надо тестировать.
			if (icount_V_cycle > istop_speed_cycling) {

				

				if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
					if (dres < 1.0e-3*dres_initial) {
						break;
					}
					else {
						istop_speed_cycling += 2;
					}
				}
				if (iVar == PAM) {
					if (dres < 1.0e-1*dres_initial) {
						//break;
					}
					else {
						istop_speed_cycling += 2;
					}
				}
			}
		}
	

		if (fabs(dres / rho)<1.0) {
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search2[i47] = x[i47];
			}
		}

		if (bPhysics_stop == true) {
			if (icount_V_cycle > 0) {
				doublerealT maxnew = -1.0e30;
				for (integer i = 1; i <= n_a[0]; i++) {
					if (x[i] > maxnew) maxnew = x[i];
				}
				if (iVar == TOTALDEFORMATIONVAR) {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 1.0e-9)) {
						printf("break bPhysics_stop, dres<1e-2 && (fabs(maxnew - maxold) < 1.0e-9)\n");
						break;
					}
					else {
						maxold = maxnew;
					}
				}
				else {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 0.0005)) {
						printf("break bPhysics_stop, dres<1e-2 && (fabs(maxnew - maxold) < 0.0005)\n");
						break;
					}
					else {
						maxold = maxnew;
					}
				}

			}
		}


		if (icount_V_cycle > 0) {
			// установить 0 в случае отката на предыдущую стабильную локально-линейную версию алгоритма.
			// главная причина установки значения 1 является сокращение числа проходов для устранения
			// нелинейности в системе с 26 до 4. При установке 1 в данном месте кода надо в модуле
			// mysolver_v0_03 установить fHORF=1.0; 
			if (((iVar == TEMP) && (my_amg_manager.istabilization == 3)) && (iVar == TEMP)) {
				if (bonly_solid_calculation == true) {
					if (bvacuumPrism) {
						// предполагается неизменый порядок следования позиций в x
						// и rthdsd.

						doublereal* x_temper = NULL;
						//x_temper = new doublerealT[n_a[0] + 1];
						x_temper = (doublereal*)malloc(((integer)(n_a[0])+1) * sizeof(doublereal));
						if (x_temper == NULL) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem : not enough memory on your equipment for x_temper my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							if (x[i23 + 1] < -272.15) x[i23 + 1] = -272.15;
							//x_temper[i23] = x[i23 + 1];
							// 0.01 параметр нижней релаксации.
							// 0.25
							x_temper[i23] = x_old[i23 + 1] + 0.2*(x[i23 + 1] - x_old[i23 + 1]);
							if (x_temper[i23] < -272.15) x_temper[i23] = -272.15;
							x[i23 + 1] = x_temper[i23];
						}

						// На старте мы блокируем Стефана Больцмана дав сойтись лучистым потокам.
						// Вычисление осреднённых температур в К на границах вакуумных промежутков :
						for (integer i23 = 0; i23 < lb; i23++) {
							update_avg_temperatures(x_temper, my_body[i23]);
						}
						// Вычисление плотностей радиационных тепловых потоков :
						for (integer i23 = 0; i23 < lb; i23++) {
							calculation_density_radiation_heat_flux(my_body[i23]);
						}


						doublereal* rthdsd_loc123 = NULL;
						//rthdsd_loc123 = new doublerealT[n_a[0] + 1];
						rthdsd_loc123 = (doublereal*)malloc(((integer)(n_a[0]) + 1) * sizeof(doublereal));
						if (rthdsd_loc123 == NULL) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem : not enough memory on your equipment for rthdsd_loc123 my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}

						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							rthdsd_loc123[i23] = rthdsd_no_radiosity_patch[i23];
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on)) {
								doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23] = alpha_relax142 *(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*5.670367e-8*((273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb))) +
									(1.0 - alpha_relax142)*(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*5.670367e-8*((273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)));
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
						}

						radiosity_patch_for_vacuum_Prism_Object_(rthdsd_loc123, my_body, lb, maxelm_out);
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							x_old[i23 + 1] = x_temper[i23];
							//x_old[i23 + 1] = x[i23 + 1];
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							b[i23 + 1] = rthdsd_loc123[i23];
						}

						if (rthdsd_loc123 != NULL) {
							free(rthdsd_loc123);
						}
						rthdsd_loc123 = NULL;

						if (x_temper != NULL) {
							free(x_temper);
						}
						x_temper = NULL;
					}
					else if (b_sign_on_nonlinear_bc) {
						//  25 декабря 2015. Ускорение сходимости при использовании 
						// нелинейных граничных условий.
						doublerealT* x_temper = NULL;
						//x_temper = new doublerealT[n_a[0] + 1];
						x_temper = (doublerealT*)malloc(((integer)(n_a[0]) + 1) * sizeof(doublerealT));
						if (x_temper == NULL) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem : not enough memory on your equipment for x_temper my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							if (x[i23 + 1] < -272.15) x[i23 + 1] = -272.15;
							//x_temper[i23] = x[i23 + 1];
							// 0.01 параметр нижней релаксации.
							// 0.25
							// 0.2
							// 10 июня 2018 года заменил на коэффициент нижней релаксации равный 0.9.
							x_temper[i23] = x_old[i23 + 1] + 0.9*(x[i23 + 1] - x_old[i23 + 1]);
							if (x_temper[i23] < -272.15) x_temper[i23] = -272.15;
							x[i23 + 1] = x_temper[i23];
						}

						doublerealT* rthdsd_loc123 = NULL;
						//rthdsd_loc123 = new doublerealT[n_a[0] + 1];
						rthdsd_loc123 = (doublerealT*)malloc(((integer)(n_a[0]) + 1) * sizeof(doublerealT));
						if (rthdsd_loc123 == NULL) {
							// недостаточно памяти на данном оборудовании.
							printf("Problem : not enough memory on your equipment for rthdsd_loc123 my_agregat_amg.cpp...\n");
							printf("Please any key to exit...\n");
							exit(1);
						}

						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							rthdsd_loc123[i23] = rthdsd_no_radiosity_patch[i23];
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on) && (qnbc[i23 - iadd_qnbc_maxelm].bNewtonRichman_q_on==false)) {
								// Стефан Больцман.
								doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23] = alpha_relax142 *(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*5.670367e-8*((273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb))) +
									(1.0 - alpha_relax142)*(-qnbc[i23 - iadd_qnbc_maxelm].emissivity*5.670367e-8*((273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1])*(273.15 + x_old[i23 + 1]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)));
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bNewtonRichman_q_on) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on == false)) {
								// Ньютон-Рихман.
								//doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23]  = -qnbc[i23 - iadd_qnbc_maxelm].film_coefficient*(x_temper[i23] - qnbc[i23 - iadd_qnbc_maxelm].Tamb);
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
							if ((i23 >= iadd_qnbc_maxelm) && (qnbc[i23 - iadd_qnbc_maxelm].bactive) && (qnbc[i23 - iadd_qnbc_maxelm].bNewtonRichman_q_on) && (qnbc[i23 - iadd_qnbc_maxelm].bStefanBolcman_q_on)) {
								// Условие смешанного типа.
								//doublerealT alpha_relax142 = 0.25;
								rthdsd_loc123[i23] = (-qnbc[i23 - iadd_qnbc_maxelm].emissivity*5.670367e-8*((273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23])*(273.15 + x_temper[i23]) - (273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)*(273.15 + qnbc[i23 - iadd_qnbc_maxelm].Tamb)));
								rthdsd_loc123[i23] += -qnbc[i23 - iadd_qnbc_maxelm].film_coefficient*(x_temper[i23] - qnbc[i23 - iadd_qnbc_maxelm].Tamb);
								rthdsd_loc123[i23] *= qnbc[i23 - iadd_qnbc_maxelm].dS;
							}
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							x_old[i23 + 1] = x_temper[i23];
							//x_old[i23 + 1] = x[i23 + 1];
						}
#pragma omp parallel for
						for (integer i23 = 0; i23 < n_a[0]; i23++) {
							b[i23 + 1] = rthdsd_loc123[i23];
						}

						if (rthdsd_loc123 != NULL) {
							free(rthdsd_loc123);
						}
						rthdsd_loc123 = NULL;

						if (x_temper != NULL) {
							free(x_temper);
						}
						x_temper = NULL;

					}
				}
			}
		}

		//getchar();
		icount_V_cycle++;
		//if (icount_V_cycle > 8) break;
		count_iter_for_film_coef++;
		// В случае задачи Ньютона - Рихмана, Стефана-Больцмана и миксового условия не итерируем до конца обрываем, 
		// т.к. нам требуется частая пересборка матрицы. 13 марта 2016.
		if (((adiabatic_vs_heat_transfer_coeff > 0) || (breakRUMBAcalc_for_nonlinear_boundary_condition)) && (count_iter_for_film_coef>1250)) break;

		// 1 dec 2016.
		//  Прерывание после 2 или 5 V циклов обязательно необходимо иначе не будет сходимости.
		if (bvacuumPrism) {
			// 5
			// 250
			if (icount_V_cycle > 250) break;
		}


		if ((iter_limit == 5000) || ((iVar == PAM) && (fabs(dres)>7.0e3))) {
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_copy[i47];
			}
			if (iVar == PAM) {
				printf("pressure amendment divergence...\n");
			}
			printf("amg divergence detected dres=%e...\n", dres);
#if doubleintprecision == 1
			printf("nV=%lld dres0=%e\n", icount_V_cycle, dres_initial);
#else
			printf("nV=%d dres0=%e\n", icount_V_cycle, dres_initial);
#endif
			
			printf("CopA=%1.2f  CopP=%1.2f...\n", dr_grid_complexity, (doublerealT)(nnz_P_memo_all / n_a[0]));
			printf("res_best_search=%e\n", res_best_search);
			//getchar();
			// пауза убрана 22 12 2016
			//system("PAUSE");
			break;
		}

		if (iter_limit == 1) {
			// начальная невязка.
			res0start = fabs(dres);
		}

		// Невязка по температуре :
		// НЕТ сходимости для поля температур в гидродинамическом решателе и параметры не помогают.
		//if (iVar == TEMP) printf("temp res=%e\n", fabs(dres));

		if (fabs(dres) < res_best_search)
		{
			// Запоминаем лучшую попытку.
			res_best_search = fabs(dres);
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
			}
		}
		/*
		if (iVar == PAM) {
		if (fabs(dres) < 1.0) {
		// Идея в том что нам нужна хоть какая-то поправка давления,
		// всё лучше чем тождественно нулевое распределение.
		// невязка при этом у нас менеее 1.0 что гарантирует что мы не сильно улетели.
		for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		}
		}
		}
		*/

		// debug 7 июня 2016
		//if (iter_limit > 300) {
		//printf("amg divergense detected...9 june 2016\n");
		//system("pause");
		//break;
		//}

		//if (dres < 1.0e-14) break;

		// 100
		if (iter_limit > 5000) { // Finned Heat Sink



			if (bfirst_divergence) {
				iter_limit = 3;
				nu1 += 2;
				nu2 += 2;
				nFinestSweeps += 2;
				bfirst_divergence = false;
			}
			else {
				if ((fabs(res_best_search / res0start) < 0.23) && (fabs(res_best_search) < 1.0e-3*sqrt(n_a[0]))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				else if ((fabs(res_best_search / res0start) <= 1.0) && (fabs(res_best_search) < 1.0e-4*sqrt(n_a[0]))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
				// Эта ветвь кода вообще никогда не вызовется.
				printf("Fatal amg error : Strong divergence amg solver...%e \n", fabs(res_best_search / res0start));
				printf("res_best_search=%e, res0start=%e\n", fabs(res_best_search), fabs(res0start));
				printf("BiCGStab+ILU2 is start now...\n");
				printf("please wait...");
				system("pause");
				break; // досрочный выход из while цикла.
			}
		}
		iter_limit++;

		if (fabs(dres) < fabs(dres_previos)) {
			// все нормально процесс сходится.
			icount_bad_convergence_Vcycles = 0;
		}
		else {
			icount_bad_convergence_Vcycles++;
		}

		//if (_finite(dres) == 0) {
		//if (fabs(dres) > 1.0e30)
		//{
		//printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
		//printf("\a\a\a\a\a\a\a\a");
		//system("pause");
		//exit(1);
		//return true;
		//for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		//	x[i47] = x_copy[i47];
		//}
		//if (iter_limit > 100) {
		//	ret_value = true;
		//	break;
		//}
		//else {
		// Увеличение количества сглаживающих итераций ни коим образом не 
		// исправляет факт расходимости. 
		//	nu1++;
		//	nu2++;
		//	nFinestSweeps++;
		// По видимому надо действовать очень тонкой настройкой параметра верхней релаксации omega optimal.
		// Настройка omega optimal должна быть самообучающейся (адаптированной к задаче).
		//}
		//}

		// 24 10 2016
		if (icount_bad_convergence_Vcycles > 40) break;

		if ((icount_bad_convergence_Vcycles >= istop_porog_reconst) || (fabs(dres) / sqrt(n_a[0]) > 1.0e30)) {
			// детектировано 10 шагов расходимости подряд по-видимому метод расходится.
			// Также о расходимости говорит невязка большая 1.0e30.

			//if (fabs(dres) < 1.0e-3) break; // Будем считать сходимость достигнута успешно.
			if ((fabs(res_best_search / res0start) < 1.0e-1) && (fabs(dres) / sqrt(n_a[0]) < 1.0e-3)) {
				// Если невязка меньше первоначальной на два порядка.
				// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				printf("stagnaion break out\n");
				break;
			}
			i_count_stagnation++;

			printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			if (i_count_stagnation < 20) {
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					x[i47] = x_best_search[i47]; // лучшее найденное решение
				}
			}
			if (i_count_stagnation == 20 || i_count_stagnation == 21) gold_const = 0.2;
			if ((i_count_stagnation >= 20) && (i_count_stagnation < 30)) {
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					// Можно еще единократно немного улучшить nu1 и nu2.
					doublerealT signumnow = 1.0;
					if (rand() % 2 == 0) signumnow = -1.0;
					x[i47] = signumnow *1.0*(rand() % 90 + 10) / 100.0; // Случайное число в интервале от 0 до 1.
				}
			}
			if (i_count_stagnation == 30 || i_count_stagnation == 31) gold_const = 0.2;
			if (i_count_stagnation >= 30) {
#pragma omp parallel for
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = 1.0;
				}
			}
			if (bproblem_amg_convergence1) {
				if (bproblem_amg_convergence2) {
					if (bproblem_amg_convergence3) {
						// выход к вызову BiCGStab+ILU2.
						ret_value = true;
						break;
					}
					else {
						// смена omega.
						bproblem_amg_convergence3 = true;
						icount_bad_convergence_Vcycles = 0;
						buffers3omega = dres / dres_previos;
						printf("buffers1omega=%1.4f, buffers2omega=%1.4f, buffers3omega=%1.4f\n", buffers1omega, buffers2omega, buffers3omega);
					}
				}
				else {
					// смена omega.
					bproblem_amg_convergence2 = true;
					icount_bad_convergence_Vcycles = 0;
					buffers2omega = dres / dres_previos;
					printf("buffers1omega=%1.4f, buffers2omega=%1.4f\n", buffers1omega, buffers2omega);
					//istop_porog_reconst += 50; // 10, 20, 30, 40
					// Увеличение количества сглаживающих итераций ничего не даёт.
					//nu1++;
					//nu2++;
					//nFinestSweeps++;
				}
			}
			else {

				bproblem_amg_convergence1 = true; // переход с SOR на стабильный Зейдель.
				icount_bad_convergence_Vcycles = 0;
				buffers1omega = dres / dres_previos;
			}
		}


		dres_previos = dres;


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
			R0_0 = norma(residual_fine[0], n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nu1; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection[0], row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
				Rnext_0 = norma(residual_fine[0], n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smoother
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						// ILU0
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if ((bILU2smoother == 2)||(my_amg_manager.iFinnest_ilu == 1)) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection[0], row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine[0] = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine[0]);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0]);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);
		}
		dres = norma(residual_fine[0], n_a[0]);
		ret74 += fabs(dres);
		if (bprint_mesage_diagnostic) {


			doublereal minx = 1.0e30;
			doublereal maxx = -1.0e30;
			for (integer i_83 = 1; i_83 <= n_a[0]; i_83++) {
				if (x[i_83] < minx) minx = x[i_83];
				if (x[i_83] > maxx) maxx = x[i_83];
			}

			if (((iVar == TEMP) && (my_amg_manager.istabilization == 3))) {
				//  Сходимость достинута - досрочный выход из решения нелинейной задачи.
				if ((fabs(minx - minx_gl) < 1.0e-2) && (fabs(maxx - maxx_gl) < 1.0e-2)) {
					printf("Solution nonlinear problem converged succsefull. Ok...\n");
					break;
				}
		}

			minx_gl = minx;
			maxx_gl = maxx;

#if doubleintprecision == 1
			printf("%lld %e rho=%e min=%e max=%e\n", iiter, dres, dres / rho, minx, maxx);
#else
			printf("%d %e rho=%e min=%e max=%e\n", iiter, dres, dres / rho, minx, maxx);
#endif
			
			if (!((iVar == TEMP) && (my_amg_manager.istabilization == 3))) {
				if (fabs(1.0 - fabs(dres / rho)) < 1.0e-3) {
					printf("stagnation in amg solver determinate ...\n");
					// 28_10_2016.
					// Осуществляем досрочный выход из итерирования, 
					// т.к. невязка перестала меняться.
					break;
				}
			}
			if (icount_V_cycle == 1) {
				if (fabs(dres / rho)<1.0) {
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x_best_search[i47] = x[i47];
					}
				}
			}
		}
		iiter++;
		// 28.07.2016

		if (fabs(dres) > 1.0e9) {

			printf("amg solver divergence detected.\n");
			system("pause");

#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				///x[i47] = x_best_search[i47];
				//x_copy[i47] = x[i47]; // 4 ноября 2016.
				x[i47] = x_copy[i47];
			}
			residualq2_analysys(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);

			printf("dres_initial=%e res_best_search=%e dres=%e current=%e\n", dres_initial, res_best_search, dres, norma(residual_fine[0], n_a[0]));
			printf("break. amg divergence detected. fabs(dres) > 1.0e7\n");
			//getchar();
			if ((bILU2smoother == 2)||(bILU2smoother == 0)) {
				printf("apply ilu2 smoother for number 0 level\n");
				equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
				
			}
			if (bILU2smoother == 0) {
				// переключение.
				memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1);
				bILU2smoother = 2;
			}

			// Это по умолчанию для поправки давления.
			doublerealT dresfinish_probably = 0.1*norma(residual_fine[0], n_a[0]);
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				// Это по умолчанию для компонент скорости внутри SIMPLE алгоритма.
				dresfinish_probably = 1.0e-3*norma(residual_fine[0], n_a[0]);
			}
			if (bSIMPLErun_now_for_temperature == true) {
				if (iVar == TEMP) {
					// Для поля температур при гидродинамическом расчёте.
					// В BiCGStab Internal 3 домножается на 1e-10.
					dresfinish_probably = 1.0e-3*norma(residual_fine[0], n_a[0]);
				}
			}
			if (iVar == TOTALDEFORMATIONVAR) {
				// Для механических деформаций
				dresfinish_probably = 1.0e-3*norma(residual_fine[0], n_a[0]);
			}
			if (bonly_solid_calculation) {
				dresfinish_probably = 1.0e-5*norma(residual_fine[0], n_a[0]);
			}
			integer i943 = 0;
			for (integer i_prob_detect_i = 0; i_prob_detect_i < 1000; i_prob_detect_i++) {
				i943 = i_prob_detect_i;
				seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, F_false_C_true, 0);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine[0], diag[0]);

				doublereal minx = 1.0e30;
				doublereal maxx = -1.0e30;
				for (integer i_83 = 1; i_83 <= n_a[0]; i_83++) {
					if (x[i_83] < minx) minx = x[i_83];
					if (x[i_83] > maxx) maxx = x[i_83];
			}

#if doubleintprecision == 1
				printf("%lld residual=%e min=%e max=%e \n", i_prob_detect_i, norma(residual_fine[0], n_a[0]), minx, maxx);
#else
				printf("%d residual=%e min=%e max=%e \n", i_prob_detect_i, norma(residual_fine[0], n_a[0]), minx, maxx);
#endif
				
				// Досрочный выход из цикла.
				if (norma(residual_fine[0], n_a[0]) < dresfinish_probably) {
					printf("Ok!!! calculation local compleate... \n");
					break;
				}
#pragma omp parallel for
				for (integer i43 = 0; i43 < n_a[0]; i43++) {
					milu2[0].zbuf[i43 + 1] = residual_fine[0][i43 + 1];
				}
				lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
#pragma omp parallel for
				for (integer i43 = 0; i43 < n_a[0]; i43++) {
					x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
				}
			}

			// Детектируем возможные проблемы со сходимостью:
			if (norma(residual_fine[0], n_a[0]) >= dresfinish_probably) {
				printf("Fatal error !!! ilu2 divergence detected... \n");
				printf("residual curent=%e target residual=%e\n", norma(residual_fine[0], n_a[0]), dresfinish_probably);
				if (i943 < 997) {
					break;
				}
			}
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
				x_copy[i47] = x[i47]; // 4 ноября 2016.
			}
			system("PAUSE");

			goto FULL_DIVERGENCE_DETECTED;
			//break;
		}

		if (iVar == PAM) {
			if ((fabs(dres / rho) > 0.99999) || (fabs(dres) > 1.0e7)) {
				// Выход из мультигрида ести достигнуто 20 циклов расходимости.
				delta_old_iter = fabs(dres);
				i_signal_break_pam_opening++;
				if (i_signal_break_pam_opening > i_limit_signal_pam_break_opening) {
#if doubleintprecision == 1
					printf("iter = %lld\n", iiter);
#else
					printf("iter = %d\n", iiter);
#endif
					
					// Обратное копирование и выход и алгоритма.
#pragma omp parallel for
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
			}
		}


		//rho=norma(residual_fine[0], n_a[0]);
		rho = dres;
		// start 08.01.2018
		V_cycle_solve<doublerealT>(Amat, x, b, process_flow_logic, row_ptr_start,
			row_ptr_end, residual_fine, diag, n_a, bonly_serial,
			process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
			ilevel, 1, imyinit, idim_diag, milu2, milu0, nested_desection,
			R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
			error_approx_coarse, dapply_ilu_max_pattern_size,
			process_flow_alpha,
			error_approx_fine, nFinestSweeps);
		// end 08.01.2018

		//if (bfirst_start_nonlinear_process) {
		// Во избежании расходимости по начальному условию в двойном 
		// вакуумном промежутке.
		//bfirst_start_nonlinear_process = false;
		//break;
		//}
		if (iVar != PAM) {
			if (btheoryGuideANSYSFluent) break; // Делаем лишь один V  цикл.
		}
		//system("pause");
	}
	} // bBiCGStab_plus_RUMBA_camg if (my_amg_manager.istabilization == 1)
	else if (my_amg_manager.istabilization == 1) {
		// Рекомендуется использовать гибридную точность: двойную для BiCGStab и одинарную для предобуславливания с помощью V - цикла.
		// Алгебраический Многосеточный Метод как предобуславливатель
		// к алгоритму Крыловского типа Хенка Ван Дер Ворста BiCGStab
		// со стабилизацией.
		// Требует ещё одну память под матрицу А на самом подробном уровне.
		// 5.01.2017 Алгоритм BiCGStab изобретён в 1992 году.

		integer inumberVcyclelocbicgstab = 1;

		// нумерация векторов начинается с нуля.
		integer n75 = n_a[0]; // число неизвестных на подробном уровне.
		doublereal* val75 = NULL;
		val75 = new doublereal[nnz_a[0]];
		integer* col_ind75 = NULL;
		col_ind75 = new integer[nnz_a[0]];
		integer* row_ptr75 = NULL;
		row_ptr75 = new integer[n_a[0] + 1];
		if ((val75 == NULL) || (col_ind75 == NULL) || (row_ptr75 == NULL)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for val, col_ind or row_ptr: bicgStab + camg...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// инициализация матрицы.
		/*
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {
			val75[row_ptr_start[i_1] - 1] = diag[0][Amat[row_ptr_start[i_1]].i];
			col_ind75[row_ptr_start[i_1] - 1] = Amat[row_ptr_start[i_1]].i-1;
			for (integer i_2 = row_ptr_start[i_1] + 1; i_2 <= row_ptr_end[i_1]; i_2++) {
				val75[i_2 - 1] = Amat[i_2].aij;
				col_ind75[i_2 - 1] = Amat[i_2].j-1;
			}
			row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}
		*/
		// инициализация матрицы.
#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {
			
			for (integer i_2 = row_ptr_start[i_1] ; i_2 <= row_ptr_end[i_1]; i_2++) {
				if (Amat[i_2].i == Amat[i_2].j) {
					if (i_1 != Amat[i_2].i) {
						printf("err i!=i\n");
						system("PAUSE");
					}
					val75[i_2-1] = diag[0][i_1];
					col_ind75[i_2 - 1] = i_1-1;
				}
				else {
					val75[i_2 - 1] = Amat[i_2].aij;
					col_ind75[i_2 - 1] = Amat[i_2].j-1;
				}
			}
			row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}	
#if doubleintprecision == 1
		//printf("nnz=%lld rpe=%lld rps=%lld\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#else
		//printf("nnz=%d rpe=%d rps=%d\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#endif
		
		//system("PAUSE");
		row_ptr75[n_a[0]] = row_ptr_end[n_a[0]];
		// Вектора необходимые для работы BiCGStab.
		doublereal* ri75 = NULL;
		doublereal* roc75 = NULL;
		doublereal* s75 = NULL;
		doublereal* t75 = NULL;
		doublereal* vec75 = NULL;
		doublereal* vi75 = NULL;
		doublereal* pi75 = NULL;
		doublereal* dx75 = NULL;
		doublereal* dax75 = NULL;
		doublereal* y75 = NULL;
		doublereal* z75 = NULL;
		// Первое предобуславливание:
		doublereal* y76 = NULL;
		doublereal* pi76 = NULL;
		y76 = new doublereal[n75+1];
		pi76 = new doublereal[n75+1];
		// Второе предобуславливание:
		doublereal* z76 = NULL;
		doublereal* s76 = NULL;
		z76 = new doublereal[n75 + 1];
		s76 = new doublereal[n75 + 1];

		ri75 = new doublereal[n75];
		roc75 = new doublereal[n75];
		s75 = new doublereal[n75];
		t75 = new doublereal[n75];
		vec75 = new doublereal[n75];
		vi75 = new doublereal[n75];
		pi75 = new doublereal[n75];
		dx75 = new doublereal[n75];
		dax75 = new doublereal[n75];
		y75 = new doublereal[n75];
		z75 = new doublereal[n75];
		if ((ri75 == NULL) || (roc75 == NULL) || (s75 == NULL) || (t75 == NULL) || (vi75 == NULL) || (pi75 == NULL) || (dx75 == NULL) || (dax75 == NULL) || (y75 == NULL) || (z75 == NULL)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for : bicgStab + camg...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}

		integer iflag75 = 1, icount75 = 0;
		doublereal delta075 = 1.0e30, deltai75 = 1.0e30;
		doublereal bet75 = 0.0, roi75 = 0.0;
		doublereal roim175 = 1.0, al75 = 1.0, wi75 = 1.0;

		doublereal epsilon75 = dterminatedTResudual;  // точность вычисления
		if (iVar == TEMP) {
			epsilon75 *= 1.0e-4; // 1.0e-4
		}
		if (iVar == TOTALDEFORMATIONVAR) {
			epsilon75 *= 1.0e-4; // 1.0e-4
			//epsilon75 *= 1.0e-12;
		}
		integer i75 = 0;

		// initialize
#pragma omp parallel for
		for (i75 = 0; i75<n75; i75++) {
				s75[i75] = 0.0;
				t75[i75] = 0.0;
				vi75[i75] = 0.0;
				pi75[i75] = 0.0;
				// инициализатор массивов для предобуславливания
				y75[i75] = 0.0;
				z75[i75] = 0.0;
				// результат умножения матрицы на вектор.
				dax75[i75] = 0.0;
				// Начальное приближение.
				dx75[i75] = x[i75 + 1];
			}

		// Умножение матрицы на вектор. Нумерации векторов начинаются с нуля.
		MatrixCRSByVector(val75, col_ind75, row_ptr75, dx75, dax75, n75); // результат занесён в  dax75

		// Вычисление ri75 и roc75.
#pragma omp parallel for
		for (i75 = 0; i75 < n75; i75++) {
			ri75[i75] = b[i75 + 1] - dax75[i75];
			roc75[i75] = 1.0;
		}
		delta075 = NormaV(ri75, n75);
		

		// Если решение сразу хорошее то не считать:
		if (iVar == TEMP) {
			if (fabs(delta075)<1.0e-4*dterminatedTResudual) iflag75 = 0;
		}
		else {
			if (fabs(delta075)<dterminatedTResudual) iflag75 = 0;
		}
		integer iflag175 = 1;
		if (fabs(delta075)<1e-14) iflag175 = 0;
		if ((iVar == TEMP) && (iflag75 == 0) && (iflag175 == 0)) {
#if doubleintprecision == 1
			printf("bicgStab+camg: iflag=%lld, iflag1=%lld, delta0=%e\n", iflag75, iflag175, delta075);
#else
			printf("bicgStab+camg: iflag=%d, iflag1=%d, delta0=%e\n", iflag75, iflag175, delta075);
#endif
			
			system("PAUSE");
		}

		integer iN75 = 10;
		if (n75<30000) {
			// задача очень малой размерности !
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				iN75 = 1; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 2;
				epsilon75 = fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature == true) {
					//printf("epsilon=%e \n",epsilon);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-10;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 3; // решение для поправки давления должно быть получено точно.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if ((n75 >= 30000) && (n75 < 100000)) {
			// Здесь я немного увеличил число итераций и 
			// скоректировал условие окончания чтобы считало 
			// поточнее, но это не повлияло.
			// Главный вопрос в том что невязка по температуре почему-то не меняется.
			// задача небольшой размерности.
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				iN75 = 3; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				// 27.07.2016
				iN75 = 12;
				epsilon75 *= 1e-2;
			}
			if (iVar == TEMP) {
				iN75 = 4;
				epsilon75 = fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature == true) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-10;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 6; // решение для поправки давления должно быть получено точно.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
				// 27.07.2016.
				epsilon75 *= 1e-2;
				iN75 = 20;
			}
		}
		else if ((n75 >= 100000) && (n75<300000)) {
			// задача небольшой средней размерности.
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				iN75 = 3; // обязательно нужна хотя бы одна итерация.
						// Вообще говоря невязка для скоростей падает очень быстро поэтому всегда достаточно iN итераций для скорости.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 4;
				epsilon75 = fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature == true) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-10;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 8; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if ((n75 >= 300000) && (n75<1000000)) {
			// задача истинно средней размерности.
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				iN75 = 3; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 4;
				epsilon75 = 1e-5*fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature == true) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-8;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 16; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if ((n75 >= 1000000) && (n75<3000000)) {
			// задача достаточно большой размерности.
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				iN75 = 6; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 8;
				epsilon75 = 1e-5*fmin(0.1*fabs(delta075), epsilon75);
				if (bSIMPLErun_now_for_temperature == true) {
					//printf("epsilon75=%e \n",epsilon75);
					//getchar();
					// Экспериментальным образом обнаружена недоэтерированость по температуре для гидродинамического решателя.
					// поэтому точность было решено увеличить на 5 порядков.
					// 27.07.2016
					epsilon75 *= 1e-8;
					iN75 = 20;
					//epsilon75 *= 1e-16;
					//iN75 = 30;
				}
			}
			if (iVar == PAM) {
				iN75 = 23; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon75); getchar();
			}
		}
		else if (n75 >= 3000000) {
			// задача очень большой размерности.
			if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
				iN75 = 6; // обязательно нужна хотя бы одна итерация.
						// если этого будет недостаточно то мы всё равно будем итерировать до тех пор пока невязка не станет меньше epsilon.
				if (1.0e-3*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-3*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
			}
			if (iVar == TEMP) {
				iN75 = 8;
				epsilon75 = 1e-10*fmin(0.1*fabs(delta075), epsilon75);
			}
			if (iVar == PAM) {
				iN75 = 36; // решение для поправки давления должно быть получено точно.
				if (1.0e-4*fabs(delta075)<epsilon75) {
					epsilon75 = 1.0e-4*fabs(delta075);
				}
				if (iflag175 == 1) {
					iflag75 = 1;
				}
				//printf("%e",epsilon); getchar();
			}
		}

		integer maxit75 = 2000;
		if (iVar == TEMP) {
			maxit75 = 2000;
		}
		if (iVar == PAM) {
			maxit75 = 2000; // 2000
		}
		if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
			maxit75 = 100;//100
		}
		if (iVar == TOTALDEFORMATIONVAR) {
			maxit75 = 2000; // 2000
			if (1.0e-4*fabs(delta075) < epsilon75) {
				epsilon75 = 1.0e-4*fabs(delta075);
			}
			epsilon75 = 1.0e-16;
			iN75 = 8; // Обязательное минимально необходимое число итераций.
			if (iflag175 == 1) {
				iflag75 = 1;
			}

		}

		// Если число расходимостей превысит оговорённую константу то произойдёт выход из алгоритма.
		integer i_signal_break_pam_opening75 = 0;
		// x хорошее значение.
		const integer i_limit_signal_pam_break_opening75 = 4000;//20
		doublereal delta_old_iter75 = 1.0e10;

		integer count_iter_for_film_coef75 = 0;


		// Мы обязательно должны сделать несколько итераций. (не менее 10).
		// Если только решение не удовлетворяет уравнению тождественно.
		while (((icount75 < iN75) && (iflag175 != 0)) || (iflag75 != 0 && icount75 < maxit75)) {
		
			// 6.01.2017: Body BiCGStab + AMG. (BiCGStab_internal4).


			icount75++;

			count_iter_for_film_coef75++;
			// В случае задачи Ньютона - Рихмана, Стефана-Больцмана и миксового условия не итерируем до конца обрываем, 
			// т.к. нам требуется частая пересборка матрицы. 13 марта 2016.
			//if (((adiabatic_vs_heat_transfer_coeff > 0) || (breakRUMBAcalc_for_nonlinear_boundary_condition)) && (count_iter_for_film_coef75>5)) break;

			roi75 = Scal(roc75, ri75, n75);
			bet75 = (roi75 / roim175)*(al75 / wi75);
			

			//printf("%e %e %e %e\n",roi75,roim175,al75,wi75);
			//getchar();

#pragma omp parallel for 
			for (i75 = 0; i75<n75; i75++) {
				doublereal pibuf75 = ri75[i75] + (pi75[i75] - vi75[i75] * wi75)*bet75;
				pi75[i75] = pibuf75;
			}

			// Первое предобуславливание.
			// Ky=pi
#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				y75[i75] = 0.0; // Если начинать не с нуля то небудет сходимости для PAM !.
				y76[i75 + 1] = 0.0;
				pi76[i75 + 1] = pi75[i75];
			}

			// multigrid RUMBA preconditioner
			// TODO begin
			// Вставлено 6.01.2017 begin
			// одного V цикла недостаточно.
			// A*y76=pi76;
			V_cycle_solve<doublerealT>(Amat, y76, pi76, process_flow_logic, row_ptr_start,
				row_ptr_end, residual_fine, diag, n_a, bonly_serial,
				process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
				ilevel, inumberVcyclelocbicgstab, imyinit, idim_diag, milu2, milu0, nested_desection,
				R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
				error_approx_coarse, dapply_ilu_max_pattern_size,
				process_flow_alpha,
				error_approx_fine, nFinestSweeps);
			// TODO end
			// Вставлено 6.01.2017 end

			// Возвращение результата.
#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				y75[i75] = y76[i75 + 1];
			}

			MatrixCRSByVector(val75, col_ind75, row_ptr75, y75, vi75, n75); // vi==A*y;

			if ((fabs(roi75)<1e-30) && (fabs(Scal(roc75, vi75, n75))<1e-30)) {
				al75 = 1.0;
			}
			else if (fabs(roi75)<1e-30) {
				al75 = 0.0;
			}
			else {
				al75 = roi75 / Scal(roc75, vi75, n75);
			}

			
#pragma omp parallel for
			for (i75 = 0; i75<n75; i75++) {
				s75[i75] = ri75[i75] - al75*vi75[i75];
			}

			// Второе предобуславливание.
			// Kz=s

#pragma omp parallel for
			for (i75 = 0; i75<n75; i75++) z75[i75] = 0.0; // Если начинать не с нуля то небудет сходимости для PAM !.

#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				vec75[i75] = s75[i75];
			    z76[i75 + 1] = 0.0;
				s76[i75 + 1] = s75[i75];
			}

			// multigrid RUMBA preconditioner
			// Вставлено 6.01.2017 begin
			// одного V цикла недостаточно.
			// A*z76=s76;
			V_cycle_solve<doublerealT>(Amat, z76, s76, process_flow_logic, row_ptr_start,
				row_ptr_end, residual_fine, diag, n_a, bonly_serial,
				process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
				ilevel, inumberVcyclelocbicgstab, imyinit, idim_diag, milu2, milu0, nested_desection,
				R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
				error_approx_coarse, dapply_ilu_max_pattern_size,
				process_flow_alpha,
				error_approx_fine, nFinestSweeps);
			// Вставлено 6.01.2017 end

#pragma omp parallel for
			for (i75 = 0; i75 < n75; i75++) {
				s75[i75] = vec75[i75];
				// Возвращаем результат.
				z75[i75] = z76[i75 + 1];
			}

			MatrixCRSByVector(val75, col_ind75, row_ptr75, z75, t75, n75); // t==A*z;

			wi75 = Scal(t75, s75, n75) / Scal(t75, t75, n75);
			// printf("%e %e",Scal(t75,s75,n75),Scal(t75,t75,n75));

#pragma omp parallel for
			for (i75 = 0; i75<n75; i75++) {
				//dx75[i75]+=al75*pi75[i75]+wi75*s75[i75]; // так было без предобуславливателя
				dx75[i75] += al75*y75[i75] + wi75*z75[i75]; // так стало с предобуславливателем
				ri75[i75] = s75[i75] - wi75*t75[i75];
			}
			deltai75 = NormaV(ri75, n75);

			//printf("deltai75=%e\n",deltai75); getchar();

			// печать невязки на консоль
			if (bprint_mesage_diagnostic) {
				if ((icount75 % 10) == 0) {
					printf("iter  residual\n");
					//fprintf(fp_log, "iter  residual\n");
				}
#if doubleintprecision == 1
				printf("%lld %e\n", icount75, deltai75);
				//fprintf(fp_log, "%lld %e \n", icount75, deltai75);
#else
				printf("%d %e\n", icount75, deltai75);
				//fprintf(fp_log, "%d %e \n", icount75, deltai75);
#endif
				
			}

			// 28.07.2016.
#if doubleintprecision == 1
			//printf("%lld %e\n", icount75, deltai75);
			//fprintf(fp_log, "%lld %e \n", icount75, deltai75);
#else
			//printf("%d %e\n", icount75, deltai75);
			//fprintf(fp_log, "%d %e \n", icount75, deltai75);
#endif
			
			//getchar();
			if (deltai75 > delta_old_iter75) i_signal_break_pam_opening75++;
			delta_old_iter75 = deltai75;
			if (iVar == PAM) {
				if (i_signal_break_pam_opening75 > i_limit_signal_pam_break_opening75) {
					// досрочный выход из цикла.
#if doubleintprecision == 1
					printf("icount PAM=%lld\n", icount75);
#else
					printf("icount PAM=%d\n", icount75);
#endif
					
					break;
				}
			}

			if (deltai75 <epsilon75) iflag75 = 0; // конец вычисления
			else roim175 = roi75;

			if (iVar == TEMP) {
#if doubleintprecision == 1
				//printf("epsilon=%e deltai=%e icount=%lld\n",epsilon75,deltai75, icount75);
#else
				//printf("epsilon=%e deltai=%e icount=%d\n",epsilon75,deltai75, icount75);
#endif
				
				//getchar();
			}

			icount_V_cycle = icount75; // количество итераций в BiCGStabP для лога.

			if (icount75 > 2600) break; // 15.02.2017

		}

		// Возвращение результата вычислений.
#pragma omp parallel for
		for (i75 = 0; i75 < n75; i75++) {
			x[i75 + 1] = dx75[i75];
			x_best_search[i75 + 1] = dx75[i75];
		}

		// Освобождение оперативной памяти.
		// Первое предобуславливание
		if (pi76 != NULL) {
			delete[] pi76;
			pi76 = NULL;
		}
		if (y76 != NULL) {
			delete[] y76;
			y76 = NULL;
		}
		// Второе предобуславливание
		if (z76 != NULL) {
			delete[] z76;
			z76 = NULL;
		}
		if (s76 != NULL) {
			delete[] s76;
			s76 = NULL;
		}
		if (ri75 != NULL) {
			delete[] ri75;
			ri75 = NULL;
		}
		if (roc75 != NULL) {
			delete[] roc75;
			roc75 = NULL;
		}
		if (s75 != NULL) {
			delete[] s75;
			s75 = NULL;
		}
		if (t75 != NULL) {
			delete[] t75;
			t75 = NULL;
		}
		if (vec75 != NULL) {
			delete[] vec75;
			vec75 = NULL;
		}
		if (vi75 != NULL) {
			delete[] vi75;
			vi75 = NULL;
		}
		if (pi75 != NULL) {
			delete[] pi75;
			pi75 = NULL;
		}
		if (dx75 != NULL) {
			delete[] dx75;
			dx75 = NULL;
		}
		if (dax75 != NULL) {
			delete[] dax75;
			dax75 = NULL;
		}
		if (y75 != NULL) {
			delete[] y75;
			y75 = NULL;
		}
		if (z75 != NULL) {
			delete[] z75;
			z75 = NULL;
		}

		// Освобождение оперативной памяти.
		if (val75 != NULL) {
			delete[] val75;
			val75 = NULL;
		}
		if (col_ind75 != NULL) {
			delete[] col_ind75;
			col_ind75 = NULL;
		}
		if (row_ptr75 != NULL) {
			delete[] row_ptr75;
			row_ptr75 = NULL;
		}

	}
	else
	{   //  09.01.2018
		// Рекомендуется использовать гибридную точность: двойную для FGMRES и одинарную для предобуславливания с помощью V - цикла.
	    // FGMRes if (my_amg_manager.istabilization == 2)
	    // Гибкий вариант обобщённого метода минимальных невязок в котором на каждой итерации
	    // однократно применяется многосеточный предобуславливатель. Алгорим Саада и Шульца 1986 года.

		integer inumberVcyclelocbicgstab = 1;

		// нумерация векторов начинается с нуля.
		integer n75 = n_a[0]; // число неизвестных на подробном уровне.
		doublereal* val75 = NULL;
		val75 = new doublereal[nnz_a[0]];
		integer* col_ind75 = NULL;
		col_ind75 = new integer[nnz_a[0]];
		integer* row_ptr75 = NULL;
		row_ptr75 = new integer[n_a[0] + 1];
		if ((val75 == NULL) || (col_ind75 == NULL) || (row_ptr75 == NULL)) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for val, col_ind or row_ptr: bicgStab + camg...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		// инициализация матрицы.
		/*
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {
		val75[row_ptr_start[i_1] - 1] = diag[0][Amat[row_ptr_start[i_1]].i];
		col_ind75[row_ptr_start[i_1] - 1] = Amat[row_ptr_start[i_1]].i-1;
		for (integer i_2 = row_ptr_start[i_1] + 1; i_2 <= row_ptr_end[i_1]; i_2++) {
		val75[i_2 - 1] = Amat[i_2].aij;
		col_ind75[i_2 - 1] = Amat[i_2].j-1;
		}
		row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}
		*/
		// инициализация матрицы.
#pragma omp parallel for
		for (integer i_1 = 1; i_1 <= n_a[0]; i_1++) {

			for (integer i_2 = row_ptr_start[i_1]; i_2 <= row_ptr_end[i_1]; i_2++) {
				if (Amat[i_2].i == Amat[i_2].j) {
					if (i_1 != Amat[i_2].i) {
						printf("err i!=i\n");
						system("PAUSE");
					}
					val75[i_2 - 1] = diag[0][i_1];
					col_ind75[i_2 - 1] = i_1 - 1;
				}
				else {
					val75[i_2 - 1] = Amat[i_2].aij;
					col_ind75[i_2 - 1] = Amat[i_2].j - 1;
				}
			}
			row_ptr75[i_1 - 1] = row_ptr_start[i_1] - 1;
		}
#if doubleintprecision == 1
		//printf("nnz=%lld rpe=%lld rps=%lld\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#else
		//printf("nnz=%d rpe=%d rps=%d\n",nnz_a[0], row_ptr_end[n_a[0]], row_ptr_start[n_a[0]+1]-1);
#endif

		//system("PAUSE");
		row_ptr75[n_a[0]] = row_ptr_end[n_a[0]];


		bool bnorelax = true; // Для уравнения теплопроводности не используется релаксация.
		integer m_restart = my_amg_manager.m_restart;

		doublereal resid;
		integer i, j = 1, k;
		//Vector s(m + 1), cs(m + 1), sn(m + 1), w;
		doublereal* w = new doublereal[n75];
		doublereal* s = new doublereal[m_restart + 2];
		doublereal* cs = new doublereal[m_restart + 2];
		doublereal* sn = new doublereal[m_restart + 2];

		doublereal *dx = new doublereal[n75];
		doublereal *buffer = new doublereal[n75];
		doublereal *Zcopy = new doublereal[n75 + 1];
		doublereal *vCopy = new doublereal[n75 + 1];

		// A*x=b, x - решение, b - правая часть. 
		// Индексация в х и b начинается с единицы.

		// начальное приближение
		for (i = 0; i<n75; i++) dx[i] = x[i + 1];


		//doublereal normb = norm(M.solve(b));
		doublereal normb = 0.0;
		// здесь реализованы все три нормы
		// вообще говоря они все эквивалентны



		normb = NormaV_for_gmres(&b[1], n75);
		//normb = NormaV(buffer, n75);

		//Vector r = &b[1] - A * x;
		doublereal *r = new doublereal[n75];
		MatrixCRSByVector(val75, col_ind75, row_ptr75, dx, r, n75); // результат занесён в  r
		for (i = 0; i < n75; i++) r[i] = b[i + 1] - r[i];

		//  calculate residual precontidioning;


		//doublereal beta = norm(r);
		doublereal beta = 0.0;



		beta = NormaV_for_gmres(r, n75);

		if (fabs(normb) < 1.0e-30)
			normb = 1;

		doublereal norm_r = 0.0;


		norm_r = NormaV_for_gmres(r, n75);

		integer maxit = 2000;

		if ((resid = norm_r / normb) <= dterminatedTResudual) {
			//tol = resid;
			maxit = 0;
			return 0;
		}

		//integer i_1 = 0; // счётчик цикла for

		doublereal** H = new doublereal*[m_restart + 2]; // Hessenberg
		for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) H[i_1] = new doublereal[m_restart + 2];


		for (integer i_1 = 0; i_1 < m_restart + 2; i_1++)
		{
			for (integer j_1 = 0; j_1 < m_restart + 2; j_1++)
			{
				H[i_1][j_1] = 0.0;
			}
		}

		//Vector *v = new Vector[m_restart + 1];
		doublereal** v = new doublereal*[m_restart + 2];
		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) v[i_1] = new doublereal[n75];


		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) {
			for (integer j_1 = 0; j_1 < n75; j_1++)
			{
				v[i_1][j_1] = 0.0;
			}
		}

		doublereal** Z = new doublereal*[m_restart + 2];
		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) Z[i_1] = new doublereal[n75];

		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) {
			for (integer j_1 = 0; j_1 < n75; j_1++)
			{
				Z[i_1][j_1] = 0.0;
			}
		}

		j = 1; // номер первой итерации
	    //doublereal delta = 1.0e-3;// DOPOLNENIE

		integer i_copy;

		while (j <= maxit) {

			//v[0] = r * (1.0 / beta);    // ??? r / beta
			for (integer j_1 = 0; j_1 < n75; j_1++)
			{
				v[0][j_1] = r[j_1] * (1.0 / beta);
			}

			//s = 0.0;
			for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) s[i_1] = 0.0;
			s[0] = beta;
			//s[0] = 1.0;


			for (integer i_1 = 0; i_1 < m_restart + 2; i_1++)
			{ // DOPOLNENIE
				for (integer j_1 = 0; j_1 < m_restart + 2; j_1++)
				{
					H[i_1][j_1] = 0.0;
				}
			}


			// Ортогонализация Арнольди.
			for (i = 0; i < m_restart && j <= maxit; i++, j++) {

				i_copy = i;


				// KZ[i]=v[i]

				// (LU)Z[i]=v[i];

				// multigrid Ruge and Stuben preconditioning [1986].
				// достаточно одного V цикла.
				// K*Z = v;
				for (integer i_1 = 0; i_1 < n75; i_1++) {
					Zcopy[i_1 + 1] = 0.0;
					vCopy[i_1 + 1] = v[i][i_1];
				}

				// Предобуславливание с помощью V цикла многосеточного метода.
				// Нулевое начальное приближение
				for (integer i_numberV_cycle = 0; i_numberV_cycle < 1; i_numberV_cycle++) {
					// достаточно одного V цикла.
					// A*Zcopy=vCopy;
					// В Zcopy и vCopy нумерация начинается с единицы.
					V_cycle_solve<doublerealT>(Amat, Zcopy, vCopy, process_flow_logic, row_ptr_start,
						row_ptr_end, residual_fine, diag, n_a, bonly_serial,
						process_flow_beta, F_false_C_true, nu1, nu2, bILU2smoother,
						ilevel, inumberVcyclelocbicgstab, imyinit, idim_diag, milu2, milu0, nested_desection,
						R, P, nnz_aRP, flag, residual_coarse, igam, nnz_a,
						error_approx_coarse, dapply_ilu_max_pattern_size,
						process_flow_alpha,
						error_approx_fine, nFinestSweeps);
					//getchar();
				}

				for (integer i_1 = 0; i_1 < n75; i_1++) {
					Z[i][i_1] = Zcopy[i_1 + 1];
				}
				

				// Совсем без предобуславливателя.
				//for (i_1 = 0; i_1 < n75; i_1++) Z[i][i_1] = v[i][i_1];

				// Закоментировано без предобуславливания.
				//w = A * Z[i];
				MatrixCRSByVector(val75, col_ind75, row_ptr75, Z[i], w, n75); // результат занесён в  w

				for (k = 0; k <= i; k++) {
					H[k][i] = Scal(w, v[k], n75);

					for (integer j_1 = 0; j_1 < n75; j_1++)
					{
						w[j_1] -= H[k][i] * v[k][j_1];
					}
				}
				H[i + 1][i] = NormaV_for_gmres(w, n75);



				for (integer j_1 = 0; j_1 < n75; j_1++)
				{
					v[i + 1][j_1] = w[j_1] * (1.0 / H[i + 1][i]); // ??? w / H(i+1, i)
				}
				// Окончание ортогонализации Арнольди.
				// В v - хранится ортонормированный базис подпространства Крылова размерности m_restart.
				// H - Верхнетреугольная матрица Хессенберга - матрица коэффициентов ортогонализации.


				// 26.11.2017
				// Это проверенный и испытанный кусок кода.
				for (k = 0; k < i; k++)
					ApplyPlaneRotation(H[k][i], H[k + 1][i], cs[k], sn[k]);

				GeneratePlaneRotation(H[i][i], H[i + 1][i], cs[i], sn[i]);
				ApplyPlaneRotation(H[i][i], H[i + 1][i], cs[i], sn[i]);
				ApplyPlaneRotation(s[i], s[i + 1], cs[i], sn[i]);



				// Вручную устраняем случай полного совпадения невязок на двух соседних итерациях,
				// т.к. иначе это приводит к развалу решения.
				//if (fabs(s[i] - s[i + 1]) < 1.0e-37) s[i + 1] = 1.05*s[i];

				printf("%lld %e \n", j, fabs(s[i + 1]) / normb);
				//printf("%d %e \n", j, beta*fabs(s[i + 1]));
				//getchar();

				resid = fabs(s[i + 1]) / normb;
				//resid = beta*fabs(s[i + 1]);

				if ((resid) < dterminatedTResudual) {
					printf("dosrochnji vjhod\n");
					//getchar();				
					Update(dx, i, n75, H, s, Z);
					//tol = resid;
					//maxit = j;

					for (integer i_1 = 0; i_1<n75; i_1++) {
						x[i_1 + 1] = dx[i_1];
						x_best_search[i_1 + 1] = dx[i_1];
					}

					for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] v[i_1];
					delete[] v;
					for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] Z[i_1];
					delete[] Z;
					for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) delete[] H[i_1];
					delete[] H;
					delete[] dx;
					delete[] buffer;
					delete[] r;
					delete[] w;
					delete[] s;
					delete[] cs;
					delete[] sn;
					delete[] Zcopy;
					delete[] vCopy;

					// Освобождение оперативной памяти.
					if (val75 != NULL) {
						delete[] val75;
						val75 = NULL;
					}
					if (col_ind75 != NULL) {
						delete[] col_ind75;
						col_ind75 = NULL;
					}
					if (row_ptr75 != NULL) {
						delete[] row_ptr75;
						row_ptr75 = NULL;
					}

					goto LABEL_FGMRES_CONTINUE;

				}
			}



			// i-1 -> m_restart-1
			Update(dx, i - 1, n75, H, s, Z);//i-1 //ERROR

			//r = M.solve(b - A * x);
			MatrixCRSByVector(val75, col_ind75, row_ptr75, dx, r, n75); // Результат занесён в r
			for (integer  i_1 = 0; i_1 < n75; i_1++) r[i_1] = b[i_1 + 1] - r[i_1];

			//beta = norm(r);
			beta = NormaV_for_gmres(r, n75);

			resid = beta / normb;
			//resid = beta;

			if ((resid) < dterminatedTResudual) {
				//tol = resid;
				//maxit = j;

				printf("end\n");
				//getchar();

				for (integer i_1 = 0; i_1 < n75; i_1++) {
					x[i_1 + 1] = dx[i_1];
					x_best_search[i_1 + 1] = dx[i_1];
				}

				for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] v[i_1];
				delete[] v;
				for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] Z[i_1];
				delete[] Z;
				for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) delete[] H[i_1];
				delete[] H;
				delete[] dx;
				delete[] buffer;
				delete[] r;
				delete[] w;
				delete[] s;
				delete[] cs;
				delete[] sn;
				delete[] Zcopy;
				delete[] vCopy;

				// Освобождение оперативной памяти.
				if (val75 != NULL) {
					delete[] val75;
					val75 = NULL;
				}
				if (col_ind75 != NULL) {
					delete[] col_ind75;
					col_ind75 = NULL;
				}
				if (row_ptr75 != NULL) {
					delete[] row_ptr75;
					row_ptr75 = NULL;
				}

				goto LABEL_FGMRES_CONTINUE;


			}
		}

		//tol = resid;
		for (integer i_1 = 0; i_1<n75; i_1++) {
			x[i_1 + 1] = dx[i_1];
			x_best_search[i_1 + 1] = dx[i_1];
		}

		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] v[i_1];
		delete[] v;
		for (integer i_1 = 0; i_1 <= m_restart + 1; i_1++) delete[] Z[i_1];
		delete[] Z;
		for (integer i_1 = 0; i_1 < m_restart + 2; i_1++) delete[] H[i_1];
		delete[] H;
		delete[] dx;
		delete[] buffer;
		delete[] r;
		delete[] w;
		delete[] s;
		delete[] cs;
		delete[] sn;
		delete[] Zcopy;
		delete[] vCopy;

		// Освобождение оперативной памяти.
		if (val75 != NULL) {
			delete[] val75;
			val75 = NULL;
		}
		if (col_ind75 != NULL) {
			delete[] col_ind75;
			col_ind75 = NULL;
		}
		if (row_ptr75 != NULL) {
			delete[] row_ptr75;
			row_ptr75 = NULL;
		}
		goto LABEL_FGMRES_CONTINUE;


	

	}

LABEL_FGMRES_CONTINUE:

	if (debug_reshime) system("pause");
	//system("pause");




	// Внимание : именно эта строчка обеспечивает сходимость.
#pragma omp parallel for
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x[i47] = x_best_search[i47];
	}

	identiti = true;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		if (fabs(x[i47] - x_best_search_init[i47]) > 1e-5) {
			identiti = false;
		}
	}
	if (identiti) {
		if (iVar != TOTALDEFORMATIONVAR) {
			printf("identity situation\n");
			// если техника x_best_search вообще не дала результатов.
#pragma omp parallel for
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_best_search2[i47];
			}
		}
	}

	// Метка к которой мы приходим если значение невязки превысило 1.0e7.
FULL_DIVERGENCE_DETECTED:

	// диагностическое сообщение какую переменную мы решаем.
	if (bprint_mesage_diagnostic) {
		switch (iVar) {
		case PAM: printf("PAM\n");  break;
		case VX:  printf("VX\n"); break;
		case VY:  printf("VY\n"); break;
		case VZ:  printf("VZ\n"); break;
		case TEMP:  printf("TEMP\n"); break;
		case TOTALDEFORMATIONVAR: printf("Stress system\n"); break;
		}
	}
	else {
#if doubleintprecision == 1
		//switch (iVar) {
		// Радиатор водяного охлаждения 3л/мин ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		//case PAM: printf("PAM %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel-2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]);  break;
		//case VX:  printf("VX %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VY:  printf("VY %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VZ:  printf("VZ %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TEMP:  printf("TEMP %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TOTALDEFORMATIONVAR:  printf("Stress system %lld %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//}
#else
		//switch (iVar) {
		// Аляска ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		//case PAM: printf("PAM %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel-2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]);  break;
		//case VX:  printf("VX %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VY:  printf("VY %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case VZ:  printf("VZ %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TEMP:  printf("TEMP %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//case TOTALDEFORMATIONVAR:  printf("Stress system %d %e %e %e %e\n", ilevel, n_a[ilevel - 4] / n_a[ilevel - 3], n_a[ilevel - 3] / n_a[ilevel - 2], n_a[ilevel - 2] / n_a[ilevel - 1], n_a[ilevel - 1] / n_a[ilevel]); break;
		//}
#endif
		

#if doubleintprecision == 1
		switch (iVar) {
			// Аляска ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%lld  CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VX:  printf("VX level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VY:  printf("VY level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VZ:  printf("VZ level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TOTALDEFORMATIONVAR:  printf("Stress system level=%lld CopA=%1.2f CopP=%1.2f nV=%lld res0=%e %lld %lld %lld\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#else
		switch (iVar) {
			// Аляска ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%d  CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VX:  printf("VX level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VY:  printf("VY level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VZ:  printf("VZ level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TOTALDEFORMATIONVAR:  printf("Stress system  level=%d CopA=%1.2f CopP=%1.2f nV=%d res0=%e %d %d %d\n", ilevel, dr_grid_complexity, (doublereal)(nnz_P_memo_all / n_a[0]), icount_V_cycle, dres_initial, n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#endif
	
	}
	//getchar();

	// free
	if (x_best_search2 != NULL) {
		delete[] x_best_search2;
		x_best_search2 = NULL;
	}
	if (x_best_search_init != NULL) {
		delete[] x_best_search_init;
		x_best_search_init = NULL;
	}
	
	
	// free	
	if (bnested_desection_global_amg != NULL) {
		free(bnested_desection_global_amg);  // Глобальная память.
		bnested_desection_global_amg = NULL;
	}
	for (integer i_scan_levels = 0; i_scan_levels <= maxlevel-1; i_scan_levels++) {
		if (ilevel +1 > i_scan_levels) {
			// free
			if (i_scan_levels <= maxlevel - 1) {
				if (diag[i_scan_levels] != NULL) {
					free(diag[i_scan_levels]);
					diag[i_scan_levels] = NULL;
				}
				if (nested_desection[i_scan_levels] != NULL) {
					free(nested_desection[i_scan_levels]);
					nested_desection[i_scan_levels] = NULL;
				}
				integer i_scan_levels_prev = i_scan_levels - 1;
				if (i_scan_levels_prev >= 0) {
					if (error_approx_fine[i_scan_levels_prev] != NULL) {
						free(error_approx_fine[i_scan_levels_prev]);
						error_approx_fine[i_scan_levels_prev] = NULL;
					}
					if (error_approx_coarse[i_scan_levels_prev] != NULL) {
						free(error_approx_coarse[i_scan_levels_prev]);
						error_approx_coarse[i_scan_levels_prev] = NULL;
					}
					if (residual_coarse[i_scan_levels_prev] != NULL) {
						free(residual_coarse[i_scan_levels_prev]);
						residual_coarse[i_scan_levels_prev] = NULL;
					}
				}
				if (residual_fine[i_scan_levels] != NULL) {
					free(residual_fine[i_scan_levels]);
					residual_fine[i_scan_levels] = NULL;
				}
			}
		}
	}
	

	// метод огрубления.
	my_amg_manager.icoarseningtype = memo_icoarseningtype;


	if (F_false_C_true != NULL) {
		free(F_false_C_true);
		F_false_C_true = NULL;
	}

	if (diag != NULL) {
		delete[] diag;
		diag = NULL;
	}
	if (nested_desection != NULL) {
		delete[] nested_desection;
		nested_desection = NULL;
	}

//#ifdef	_NONAME_STUB29_10_2017
#ifdef _OPENMP
	// Освобождение озу ГУСТАВСОН умножение разреженных матриц.
	// Единожды!!!
	for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {
		free(vector_sum_m[i_9]);
		free(index_visit_m[i_9]);
		free(hash_table_m[i_9]);
	}
	delete[] vector_sum_m;
	delete[] index_visit_m;
	delete[] hash_table_m;
	delete[] index_size_m;
	vector_sum_m = NULL;
	index_visit_m = NULL;
	hash_table_m = NULL;
	index_size_m = NULL;

	for (integer i_9 = 0; i_9 < iKnumber_thread; i_9++) {
		delete[] AccumulqtorA_m[i_9];
	}
	delete[] AccumulqtorA_m;
	AccumulqtorA_m = NULL;
	delete[] istartAnew_m;
	istartAnew_m = NULL;
#endif

	delete[] n_a;
	delete[] nnz_a;

	// освобождение оперативной памяти.
	free_level_additional_data(milu0, ilevel);
	free_level_additional_data(milu2, ilevel);

	// Освобождение общей памяти в ILU буффере.
	if (milu_gl_buffer.alu_copy != NULL) delete[] milu_gl_buffer.alu_copy;
	if (milu_gl_buffer.jlu_copy != NULL) delete[] milu_gl_buffer.jlu_copy;
	if (milu_gl_buffer.ju_copy != NULL) delete[] milu_gl_buffer.ju_copy;
	milu_gl_buffer.alu_copy = NULL;
	milu_gl_buffer.jlu_copy = NULL;
	milu_gl_buffer.ju_copy = NULL;

	//delete[] residual_fine[0];
	if (residual_fine[0] != NULL) {
		free(residual_fine[0]);
		residual_fine[0] = NULL;
	}

	//delete[] residual_fine;
	if (residual_fine != NULL) {
		delete[] residual_fine;
		residual_fine = NULL;
	}

	//delete[] error_approx_fine;
	if (error_approx_fine != NULL) {
		delete[] error_approx_fine;
		error_approx_fine = NULL;
	}

	//delete[] error_approx_coarse;
	if (error_approx_coarse != NULL) {
		delete[] error_approx_coarse;
		error_approx_coarse = NULL;
	}

	//delete[] residual_coarse;
	if (residual_coarse != NULL) {
		delete[] residual_coarse;
		residual_coarse = NULL;
	}

	//delete[] row_ptr_start;
	//delete[] row_ptr_end;
	if (row_ptr_start != NULL) {
		free(row_ptr_start);
		row_ptr_start = NULL;
	}
	if (row_ptr_end != NULL) {
		free(row_ptr_end);
		row_ptr_end = NULL;
	}



	//delete[] flag_shadow;
	if (flag_shadow != NULL) {
		free(flag_shadow);
		flag_shadow = NULL;
	}


	//delete[] flag;
	if (flag != NULL) {
		free(flag);
		flag = NULL;
	}
	if (x_copy != NULL) {
		free(x_copy);
		x_copy = NULL;
	}
	if (x_old != NULL) {
		free(x_old);
		x_old = NULL;
	}
	if (x_best_search != NULL) {
		free(x_best_search);
		x_best_search = NULL;
	}

	// Для подстраховки:

	if (row_ptr_start != NULL) {
		free(row_ptr_start);
		row_ptr_start = NULL;
	}
	if (row_ptr_end != NULL) {
		free(row_ptr_end);
		row_ptr_end = NULL;
	}


	if (x_jacoby_buffer != NULL) {
		delete[] x_jacoby_buffer;
		x_jacoby_buffer = NULL;
	}

	if (btree_vs_hash == 1) {
		free_hash_table_Gus_struct01();
	}

	// Освобождение оперативной памяти.
	if (threshold_quick_all != NULL) {
		free(threshold_quick_all);
		threshold_quick_all = NULL;
	}

	if (threshold_quick_only_negative != NULL) {
		free(threshold_quick_only_negative);
		threshold_quick_only_negative = NULL;
	}

	//return false;
	return ret_value;

} // classic_aglomerative_amg4



// объявление функционала который потребуется уже здесь а реализован далее по коду.
void exporttecplotxy360T_3D_part2amg(doublereal* u, bool bextendedprint, integer imove);

// 25.04.2018 пятая версия classic_aglomerative_amg5 давно не поддерживается.
// Основная версия четыре classic_aglomerative_amg4.
// 4-6, 26 ноября 2016. Добавлен ILU0. Полностью удалён устаревший код из Solution Phase.
// 15 августа 2016. Черногория. Проблема нефизичных positive connections.
// 9 августа 2016. Зейдель не справляется с большими спектральными радиусами матриц даже в составе данного amg,
// это же проявляется и на классическом amg1r5. 9 августа решено уменьшить спектральный радиус в Зейделе 
// на каждом уровне вложенности с помощью ILU2 декомпозиции. Это подтверждает статья Е.М.Андреева, Г.В.Муратова
// "Многосеточный метод решения сильно нессиметричных систем" ЮГИНФО РГУ, Ростов-на-Дону, Россия. Там они
// показывают расходимость мультигрида на основе Зейделя для задач с существенным спектральным радиусом и
// рекомендуют заменить Зейделя на ТКМ2 метод (треугольный кососимметричный метод). В данной программе у нас есть 
// успешный опыт использования ILU2 предобуславливателя из библиотеки SPARSKIT2 Ю.Саада поэтому вместо ТКМ2 у нас 
// будет ILU2.
// 22 января текущий работоспособный вариант кода.
// Планы : 1. сделать версию amg3. 
// В ней : 2. заменить все проверки на невыделение оперативной памяти на универсальную функцию единую для всего.
// это очевидно немного сократит программный код.
// В ней 3. код V цикла оформить в виде цикла for. Тогда же можно будет попробовать вставить direct метод для самого грубого уровня.
// Это же откроет возможности сделать из amg алгоритма предобуславливатель для BiCGStab.
// 15 января экономим память переходим на Ak1.
// 10 января 2016 двоичный поиск заменён на хеширование.
// 15 декабря 2015. Данная версия кода будет полностью очищена от устаревшего кода.
// 13 декабря 2015. Внедрено АВЛ дерево. При внедрении АВЛ дерева исправлена логическая ошибка в
// построении С-F разбиения, теперь C-F разбиение строится корректно.
// Исправлен и внедрён quicksort (qs,qsj)
// который в рять раз быстрее пирамидальной сортировки.
// Полный отказ от band_size!!!.
// Время работы алгоритма на 1.7М неизвестных в 3D составило ровно 1 минуту.
// 18 октября 2015. Полностью работоспособный мультигрид.
// Тестировалось на условиях Дирихле но должно работать на любых 
// краевых задачах. 18 октября датируется версия 0.04. Версия 0.04 на треть
// быстрее версии 0_03. Были ускорены как операции построения C-F разбиения, 
// так и нахождение оператора Галёркина. При нахождении С-F разбиения 
// учитывается уже построеннная его часть и поэтому число сканирований на
// на поздних циклах сокращается охватывая только не построенную часть.
// При нахождении произведеия Галёркина получена самая оптимальная по быстродествию версия,
// Основанная на алгоритме слияния отсортированных списков.
// 4 октября правильное построение последовательности вложенных графов.
// 30 сентября продолжаем исправление метода. Делаем классический 
// алгебраический многосеточный метод на основе  C-F разбиения.
// 16 сентября 2015 года обнаружено что операции 
// сгрубления и интерполяции сделаны совершенно неверно,
// и если сгрубление еще в какой-то мере проецирует то интерполяция просто никакая.
// Операции сгрубления и интерполляции будут сделаны заново на основе статьи К.Н. Волкова в новой версии солвера.
// 3 september 2015 Villa Borgese.
// Возвращает divergence detected.
template <typename doublerealT>
bool classic_aglomerative_amg5(Ak1* &Amat,
	integer nsizeA, // количество ячеек выделенное извне для хранилища матриц А
	integer &nsizePR, // Память под P в количествах n.
	integer nnz, // number of non zero elements
	integer n, // dimension of vectors x and b.
	Ak1* &R, // restriction
	Ak1* &P, // prolongation
	doublereal* &x, doublereal* &b,
	bool* &bamg_bound, // true - граничный узел, false - внутренний.
	doublerealT &theta, doublerealT &theta83, doublerealT &magic82, doublerealT &magic83, doublerealT &ret74,
	integer iVar,
	bool bmemory_savings
	) {

	bfirst_jacoby_start = true;

	signal_omega_correct = false;

	// Универсальные сглаживающие процедуры. 4 ноября 2016.
	// ILU2 smoother
	// 0 - ILU не используется. используется Gaus-Seidel.
	// 1 - ILU0 используется.
	// 2 - ILU2 используется.
	integer bILU2smoother = 0;
	if (my_amg_manager.ilu2_smoother == 1) {
		// Включаем ILU0 сглаживатель. 
		// он ест больше памяти но более быстро сходится.
		// Есть надежда что он справится с гораздо более плохообусловленными матрицами.

		bILU2smoother = 1; // ILU0

						   // По - видимому алгоритм 
						   // ilu0_(maxelm_plus_maxbound, milu0.val, milu0.col_ind, milu0.row_ptr, milu0.alu, milu0.jlu, milu0.ju, milu0.iw, ierr);
						   // является дефектным. Я не получил с ним сходимости как ни пытался. Зато алгоритм iluk с lfil=0 проявил себя наилучшим 
						   // образом и я его рекомендую к использованию. Это реализовано в ветке кода my_amg_manager.ilu2_smoother == 2.
						   // Причём iluk с lfil=0 работает на всех уровнях и прекрасно себя провляет.

						   // Перенаправление.
		bILU2smoother = 2; // ILU0
	}
	if (my_amg_manager.ilu2_smoother == 2) {
		// Включаем ILU2 сглаживатель. 
		// он ест больше памяти но более быстро сходится.

		// Его рекомендуется применять только для исходной матрицы - уровень ноль.
		// Если его применять на более глубоких уровнях то сходимость лишь замедляется.

		bILU2smoother = 2; // ILU2

						   // ILU2 ест слишком много оперативной памяти и я его заменил на ILU0 сглаживатель на каждом уровне : iluk с lfil=0.
						   // Возможно я ещё вернусь к ilu2 хотябы на нулевом уровне, т.к. там он особенно хорош.
	}
	//bILU2smoother = 0; // only seidel sor smoother.
		
	

	// Параметры отвечающие за автоматическую настройку SOR.
	// По трём точкам мы построим параболу и на её основе 
	// спрогнозируем улучшенный параметр релаксации omega_optimal.
	// Парабола представляется намного лучшей чем простая линейная экстрополяция.
	bproblem_amg_convergence1 = false;
	bproblem_amg_convergence2 = false;
	bproblem_amg_convergence3 = false;
	gold_const = 0.2;

	bool bprint_mesage_diagnostic = true;
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		bprint_mesage_diagnostic = false;
	}

	if (my_amg_manager.iprint_log == 0) {
		bprint_mesage_diagnostic = false;
	}

	const integer AVL_TREE_ID = 0;
	const integer SPLAY_TREE_ID = 1;
	integer id_tree = SPLAY_TREE_ID;


	// Для вычисления grid complexity оператора интерполляции:
	integer nnz_P_memo_0 = 0;
    integer nnz_P_memo_all = 0;

	// Надо заменить все new на malloc.
	//theta = 0.25;

	bool bonly_serial = true;
//#ifdef _OPENMP
	//omp_set_num_threads(2);
//#endif

	// barjer=0.0001; optimum. для 1M задач.
	// Для зачачи с 3.2M неизвестных (теплопередача в 5mm СВЧ транзисторе без дырок.)
	// для константы 1.0e-8 получено сокращение времени счёта с 9мин до 4мин (Количество итераций 213 вместо 1003).
	// Пик использования оперативной памяти при этом приложению составил 2373Мб.
	// Для BiCGStab+ILU2 время счёта равно 1мин 50с против 4мин в данной версии алгоритма.
	// 14 января 2016 подобраны оптимальными и равными 1e-7 каждый.
	// 23 10 2016 первый барьер полностью отключен.
	doublerealT barjer = 1.0e-7; // 1.0e-7 
	// 22 10 2016. Второй барьер можно использовать и у него большой потенциал,
	// но надо им правильно пользоваться в соответствии с теорией, это не просто импирическое изменение константы.
	// Если барьер А не используется то его значение отрицательно.
	// значение без барьера А называется мультигридом Галёркина.
	doublerealT barjerA = -1.0e-7; // 1.0e-7

	//if (iVar == PAM) {
	//barjer = 1.0e-10; // 1.0e-7 
	//barjerA = 1.0e-10; // 1.0e-7
	//}

	// контроль числа сильных связей между переменными.
	// doublerealT theta = 0.25;  // 0.25 for 2D and 0.5 for 3D 

	// количество рекурсивных вызовов ограничено, поэтому QuickSort не подходит.
	// В компиляторе надо увеличить размер стека до 4Мб.
	// Если bqs == false то используется пирамидальная сортировка.
	bool bqs = false; // Использовать ли quicksort qs and qsj.
	// Сортировка с подсчётом быстрее quickSort.
	bool bCounting_Sort = true; // Использовать ли сортировку подсчётом которая жрёт килотонну памяти (Короче для машин у которых море оперативки).


	const doublereal RealZERO = 1.0e-300;// 1.0e-10;
	const doublereal divisionZERO = 1.0e-300;
	const doublereal RealMAXIMUM = 1.0e300;
	// включение/отключение отладочного режима.
	bool debug_reshime = false;

	const integer max_sosed = 27850;
	// Мы будем поддерживать информацию о максимальном количестве соседей.
	integer Maximumsosedcount = -1;
	// мы получим порядковый номер элемента с максимальным число соседей в матрице А,
	// прямо в результате построения C-F разбиения.
	bool bmaxsosedinfoactive = false;


	// Возможно можно обойтись без ji связи.
	// 17 dec 2015 эксперимент показывает что можно обойтись без учёта ji связи.
	// false без связи. Если false то Atemp вообще ненужен.
	bool bji = false;
	Ak1* Atemp = NULL;
	if (bji) {
		Atemp = new Ak1[3 * nnz + 1];
	}

	// нумерация начинается с единицы.

	const integer maxlevel = 30;
	integer ilevel = 1;
	integer nnz_a[maxlevel];
	integer n_a[maxlevel];
	nnz_a[0] = nnz;
	n_a[0] = n;
	//bool* flag = new bool[n + 1];
	bool* flag = NULL;
	flag = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag, "flag", "classic_aglomerative_amg_5", (n + 1));
	bool* flag85 = NULL;
	flag85 = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag85, "flag", "classic_aglomerative_amg_5", (n + 1));
	
	

	//bool* flag_shadow = new bool[n + 1];
	bool* flag_shadow = NULL;
	flag_shadow = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(flag_shadow, "flag_shadow", "classic_aglomerative_amg_5", (n + 1));

	//bool* hash_table = new bool[nnz + 1]; // Огромного размера hash таблица.
	bool* hash_table = NULL;
	hash_table = (bool*)malloc((nnz + 1) * sizeof(bool));
	handle_error<bool>(hash_table, "hash_table", "classic_aglomerative_amg_5", (nnz + 1));

	// Огромный размер поэтому инициализация делается лишь единожды.
	for (integer isc = 0; isc <= nnz; isc++) hash_table[isc] = false; // initialization 
	const integer istack_size_limit = n + 1; // 128000
	//integer ipool[ipool_size_limit];
	integer* istack = NULL;
	//istack = new integer[istack_size_limit];
	istack = (integer*)malloc((istack_size_limit)*sizeof(integer));
	handle_error<integer>(istack, "istack", "classic_aglomerative_amg_5", (istack_size_limit));

	// Для построения C-F декомпозиции нам тоже потребуется хеш таблица
	// и стек для очистки хеш таблицы.
	bool* hash_table2 = NULL;
	hash_table2 = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(hash_table2, "hash_table2", "classic_aglomerative_amg_5", (n + 1));

	// Инициализация.
	for (integer isc = 0; isc <= n; isc++) hash_table2[isc] = false;
	// И теперь стек для очистки хеш таблицы.
	integer* istack2 = NULL;
	//istack2 = new integer[n + 1];
	istack2 = (integer*)malloc((n + 1)*sizeof(integer));
	handle_error<integer>(istack2, "istack2", "classic_aglomerative_amg_5", (n + 1));


	integer iadd = 0;
	integer nnzR = 1;
	integer iaddR = 0;
	integer nnz_aRP[maxlevel];
	bool bcontinue = true;
	//bool* this_is_C_node = new bool[n + 1];
	//bool* this_is_F_node = new bool[n + 1];
	bool* this_is_C_node = NULL;
	this_is_C_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_C_node, "this_is_C_node", "classic_aglomerative_amg_5", (n + 1));

	bool* this_is_F_node = NULL;
	this_is_F_node = (bool*)malloc((n + 1) * sizeof(bool));
	handle_error<bool>(this_is_F_node, "this_is_F_node", "classic_aglomerative_amg_5", (n + 1));


	while ((ilevel < maxlevel - 1) && (n_a[ilevel - 1] > 50) && (bcontinue)) {


		/*
		hashlist** hash = new hashlist*[n_a[ilevel - 1]+1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hash[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].i;
		insertion_hash(hash[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hash[i_1]);
		hash[i_1] = 0;
		}
		delete[] hash;

		hashlist** hashj = new hashlist*[n_a[ilevel - 1] + 1];
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		hashj[i_1] = 0; // инициалзация.
		}

		// Заполнение структуры данных
		for (integer i_1 = 1; i_1 <= nnz_a[ilevel - 1]; i_1++) {
		integer iposA = i_1 + iadd;
		integer id = Amat[iposA].j;
		insertion_hash(hashj[id], Amat[iposA]);
		}


		// Освобождение памяти.
		for (integer i_1 = 0; i_1 <= n_a[ilevel - 1]; i_1++) {
		clear_hash(hashj[i_1]);
		hashj[i_1] = 0;
		}
		delete[] hashj;
		*/


		Maximumsosedcount = -1;
		bmaxsosedinfoactive = false;

		//if (ilevel > 1) {
		//if (n_a[ilevel - 2] == n_a[ilevel - 1]) break;
		//}

		if (ilevel > 10) {
			if (n_a[ilevel - 1] < 300) break;
		}

		if (ilevel > 1) {
			doublerealT procent = (100.0*(abs(n_a[ilevel - 1] - n_a[ilevel - 2]))) / (1.0*n_a[ilevel - 2]);
			if (procent<2.0) break;
		}

		if (((ilevel > 1) && (nnz_a[ilevel - 1] > nnz_a[ilevel - 2]))) {
			//break;
		}

#if doubleintprecision == 1
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld nnz_a[0]=%lld nnz_a[1]=%lld iadd=%lld\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld iadd=%lld\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%lld", ilevel);
				printf("n_a[0]=%lld n_a[1]=%lld n_a[2]=%lld n_a[3]=%lld \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%lld nnz_a[1]=%lld nnz_a[2]=%lld nnz_a[3]=%lld iadd=%lld\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%lld\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%lld]=%lld nnz_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#else
		if (bprint_mesage_diagnostic) {
			// level info.
			if (ilevel == 2) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d nnz_a[0]=%d nnz_a[1]=%d iadd=%d\n", n_a[0], n_a[1], nnz_a[0], nnz_a[1], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 3) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d iadd=%d\n", n_a[0], n_a[1], n_a[2], nnz_a[0], nnz_a[1], nnz_a[2], iadd);
				if (debug_reshime) system("pause");
			}
			if (ilevel == 4) {
				printf("ilevel=%d", ilevel);
				printf("n_a[0]=%d n_a[1]=%d n_a[2]=%d n_a[3]=%d \n", n_a[0], n_a[1], n_a[2], n_a[3]);
				printf("nnz_a[0]=%d nnz_a[1]=%d nnz_a[2]=%d nnz_a[3]=%d iadd=%d\n", nnz_a[0], nnz_a[1], nnz_a[2], nnz_a[3], iadd);
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 5) || (ilevel == 6) || (ilevel == 7) || (ilevel == 8) || (ilevel == 9) || (ilevel == 10)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 11) || (ilevel == 12) || (ilevel == 13) || (ilevel == 14) || (ilevel == 15)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if ((ilevel == 16) || (ilevel == 17) || (ilevel == 18) || (ilevel == 19) || (ilevel == 20)) {
				printf("ilevel=%d\n", ilevel);
				for (integer i_1 = 0; i_1 < ilevel; i_1++) {
					printf("n_a[%d]=%d nnz_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1]);
				}
				if (debug_reshime) system("pause");
			}

			if (ilevel > 17) {
				printf("very big matrix (mesh). no programming.\n");
				system("pause");
				exit(1);
			}
		}
#endif

		

		//nnzR = 1;

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		for (integer ii = n_a[ilevel - 1]+1; ii <= n; ii++) {
#if doubleintprecision == 1
			//printf("warning: n!=n_a[ilevel-1] : n=%lld, n_a=%lld, ilevel=%lld\n", n, n_a[ilevel - 1], ilevel);
#else
			//printf("warning: n!=n_a[ilevel-1] : n=%d, n_a=%d, ilevel=%d\n", n, n_a[ilevel - 1], ilevel);
#endif
			
			//getchar();
			this_is_C_node[ii] = false;
			this_is_F_node[ii] = false;
		}

		// Сортировка нужна лишь на первом уровне, т.к.
		// результат алгоритма перемножения по Густавсону уже 
		// даёт на выходе отсортированную по строкам матрицу.
		if (ilevel == 1) {
			// сортировка исходной  А  по i.
			//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);


			// 7 января 2016. Обязательно нужна эта сортировка.
			if (bqs) {
				if (bCounting_Sort) {
					Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd, bmemory_savings);
				}
				else {
					// quicksort
					qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				}
			}
			else {
				HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
			}
			//QuickSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}





		if (bji) {
			// Создаём копию в Atemp, копия будет отсортирована по j.
			for (integer i_1 = 1 + iadd; i_1 <= nnz_a[ilevel - 1] + iadd; i_1++) {
				Atemp[i_1 - iadd] = Amat[i_1];
			}
			// Сортируем копию по j.
			// Мы сортируем по j, чтобы потом быстро искать по j.
			if (bqs) {
				if (bCounting_Sort) {
					// Сортировка с подсчётом за линейное время.
					Counting_Sortj(Atemp, 1, nnz_a[ilevel - 1]);
				}
				else {
					// Быстрая сортировка Чарльза Хоара.
					qsj(Atemp, 1, nnz_a[ilevel - 1]);
				}
			}
			else {
				HeapSort_j(Atemp, 1, nnz_a[ilevel - 1]);
			}
		}

		for (integer i_1 = 1; i_1 <= n; i_1++) {
			flag[i_1] = false;
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}

		// позиция начала каждой строки в матрице.
		integer* row_startA = NULL;
		//row_startA = new integer[n_a[ilevel - 1] + 1];
		row_startA = (integer*)malloc((n_a[ilevel - 1] + 2)*sizeof(integer));
		handle_error<integer>(row_startA, "row_startA", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 2));

		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				flag[Amat[ii].i] = true;
				row_startA[Amat[ii].i] = ii;
			}
		}
		row_startA[n_a[ilevel - 1] + 1] = nnz_a[ilevel - 1] + iadd + 1; // заглушка на окончание матрицы.

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false;
		}


		// вычисляем для кадого узла число его соседей.
		integer* count_sosed = NULL;
		//count_sosed = new integer[n_a[ilevel - 1] + 1];
		count_sosed = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(count_sosed, "count_sosed", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			count_sosed[ii] = 0; // нет соседей.
		}



		/*
		// При таком коде узел Дирихле тоже имеет соседа, сосед это
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		integer ic = -1;
		integer cand[max_sosed];
		if (0) {
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		else {
		// 12 января 2016.
		// Учитываем только Strong соседей.
		doublerealT threshold = -1.0;
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > threshold) {
		// Определяем максимальный внедиагональный элемент.
		threshold = fabs(Amat[is0].aij);
		}
		}
		}
		for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
		if (Amat[is0].j != Amat[ii].i) {
		if (fabs(Amat[is0].aij) > theta*threshold) {
		// Учитываем только сильно связанных соседей.
		ic++; //i,j
		cand[ic] = Amat[is0].j;
		}
		}
		}
		}
		integer len_sosed = ic;
		// Найти столбец j который равен индексу Amat[ii].i
		//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
		//if (Amat[ii1].i != Amat[ii].i) {
		//	if (Amat[ii1].j == Amat[ii].i) {
		// j,i
		//		bool foundsosed = false;
		//		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
		//			if (Amat[ii1].j == cand[i_1]) foundsosed = true;
		//		}
		//		if (!foundsosed) {
		//			ic++;
		//			cand[ic] = Amat[ii1].j;
		//			len_sosed++;
		//		}
		//	}
		//}
		//}
		if (bji) {
		// Ускоренная версия с бинарным поиском по j.
		integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
		for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == Amat[ii].i); ii1++) {
		if (Atemp[ii1].i != Amat[ii].i) {
		// j,i
		bool foundsosed = false;
		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
		if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
		}
		if (!foundsosed) {
		ic++;
		cand[ic] = Atemp[ii1].j;
		len_sosed++;
		}
		}
		}
		}


		count_sosed[Amat[ii].i] = ic;
		if (ic > Maximumsosedcount) {
		Maximumsosedcount = ic;
		bmaxsosedinfoactive = true;
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/

		// При таком коде узел Дирихле тоже имеет соседа, сосед это 
		// внутренний узел который связан с этим узлом Дирихле.
		// Соседей вычисляем на самой первой матрице А (самой левой).
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer ic = -1;
				integer cand[max_sosed];
				if (0) {
					for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii].i); is0++) {
						ic++; //i,j
						cand[ic] = Amat[is0].j;
					}
				}
				else {
					// 12 января 2016.
					// 12 февраля 2016. матрица отсортирована по i.
					// Учитываем только Strong соседей.
					doublerealT threshold = -1.0;
					for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > threshold) {
									// Определяем максимальный внедиагональный элемент.
									threshold = fabs(Amat[is0].aij);
								}
							}
						}
					}
					for (integer is0 = ii; (is0 <= row_startA[Amat[ii].i + 1] - 1); is0++) {
						if (Amat[is0].j != Amat[ii].i) {
							if (Amat[is0].aij < 0.0) {
								if (fabs(Amat[is0].aij) > theta*threshold) {
									// Учитываем только сильно связанных соседей.
									ic++; //i,j
									cand[ic] = Amat[is0].j;
								}
							}
						}
					}
				}
				integer len_sosed = ic;
				// Найти столбец j который равен индексу Amat[ii].i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != Amat[ii].i) {
				//	if (Amat[ii1].j == Amat[ii].i) {
				// j,i
				//		bool foundsosed = false;
				//		for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
				//			if (Amat[ii1].j == cand[i_1]) foundsosed = true;
				//		}
				//		if (!foundsosed) {
				//			ic++;
				//			cand[ic] = Amat[ii1].j;
				//			len_sosed++;
				//		}
				//	}
				//}
				//}
				if (bji) {
					// Ускоренная версия с бинарным поиском по j.
					integer ii2 = BinarySearchAj(Atemp, Amat[ii].i, 1, nnz_a[ilevel - 1]);
					for (integer ii1 = ii2; (ii1 <= row_startA[Amat[ii2].i + 1] - 1); ii1++) {
						if (Atemp[ii1].i != Amat[ii].i) {
							// j,i
							bool foundsosed = false;
							for (integer i_1 = 0; i_1 <= len_sosed; i_1++) {
								if (Atemp[ii1].j == cand[i_1]) foundsosed = true;
							}
							if (!foundsosed) {
								ic++;
								cand[ic] = Atemp[ii1].j;
								len_sosed++;
							}
						}
					}
				}


				count_sosed[Amat[ii].i] = ic;
				if (ic > Maximumsosedcount) {
					Maximumsosedcount = ic;
					bmaxsosedinfoactive = true;
				}
				flag[Amat[ii].i] = true;
			}
		}



		integer maxsosed = 0;
		integer icandidate = 0;
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}
		// Находим узел с наибольшим числом соседей и запоминаем его.
		// Это первый встретившийся узел с наибольшим числом соседей.
		/*
		for (integer ii = 1 + iadd; ii <= nnz_a[ilevel - 1] + iadd; ii++) {
		if (flag[Amat[ii].i] == false) {
		if (count_sosed[Amat[ii].i] > maxsosed) {
		maxsosed = count_sosed[Amat[ii].i];
		icandidate = ii;
		if (bmaxsosedinfoactive) {
		// организуем досрочный выход из цикла for.
		// Это должно сильно сокращать количество сканирований.
		if (maxsosed == Maximumsosedcount) break;
		}
		}
		flag[Amat[ii].i] = true;
		}
		}
		*/
		for (integer i7 = 1; i7 <= n_a[ilevel - 1]; i7++) {
			if (count_sosed[i7] > maxsosed) {
				maxsosed = count_sosed[i7];
				icandidate = row_startA[i7];
				if (bmaxsosedinfoactive) {
					// организуем досрочный выход из цикла for.
					// Это должно сильно сокращать количество сканирований.
					if (maxsosed == Maximumsosedcount) break;
				}
			}
		}

		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			flag[ii] = false; // init flag
		}


		// нужно выделить кто попал в coarse, а кто в этот раз попал в Fine Выделить всех кто соседствует
		// с новыми Fine увеличить им счётчик соседей.

		integer n_coarce = 1; // начальный номер C узла.
		nnzR = 1;

		const integer NULL_SOSED = -1;
		integer vacant = NULL_SOSED;
		

		// Построение C-F разбиения.
		//while (icandidate != 0)
		integer icountprohod = 0;
		// Мы будем заоминать с какой позиции начинаются ещё не помеченные узлы,
		// это сократит количество перебираемых элементов в поиске узла с максимальным 
		// количеством соседей.
		//integer ibegining_start_index_found_maximum = 1 + iadd;
		// храним те узлы которые уже были пройдены при конструировании.
		bool *bmarkervisit = NULL;
		//bmarkervisit = new bool[n + 1];
		bmarkervisit = (bool*)malloc((n + 1)*sizeof(bool));
		handle_error<bool>(bmarkervisit, "bmarkervisit", "classic_aglomerative_amg_5", (n + 1));

		// поначалу все узлы помечены как непосещенные.
		for (integer i_1 = 1; i_1 <= n; i_1++) bmarkervisit[i_1] = false;

		// Сразу заносим граничные условия Дирихле в С узлы.
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			integer iadd42 = 0;
			for (integer i42 = 0; i42 < ilevel - 1; i42++) {
				iadd42 += n_a[i42];
			}
			if (bamg_bound[ii+iadd42]) {
				flag[ii] = true; // init flag
				bmarkervisit[ii] = true;
				this_is_C_node[ii] = true;
				this_is_F_node[ii] = false;
			}
		}

		// увеличение быстродействия достигается 
		// сокращением пределов сканирования
		// здесь хранится индекс начала сканирования flag.
		integer istartflag_scan = 1;


		// if (bAVL) работа на основе АВЛ дерева.
		bool bAVL = true;
		bool bAVL_deb = false;
		node_AVL* root = 0;
		Tree_splay* root_splay = 0;
		size_splay_Tree = 0;

		integer newCcount = 0;

		// 4 июля 2016.
		// это случай когда следующий уровень вложенности просто не из чего строить и это 
		// становится понятно только здесь.
		if ((icandidate == 0) && (maxsosed == 0)) {
#if doubleintprecision == 1
			//printf("maxsosed==%lld\n",maxsosed);
#else
			//printf("maxsosed==%d\n",maxsosed);
#endif
			
			//getchar();
			// уровень построить нельзя поэтому досрочный выход из цикла.
			break;
		}

		bool bcontinue = true;

		while (bcontinue)
		{


#if doubleintprecision == 1
			//printf("prohod count number %lld\n", icountprohod);
#else
			//printf("prohod count number %d\n", icountprohod);
#endif
			


			integer set[max_sosed]; // не более 20 узлов в одном агрегате.
			// инициализация убрана потому что она не нужна и она сильно тормозит быстродействие.
			//for (integer js = 0; js < max_sosed; js++) {
			//set[js] = NULL_SOSED;
			//}
			integer ic = 0;

			integer ii = icandidate;
			if (flag[Amat[ii].i] == false) {

				ic = 0; // Обязательная инициализация.
				set[ic] = Amat[ii].i;



				this_is_C_node[set[0]] = true;
				bmarkervisit[set[0]] = true;

				doublerealT max_vnediagonal = -1.0; // максимальное значение модуля вне диагонального элемента. 
				// добавляем диагональный элемент.
				// узел set[0]==Amat[is0].i.
				// Нахождение значения максимального внедиагольного элемента, с 
				// учётом того что даже узел Дирихле связан с одним внутренним узлом расчётной области.
				// 17 января 2016 правильное определение максимального внедиагонального элемента.
				// Обязательная перемотка в самое начало строки.
				integer ii_back = ii;
				while ((ii_back > iadd) && (Amat[ii_back].i == set[0])) ii_back--;
				ii_back++;

				doublerealT max_vnediagonal1 = -1.0;
				doublerealT min_vnediagonal1 = 1.0e30;
				doublerealT counter_vnediagonal = 0.0;
				doublerealT avg_vnediagonal1 = 0.0;

				// Если делать по максимальному внедиагональному элементу то мы получим очень много элементов на грубых уровнях,
				// и чрезвычайно медленную сходимость.

				for (integer is0 = ii_back; (is0 <= row_startA[set[0] + 1] - 1); is0++) {
					if (Amat[is0].j != set[0]) {
						if (Amat[is0].aij < 0.0) {
							counter_vnediagonal = counter_vnediagonal + 1.0;
							avg_vnediagonal1 += fabs(Amat[is0].aij);
							if (fabs(Amat[is0].aij) > max_vnediagonal1) {
								max_vnediagonal1 = fabs(Amat[is0].aij); //i,j
								// Большое количество элементов на грубых уровнях,
								// очень медленная сходимость.
								//if (Amat[is0].j == set[0]) break; 
							}
							if (fabs(Amat[is0].aij) < min_vnediagonal1) {
								min_vnediagonal1 = fabs(Amat[is0].aij); //i,j

							}
						}
					}
				}
				if (fabs(counter_vnediagonal) > 0.5) {
					avg_vnediagonal1 = avg_vnediagonal1 / counter_vnediagonal;
				}
				else {
					avg_vnediagonal1 = max_vnediagonal1;
				}
				//max_vnediagonal = avg_vnediagonal1;
				//max_vnediagonal = max_vnediagonal1;  // 1
				//max_vnediagonal = 0.5* avg_vnediagonal1 + 0.5*max_vnediagonal1;
				//max_vnediagonal = avg_vnediagonal1 + 0.05*(max_vnediagonal1 - avg_vnediagonal1);
				// наиболее близка к оптимальной. -85%. но несомненно лучше max_vnediagonal = -1.0;
				//max_vnediagonal = avg_vnediagonal1 - 0.85*(avg_vnediagonal1 - min_vnediagonal1);
				// 19 января 2016 установлено что важды все связы, не нужно учитывать threshold
				// max_vnediagonal должно быть -1.0. Именно это значение обеспечивает наилучшую 
				// скорость агломерации и наилучшую скорость сходимости.
				max_vnediagonal = -1.0;  // все связи!!!

				/*
				// Лишний код 19 января 2016.
				for (integer is0 = ii; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == set[0]); is0++) {
				if (Amat[is0].j == set[0]) {

				// Из-за этого прерывания максимальный внедиагональный элемент может быть определён неверно.
				// поэтому смотри цикл выше от 17 января 2016 по правильному определению максимального внедиагонального элемента.
				break;
				}
				else {
				if (fabs(Amat[is0].aij) > max_vnediagonal) {
				// При стабильной версии требуется расскоментировать
				// 19 jan 2016.
				//max_vnediagonal = fabs(Amat[is0].aij); //i,j
				}
				}

				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Медленный линейный поиск.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1] + iadd; ii1++) {
				//if (Amat[ii1].i != set[0]) {
				//if (!flag[Amat[ii1].i]) {
				//	if (Amat[ii1].j == set[0]) {
				//		if (fabs(Amat[ii1].aij) > max_vnediagonal) {
				//			max_vnediagonal = fabs(Amat[ii1].aij); //j,i
				//		}
				//	}
				//}
				//}
				//}

				if (bji) {
				// Этот цикл является добавочным.
				// Найти связь j,i где кандидат i еще не был включен в строящееся С-F разбиение.
				// Ускоренная версия на основе двоичного поиска.
				integer ii2 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
				for (integer ii1 = ii2; (ii1 <= nnz_a[ilevel - 1]) && (Atemp[ii1].j == set[0]); ii1++)
				{
				if (Atemp[ii1].i != set[0]) {
				if (!flag[Atemp[ii1].i]) {
				if (fabs(Atemp[ii1].aij) > max_vnediagonal) {
				max_vnediagonal = fabs(Atemp[ii1].aij); //j,i
				}
				}
				}
				}
				}


				}
				*/

				ic++;


				// если узел j ещё не был добавлен в агрегат.
				if (flag[Amat[ii].j] == false) {
					if ((Amat[ii].j != set[0]) && (Amat[ii].aij<0.0) && (fabs(Amat[ii].aij) >= theta*max_vnediagonal)) {
						vacant = Amat[ii].j;
						for (integer js = 0; js < ic; js++) {
							if (vacant == set[js]) {
								vacant = NULL_SOSED;
							}
						}
						if (vacant != NULL_SOSED) {
							set[ic] = vacant;

							ic++;
						}
					}
				}

				//printf("sboi start");

				integer iscan = ii + 1;
				iscan = ii_back + 1; // важная модификация 19 января 2016г.

				
					// TODO 19 jan 2016.
					while ((iscan <= nnz_a[ilevel - 1] + iadd) && (Amat[iscan].i == set[0])) {
						// 14 февраля 2016 код иногда приводящий к сбою.
						//while (iscan <= row_startA[set[0] + 1] - 1) { // код иногда приводящий к сбою по непонятной причине.
						// если узел j ещё не был добавлен в агрегат.
						if (flag[Amat[iscan].j] == false) {
							if ((Amat[iscan].j != set[0]) && (Amat[iscan].aij < 0.0) && (fabs(Amat[iscan].aij) >= theta*max_vnediagonal)) {
								vacant = Amat[iscan].j;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant;

									ic++;

								}
							}
						}

						iscan++;

					} // while
				

				//printf("sboi end");
				// Это была учтена только связь i,j



				// Учёт свяи j,i
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_SOSED;
				//		}
				//	}
				//	if (vacant != NULL_SOSED) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//	}
				//}
				//}
				//}

				// Учёт связи j,i
				// Медленная версия на основе линейного поиска.
				//for (integer ii1 = 1 + iadd; ii1 <= nnz_a[ilevel - 1]; ii1++) {
				//if ((Amat[ii1].i != set[0]) && (Amat[ii1].j == set[0])) {
				//if (!flag[Amat[ii1].i]) {
				//if (fabs(Amat[ii1].aij) >= theta*max_vnediagonal) {
				//	vacant = Amat[ii1].i;
				//	for (integer js = 0; js < ic; js++) {
				//		if (vacant == set[js]) {
				//			vacant = NULL_SOSED;
				//		}
				//	}
				//	if (vacant != NULL_SOSED) {
				//		set[ic] = vacant; // j,i связь.

				//		ic++;
				//	}
				//}
				//}
				//}
				//}

				if (bji) {
					// Учёт свяи j,i
					// Более быстрая версия на основе двоичного поиска.
					integer ii1 = BinarySearchAj(Atemp, set[0], 1, nnz_a[ilevel - 1]);
					for (integer ii2 = ii1; (ii2 <= row_startA[set[0] + 1] - 1); ii2++) {
						if ((Atemp[ii2].i != set[0]) && (!flag[Atemp[ii2].i])) {
							if ((Atemp[ii2].aij<0.0)&&(fabs(Atemp[ii2].aij) >= theta*max_vnediagonal)) {
								vacant = Atemp[ii2].i;
								for (integer js = 0; js < ic; js++) {
									if (vacant == set[js]) {
										vacant = NULL_SOSED;
									}
								}
								if (vacant != NULL_SOSED) {
									set[ic] = vacant; // j,i связь.
									ic++;
								}
							}
						}
					}


				}


				for (integer isc = 1; isc < ic; isc++) {
					this_is_F_node[set[isc]] = true; // это только новые F узлы.
					bmarkervisit[set[isc]] = true;
				}




				// Помечаем узлы как включённые в агрегат.
				for (integer js = 0; js < ic; js++) {
					flag[set[js]] = true;
				}






				// Алгоритм (5 декабря 2015 revised) 
				// 1. Сканируем все F которые соседи данного С на данном проходе.
				// 2. Для каждого фиксированного F сканируем его "строчных" соседей.
				// 3. Если узел еще не был включён в агрегат то ищем всех соседей данного узла на предмет 
				// соседства с фиксированным набором F из пункта 1.



				if (bAVL) {
					// 12 декабря 2015.
					// Надо удалить из АВЛ дерева C и F узлы.
					// Это удаление очищает АВЛ дерево и приводит его к
					// рабочему состоянию. Удаление несуществующих в дереве узлов
					// производится корректно. Удаление производится за логарифмическое
					// по основанию 2  время от количества элементов в дереве
					// сбалансированность дерева при этом сохраняется.
					for (integer js = 0; js < ic; js++) {
						data_BalTree ddel;
						ddel.i = set[js];
						ddel.countsosed = count_sosed[set[js]];
						//ddel.ii = row_startA[ddel.i];
						switch (id_tree) {
						case AVL_TREE_ID: root = remove_AVL(root, ddel);
							break;
						case SPLAY_TREE_ID: root_splay = delete_splay_Tree(ddel, root_splay);
							break;
						default: root = remove_AVL(root, ddel);
							break;
						}

						if (bAVL_deb)
						{
							printf("remove\n");
						}
					}
				}


				//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) {
				//flag_shadow[i_1] = flag[i_1];
				//}



				//integer i3 = 1;
				//while ((i3 <= n_a[ilevel - 1]) && (row_startA[i3] < istart)) i3++;
				//integer i4 = n_a[ilevel - 1];
				//while ((i4 >= 1) && (row_startA[i4]>iend)) i4--;


				// Ищем только среди ближайшего окружения вновь добавленного F узла.
				//for (integer ii_2 = istart; ii_2 <= iend; ii_2++) {

				// Старая реализация которой присуща большая нагрузка на операторы new && delete.
				if (0) {
					for (integer js = 1; js < ic; js++) {

						// см. новый вариант от 10 января 2016.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						List *lsos = NULL;
						List *lsos_head = NULL;
						lsos = new List;
						lsos->prev = NULL;
						lsos_head = lsos;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_11;
							//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_11].i)) istart2--;
							//istart2++;
							istart2 = row_startA[Amat[ii_11].i];
							bool bvisitsos = false;
							for (integer is0 = istart2; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
								if (flag[Amat[is0].j] == false) {
									lsos->next = NULL;
									lsos->i = Amat[is0].j;
									lsos->ii = row_startA[lsos->i];
									// lsos->countsosed // не используется.
									List *newnodesos = new List;
									newnodesos->prev = lsos;
									lsos->next = newnodesos;
									newnodesos->next = NULL;
									lsos = lsos->next;
									newnodesos = NULL;
									bvisitsos = true;
								}
							}
							if (bvisitsos) {

								List *delsos = lsos;
								lsos = lsos->prev;
								lsos->next = NULL;
								delsos->prev = NULL;
								delete delsos;
								delsos = NULL;
							}
							else {
								// Нет ни одного соседа
								lsos_head = NULL;
								delete lsos;
								lsos = NULL;
							}
						}

						lsos = lsos_head;
						// ищем соседа узла set[js].
						//for (integer i5 = i3; i5 <= i4; i5++) {
						while (lsos != NULL) {


							//integer isc = Amat[ii_2].i;
							//integer ii_2 = row_startA[i5];
							//integer ii_2 = BinarySearchAi(Amat, i5, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//integer isc = i5;

							integer isc = lsos->i;
							integer ii_2 = lsos->ii;


							//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
							//if (flag[isc] == false) {
							//flag_shadow[isc] = true;
							integer ic2 = 0;
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart2 = ii_2;
							while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
							istart2++;
							for (integer is0 = istart2; (is0 <= iend2) && (Amat[is0].i == Amat[ii_2].i); is0++) {
								if (Amat[is0].j == set[js]) {
									ic2++;
								}
							}

							data_BalTree dsearch;
							dsearch.countsosed = count_sosed[isc];
							//dsearch.ii = ii_2;
							dsearch.i = isc;
							count_sosed[isc] += ic2;
							data_BalTree dadd;
							dadd.countsosed = count_sosed[isc];
							//dadd.ii = ii_2;
							dadd.i = isc;
							if (bmaxsosedinfoactive) {
								// Обновляем информацию о максимальном количестве соседей.
								if (count_sosed[isc] >= Maximumsosedcount) {
									Maximumsosedcount = count_sosed[isc];
								}

								// Добавляем соседа в любом случае
								// позволило существенным образом 
								// ускорить алгоритм. Если раньше 
								// old = 48595  | 21229
								// new = 433315 | 63031
								// new2 = 19434 | 3698
								// и основное время уходило на old
								// то теперь
								// old = 1449 | 1466
								// new = 472600 | 64525
								// new2= 56544 | 18431
								// Время решения 3D задачи с 1M неизвестными 
								// сократилось с 6мин 48с до 4мин 45с.

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree) {
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}


							}
							//}
							lsos = lsos->next;
						}

						// Уничтожение lsos
						// Список постепенно уничтожается с головы.
						lsos = lsos_head;
						while (lsos != NULL) {
							lsos_head = lsos_head->next;
							if (lsos_head != NULL) {
								lsos_head->prev = NULL;
							}
							lsos->next = NULL;
							delete lsos;
							lsos = lsos_head;
						}

					}
				}
				else if (0) {
					for (integer js = 1; js < ic; js++) {

						// см.ниже  новый вариант от 10 января 2016.
						// 7 января 2016.
						// Новая версия в которой я избавился от лишних оператров new&&delete.
						// Никаких дублирующих линейных списков, никаких операторов new && delete.
						// Код стал намного понятнее.

						// Строковые соседи данного F узла заносятся в список lsos с указателем на головной 
						// элемент lsos_head;
						{
							integer i_11 = set[js];
							integer ii_11 = row_startA[i_11];
							integer iend2 = nnz_a[ilevel - 1] + iadd;
							integer istart3 = ii_11;
							while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
							istart3++;
							for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;
									integer ii_2 = row_startA[isc];

									//if ((flag_shadow[isc] == false)/* && ((!bmarkervisit[isc]))*/) {
									//if (flag[isc] == false) {
									//flag_shadow[isc] = true;
									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									istart2++;
									for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									count_sosed[isc] += ic2;
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;
									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}

										// Добавляем соседа в любом случае
										// позволило существенным образом 
										// ускорить алгоритм. Если раньше 
										// old = 48595  | 21229
										// new = 433315 | 63031
										// new2 = 19434 | 3698
										// и основное время уходило на old
										// то теперь
										// old = 1449 | 1466
										// new = 472600 | 64525
										// new2= 56544 | 18431
										// Время решения 3D задачи с 1M неизвестными 
										// сократилось с 6мин 48с до 4мин 45с.

										if (bAVL) {

											// добавляем элемент в АВЛ дерево,
											// причём если элемент уже находился в дереве то он модифицируется.
											// 12 декабря 2015.
											// Добавление узла происходит за логарифмическое по основанию 2 время,
											// причём после добавления дерево остаётся сбалансированным.
											// Адельсон-Вельский и Ландис 1962.
											switch (id_tree)
											{
											case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch); break;
											case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch); break;
											default: root = insert_and_modify(root, dadd, dsearch);
												break;
											}

											if (bAVL_deb)
											{
												printf("insert and modify\n");
											}
										}


									}

								}
							}

						}
					}

				}
				else if (0) {
					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;
								integer ii_2 = row_startA[isc];

								// При таком подходе некоторые соседи инкрементируются дважды и это
								// даёт хорошую скорость агломерации. Хватает 4 кратного размера памяти под исходную матриу.
								// Количество повторно инкрементируемых узлов составило около 33% в 2D на пятиточечном шаблоне.
								// Было решено оставить этот вариант кода т.к. он даёт хорошую скорость агломерации.


								integer ic2 = 0;
								integer iend2loc = nnz_a[ilevel - 1] + iadd;
								integer istart2 = ii_2;
								while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
								istart2++;
								for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
									if (Amat[is01].j == set[js]) {
										ic2++;
									}
								}

								data_BalTree dsearch;
								dsearch.countsosed = count_sosed[isc];
								//dsearch.ii = ii_2;
								dsearch.i = isc;
								count_sosed[isc] += ic2;
								data_BalTree dadd;
								dadd.countsosed = count_sosed[isc];
								//dadd.ii = ii_2;
								dadd.i = isc;

								if (bAVL) {

									// добавляем элемент в АВЛ дерево,
									// причём если элемент уже находился в дереве то он модифицируется.
									// 12 декабря 2015.
									// Добавление узла происходит за логарифмическое по основанию 2 время,
									// причём после добавления дерево остаётся сбалансированным.
									// Адельсон-Вельский и Ландис 1962.
									switch (id_tree)
									{
									case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
										break;
									case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
										break;
									default: root = insert_and_modify(root, dadd, dsearch);
										break;
									}

									if (bAVL_deb)
									{
										printf("insert and modify\n");
									}
								}

								if (bmaxsosedinfoactive) {
									// Обновляем информацию о максимальном количестве соседей.
									if (count_sosed[isc] >= Maximumsosedcount) {
										Maximumsosedcount = count_sosed[isc];
									}
								}

							}

						}
					}
				}
				else if (1) {
					//printf("additional and modify new neighbour\n");

					// 10 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Эта модификация даёт сокращение количества V циклов которые требуются до сходимости
					// Эта модификация наиболее близка к классической описанной в литературе чем все предыдущие.
					// На момент 13 января 2016 это лучший вариаент по скорости вычислений.
					integer itop_stack2 = 0;

					// 10 января 2016. Старый вариант просто очищенный от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						//while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						//istart3++;
						istart3 = row_startA[Amat[ii_11].i];
						bool bvisitsos = false;
						for (integer is0 = istart3; (is0 <= row_startA[Amat[ii_11].i + 1] - 1); is0++) {
							//for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (flag[Amat[is0].j] == false) {


								integer isc = Amat[is0].j;

								// Избавляемся от повторных инкрементаций.
								// В 2D на пятиточечном шаблоне повторные инкрементации составляют
								// около 33%.
								// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
								// на ряде тестовых задач при таком подходе агломерация проходила очень
								// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
								// Эта проблема проявилась на задачах :
								// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
								// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
								// Проблема не в этом месте кода.
								if (hash_table2[isc] == false) {
									hash_table2[isc] = true;
									istack2[itop_stack2] = isc;
									itop_stack2++;

									integer ii_2 = row_startA[isc];


									integer ic2 = 0;
									integer iend2loc = nnz_a[ilevel - 1] + iadd;
									integer istart2 = ii_2;
									//while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
									//istart2++;
									istart2 = row_startA[Amat[ii_2].i];
									for (integer is01 = istart2; (is01 <= row_startA[Amat[ii_2].i + 1] - 1); is01++) {
										if (Amat[is01].j == set[js]) {
											ic2++;
										}
									}

									data_BalTree dsearch;
									dsearch.countsosed = count_sosed[isc];
									//dsearch.ii = ii_2;
									dsearch.i = isc;
									// Увеличиваем на количество связей с новыми F узлами.
									count_sosed[isc] += ic2;
									//if (ic2 > 0) {
									//count_sosed[isc] += 1;
									//}
									data_BalTree dadd;
									dadd.countsosed = count_sosed[isc];
									//dadd.ii = ii_2;
									dadd.i = isc;

									if (bAVL) {

										// добавляем элемент в АВЛ дерево,
										// причём если элемент уже находился в дереве то он модифицируется.
										// 12 декабря 2015.
										// Добавление узла происходит за логарифмическое по основанию 2 время,
										// причём после добавления дерево остаётся сбалансированным.
										// Адельсон-Вельский и Ландис 1962.
										switch (id_tree)
										{
										case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
											break;
										case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
											break;
										default: root = insert_and_modify(root, dadd, dsearch);
											break;
										}
										if (bAVL_deb)
										{
											printf("insert and modify\n");
										}
									}

									if (bmaxsosedinfoactive) {
										// Обновляем информацию о максимальном количестве соседей.
										if (count_sosed[isc] >= Maximumsosedcount) {
											Maximumsosedcount = count_sosed[isc];
										}
									}
								}

							}

						}
					}

					// Очистка (восстановление хеш таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				} // the end
				else {
					// 13 января 2016. Новая логика.
					// Устраним некоторые повторные модификации (это должно снизить нагрузку на АВЛ дерево).
					// Отличие в том что мы учитываем лишь Strong связи при инкрементации счётчика.
					// Это привело к 5 уровням вместо 13, и очень медленной сходимости.
					// Это было при magic=0.4
					// Strong связи при инкрементации счётчика не подходят по причине низкой производительности. 13 января 2016.
					integer itop_stack2 = 0;

					// На основе  старого варианта просто очищенного от устаревшего кода.
					for (integer js = 1; js < ic; js++) {

						integer i_11 = set[js];
						integer ii_11 = row_startA[i_11];
						integer iend2 = nnz_a[ilevel - 1] + iadd;
						integer istart3 = ii_11;
						while ((istart3 >= 1 + iadd) && (Amat[istart3].i == Amat[ii_11].i)) istart3--;
						istart3++;
						doublerealT threshold9 = -1.0;
						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if (Amat[is0].j != Amat[ii_11].i) {
								if ((Amat[is0].aij <0.0)&&(fabs(Amat[is0].aij) > threshold9)) {
									threshold9 = fabs(Amat[is0].aij);
								}
							}
						}

						for (integer is0 = istart3; (is0 <= iend2) && (Amat[is0].i == Amat[ii_11].i); is0++) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > theta*threshold9)) {
								if (flag[Amat[is0].j] == false) {


									integer isc = Amat[is0].j;

									// Избавляемся от повторных инкрементаций.
									// В 2D на пятиточечном шаблоне повторные инкрементации составляют
									// около 33%.
									// Это даёт стандартный алгоритм сгрубления описаный в статьях, но
									// на ряде тестовых задач при таком подходе агломерация проходила очень
									// плохо (переполнение по памяти, не хватало даже семикратного размера исходной матрицы).
									// Эта проблема проявилась на задачах :
									// CGHV1J006D, Потенциал тора, Электрический потенциал в FET, Module 2.
									// Плохая скорость агломерации получается главным образом из-за шестого способа интерполяции.
									// Проблема не в этом месте кода.
									if (hash_table2[isc] == false) {
										hash_table2[isc] = true;
										istack2[itop_stack2] = isc;
										itop_stack2++;

										integer ii_2 = row_startA[isc];


										integer ic2 = 0;
										integer iend2loc = nnz_a[ilevel - 1] + iadd;
										integer istart2 = ii_2;
										while ((istart2 >= 1 + iadd) && (Amat[istart2].i == Amat[ii_2].i)) istart2--;
										istart2++;
										// Определяем модуль максимального внедиагонального элемента.
										doublerealT threshold_loc1 = -1.0; // инициализация порога.
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if ((Amat[is01].aij<0.0)&&(fabs(Amat[is01].aij) > threshold_loc1)) {
													threshold_loc1 = fabs(Amat[is01].aij);
												}
											}
										}
										for (integer is01 = istart2; (is01 <= iend2loc) && (Amat[is01].i == Amat[ii_2].i); is01++) {
											// Только внедиагональные элементы.
											if (Amat[is01].j != Amat[ii_2].i) {
												if (Amat[is01].j == set[js]) {
													// только Strong связи
													// по крайней мере именно так рекомендуют в литературе.
													if ((Amat[is01].aij<0.0)&&(fabs(Amat[is01].aij) > theta*threshold_loc1)) {
														ic2++;
													}
												}
											}
										}

										if (ic2 > 0) {
											// Только если были Strong связи приводящие к инкрементации счётчика ic2.


											data_BalTree dsearch;
											dsearch.countsosed = count_sosed[isc];
											//dsearch.ii = ii_2;
											dsearch.i = isc;
											count_sosed[isc] += ic2;
											data_BalTree dadd;
											dadd.countsosed = count_sosed[isc];
											//dadd.ii = ii_2;
											dadd.i = isc;

											if (bAVL) {

												// добавляем элемент в АВЛ дерево,
												// причём если элемент уже находился в дереве то он модифицируется.
												// 12 декабря 2015.
												// Добавление узла происходит за логарифмическое по основанию 2 время,
												// причём после добавления дерево остаётся сбалансированным.
												// Адельсон-Вельский и Ландис 1962.
												switch (id_tree)
												{
												case AVL_TREE_ID: root = insert_and_modify(root, dadd, dsearch);
													break;
												case SPLAY_TREE_ID: root_splay = insert_and_modify(root_splay, dadd, dsearch);
													break;
												default: root = insert_and_modify(root, dadd, dsearch);
													break;
												}
												if (bAVL_deb)
												{
													printf("insert and modify\n");
												}
											}
										}

										if (bmaxsosedinfoactive) {
											// Обновляем информацию о максимальном количестве соседей.
											if (count_sosed[isc] >= Maximumsosedcount) {
												Maximumsosedcount = count_sosed[isc];
											}
										}
									}

								}
							}

						}
					}

					// Очистка (восстановление хеш таблицы).
					for (integer i_54 = 0; i_54 < itop_stack2; i_54++) {
						hash_table2[istack2[i_54]] = false;
					}
					itop_stack2 = 0; // стек снова готов к работе.


				}



				n_coarce++; // Увеличено количество С узлов.

				// Один агрегат создан.

			} // узел не был ещё включён в агрегат.



			bcontinue = false;
			for (integer i_1 = istartflag_scan; i_1 <= n_a[ilevel - 1]; i_1++) {
				if (flag[i_1] == false) {
					bcontinue = true;
					istartflag_scan = i_1; // сокращаем пределы сканирования.
					break; // досрочный выход из цикла for.
					//if (maxsosed == -1) {
#if doubleintprecision == 1
					//printf("ERROR!!!!  i_1=%lld\n", i_1);
#else
					//printf("ERROR!!!!  i_1=%d\n", i_1);
#endif
					
					//system("pause");
					//}
				}
			}

			// Вычисление узла с максимальным количеством соседей.
			maxsosed = -1;
			icandidate = 0;


			// TODO 6 november
			//integer isize_p = -1;
			/*
			if (0) {

			// На основе линейного поиска (медленный вариант на больших размерностях).

			const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			integer* ipool = new integer[ipool_size_limit];

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			if (i_7 < ipool_size_limit) {
			if (ipool[i_7] == icandidateq) {
			found1 = true;
			}
			}
			else {
			#if doubleintprecision == 1
				printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;
			if (isize_p < ipool_size_limit) {
			ipool[isize_p] = icandidateq;
			}
			else {
			#if doubleintprecision == 1
				printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			system("pause");
			exit(1);
			}
			}
			ii_c++;
			}
			}
			delete[] ipool;

			}
			else if (0){

			// 4 января 2016. Медленный линейный поиск заменён на обработку АВЛ дерева.

			// На основе АВЛ дерева.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			node_AVL_Gus* root_Gus = 0;

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			found1 = isfound_Gus(root_Gus, icandidateq);
			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			root_Gus = insert_Gus(root_Gus, icandidateq);

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			else {

			// 6 января 2016. Медленный линейный поиск заменён на обработку hash таблицы.

			// На основе hash таблицы.
			//const integer ipool_size_limit = 256000; // 128000
			//integer ipool[ipool_size_limit];
			//integer* ipool = new integer[ipool_size_limit];

			//node_AVL_Gus* root_Gus = 0;
			// Нельзя это вызывать это очень медленно.
			//for (integer isc = 0; isc <= nnz_a[ilevel - 1]; isc++) hash_table[isc] = false; // initialization
			integer itop = 0; // указатель на вершину стека.

			for (integer isc = 0; isc < ic; isc++) {
			integer ii_s = BinarySearchAi(Amat, set[isc], 1 + iadd, iadd + nnz_a[ilevel - 1]);
			integer ii_c = ii_s;
			//while ((ii_c >= 1 + iadd) && (Amat[ii_c].i == Amat[ii_s].i)) ii_c--;
			//ii_c++;
			while ((ii_c <= iadd + nnz_a[ilevel - 1]) && (Amat[ii_c].i == Amat[ii_s].i)) {
			integer icandidateq = ii_c;
			bool found1 = false;
			//found1 = isfound_Gus(root_Gus, icandidateq);
			found1 = hash_table[icandidateq - iadd];

			//for (integer i_7 = 0; i_7 <= isize_p; i_7++) {
			//if (i_7 < ipool_size_limit) {
			//if (ipool[i_7] == icandidateq) {
			//found1 = true;
			//}
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			//}
			// элемент в списке не обнаружен, поэтому запомним индекс.
			if (found1 == false) {
			isize_p++;

			//root_Gus = insert_Gus(root_Gus, icandidateq);
			hash_table[icandidateq - iadd] = true;
			if (itop < istack_size_limit ) {
			istack[itop] = icandidateq - iadd;
			itop++;
			}
			else {
			printf("itop>=istack_size_limit nado uvelichit istack_size_limit");
			}

			//if (isize_p < ipool_size_limit) {
			//ipool[isize_p] = icandidateq;
			//}
			//else {
			#if doubleintprecision == 1
				//printf("nado uvelichiti ipool bolee %lld, string 4118\n", ipool_size_limit);
			#else
				//printf("nado uvelichiti ipool bolee %d, string 4118\n", ipool_size_limit);
			#endif
			
			//system("pause");
			//exit(1);
			//}
			}
			ii_c++;
			}
			}
			//delete[] ipool;
			//clear_AVL_Gus(root_Gus);
			//root_Gus = 0;

			for (integer isc = itop - 1; isc >= 0; isc--) {
			hash_table[istack[isc]] = false;
			}
			itop = 0;

			// На основе сбалансированного АВЛ дерева поиска.
			}
			*/


			//	ibegining_start_index_found_maximum += isize_p + 1;

			if (bAVL) {
				if (bAVL_deb)
				{
					printf("found max");
				}
				// Данный код чрезвычайно компактен.
				bmaxsosedinfoactive = true;
				// Надо найти максимальный элемент в АВЛ дереве.
				node_AVL* emax = 0;
				Tree_splay* emax_splay = 0;
				switch (id_tree)
				{
				case AVL_TREE_ID: emax = findmax(root);
					break;
				case SPLAY_TREE_ID: emax_splay = findmax(root_splay);
					break;
				default: emax = findmax(root);
					break;
				}


				switch (id_tree) {
				case AVL_TREE_ID:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				case SPLAY_TREE_ID:
					// SPLAY tree
					if (emax_splay != 0) {


						//icandidate = emax_splay->item.ii; 23 jan 2016
						icandidate = row_startA[emax_splay->item.i];
						emax_splay = 0;

					}
					else {
						root_splay = 0;
						size_splay_Tree = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				default:
					// AVL tree
					if (emax != 0) {
						if (bAVL_deb)
						{
							print_AVL(root);
							system("pause");
						}

						//icandidate = emax->key.ii; 23 jan 2016
						icandidate = row_startA[emax->key.i];
						emax = 0;
						if (bAVL_deb)
						{
							printf("find max\n");
						}
					}
					else {
						root = 0;
						icandidate = 0;
						maxsosed = -1;
						bcontinue = false;

					}
					break;
				}




			}

#if doubleintprecision == 1
			//printf("maximum number of sosed=%lld\n",maxsosed);
#else
			//printf("maximum number of sosed=%d\n",maxsosed);
#endif
			
			if (maxsosed == -1) if (debug_reshime) system("pause");
			//getchar();

			if ((icandidate == 0) && (maxsosed == -1)) {
				bcontinue = false;
			}
			// 4 june 2016
#if doubleintprecision == 1
			//printf("icandidate=%lld, maxsosed=%lld\n",icandidate, maxsosed);
#else
			//printf("icandidate=%d, maxsosed=%d\n",icandidate, maxsosed);
#endif
			

			if (bAVL_deb)
			{
				print_AVL(root);
				system("pause");
			}

			icountprohod++;

		} // Построение C-F разбиения. создано.

		//delete[] bmarkervisit;
		free(bmarkervisit);

		if (bprint_mesage_diagnostic) {
			if (n_a[ilevel - 1] == 0)  {
				printf("n_a is zero\n");
				system("pause");
			}
			printf("additional C=%3.1f\n", (doublerealT)(100.0*newCcount / n_a[ilevel - 1]));
			//system("pause");
		}

		if (bAVL)
		{
			// Освобождение оперативной памяти из под АВЛ дерева.
			// 12 декабря 2015.
			switch (id_tree)
			{
			case AVL_TREE_ID: clear_AVL(root);
				root = 0;
				break;
			case SPLAY_TREE_ID:
				clear_SPLAY(root_splay);
				root_splay = 0;
				break;
			default: clear_AVL(root);
				root = 0;
				break;
			}

		}


		// В методе стандартной интерполяции присутствует шаг уменьшения разреженности,
		// для того чтобы правильно аппроксимировать все F переменные C переменными надо
		// увеличить количество С переменных.
		integer ipromah = 0;
		integer ipromah_one = 0;
		integer ipromah_oneF = 0;

		integer iadditionalCstatistic = 0;

		bool bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			// Построение пролонгации для узлов которые составляют F nodes.
			// Каждый F-nodes окружён C-nodes.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1] == true) {
				// Найти соседей данного F-node которые C-node.
				integer icsos = 0;
				// старая версия до 10 января 2016.
				//integer i_2 = BinarySearchAi(Amat, i_1, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// Быстрый вариант без поиска, просто индексирование на основе "хеш таблицы".
				// 10 января 2016. на основе хеширования.
				integer i_2 = row_startA[i_1];

				bool bvisit = false;
				//for (integer is0 = i_2; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[i_2].i); is0++) {
				for (integer is0 = i_2; (is0 <= row_startA[Amat[i_2].i + 1] - 1); is0++) {
					if (Amat[is0].j != Amat[i_2].i) {
						bvisit = true;
						if (this_is_C_node[Amat[is0].j] == true) {
							icsos++;
						}
						else {
							ipromah++; // подсчитываем проблемы интерполяции 
						}
					}
				}

				if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.
				// Если bvisit то внедиагональные элементы есть но они все Fnodes. Иначе там обособленное условие Дирихле.
				if ((icsos == 0) && (bvisit)) {

					// А если он F узел дирихле без соседей, то сумма тоже может быть нулевой и это вызовет деление на ноль.
					// Узлы Дирихле могли быть без соседей на начальных уровнях, они располагались в конце списка и были
					// поглощены агломератами внутренних узлов и всё было впорядке.
					// Чтобы преодолеть это затруднение нужен алгоритм с обратной связью.

					// Нет С соседей, этот узел станет С узлом.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					// F node стал C_node!!! Идея стандартной интерполяции 
					// приводит к уменьшению разреженности оператора Галёркина.
					bweSholdbeContinue = true;
					newCcount++;
				}

				

				// 1 января 2015 Один сосед это недостаточно.
				// Поэтому в случае одного соседа делаем такой узел С узлом.
				if ((false) && (icsos == 1)) {
					// bvisit и так true т.к. icsos==1.
					this_is_F_node[i_1] = false;
					this_is_C_node[i_1] = true;
					bweSholdbeContinue = true;
				}

			}

			if (bprint_mesage_diagnostic) {
				if (bweSholdbeContinue) {
					printf(" prohod succseful\n");
				}
				else {
					printf("prohod empty\n");
				}
			}

		}




		// Нужно корректно обработать узлы Дирихле,
		// Если F узел окажется узлом Дирихле без соседей то его надо сделать С узлом,
		// Но узнать такой узел можно лишь в процессе выполнения алгоритма дальше по ходу исполнения.
		// Поэтому может потребоваться вернуться и начать заново (обратная связь).

		doublerealT* problem_conservation = NULL;
		problem_conservation = new doublerealT[35 * n_a[ilevel - 1] + 1];
		if (problem_conservation == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for problem_conservation vector in my_agregat_amg5.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		for (integer i43 = 0; i43 < 35 * n_a[ilevel - 1] + 1; i43++) {
			problem_conservation[i43] = 0.0; // инициализация.
		}


		integer* C_numerate = NULL;
		//C_numerate = new integer[n_a[ilevel - 1] + 1];
		C_numerate = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(C_numerate, "C_numerate", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer icounter = 1;
		integer icount1;
		integer numberofcoarcenodes;
		doublerealT* ap_coarse = NULL;

		bweSholdbeContinue = true;
		while (bweSholdbeContinue) {
			bweSholdbeContinue = false;

			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) { n_coarce++; }
			n_coarce--;


			// debug
			// проверка качества C-F разбиения.
			//doublerealT* exp1 = new doublerealT[n_a[ilevel - 1] + 1];
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) exp1[i_1] = 0.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1]) exp1[i_1] = 2.0;
			//for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_F_node[i_1]) exp1[i_1] = 1.0;
			//exporttecplot(exp1,n);
			//delete[] exp1;

			//printf("export ready");

			//system("pause");



			// C-F разбиение построено, самое время построить оператор интерполяции.
			// потом найти оператор проекции, как транспонированный оператор интерполяции.
			// Всё завершает построение матрицы нового сеточного уровня и можно запускать новый уровень.

			// Построение оператора интерполляции : 
			// coarse 2 fine.
			//P*coarse==fine


			// Занумеруем (упорядочим) узлы грубой сетки.
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) C_numerate[i_1] = 0;
			icounter = 1;
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
#if doubleintprecision == 1
				//printf("C ind= %lld", i_1); getchar();
#else
				//printf("C ind= %d", i_1); getchar();
#endif
				
				// отмечаем какие из узлов нового уровня вложенности являются граничными.
				integer iadd42 = 0;
				for (integer i42 = 0; i42 <= ilevel - 1; i42++) iadd42 += n_a[i42];
				bamg_bound[iadd42 + icounter] = bamg_bound[i_1+iadd42-n_a[ilevel-1]];

				C_numerate[i_1] = icounter;
				icounter++;
			}




			// C_numerate - перенумерация на множестве Coarse узлов.
			// Построение пролонгации для узлов которые составляют грубую сетку.
			icount1 = 1 + iaddR; // nnz_R
			for (integer i_1 = 1; i_1 <= n_a[ilevel - 1]; i_1++) if (this_is_C_node[i_1] == true) {
				P[icount1].aij = 1.0;
				problem_conservation[icount1 - iaddR] = 1.0;
				P[icount1].i = C_numerate[i_1]; // coarse number
				P[icount1].j = i_1; // fine number.
				icount1++;

				if (icount1 >= nsizePR*n) {
					printf("memory error!!!\n");
					printf("not enough memory for the interpolation operator.\n");
					//system("PAUSE");
					//exit(1);
					deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
				}
			}

			// значение icount1 нужно далее.НЕ трогать !!!.
			numberofcoarcenodes = icount1 - 1 - iaddR;

			// Для модификации R  надо transpose(P)/ap.
			if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
				printf("countloc=%lld\n", numberofcoarcenodes);
#else
				printf("countloc=%d\n", numberofcoarcenodes);
#endif
				
				if (debug_reshime) system("pause");
			}

			//ap_coarse = new doublerealT[numberofcoarcenodes + 1];
			if (ap_coarse != NULL) {
				free(ap_coarse);
				ap_coarse = NULL;
			}
			ap_coarse = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(ap_coarse, "ap_coarse", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

			ap_coarse[0] = 0.0;




			// Для каждого С узла запоминаем в ap_coarse[C_numerate[i8]] 
			// модуль диагонального элемента.
			for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_C_node[i8] == true) {
				// Старая версия до 10 января 2016. Время O(log2(nnz))
				//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
				// 10 января 2016 новая версия на основе хеширования. Время O(1).
				integer ii1 = row_startA[i8];
				// бинарный поиск должен гарантирует нахождение самого левого представителя.
				//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
				for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
#if doubleintprecision == 1
					//printf("i=%lld j=%lld Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#else
					//printf("i=%d j=%d Amat[is0].aij=%e ", Amat[is0].i, Amat[is0].j, Amat[is0].aij);
#endif
					
					if (Amat[is0].j == Amat[ii1].i) {

						if (fabs(Amat[is0].aij) > RealMAXIMUM) {
							printf("perepolnenie error!");
							//getchar();
							system("pause");
						}
						ap_coarse[C_numerate[i8]] = fabs(Amat[is0].aij);
						//printf("find = %e", fabs(Amat[is0].aij));
					}
				}
				//printf("\n");
				//getchar();
			}

			// верно 2 октября.

			bool the_good_old_interpolation = true;

			if (the_good_old_interpolation) {

				// Старая добрая верная, проверенная интерполляция.
				// К тому же чрезвычайно простая.

				// my_amg_manager.number_interpolation_procedure == 0
				// 0
				if (my_amg_manager.number_interpolation_procedure == 0) {

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
										icsos++;
									}
								}
								else {
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {



							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {

										if (fabs(sumP) < RealZERO) {
											//printf("error interpolation zero diagonal sumP.\n");
											//printf("Fnode all sosed is F");
											//system("pause");
											//printf("i8 is Dirichlet node\n");
											this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											iadditionalCstatistic++;
											//exit(1);
											// здесь нужна непрямая интерполляция.
										}
										else {

											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
												}
											}

										}

									}
								}
							}

						}

					}
				}
				// my_amg_manager.number_interpolation_procedure == 1
				// 0
				if (my_amg_manager.number_interpolation_procedure == 1) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполляция с элементам непрямой.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.
					// Узел F имеющий одного Strong  С соседа получает свое значение из этого Strong C соседа.
					// Узел F не имеющий Strong C соседей, получает значение из Strong C соседей соседних Strong F узлов в
					// в результате сканирования списка Strong F соседей.
					// Если на встречаются два Strongly связанных F узла у которых в совокупности нет вообще ни одного Strong C соседа
					// то один из этих Strong F узлов тановится С узлом и сканирование списка сильных Strong F соседов данного узла F прекращается.
					// Потом мы повторн запускаем алгоритм построения с учётом уже добавленных С узлов.


					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						// O(log2(nnz))
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						// O(1)
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполляция.
								bool* empty_interpol = NULL;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_5", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								bool bCinsert = false;

								// Сканируем сильных F соседей данного F узла для которого надо построить интерполляцию.
								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//O(log2(nnz))
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												// O(1)
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Будем рассматривать только действительно сильных C кандидатов второго уровня.
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j] == true) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}

												
												if (bvisit_sumPloc) {
													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполляция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													bCinsert = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполлчяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубосеточных уровнях.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых уровнях сетки.

												}

												i_38_count++;

											}
										}
									}
								}

								if (!bCinsert) {
									// Ибиранее этой добавки даёт ускорение вместо 3мин 42с до 3мин 29с.

									bool bstandart_vjzov = true;
									for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
										// 3 января. На самом деле здесь хорошо бы посмотреть вариант
										// когда с не менее чем двух сторон интерполляция сработала, здесь 
										// же срабатывание было лишь с одной из сторон как минимум.
										if (empty_interpol[i_38] == true) {
											bstandart_vjzov = false;
										}
									}
									if (bstandart_vjzov) {
										this_is_F_node[i8] = false;
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
									}
								}

								free(empty_interpol);

							}



							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
												}
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}

				// my_amg_manager.number_interpolation_procedure == 2
				// 0
				if (my_amg_manager.number_interpolation_procedure == 2) {
					// Немного более экономичная по памяти. Коэффициент не превышал 3.

					// Прямая интерполляция с элементам непрямой. Экспериментальный вариант. TODO.
					// Непрямая интерполляция применяется только для F узлов которые
					// не имеют С соседей или имеют недостаточное число С соседей.
					// По идее это должно поддерживать оператор Галёркина на должном уровне разреженности.

					// Надо сохранить разреженность оператора Галёркина но при этом усилить интерполляцию.
					// Идея в том чтобы узел F имеющий лишь одного Strong С соседа обработать так чтобы у него было не менее 
					// двух  C соседей учитывая эффект непрямой интерполляции.


					ipromah = 0;
					ipromah_one = 0;
					ipromah_oneF = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}


						// 1 января 2015 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if (fabs(sumP) < RealZERO) {
								//printf("error interpolation zero diagonal sumP.\n");
								//printf("Fnode all sosed is F");
								//system("pause");
								//printf("i8 is Dirichlet node\n");

								//exit(1);
								// здесь нужна непрямая интерполляция.
								bool* empty_interpol = NULL;
								//empty_interpol = new bool[icount_StronglyF];
								empty_interpol = (bool*)malloc(icount_StronglyF*sizeof(bool));
								handle_error<bool>(empty_interpol, "empty_interpol", "classic_aglomerative_amg_5", icount_StronglyF);

								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									empty_interpol[i_38] = false; // initialization
								}

								integer i_38_count = 0;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_F_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

												integer iFpoint = Amat[is0].j;
												doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
												// сканируем всех соседей iFpointeger 
												// чтобы найти среди них С узлы.

												// Идентифицируем локальный порог.
												doublerealT maxelem_threshold_loc = -1.0;
												//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
												integer ii1_loc = row_startA[iFpoint];
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														//if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Будем рассматривать только действительно сильных С кандидатов второго уровня.
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
														//}
													}
												}


												// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

												// Найти соседей данного F-node которые C-node.
												integer icsos_loc = 0;
												bool bvisit_sumPloc = false;

												// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
												// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
												doublerealT sumP_loc = 0.0;
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {




														if (this_is_C_node[Amat[is0_loc].j] == true) {
															//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
															if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																icsos_loc++;
																bvisit_sumPloc = true;
																empty_interpol[i_38_count] = true;
															}
														}
														else {
															// Подсчитываем количество соседей которые не являются С узлами.
															//ipromah_loc++; // подсчитываем проблемы интерполяции 
														}
													}
												}


												if (bvisit_sumPloc) {
													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}
												}
												else {
													// не было С соседей интерполляция может испытывать проблемы.
													// Это означает что рядом есть два сильно связанных F узла у которых вообще нет сильных С соседей.
													// Данная проблема проявляется уже на втором уровне вложенности.
													//printf("problem situation");
													//getchar();
													this_is_F_node[iFpoint] = false;
													this_is_C_node[iFpoint] = true;
													bweSholdbeContinue = true;
													// Досрочно прервём сканирование сильных F соседей данного F узла для которого ищем интерполяцию,
													// Иначе я боюсь мы можем добавить слишком много С узлов на грубых уровнях влженности.
													break;
													// Этот шаг очень важен т.к. он сохраняет разреженность операторов на грубых урвнях сетки.
												}

												i_38_count++;

											}
										}
									}
								}

								bool bstandart_vjzov = true;
								for (integer i_38 = 0; i_38 < icount_StronglyF; i_38++) {
									// 3 января. На самом деле здесь хорошо бы посмотреть вариант
									// когда с не менее чем двух сторон интерполляция сработала, здесь 
									// же срабатывание было лишь с одной из сторон как минимум.
									if (empty_interpol[i_38] == true) {
										bstandart_vjzov = false;
									}
								}
								if (bstandart_vjzov) {
									this_is_F_node[i8] = false;
									this_is_C_node[i8] = true;
									bweSholdbeContinue = true;
									iadditionalCstatistic++;
								}

								free(empty_interpol);

							}
							else if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											// Внедиагональный элемент из множества С узлов.

											// Данная вставка должна существенно сохранять 
											// разреженность оператора Галёркина на глубоких 
											// сеточных уровнях.
											// Модификация 5 декабря 2015.
											//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												P[icount1].j = i8;
												P[icount1].i = C_numerate[Amat[is0].j];
												P[icount1].aij = fabs(Amat[is0].aij) / sumP;
												icount1++;
												if (icount1 >= nsizePR*n) {
													printf("memory error!!!\n");
													printf("not enough memory for the interpolation operator.\n");
													//system("PAUSE");
													//exit(1);
													deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
												}
											}



										}
									}
								}
							} // standart

						} // i8


					}

				}



				// my_amg_manager.number_interpolation_procedure == 3
				// 1
				// the begining
				if (my_amg_manager.number_interpolation_procedure == 3) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = 0.23; // оптимальный выбор.
					theta_strong_F = theta83; // 3 июля 2016


											  // четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					//6interpolation 0.4 6.77 11 26 28.355
					//6interpolation 0.45 6.6 10 27 28.151
					//6interpolation 0.5 6.42 12 32 28.735
					//4interpolation 0.4 3.7  52 24.736 // best
					//4interpolation 0.3 3.78 13 59 27.525
					//4interpolation 0.5 3.61 12 55 25.533
					//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij)>maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Следующий случай назван "безнадёжным".
											   // Безнадёжный случай оставляется без изменений.
											   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
											   // интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}

							


							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{
								// ДУМАТЬ.
								//if (1 || (icsos == 1)) { // 5_03_2017
									if ((icsos == 1) && (icsosF != 0)) {
										// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
										//
										//SumPall += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (this_is_C_node[Amat[is0].j] == true) {

														// 20 января 2016.
														// По-моему этой ситуации вообще быть не может так как у нас 
														// заведомо один С сосед.
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all sosed is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															byes_add = true; // Были добавления узлов.
																			 //exit(1);
																			 // здесь нужна непрямая интерполляция.
														}


													}

												}
											}
										}
									}
									else {

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (this_is_C_node[Amat[is0].j] == true) {
												if (Amat[is0].j != Amat[ii1].i) {


													// 20 jan 2016.
													// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


													if (fabs(sumP) < RealZERO) {
														// Это случай когда вообще нет сильных С соседей.


														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
																		 //exit(1);
																		 // здесь нужна непрямая интерполляция.
													}


												}
											}
										}
									}
								//}

							}


							//***



						}

					}



					if (!byes_add) {

						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						doublerealT magic = 0.4; // 0.4 optimum
												//magic = 0.3; // 3 июля 2016 для конвективных задач
												// линейный прогноз не дает улучшений
												// ни по быстрдействию ни по числу V циклов.
												//magic = 0.5 - 0.2*ilevel / 12.0;
						magic = magic82;



						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							integer istr_etalon1 = Amat[ii1].i;
							integer iend_for1 = -1;
							for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
								iend_for1 = is0;
								if (Amat[is0].j != istr_etalon1) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; is0 <= iend_for1; is0++) {
								if (Amat[is0].j != istr_etalon1) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
											   // Следующий случай назван "безнадёжным".
											   // Безнадёжный случай оставляется без изменений.
											   // К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
											   // интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.


											if (this_is_C_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															problem_conservation[icount1 - iaddR] = SumPall;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

													}
												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
														// Рассматриваем Strong F связи.

														// Смысл :
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														integer istr_etalon = Amat[ii1_loc].i;
														integer iend_for = -1;
														for (integer is0_loc = ii1_loc; (is0_loc <= row_startA[istr_etalon + 1] - 1); is0_loc++) {
															iend_for = is0_loc;
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (Amat[is0_loc].j != istr_etalon) {
																	if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (Amat[is0_loc].j != istr_etalon) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

														// В общем это двойная интерполляционная сумма 
														//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if (Amat[is0_loc].j != istr_etalon) {

																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																	//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																	if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		problem_conservation[icount1 - iaddR] = sumP_loc;
																		icount1++;
																		if (icount1 >= nsizePR*n) {
																			printf("memory error!!!\n");
																			printf("not enough memory for the interpolation operator.\n");
																			//system("PAUSE");
																			//exit(1);
																			deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																		}
																	}
																}
															}
														}


														//}
													}
												}
										}

									}
								}
								else {

									if (1 && (icsos >= 4)) {
										// 13_10_2016 Это лишнее т.к. ниже по коду эти действия уже есть. Избыточный код.

										// Очень большое количество сильных С узлов. 
										// Это нужно использовать для интерполяции.
										//if (ilevel > 3) {
										//printf("horosho :  icsos>=4\n");
										//getchar();
										//}
										doublerealT SumPall7 = 0.0;
										SumPall7 += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.


												if (this_is_C_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all sosed is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															//exit(1);
															// здесь нужна непрямая интерполляция.
														}
														else {
															// Это как раз единственная Strong C связь. 
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять 
															// разреженность оператора Галёркина на глубоких 
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
															//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
																P[icount1].j = i8;
																P[icount1].i = C_numerate[Amat[is0].j];
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																P[icount1].aij = fabs(Amat[is0].aij) / SumPall7;
																problem_conservation[icount1 - iaddR] = SumPall7;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																}
															}

														}
													}
												}
											}
										}

									}
									else {

										// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
										// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
										// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
										// bmodify_interpol4_amg = false;
										// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
										bool bmodify_interpol4_amg = false;
										doublerealT magic2 = 0.5;
										//magic2 = magic83;

										// Подготовительный этап к усилению четвертой интерполяции 
										// Усиление интерполяции происходит без добавления новых С узлов.
										// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
										// имеется конечно.
										// Подготовительный этап заключается в определении положения is0_candidate самой сильной
										// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
										doublerealT sum1 = 0.0;
										integer is0_candidate = -1;

										// Эта ветвь никогда не активна.
										if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {

											for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
												if (Amat[is0].j != Amat[ii1].i) {
													if (this_is_C_node[Amat[is0].j] == true) {
														//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
														if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
															if (fabs(Amat[is0].aij) > sum1) {
																sum1 = fabs(Amat[is0].aij);
																is0_candidate = is0;
															}
														}
													}
												}
											}

											if (sum1 / sumP < magic2) {
												// Если найденный элемент слишком слабый ничего не делаем с этим С,
												// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
												sum1 = 0.0;
												is0_candidate = -1;

												// Тогда ищем среди Weakly F узлов кандидата.
												for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
													if (Amat[is0].j != Amat[ii1].i) {
														if (this_is_F_node[Amat[is0].j] == true) {
															//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
															if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
																if (fabs(Amat[is0].aij) > sum1) {
																	sum1 = fabs(Amat[is0].aij);
																	is0_candidate = is0;
																}
															}
														}
													}
												}

#if doubleintprecision == 1
												printf("C=%lld F=%lld div=%e\n", icsos, icsosF, sum1 / sumP);
#else
												printf("C=%d F=%d div=%e\n", icsos, icsosF, sum1 / sumP);
#endif
												
												//getchar();
												system("PAUSE");
												// такой узел F должен стать новым С узлом.
												if (sum1 / sumP >= magic2) {
													printf("plosho\n");
													//getchar();
													system("PAUSE");

													this_is_F_node[i8] = false; // Этот узел  станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													byes_add = true;
													iadditionalCstatistic++;

												}
												// Обязательный сброс перед рестартом чтобы не было деления на ноль.
												sum1 = 0.0;
												is0_candidate = -1;

											}
										}


										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_C_node[Amat[is0].j] == true) {



													if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
														// Мы усиливаем силу интерполяции без добавления новых узлов за
														// счёт одной дополнительной самой сильной Weakly C связи.
														// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

														ioneStrongC_and_0_StrongF++;
														if (is0_candidate != -1) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_candidate].j];
															P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
															problem_conservation[icount1 - iaddR] = sumP + sum1;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
															problem_conservation[icount1 - iaddR] = sumP + sum1;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}
													}
													else {

														/*
														if (icsos == 1) {

														// при icsos == 1 величина icsosF всегда 0. это граничное условие наверно.
														#if doubleintprecision == 1
															printf("ilevel=%lld C=%lld F=%lld div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
														#else
															printf("ilevel=%d C=%d F=%d div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
														#endif
														
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														printf("info load\n");
														}
														getchar();
														}
														*/

														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all sosed is F");
															//system("pause");
															//printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															//exit(1);
															// здесь нужна непрямая интерполляция.
														}
														else {

															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять 
															// разреженность оператора Галёркина на глубоких 
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
															//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
																P[icount1].j = i8;
																P[icount1].i = C_numerate[Amat[is0].j];
																P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																problem_conservation[icount1 - iaddR] = sumP;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																}
															}

														}

													}

												}
											}
										}
									}
								}

							}
						}

					}

#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				// this is the end


				// my_amg_manager.number_interpolation_procedure == 7
				// 1
				// the begining
				if (my_amg_manager.number_interpolation_procedure == 7) {
					//theta = 0.24;
					// theta_strong_F iter_number time,s
					// 0.21 56 22.63
					// 0.22 55 21.769
					// 0.23 52 21.488
					// 0.24 52 21.741 == theta // optimum
					// 0.26 69 24.623
					doublerealT theta_strong_F = 0.23; // оптимальный выбор.
					theta_strong_F = theta83; // 3 июля 2016


					// четвёртая версия интерполяции.
					integer ioneStrongC_and_0_StrongF = 0;

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					//6interpolation 0.4 6.77 11 26 28.355
					//6interpolation 0.45 6.6 10 27 28.151
					//6interpolation 0.5 6.42 12 32 28.735
					//4interpolation 0.4 3.7  52 24.736 // best
					//4interpolation 0.3 3.78 13 59 27.525
					//4interpolation 0.5 3.61 12 55 25.533
					//4interpolation 0.45 3.65 10 63 30.24

					bool byes_add = false;
					// Быстрое добавление недостающих С узлов.
					if (1) {
						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						//doublerealT magic = 0.4; // 0.4 optimum


						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							//pc - positive connections.
							doublerealT maxelem_thresholdpc = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_thresholdpc)) {
										maxelem_thresholdpc = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij)>maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}

							// Найти соседей данного F-node которые C-node.
							integer icsos_pc = 0;
							integer icsosF_pc = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP_pc = 0.0;
							doublerealT SumPall_pc = 0.0;
							integer icount_StronglyF_pc = 0;
							doublerealT maxelem_threshold_theta_pc = maxelem_thresholdpc*theta;
							doublerealT maxelem_threshold_theta_strong_F_pc = maxelem_thresholdpc*theta_strong_F;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_thresholdpc*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_thresholdpc*theta) {
										if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij)>maxelem_threshold_theta_pc)) {
											sumP_pc += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos_pc++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_thresholdpc*theta_strong_F) {
											if ((Amat[is0].aij>0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F_pc)) {
												SumPall_pc += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF_pc++;
												icsosF_pc++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							{
								// ДУМАТЬ.
								if (1||(icsos == 1)) { // 5_03_2017
									if ((icsos == 1) && (icsosF != 0)) {
										// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
										//
										//SumPall += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij < 0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (this_is_C_node[Amat[is0].j] == true) {

														// 20 января 2016.
														// По-моему этой ситуации вообще быть не может так как у нас 
														// заведомо один С сосед.
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all sosed is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															byes_add = true; // Были добавления узлов.
															//exit(1);
															// здесь нужна непрямая интерполляция.
														}


													}

												}
											}
										}
									}
									else {

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (this_is_C_node[Amat[is0].j] == true) {
												if (Amat[is0].j != Amat[ii1].i) {


													// 20 jan 2016.
													// Можно не добавлять узел в случае если есть не менее трёх сильных F соседей.


													if (fabs(sumP) < RealZERO) {
														// Это случай когда вообще нет сильных С соседей.


														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														byes_add = true; // Были добавления узлов.
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}


												}
											}
										}
									}
								}

							}


							//***



						}

					}



					if (!byes_add) {

						// с параметром 0.4 четвертая интерполяция обгоняет более сильную шестую.
						doublerealT magic = 0.4; // 0.4 optimum
						//magic = 0.3; // 3 июля 2016 для конвективных задач
						// линейный прогноз не дает улучшений
						// ни по быстрдействию ни по числу V циклов.
						//magic = 0.5 - 0.2*ilevel / 12.0;
						magic = magic82;



						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							integer istr_etalon1 = Amat[ii1].i;
							integer iend_for1 = -1;
							for (integer is0 = ii1; (is0 <= row_startA[istr_etalon1 + 1] - 1); is0++) {
								iend_for1 = is0;
								if (Amat[is0].j != istr_etalon1) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							doublerealT maxelem_threshold_theta = maxelem_threshold*theta;
							doublerealT maxelem_threshold_theta_strong_F = maxelem_threshold*theta_strong_F;


							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							//	for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							for (integer is0 = ii1; is0 <= iend_for1; is0++) {
								if (Amat[is0].j != istr_etalon1) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if (((icsos == 1) || (icsos == 2) || (icsos == 3)) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.


											if (this_is_C_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
														if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															problem_conservation[icount1 - iaddR] = SumPall;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

													}
												}

											}
											else
											if (this_is_F_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta_strong_F)) {
													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta_strong_F) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													integer istr_etalon = Amat[ii1_loc].i;
													integer iend_for = -1;
													for (integer is0_loc = ii1_loc; (is0_loc <= row_startA[istr_etalon + 1] - 1); is0_loc++) {
														iend_for = is0_loc;
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															if (Amat[is0_loc].j != istr_etalon) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}

													doublerealT maxelem_threshold_loc_magic = maxelem_threshold_loc*magic;
													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
														if (Amat[is0_loc].j != istr_etalon) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													doublerealT maxelem_threshold_loc_magic_minus = -maxelem_threshold_loc_magic;

													// В общем это двойная интерполляционная сумма 
													//for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													for (integer is0_loc = ii1_loc; is0_loc <= iend_for; is0_loc++) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															if (Amat[is0_loc].j != istr_etalon) {

																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic) {
																//if ((Amat[is0_loc].aij<maxelem_threshold_loc_magic_minus) || (Amat[is0_loc].aij>maxelem_threshold_loc_magic)) {
																if ((Amat[is0_loc].aij<0.0) && (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc_magic)) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	problem_conservation[icount1 - iaddR] = sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
											}
										}

									}
								}
								else {

									if (1&&(icsos >= 4)) {
										// 13_10_2016 Это лишнее т.к. ниже по коду эти действия уже есть. Избыточный код.

										// Очень большое количество сильных С узлов. 
										// Это нужно использовать для интерполяции.
										//if (ilevel > 3) {
											//printf("horosho :  icsos>=4\n");
											//getchar();
										//}
										doublerealT SumPall7 = 0.0;
										SumPall7 += sumP;

										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												// Нас интересуют только Strong связи.


												if (this_is_C_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														if (fabs(sumP) < RealZERO) {
															//printf("error interpolation zero diagonal sumP.\n");
															//printf("Fnode all sosed is F");
															//system("pause");
															//	printf("i8 is Dirichlet node\n");
															this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
															this_is_C_node[i8] = true;
															bweSholdbeContinue = true;
															iadditionalCstatistic++;
															//exit(1);
															// здесь нужна непрямая интерполляция.
														}
														else {
															// Это как раз единственная Strong C связь. 
															// Внедиагональный элемент из множества С узлов.

															// Данная вставка должна существенно сохранять 
															// разреженность оператора Галёркина на глубоких 
															// сеточных уровнях.
															// Модификация 5 декабря 2015.
															//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
															//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
															if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
																P[icount1].j = i8;
																P[icount1].i = C_numerate[Amat[is0].j];
																//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																P[icount1].aij = fabs(Amat[is0].aij) / SumPall7;
																problem_conservation[icount1 - iaddR] = SumPall7;
																icount1++;
																if (icount1 >= nsizePR*n) {
																	printf("memory error!!!\n");
																	printf("not enough memory for the interpolation operator.\n");
																	//system("PAUSE");
																	//exit(1);
																	deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																}
															}

														}
													}
												}
											}
										}

								}
								else {

								// Параметр bmodify_interpol4_amg==true при magic2<0.24 приводит к катострофическому ухудшению
								// скорости сходимости. При включенной модификации же bmodify_interpol4_amg==true и magic2>=0.24 
								// никакого влияния на иерархию сеток не оказывается сходимость такая же хорошая как и при 
								// bmodify_interpol4_amg = false;
								// 22 01 2016 нужно оставить bmodify_interpol4_amg = false; и ни в коем случае не менять.
								bool bmodify_interpol4_amg = false;
								doublerealT magic2 = 0.5;
								//magic2 = magic83;

								// Подготовительный этап к усилению четвертой интерполяции 
								// Усиление интерполяции происходит без добавления новых С узлов.
								// Мы усиливаем интерполяцию за счёт наиболее сильной Weakly C связи если таковая
								// имеется конечно.
								// Подготовительный этап заключается в определении положения is0_candidate самой сильной
								// Weakly C связи и модуля её матричного коэффициента который запомниться в sum1.
								doublerealT sum1 = 0.0;
								integer is0_candidate = -1;

								// Эта ветвь никогда не активна.
								if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {

									for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											if (this_is_C_node[Amat[is0].j] == true) {
												//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
												if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
													if (fabs(Amat[is0].aij) > sum1) {
														sum1 = fabs(Amat[is0].aij);
														is0_candidate = is0;
													}
												}
											}
										}
									}

									if (sum1 / sumP < magic2) {
										// Если найденный элемент слишком слабый ничего не делаем с этим С,
										// а ищем самого сильного Weakly F кандидата чтобы сделать его C кандидатом.
										sum1 = 0.0;
										is0_candidate = -1;

										// Тогда ищем среди Weakly F узлов кандидата.
										for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
											if (Amat[is0].j != Amat[ii1].i) {
												if (this_is_F_node[Amat[is0].j] == true) {
													//if (fabs(Amat[is0].aij) <= maxelem_threshold*theta) {
													if ((Amat[is0].aij > 0.0) || (fabs(Amat[is0].aij) <= maxelem_threshold_theta)) {
														if (fabs(Amat[is0].aij) > sum1) {
															sum1 = fabs(Amat[is0].aij);
															is0_candidate = is0;
														}
													}
												}
											}
										}

#if doubleintprecision == 1
										printf("C=%lld F=%lld div=%e\n", icsos, icsosF, sum1 / sumP);
#else
										printf("C=%d F=%d div=%e\n", icsos, icsosF, sum1 / sumP);
#endif
										
										//getchar();
										system("PAUSE");
										// такой узел F должен стать новым С узлом.
										if (sum1 / sumP >= magic2) {
											printf("plosho\n");
											//getchar();
											system("PAUSE");

											this_is_F_node[i8] = false; // Этот узел  станет С нодом.
											this_is_C_node[i8] = true;
											bweSholdbeContinue = true;
											byes_add = true;
											iadditionalCstatistic++;

										}
										// Обязательный сброс перед рестартом чтобы не было деления на ноль.
										sum1 = 0.0;
										is0_candidate = -1;

									}
								}


								for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										if (this_is_C_node[Amat[is0].j] == true) {



											if (bmodify_interpol4_amg && ((icsos == 1) && (icsosF == 0))) {
												// Мы усиливаем силу интерполяции без добавления новых узлов за
												// счёт одной дополнительной самой сильной Weakly C связи.
												// Самая сильная Weakly C связь имеет параметры sum1 и is0_candidate.

												ioneStrongC_and_0_StrongF++;
												if (is0_candidate != -1) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0_candidate].j];
													P[icount1].aij = fabs(Amat[is0_candidate].aij) / (sumP + sum1);
													problem_conservation[icount1 - iaddR] = sumP + sum1;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
													}
												}

												//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
												if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0].j];
													P[icount1].aij = fabs(Amat[is0].aij) / (sumP + sum1);
													problem_conservation[icount1 - iaddR] = sumP + sum1;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
													}
												}
											}
											else {

												/*
												if (icsos == 1) {

													// при icsos == 1 величина icsosF всегда 0. это граничное условие наверно.
													#if doubleintprecision == 1
														printf("ilevel=%lld C=%lld F=%lld div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
													#else
														printf("ilevel=%d C=%d F=%d div=%e\n", ilevel, icsos, icsosF, sum1 / sumP);
													#endif
													
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														printf("info load\n");
													}
													getchar();
												}
												*/

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													//	if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {
													if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold_theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														problem_conservation[icount1 - iaddR] = sumP;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}

										}
									}
								}
							}
								}

							}
						}

					}

#if doubleintprecision == 1
					//printf("one Strong C and 0 Strong F=%lld additional all %lld", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#else
					//printf("one Strong C and 0 Strong F=%d additional all %d", ioneStrongC_and_0_StrongF, iadditionalCstatistic);
#endif
					
					//system("pause");
				}
				// this is the end

				
				if (0) {
					// делаем как рекомендовал Falgout
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						
						//for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.
						//theta = 0.24;
						doublerealT znamenatel = 0.0;
						for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > theta*maxelem_threshold)) {
									// Strong connections
								}
								else {
									// Weakly connections
									znamenatel += Amat[is0].aij;
								}

							}
							else {
								// диагональный элемент.
								znamenatel += Amat[is0].aij;
							}
						}

						if (fabs(znamenatel) > 1.0e-30) {

							znamenatel = fabs(znamenatel);

							// Сумма всех Strong F соседей узла i8.
							doublerealT sumapF = 0.0;
							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j]) {
										if ((Amat[is0].aij<0.0) && (fabs(Amat[is0].aij) > theta*maxelem_threshold)) {
											// Strong connections
											sumapF += Amat[is0].aij;
										}
									}
								}
							}

							for (integer is0 = ii1; (is0 <= row_startA[Amat[ii1].i + 1] - 1); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j]) {
										doublerealT wij = Amat[is0].aij;

										if (fabs(sumapF) > 1.0e-30) {
											// Перебираем всех Strong F соседей узла i.
											for (integer is0l = ii1; (is0l <= row_startA[Amat[ii1].i + 1] - 1); is0l++) {
												if (Amat[is0l].j != Amat[ii1].i) {
													if (this_is_F_node[Amat[is0l].j]) {
														if ((Amat[is0l].aij<0.0) && (fabs(Amat[is0l].aij) > theta*maxelem_threshold)) {
															// Strong connections
															// Текущий Strong F сосед.
															integer i9 = Amat[is0l].j;
															// Есть ли среди его соседей узел Amat[is0].j
															integer ii6 = row_startA[i9];
															doublerealT maxelm_threshold_magic = -1.0e40;
															for (integer is0s = ii6; (is0s <= row_startA[Amat[ii6].i + 1] - 1); is0s++) {
																if (Amat[is0s].j != Amat[ii6].i) {
																	if ((Amat[is0s].aij<0.0) && (fabs(Amat[is0s].aij)>maxelm_threshold_magic)) {
																		maxelm_threshold_magic = fabs(Amat[is0s].aij);
																	}
																}
															}

															for (integer is0s = ii6; (is0s <= row_startA[Amat[ii6].i + 1] - 1); is0s++) {
																if (Amat[is0s].j != Amat[ii6].i) {
																	if (Amat[is0s].j == Amat[is0].j) {
																		// Найдено.
																		if ((Amat[is0s].aij<0.0) && (fabs(Amat[is0s].aij) > 0.35*maxelm_threshold_magic)) {
																			// Теперь точно найдено.
																		     wij += (Amat[is0s].aij / sumapF)*Amat[is0l].aij;
																		}
																	}
																}
															}
														}
													}
												}
											}
										}
										P[icount1].j = i8;
										P[icount1].i = C_numerate[Amat[is0].j];
										P[icount1].aij = -wij / znamenatel; // именно минус не забываем.
										problem_conservation[icount1 - iaddR] = znamenatel;
										icount1++;
										if (icount1 >= nsizePR*n) {
											printf("memory error!!!\n");
											printf("not enough memory for the interpolation operator.\n");
											//system("PAUSE");
											//exit(1);
											deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
										}

									}
								}
							}
						}
						else {
							printf("zero  znamenatel in Falgout = %e\n", znamenatel);
							//getchar();
							system("PAUSE");
							exit(1);
						}
						if (znamenatel < 0.0) {
							printf("negative  znamenatel in Falgout = %e\n", znamenatel);
						}

					}
				}

				//my_amg_manager.number_interpolation_procedure == 4
				// 0
				if (my_amg_manager.number_interpolation_procedure == 4) {
					// пятая попытка.
					// показывает время 1.22 против времени в 1.36 в четвертой попытке.

					// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
					// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
					// сильных F узлов.

					ipromah = 0;
					ipromah_one = 0;
					// Построение пролонгации для узлов которые составляют F nodes.
					// Каждый F-nodes окружён C-nodes.
					for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

						// Нам нужен разреженный оператор Галёркина.
						// 5 декабря 2015 года мы попробуем увеличить разреженность
						// оператора интерполляции а значит и оператора Галёркина.
						doublerealT maxelem_threshold = -1.0;
						//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
						integer ii1 = row_startA[i8];
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
								//if (this_is_C_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
									maxelem_threshold = fabs(Amat[is0].aij);
								}
								//}
							}
						}
						// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

						// Найти соседей данного F-node которые C-node.
						integer icsos = 0;
						integer icsosF = 0;

						// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
						// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
						doublerealT sumP = 0.0;
						doublerealT SumPall = 0.0;
						integer icount_StronglyF = 0;
						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {
									//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
										sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
										icsos++;
									}
								}
								else {
									if (this_is_F_node[Amat[is0].j] == true) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
											icount_StronglyF++;
											icsosF++;
										}
									}
									// Подсчитываем количество соседей которые не являются С узлами.
									ipromah++; // подсчитываем проблемы интерполяции 
								}
							}
						}
						if (icsos == 1) {
							ipromah_one++; // количество F узлов с одним единственным С соседом.
							// Следующий случай назван "безнадёжным".
							// Безнадёжный случай оставляется без изменений.
							// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
							// интерполляцию на этих уровнях можно улучшить.
							if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
						}



						// 1 января 2016 Один сосед это недостаточно.
						// Поэтому в случае одного соседа делаем такой узел С узлом.
						if ((false) && (icsos == 1)) {
							this_is_F_node[i8] = false;
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
						}
						else {

							if ((icsos == 1) && (icsosF != 0)) {
								// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
								//
								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {
										// Нас интересуют только Strong связи.
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//	printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {
													// Это как раз единственная Strong C связь. 
													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.

													// Смысл :
													// 



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpointeger 
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции 
															}
														}
													}

													// В общем это двойная интерполляционная сумма 
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять 
																// разреженность оператора Галёркина на глубоких 
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
										}
									}
								}
							}
							else {

								SumPall += sumP;

								for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
									if (Amat[is0].j != Amat[ii1].i) {

										if (this_is_C_node[Amat[is0].j] == true) {

											if (fabs(sumP) < RealZERO) {
												//printf("error interpolation zero diagonal sumP.\n");
												//printf("Fnode all sosed is F");
												//system("pause");
												//printf("i8 is Dirichlet node\n");
												this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
												this_is_C_node[i8] = true;
												bweSholdbeContinue = true;
												iadditionalCstatistic++;
												//exit(1);
												// здесь нужна непрямая интерполляция.
											}
											else {

												// Внедиагональный элемент из множества С узлов.

												// Данная вставка должна существенно сохранять 
												// разреженность оператора Галёркина на глубоких 
												// сеточных уровнях.
												// Модификация 5 декабря 2015.
												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
													P[icount1].j = i8;
													P[icount1].i = C_numerate[Amat[is0].j];
													P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
													//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
													icount1++;
													if (icount1 >= nsizePR*n) {
														printf("memory error!!!\n");
														printf("not enough memory for the interpolation operator.\n");
														//system("PAUSE");
														//exit(1);
														deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
													}
												}

											}

										}
										else
											if (this_is_F_node[Amat[is0].j] == true) {

												// Рассматриваем Strong F связи.
												// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
												// Смысл :
												//



												//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
												// Это лишнее условие, ранее уже было проверено что мы имеем дело
												// с сильной F связью.
												if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

													integer iFpoint = Amat[is0].j;
													doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
													// сканируем всех соседей iFpoint
													// чтобы найти среди них С узлы.

													// Идентифицируем локальный порог.
													doublerealT maxelem_threshold_loc = -1.0;
													//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
													integer ii1_loc = row_startA[iFpoint];
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																	maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																}
															}
														}
													}


													// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

													// Найти соседей данного F-node которые C-node.
													integer icsos_loc = 0;

													// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
													// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
													doublerealT sumP_loc = 0.0;
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {




															if (this_is_C_node[Amat[is0_loc].j] == true) {
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																	icsos_loc++;
																}
															}
															else {
																// Подсчитываем количество соседей которые не являются С узлами.
																//ipromah_loc++; // подсчитываем проблемы интерполяции
															}
														}
													}

													// В общем это двойная интерполляционная сумма
													for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
														if (Amat[is0_loc].j != Amat[ii1_loc].i) {
															if (this_is_C_node[Amat[is0_loc].j] == true) {
																// Внедиагональный элемент из множества С узлов.

																// Данная вставка должна существенно сохранять
																// разреженность оператора Галёркина на глубоких
																// сеточных уровнях.
																// Модификация 5 декабря 2015.
																//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
																	P[icount1].j = i8;
																	P[icount1].i = C_numerate[Amat[is0_loc].j];
																	//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																	P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																	icount1++;
																	if (icount1 >= nsizePR*n) {
																		printf("memory error!!!\n");
																		printf("not enough memory for the interpolation operator.\n");
																		//system("PAUSE");
																		//exit(1);
																		deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																	}
																}
															}
														}
													}


													//}
												}
											}


									}
								}
							}

						}

					}
				}


				// my_amg_manager.number_interpolation_procedure == 5
				// 0
				if (my_amg_manager.number_interpolation_procedure == 5) {

					bool byes_add = false;
					//  быстрая проверка на добавление.
					if (1) {
						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							 {

								 if ((icsos == 1) && (icsosF != 0)) {
									 // Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									 //
									 SumPall += sumP;

									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {
											 // Нас интересуют только Strong связи.
											 if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												 if (this_is_C_node[Amat[is0].j] == true) {

													 if (fabs(sumP) < RealZERO) {
														 //printf("error interpolation zero diagonal sumP.\n");
														 //printf("Fnode all sosed is F");
														 //system("pause");
														 //	printf("i8 is Dirichlet node\n");
														 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														 this_is_C_node[i8] = true;
														 bweSholdbeContinue = true;
														 iadditionalCstatistic++;
														 byes_add = true;
														 //exit(1);
														 // здесь нужна непрямая интерполляция.
													 }


												 }

											 }
										 }
									 }
								 }
								 else {



									 for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										 if (Amat[is0].j != Amat[ii1].i) {

											 if (this_is_C_node[Amat[is0].j] == true) {

												 if (fabs(sumP) < RealZERO) {
													 //printf("error interpolation zero diagonal sumP.\n");
													 //printf("Fnode all sosed is F");
													 //system("pause");
													 //printf("i8 is Dirichlet node\n");
													 this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													 this_is_C_node[i8] = true;
													 bweSholdbeContinue = true;
													 iadditionalCstatistic++;
													 byes_add = true;
													 //exit(1);
													 // здесь нужна непрямая интерполляция.
												 }


											 }



										 }
									 }



								 }

							 }

						}
					}


					// Проверка на добавление пройдена успешно, 
					// добавлений не было и можно интерполировать !!!.
					if (byes_add == false) {

						// шестая попытка.
						// CGHV1J amg1r5 time 0.26
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25   0:48  29  6.55A
						// 0.3    0:45  28  6.19A 
						// 0.35  0:43   28  5.98A
						// 0.4   0:41   27  5.77A // отыграно 14% производительности.
						// tgf2023_10 amg1r5 time 1:00
						// cl_agl_amg_v0_14 time
						// magic  time number V cycles grid complexity
						// 0.25 1:49 27 3.61
						// 0.3 1:47 26 3.47
						// 0.35 1:46 27 3.51
						// 0.4 1:44 28 3.413 // отыграно 5% производительности.
						// Electric potencial in FET2 amg1r5 time 1:38
						// cl_agl_amg_v0_14 time :
						// magic  time number V cycles grid complexity
						// 0.25 3:19 36 6.65
						// 0.3 3:02 34 6.34
						// 0.35 2:52 33 6.091
						// 0.4 2:46 33 5.91 // отыграно 20% производительности.

						// magic=0.4 is optimum.11 jan 2016
						doublerealT magic = 0.4; // 0.4

						// Здесь узел F не имеющий Strong С соседей сам становится С узлом.
						// Узел F имеющий одного Strong  С соседа обрабатывается с помощью сильных С соседей 
						// сильных F узлов.

						ipromah = 0;
						ipromah_one = 0;
						// Построение пролонгации для узлов которые составляют F nodes.
						// Каждый F-nodes окружён C-nodes.
						for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

							// Нам нужен разреженный оператор Галёркина.
							// 5 декабря 2015 года мы попробуем увеличить разреженность
							// оператора интерполляции а значит и оператора Галёркина.
							doublerealT maxelem_threshold = -1.0;
							//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
							integer ii1 = row_startA[i8];
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
									//if (this_is_C_node[Amat[is0].j] == true) {
									if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
										maxelem_threshold = fabs(Amat[is0].aij);
									}
									//}
								}
							}
							// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

							// Найти соседей данного F-node которые C-node.
							integer icsos = 0;
							integer icsosF = 0;

							// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
							// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
							doublerealT sumP = 0.0;
							doublerealT SumPall = 0.0;
							integer icount_StronglyF = 0;
							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										//	if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly С узлам.
											icsos++;
										}
									}
									else {
										if (this_is_F_node[Amat[is0].j] == true) {
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												SumPall += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат Strongly F узлам.
												icount_StronglyF++;
												icsosF++;
											}
										}
										// Подсчитываем количество соседей которые не являются С узлами.
										ipromah++; // подсчитываем проблемы интерполяции 
									}
								}
							}
							if (icsos == 1) {
								ipromah_one++; // количество F узлов с одним единственным С соседом.
								// Следующий случай назван "безнадёжным".
								// Безнадёжный случай оставляется без изменений.
								// К счастью на глубоких уровнях сетки безнадёжный случай составляет лишь небольшой процент и 
								// интерполляцию на этих уровнях можно улучшить.
								if (icsosF == 0) ipromah_oneF++; // Количество F узлов с одним единственным C соседом и к тому-же не имеющих сильных F соседов.
							}



							// 1 января 2016 Один сосед это недостаточно.
							// Поэтому в случае одного соседа делаем такой узел С узлом.
							if ((false) && (icsos == 1)) {
								this_is_F_node[i8] = false;
								this_is_C_node[i8] = true;
								bweSholdbeContinue = true;
							}
							else {

								if ((icsos == 1) && (icsosF != 0)) {
									// Случай одного Strong C соседа в добавок к которому есть покрайней мере один Strong F сосед.
									//
									SumPall += sumP;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {
											// Нас интересуют только Strong связи.
											if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
												if (this_is_C_node[Amat[is0].j] == true) {

													if (fabs(sumP) < RealZERO) {
														//printf("error interpolation zero diagonal sumP.\n");
														//printf("Fnode all sosed is F");
														//system("pause");
														//	printf("i8 is Dirichlet node\n");
														this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
														this_is_C_node[i8] = true;
														bweSholdbeContinue = true;
														iadditionalCstatistic++;
														//exit(1);
														// здесь нужна непрямая интерполляция.
													}
													else {
														// Это как раз единственная Strong C связь. 
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}

													}

												}
												else
													if (this_is_F_node[Amat[is0].j] == true) {

														// Рассматриваем Strong F связи.

														// Смысл :
														// 



														//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
														// Это лишнее условие, ранее уже было проверено что мы имеем дело
														// с сильной F связью.
														//if (fabs(Amat[is0].aij) > maxelem_threshold*theta) {

														integer iFpoint = Amat[is0].j;
														doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														// сканируем всех соседей iFpointeger 
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции 
																}
															}
														}

														// В общем это двойная интерполляционная сумма 
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	// Внедиагональный элемент из множества С узлов.

																	// Данная вставка должна существенно сохранять 
																	// разреженность оператора Галёркина на глубоких 
																	// сеточных уровнях.
																	// Модификация 5 декабря 2015.
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		P[icount1].j = i8;
																		P[icount1].i = C_numerate[Amat[is0_loc].j];
																		//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																		P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
																		icount1++;
																		if (icount1 >= nsizePR*n) {
																			printf("memory error!!!\n");
																			printf("not enough memory for the interpolation operator.\n");
																			//system("PAUSE");
																			//exit(1);
																			deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																		}
																	}
																}
															}
														}


														//}
													}
											}
										}
									}
								}
								else {

									SumPall += sumP;
									doublerealT sum_ok = 0.0;
									bool bbackreturn = false;
									integer icount1_mem = icount1;
									bool* bbackrarr = NULL;
									//bbackrarr = new bool[icount_StronglyF];
									bbackrarr = (bool*)malloc(icount_StronglyF*sizeof(bool));
									handle_error<bool>(bbackrarr, "bbackrarr", "classic_aglomerative_amg_5", icount_StronglyF);

									for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
										bbackrarr[i_63] = false;
									}
									integer icounter_bbackarr = -1;

									for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
										if (Amat[is0].j != Amat[ii1].i) {

											if (this_is_C_node[Amat[is0].j] == true) {

												if (fabs(sumP) < RealZERO) {
													//printf("error interpolation zero diagonal sumP.\n");
													//printf("Fnode all sosed is F");
													//system("pause");
													//printf("i8 is Dirichlet node\n");
													this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
													this_is_C_node[i8] = true;
													bweSholdbeContinue = true;
													iadditionalCstatistic++;
													//exit(1);
													// здесь нужна непрямая интерполляция.
												}
												else {

													// Внедиагональный элемент из множества С узлов.

													// Данная вставка должна существенно сохранять 
													// разреженность оператора Галёркина на глубоких 
													// сеточных уровнях.
													// Модификация 5 декабря 2015.
													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
														P[icount1].j = i8;
														P[icount1].i = C_numerate[Amat[is0].j];
														//P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
														P[icount1].aij = fabs(Amat[is0].aij);
														sum_ok += fabs(Amat[is0].aij);
														//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
														icount1++;
														if (icount1 >= nsizePR*n) {
															printf("memory error!!!\n");
															printf("not enough memory for the interpolation operator.\n");
															//system("PAUSE");
															//exit(1);
															deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
														}
													}

												}

											}
											else
												if (this_is_F_node[Amat[is0].j] == true) {

													// Рассматриваем Strong F связи.
													// Мы дополнительно усиливаем Strong C интерполяцию за счёт неявной Strong F интерполяции.
													// Смысл :
													//



													//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
													// Это лишнее условие, ранее уже было проверено что мы имеем дело
													// с сильной F связью.
													if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

														icounter_bbackarr++;

														integer iFpoint = Amat[is0].j;
														//doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
														doublerealT mult1 = fabs(Amat[is0].aij);
														// сканируем всех соседей iFpoint
														// чтобы найти среди них С узлы.

														// Идентифицируем локальный порог.
														doublerealT maxelem_threshold_loc = -1.0;
														//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
														integer ii1_loc = row_startA[iFpoint];
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
																		maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
																	}
																}
															}
														}


														// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

														// Найти соседей данного F-node которые C-node.
														integer icsos_loc = 0;

														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														icsos_loc = 0;
														// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
														// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
														doublerealT sumP_loc1 = 0.0;
														for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
															if (Amat[is0_loc].j != Amat[ii1_loc].i) {




																if (this_is_C_node[Amat[is0_loc].j] == true) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																	//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																	if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																		//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc)>maxelem_threshold*theta) {
																		sumP_loc1 += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
																		icsos_loc++;
																		//	}
																	}
																}
																else {
																	// Подсчитываем количество соседей которые не являются С узлами.
																	//ipromah_loc++; // подсчитываем проблемы интерполяции
																}
															}
														}

														if (icsos_loc > 0) {
															// В общем это двойная интерполляционная сумма
															for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
																if (Amat[is0_loc].j != Amat[ii1_loc].i) {
																	if (this_is_C_node[Amat[is0_loc].j] == true) {
																		// Внедиагональный элемент из множества С узлов.

																		// Данная вставка должна существенно сохранять
																		// разреженность оператора Галёркина на глубоких
																		// сеточных уровнях.
																		// Модификация 5 декабря 2015.
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
																		//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta) {
																		if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*magic)) {
																			//	if ((mult1*fabs(Amat[is0_loc].aij) / sumP_loc) > maxelem_threshold*theta) {
																			P[icount1].j = i8;
																			P[icount1].i = C_numerate[Amat[is0_loc].j];
																			//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
																			//P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			P[icount1].aij = mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			sum_ok += mult1*fabs(Amat[is0_loc].aij) / sumP_loc1;
																			icount1++;
																			if (icount1 >= nsizePR*n) {
																				printf("memory error!!!\n");
																				printf("not enough memory for the interpolation operator.\n");
																				//system("PAUSE");
																				//exit(1);
																				deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
																			}
																		}
																		//}
																	}
																}
															}
														}
														else {
															//bbackreturn = true;
															bbackrarr[icounter_bbackarr] = true;
														}


														//}
													}
												}


										}
									}


									//bbackreturn = true;
									//for (integer i_63 = 0; i_63 < icount_StronglyF; i_63++) {
									//if (!bbackrarr[i_63]) {
									//	bbackreturn = false;
									//}
									//}

									//if (bbackreturn) {
									// сильные F связи не дали результата, поэтому мы возвращаемся к исходному 
									// варианту интерполяции.
									//for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
									//P[i_95].aij = P[i_95].aij*SumPall / sumP;
									//}
									//}

									// Апосториорная корекция
									for (integer i_95 = icount1_mem; i_95 < icount1; i_95++) {
										P[i_95].aij = P[i_95].aij / sum_ok;
									}

									free(bbackrarr);

								}

							}

						}
					}

				}

			}
			else if (true) {


				// Экспериментальная интерполляция 1 января 2016.

				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполляции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Наверно разумно что threshold определён по всей строке, а не только по С узлам в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					integer icsos = 0;

					doublerealT SumPall = 0.0;
					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {

							// Сумма вообще всех внедиагональных элементов.
							//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
								SumPall += fabs(Amat[is0].aij);
							}


							if (this_is_C_node[Amat[is0].j] == true) {
								//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
								if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									icsos++;
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
					}
					if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					if ((false) && (icsos == 1)) {
						this_is_F_node[i8] = false;
						this_is_C_node[i8] = true;
						bweSholdbeContinue = true;
					}
					else {



						for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
							if (Amat[is0].j != Amat[ii1].i) {
								if (this_is_C_node[Amat[is0].j] == true) {

									if (fabs(sumP) < RealZERO) {
										//printf("error interpolation zero diagonal sumP.\n");
										//printf("Fnode all sosed is F");
										//system("pause");
										//	printf("i8 is Dirichlet node\n");
										this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
										this_is_C_node[i8] = true;
										bweSholdbeContinue = true;
										iadditionalCstatistic++;
										//exit(1);
										// здесь нужна непрямая интерполляция.
									}
									else {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											P[icount1].aij = fabs(Amat[is0].aij) / SumPall;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
											}
										}

									}

								}
								else
									if (this_is_F_node[Amat[is0].j] == true) {

										// Смысл :
										// 



										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {

											integer iFpoint = Amat[is0].j;
											doublerealT multiplyer_nu = fabs(Amat[is0].aij) / SumPall;
											// сканируем всех соседей iFpointeger 
											// чтобы найти среди них С узлы.

											// Идентифицируем локальный порог.
											doublerealT maxelem_threshold_loc = -1.0;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc)) {
															maxelem_threshold_loc = fabs(Amat[is0_loc].aij);
														}
													}
												}
											}


											// Здесь maxelem_threshold_loc это модуль максимального внедиагонального элемента в строке среди С соседей локально.

											// Найти соседей данного F-node которые C-node.
											integer icsos_loc = 0;

											// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
											// Для каждого такого члена суммы увличиваем счётчик iscos_loc. По идее iscos_loc должно быть 2 и более.
											doublerealT sumP_loc = 0.0;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {




													if (this_is_C_node[Amat[is0_loc].j] == true) {
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
															sumP_loc += fabs(Amat[is0_loc].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
															icsos_loc++;
														}
													}
													else {
														// Подсчитываем количество соседей которые не являются С узлами.
														//ipromah_loc++; // подсчитываем проблемы интерполяции 
													}
												}
											}

											// В общем это двойная интерполляционная сумма 
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														// Внедиагональный элемент из множества С узлов.

														// Данная вставка должна существенно сохранять 
														// разреженность оператора Галёркина на глубоких 
														// сеточных уровнях.
														// Модификация 5 декабря 2015.
														//if (fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*barjer) {
														if ((Amat[is0_loc].aij<0.0)&&(fabs(Amat[is0_loc].aij) > maxelem_threshold_loc*theta)) {
															P[icount1].j = i8;
															P[icount1].i = C_numerate[Amat[is0_loc].j];
															//P[icount1].aij = fabs(Amat[is0].aij) / sumP;
															P[icount1].aij = multiplyer_nu*fabs(Amat[is0_loc].aij) / sumP_loc;
															icount1++;
															if (icount1 >= nsizePR*n) {
																printf("memory error!!!\n");
																printf("not enough memory for the interpolation operator.\n");
																//system("PAUSE");
																//exit(1);
																deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
															}
														}
													}
												}
											}


										}
									}
							}
						}

					}


				}
			}
			else {
				// От интерполляции зависит очень много поэтому
				// реализуем следующую экспериментальную идею интерполляции.
				// Эта интерполляция претендует быть единственно теоретически верной,
				// сделанной на основе литературных данных.


				ipromah = 0;
				ipromah_one = 0;
				// Построение пролонгации для узлов которые составляют F nodes.
				// Каждый F-nodes окружён C-nodes.
				for (integer i8 = 1; i8 <= n_a[ilevel - 1]; i8++) if (this_is_F_node[i8] == true) {

					// Нам нужен разреженный оператор Галёркина.
					// 5 декабря 2015 года мы попробуем увеличить разреженность
					// оператора интерполляции а значит и оператора Галёркина.
					doublerealT maxelem_threshold = -1.0;
					//integer ii1 = BinarySearchAi(Amat, i8, 1 + iadd, nnz_a[ilevel - 1] + iadd);
					integer ii1 = row_startA[i8];
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							// Если закоментировано то смотрится максимальный внедиагональный элемент в строке.
							//if (this_is_C_node[Amat[is0].j] == true) {
							if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold)) {
								maxelem_threshold = fabs(Amat[is0].aij);
							}
							//}
						}
					}
					// Здесь maxelem_threshold это модуль максимального внедиагонального элемента в строке среди С соседей.

					// Найти соседей данного F-node которые C-node.
					//integer icsos = 0;

					

					// Суммируем модули внедиагональных элементов из С узлов которые больше порога.
					// Для каждого такого члена суммы увличиваем счётчик iscos. По идее iscos должно быть 2 и более.
					doublerealT sumP = 0.0;
					doublerealT sumPindicator = 0.0;
					for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
						if (Amat[is0].j != Amat[ii1].i) {
							if (this_is_C_node[Amat[is0].j] == true) {
								if ((Amat[is0].aij>0.0)||(fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								else {
									sumPindicator += fabs(Amat[is0].aij);
								}
							}
							else {
								// Подсчитываем количество соседей которые не являются С узлами.
								if ((Amat[is0].aij>0.0)||(fabs(Amat[is0].aij) <= maxelem_threshold*theta)) {
									// Weak connectors
									sumP += fabs(Amat[is0].aij); // сумма модулей внедиагональных элементов которые принадлежат С узлам.
									//icsos++;
								}
								ipromah++; // подсчитываем проблемы интерполяции 
							}
						}
						else {
							// Диагональный элемент.
							sumP += fabs(Amat[is0].aij);
						}
					}
					//if (icsos == 1) ipromah_one++; // количество F узлов с одним единственным С соседом.


					// 1 января 2015 Один сосед это недостаточно.
					// Поэтому в случае одного соседа делаем такой узел С узлом.
					//if ((false) && (icsos == 1)) {
					//this_is_F_node[i8] = false;
					//this_is_C_node[i8] = true;
					//bweSholdbeContinue = true;
					//}
					//else
					{

						if (fabs(sumPindicator) < RealZERO) {
							//printf("error interpolation zero diagonal sumP.\n");
							//printf("Fnode all sosed is F");
							//system("pause");
							//printf("i8 is Dirichlet node\n");
							this_is_F_node[i8] = false; // Этот узел Дирихле станет С нодом.
							this_is_C_node[i8] = true;
							bweSholdbeContinue = true;
							iadditionalCstatistic++;
							//exit(1);
							// здесь нужна непрямая интерполляция.

							// Мы не будем добалять С узлы, мы будем использовать непрямую интерполляцию.



						}
						else {

							integer icount1_frozen = icount1;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {

										// Внедиагональный элемент из множества С узлов.

										// Данная вставка должна существенно сохранять 
										// разреженность оператора Галёркина на глубоких 
										// сеточных уровнях.
										// Модификация 5 декабря 2015.
										//if (fabs(Amat[is0].aij) > maxelem_threshold*barjer) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											// Strongly C connectors.

											P[icount1].j = i8;
											P[icount1].i = C_numerate[Amat[is0].j];
											P[icount1].aij = fabs(Amat[is0].aij) / sumP;
											icount1++;
											if (icount1 >= nsizePR*n) {
												printf("memory error!!!\n");
												printf("not enough memory for the interpolation operator.\n");
												//system("PAUSE");
												//exit(1);
												deallocate_prolongation(nsizePR, n, R, P, bamg_bound);
											}
										}


									}
								}
							}

							integer ilength_n = icount1 - icount1_frozen;
							integer* jposition_in_P = NULL;
							//jposition_in_P = new integer[ilength_n];
							jposition_in_P = (integer*)malloc(ilength_n*sizeof(integer));
							handle_error<integer>(jposition_in_P, "jposition_in_P", "classic_aglomerative_amg_5", ilength_n);



							integer i_97 = 0;

							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_C_node[Amat[is0].j] == true) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											// Strongly C connections j position.
											jposition_in_P[i_97] = Amat[is0].j;
											i_97++;
										}
									}
								}
							}


							for (integer is0 = ii1; (is0 <= nnz_a[ilevel - 1] + iadd) && (Amat[is0].i == Amat[ii1].i); is0++) {
								if (Amat[is0].j != Amat[ii1].i) {
									if (this_is_F_node[Amat[is0].j] == true) {
										if ((Amat[is0].aij<0.0)&&(fabs(Amat[is0].aij) > maxelem_threshold*theta)) {
											// Strong F connections
											doublerealT my_mult = fabs(Amat[is0].aij);
											integer iFpoint = Amat[is0].j;
											//integer ii1_loc = BinarySearchAi(Amat, iFpoint, 1 + iadd, nnz_a[ilevel - 1] + iadd);
											integer ii1_loc = row_startA[iFpoint];

											// Смотрим всех соседей узла iFpoint
											// если среди них окажутся сильные С соседи 
											// первоначально рассматриваемого узла Amat[ii1].i
											// то мы будем накапливать в сумматоре sum23 
											// модули значеий матрицы.
											doublerealT sum23 = 0.0;
											bool bvisit23 = false;
											for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
												if (Amat[is0_loc].j != Amat[ii1_loc].i) {
													if (this_is_C_node[Amat[is0_loc].j] == true) {
														for (i_97 = 0; i_97 < ilength_n; i_97++) {
															if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																sum23 += fabs(Amat[is0_loc].aij);
																bvisit23 = true;
																break;
															}
														}
													}
												}
											}

											//if (fabs(sum23) > RealZERO) {
											if (bvisit23) {
												// мы точно не делим на ноль.

												// Сканируем всех соседей узла F.
												for (integer is0_loc = ii1_loc; (is0_loc <= nnz_a[ilevel - 1] + iadd) && (Amat[is0_loc].i == Amat[ii1_loc].i); is0_loc++) {
													if (Amat[is0_loc].j != Amat[ii1_loc].i) {
														if (this_is_C_node[Amat[is0_loc].j] == true) {
															for (i_97 = 0; i_97 < ilength_n; i_97++) {
																if (Amat[is0_loc].j == jposition_in_P[i_97]) {
																	//P[icount1_frozen + i_97].j = i8;
																	//P[icount1_frozen+i_97].i = C_numerate[Amat[is0].j];
																	P[icount1_frozen + i_97].aij += (my_mult*fabs(Amat[is0_loc].aij)) / (sumP*sum23);
																	break;
																}
															}
														}
													}
												}
											}


										}
									}
								}
							}

							//delete[] jposition_in_P;
							free(jposition_in_P);

						}

					}


				}
			}



			if (bweSholdbeContinue) {
				//delete[] ap_coarse;
				free(ap_coarse);
				ap_coarse = NULL;
				if (bprint_mesage_diagnostic) {
					printf("obratnaq svqz restart...\n");
				}
			}

			if (bprint_mesage_diagnostic) {
				printf("addition C nodes procent %3.1f", (doublerealT)(100.0*iadditionalCstatistic / n_a[ilevel - 1]));
			}
			iadditionalCstatistic = 0;
			//system("pause");


		}

		nnzR = icount1 - iaddR;



		// нужно определить nnzR количество ненулевых элементов в матрице R и P.

		// оператор restriction построен и он упорядочен по i.
		// число ненулевых элементов nnzR-1.
		// P=Copy(R);
		integer iend_marker_position = iaddR + nnzR - 1;
		for (integer ii = 1 + iaddR; ii <= iaddR + nnzR - 1; ii++) {
			//R[ii] = P[ii];
			// 18 августа 2016 года.
			R[ii] = P[ii];
			//if (fabs(R[ii].aij - 1.0) > 1.0e-20) {
			//	printf("%e\n", R[ii].aij*problem_conservation[ii - iaddR]);
			//	getchar();
			//}
			//R[ii].aij *= problem_conservation[ii - iaddR];
			/*
			if (ilevel == 1) {
				// Первый уровень в 2D соответствует пятиточечному шаблону.
				R[ii].aij *= 1.0 / (2.0*2.0*2.0); // 3D coarcen by 2
			}
			else {
				// более глубокие уровни соответствуют девятиточечному шаблону в 2D.
				R[ii].aij *= 1.0/(6.0858);
			}
			*/
			//if ((ilevel == 2) && (ii >= iaddR + nnzR - 1-30)) {
#if doubleintprecision == 1
			//printf("ii=%lld aij=%e, i=%lld j=%lld\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#else
			//printf("ii=%d aij=%e, i=%d j=%d\n", ii, P[ii].aij, P[ii].i, P[ii].j);
#endif
			
			//getchar();
			//}
		}

		// Этот оператор нужен для вычисления grid complexity для оператора 
		// интерполляции и проекции. Данная информация важна для оптимизации количества выделяемой памяти.
		if (ilevel - 1 == 0) {
			nnz_P_memo_0 = iend_marker_position - (iaddR + 1) + 1;
		}
		else {
			nnz_P_memo_all = iend_marker_position;
		}


		for (integer j85 = 1; j85 <= n_a[ilevel-1]; j85++) {
			flag85[j85] = false;
		}
		for (integer ii85 = 1 + iaddR; ii85 <= iaddR + nnzR - 1; ii85++) {
			if (flag85[P[ii85].j] == false) {
				integer jstr = P[ii85].j;
				integer ic85 = ii85;
				if ((ic85 + 1 <= n_a[ilevel - 1]) && (P[ic85 + 1].j == jstr)) {
					doublerealT minimum_aij = 1.0e40;
					doublerealT maximum_aij = -1.0e40;
					while ((ic85 <= n_a[ilevel - 1]) && (P[ic85].j == jstr)) {

						//x_fine[jstr] += P[ic].aij*x_coarse[P[ic].i];
						if (P[ic85].aij > maximum_aij) {
							maximum_aij = P[ic85].aij;
						}
						if (P[ic85].aij < minimum_aij) {
							minimum_aij = P[ic85].aij;
						}

						//printf("aij=%e sum=%e\n", P[ic85].aij, problem_conservation[ii85 - iaddR]);
						
						ic85++;
					}
					//printf("end string\n");
					//getchar();
					ic85 = ii85;
					while ((ic85 <= n_a[ilevel - 1]) && (P[ic85].j == jstr)) {
						// Так определено в литературе.
						// Даёт хорошую стабильную норму лучше среди всех предыдущих,
						// но сходимость cfd резко испортилась.
						// изменение тестовой нормы (пока наилучшее):
						// 3.334269e-5
						// 5.273e-4
						// 9.4239e-4
						// 8.113e-4
						// Максимальный элемент  нормирован на единицу.
						// Prolongation на диагонали единица.
					   // P[ic85].aij = P[ic85].aij / maximum_aij;
						// Restriction сумма значений элементов в строке есть единица.
						//R[ic85].aij = R[ic85].aij;
						ic85++;
					}
				}

				flag85[P[ii85].j] = true;
			}
		}

		delete[] problem_conservation;
		// heapsort(P,key==j,iaddR+1,iaddR+nnzR - 1);

		/*
		// 10 января 2016. Эта сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// где то надо разделить на ap, т.к. 
		// R=P/ap. ????


		// heapsort(R,key==i,iaddR+1,iaddR+nnzR - 1);

		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sort(R, 1 + iaddR, iaddR + nnzR - 1, false);
			}
			else {
				qs(R, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort(R, 1 + iaddR, iaddR + nnzR - 1);
		}


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("first level size n=%lld numberofcoarcenodes=%lld\n", n, numberofcoarcenodes);
#else
			printf("first level size n=%d numberofcoarcenodes=%d\n", n, numberofcoarcenodes);
#endif
			
		}

		// Корректировка диагонали restriction
		if (0) {
			// убрано 2 января 2015 года.
			// Убирание этого сомнительного шага дало сокращение 
			// времени счтёта для 1M неизвестных с 51с(131 итерация) до 42с (91 итерации).
			// на задаче tgf2023_01 включение данного шага приводит к расходимости вычислительного процесса.

			if (debug_reshime) system("pause");
			for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
				flag[i_1] = false; // init flag.
			}

			for (integer i_1 = 1 + iaddR; i_1 <= iaddR + nnzR - 1; i_1++) {
				if (flag[R[i_1].i] == false)
				{
					for (integer i_2 = i_1; (i_2 <= iaddR + nnzR - 1) && (R[i_2].i == R[i_1].i); i_2++) {
						if ((R[i_1].i<1) || (R[i_1].i>numberofcoarcenodes)) {
#if doubleintprecision == 1
							printf("error R[%lld].i=%lld\n", i_1, R[i_1].i);
#else
							printf("error R[%d].i=%d\n", i_1, R[i_1].i);
#endif
							
							system("pause");
						}
						if (fabs(ap_coarse[R[i_1].i]) < divisionZERO) {
							printf("error division by zero\n");
							system("pause");
						}
						doublerealT delitel;
						if (ap_coarse[R[i_1].i] > 1.0) {
							// internal node
							delitel = 0.5*ap_coarse[R[i_1].i];
						}
						else {
							// Dirichlet
							delitel = ap_coarse[R[i_1].i];
						}
						R[i_2].aij = R[i_2].aij / (delitel);
					}
					flag[R[i_1].i] = true;
				}
			}
		}

		//delete[] ap_coarse;
		free(ap_coarse);





		// Сортировка А по j.
		//heapsort(Amat, key=j*n_a[ilevel - 1] + i, 1, nnz_a[ilevel - 1]);

		// Лишний код потомучто потом сразу же следует сортировка по i.
		/*
		// 7 января 2016. закоментировано.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sortj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qsj(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort_j(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/

		// MARKER GUSTAVSON

		// Нахождение матрицы грубосеточного уровня :
		// Acorse=R*Afine*P;
		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]


		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", nnzR, nnz_a[ilevel - 1]);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", nnzR, nnz_a[ilevel - 1]);
#endif
			
		}

		integer istartAnew;


		// Фред Густавсон IBM 1978.
		// 23 октября 2015 года.

		// часть 1 : R*Afine.
		//         xxxxxx
		//         xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//  xxxxxx xxxxxx xxxxxx
		//         xxxxxx
		//         xxxxxx
		//    R       Amat     [RA]
		// Сортировка А по строкам.
		/*
		// 7 января 2016. Сортировка матрицы А была выполнена единожды при начале обработке данного уровня.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else {
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/
		// Преобразование к формату CRS.

		integer* row_ind_SR = NULL;
		//row_ind_SR = new integer[numberofcoarcenodes + 1];
		row_ind_SR = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SR, "row_ind_SR", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		integer* row_ind_ER = NULL;
		//row_ind_ER = new integer[numberofcoarcenodes + 1];
		row_ind_ER = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_ER, "row_ind_ER", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			row_ind_SR[i_1] = -1;
			row_ind_ER[i_1] = -2;
		}
		integer istart1 = 1 + iaddR;
		integer iend1 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= icounter - 1; i++) {
			flag[i] = false;
		}
		for (integer ii = istart1; ii <= iend1; ii++) {
			if (flag[R[ii].i] == false) {
				integer istr = R[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend1) && (R[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SR[istr] = ic;
				row_ind_ER[istr] = kf;
				flag[R[ii].i] = true;
			}
		}

		// Пустые строки просто отсутствуют.
		//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
		//if (row_ind_SR[i_1] == -1) {
#if doubleintprecision == 1
		//printf("empty string %lld\n", row_ind_ER[i_1]);
#else
		//printf("empty string %d\n", row_ind_ER[i_1]);
#endif
		
		//}
		//}

		integer* row_ind_SA = NULL;
		//row_ind_SA = new integer[n_a[ilevel - 1] + 1];
		row_ind_SA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_SA, "row_ind_SA", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer* row_ind_EA = NULL;
		//	row_ind_EA = new integer[n_a[ilevel - 1] + 1];
		row_ind_EA = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_EA, "row_ind_EA", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer istart3 = 1 + iadd;
		integer iend3 = nnz_a[ilevel - 1] + iadd;
		for (integer i = 1; i <= n_a[ilevel - 1]; i++) {
			flag[i] = false;
		}
		for (integer ii = istart3; ii <= iend3; ii++) {
			if (flag[Amat[ii].i] == false) {
				integer istr = Amat[ii].i;
				integer ic = ii;
				integer kf = ic;

				while ((kf <= iend3) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_SA[istr] = ic;
				row_ind_EA[istr] = kf;
				flag[Amat[ii].i] = true;
			}
		}

		istartAnew = nnz_a[ilevel - 1] + 1 + iadd;

		// Данные используемые для частичного формирователя суммы.
		doublerealT* vector_sum = NULL;
		//vector_sum = new doublerealT[n_a[ilevel - 1] + 1];
		vector_sum = (doublerealT*)malloc((n_a[ilevel - 1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		//bool* b_visit_vec_sum = new bool[n_a[ilevel - 1] + 1];
		//integer size_v = sizeof(doublerealT)*(1 + n_a[ilevel - 1]);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		integer* index_visit = NULL;
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer index_size = 0;




		// Сканируем первый операнд построчно.
		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Начинаем обрабатывать новую строку.
			// Сброс формирователя суммы в ноль.
			//#pragma omp parallel for
			//for (integer i_2 = 1; i_2 <= n_a[ilevel - 1]; i_2++) {
			//vector_sum[i_2] = 0.0; // инициализация // 18.5
			//b_visit_vec_sum[i_2] = false;
			//}
			// Более быстрое обнуление
			// По времени в лучшем случае также. Но может сильно ухудшиться из-за занятости системной dll-ки.
			//memset(vector_sum, 0,size_v );

			node_AVL_Gus* root_Gus = 0;

			if (0) {

				// линейный поиск очень медленный на больших размерностях.

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else if (0) {

				// Закоментировано т.к. это медленная ветвь кода.
				// Ситуация такая. Ранее на небольших задачах до 1М включительно,
				// данная ветвь кода не показывала выигрыша в быстродействии и возможно 
				// даже была слегка медленее (совсем немного). 
				// Это быстрая часть кода на больших размерностях.
				// Гораздо лучше линейного поиска. Сейчас это подтверждается
				// на непрямой интерполляции при задаче в 3.2М неизвестных.
				// Там на линейный поиск в данном месте тратится не менее 80% фазы построения грубосеточных операторов.

				// На основе АВЛ
				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							root_Gus = insert_Gus(root_Gus, iaddind);
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}
			else {

				// на основе hash таблицы. 

				// Сканируем текущую i-ую строку поэлементно
				for (integer ii = row_ind_SR[istr]; ii <= row_ind_ER[istr]; ii++) {
					integer col_ind = R[ii].j;
					// Сканируем col_ind строку второго операнда

					for (integer i_1 = row_ind_SA[col_ind]; i_1 <= row_ind_EA[col_ind]; i_1++) {
						doublerealT left_operand = R[ii].aij;
						doublerealT right_operand = Amat[i_1].aij;
						integer iaddind = Amat[i_1].j;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}
						// Бинарный поиск в АВЛ дереве.
						// Раскоментировать при использовании
						//foundnow = isfound_Gus(root_Gus, iaddind);
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево
							// Раскоментировать при использовании
							//root_Gus = insert_Gus(root_Gus, iaddind);
							hash_table[iaddind] = true;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}

						//vector_sum[Amat[i_1].j] += left_operand*right_operand;
						//b_visit_vec_sum[Amat[i_1].j] = true;
					}
				}
			}


			doublerealT maxth = -1.0;
			if (0) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
					if (istr != jstr) {
						// 14 января 2016.
						// Правильнее определить величину барьера только по внедиагональным элементам.
						if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
					}
				}
			}
			else {
				// 23 10 2016 Первый барьер полностью отключён.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // инициализируем hash таблицу для следующих проходов.
				}
			}

			/*
			if (nsizeA > istartAnew + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015. threshold.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjer*maxth) {
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			else {
			// диагональный элемент записываем обязательно.
			Amat[istartAnew].aij = vector_sum[jstr];
			Amat[istartAnew].i = istr;
			Amat[istartAnew].j = jstr;
			istartAnew++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем
			// проверками.
			doublerealT barjer_maxth = barjer*maxth;
			doublerealT mbarjer_maxth = -barjer_maxth;
			if (nsizeA > istartAnew + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];

					doublerealT vs1 = vector_sum[jstr];
					if (0) {
						if ((vs1 < mbarjer_maxth) || (vs1 > barjer_maxth)) {
							//Amat[istartAnew].aij = vs1;
							//Amat[istartAnew].i = istr;
							//Amat[istartAnew].j = jstr;
							//istartAnew++;

							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;
							Amat[istartAnew++] = Atemp;

						}
					}
					else {
						//Amat[istartAnew].aij = vs1;
						//Amat[istartAnew].i = istr;
						//Amat[istartAnew].j = jstr;
						//istartAnew++;

						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;
						Amat[istartAnew++] = Atemp;

					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0; // Сброс индикатора, строка обработана.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;

		}



		//delete[] index_visit;
		//delete[] row_ind_SR;
		//delete[] row_ind_ER;
		//delete[] row_ind_SA;
		//delete[] row_ind_EA;
		//delete[] vector_sum;

		free(index_visit);
		free(row_ind_SR);
		free(row_ind_ER);
		free(row_ind_SA);
		free(row_ind_EA);
		free(vector_sum);


		// Сортировка А по i (оригинала.).
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);

		/*
		// Лишняя сортировка до этого уже была выполнена сортировка по i.
		// 7 января 2016.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		qs(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		}
		else
		{
		HeapSort(Amat, 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		*/


		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error : negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}



		// Часть 2. [R*Afine]*P=Abuf*P.
		// Сортировка [R*А] по i.
		//heapsort(Amat, key=i*n_coarce + j, 1, nnz_a[ilevel - 1]);

		// В результате работы алгоритма разреженного матричного умножения по Густавсону,
		// мы и так имеем отсортированный по строкам результат, поэтому дополнительная 
		// сортировка не требуется. Это проверено 11 января 2016.
		// 11 января 2016.
		/*
		if (bqs) {
		// Обязательно нужна сортировка.
		if (bCounting_Sort) {
		Counting_Sort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		else {
		qs(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		}
		else {
		HeapSort(Amat, nnz_a[ilevel - 1] + 1 + iadd, istartAnew - 1);
		}
		*/



		// Проверка пройдена успешно.
		//for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd; i_1 <= istartAnew - 1; i_1++) {
		//if (Amat[i_1].j < 0) {
		//	printf("error : negativ j index\n");
		//	system("pause");
		//}
#if doubleintprecision == 1
		//-->	//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#else
		//-->	//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n", i_1, Amat[i_1].i, i_1, Amat[i_1].j, i_1, Amat[i_1].aij);
#endif
		
		//system("pause");
		//}




		/*
		// 10 января 2016. Данная сортировка не требуется.
		if (bqs) {
		if (bCounting_Sort) {
		Counting_Sort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else {
		qs(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		*/


		// Prolongation должна быть упорядочена по j.
		// Начальная позиция элементов матрицы грубосеточного уровня.
		integer istartAnew2 = istartAnew;



		// Быстрее этого кода на основе идеи слияния списков уже не будет.
		// 17 октября 2015. Нужно двигаться в сторону Писсанецки.
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("nnz left operand=%lld, nnz right operand=%lld\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#else
			printf("nnz left operand=%d, nnz right operand=%d\n", istartAnew - (nnz_a[ilevel - 1] + 1 + iadd), nnzR);
#endif
			
		}



		// Фред Густавсон IBM 1978
		// В ядре кода Густавсона нету ни одного ветвления,
		// а мы знаем что в результате профайлинга предыдущих версий кода :
		// (наивный, слияние, Писсанецки) львиная доля вычислительной работы уходила
		// на сравнения (ветвления) в отношении примерно 30 к 1. 30 сравнений на одно сумирование.
		// 23 октября 2015 года.
		// 6 января 2016 года Добавлено АВЛ дерево.


		// Рабочая версия алгоритма Фреда Густавсона.
		// IBM 1978 Sparse Matrix multiplication.

		// Сортировка обязательно требуется.
		// Преобразование обоих матриц в формат CRS.
		if (bqs) {
			if (bCounting_Sort) {
				Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
			else {
				qsj(P, 1 + iaddR, iaddR + nnzR - 1);
			}
		}
		else {
			HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		integer* row_ind_AS = NULL;
		//row_ind_AS = new integer[numberofcoarcenodes + 1];
		row_ind_AS = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AS, "row_ind_AS", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		integer* row_ind_AE = NULL;
		//row_ind_AE = new integer[numberofcoarcenodes + 1];
		row_ind_AE = (integer*)malloc((numberofcoarcenodes + 1)*sizeof(integer));
		handle_error<integer>(row_ind_AE, "row_ind_AE", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		integer istart2 = nnz_a[ilevel - 1] + 1 + iadd;
		integer iend2 = istartAnew - 1;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart2; ii <= iend2; ii++) {
			if (flag[Amat[ii].i] == false) {
				// сканируем построчно.
				integer istr = Amat[ii].i;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend2) && (Amat[kf].i == istr)) {
					kf++;
				}
				kf--;
				row_ind_AS[istr] = ic;
				row_ind_AE[istr] = kf;
				flag[Amat[ii].i] = true;

			}
		}

		integer* row_ind_PS = NULL;
		//row_ind_PS = new integer[n_a[ilevel - 1] + 1];
		row_ind_PS = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PS, "row_ind_PS", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		integer* row_ind_PE = NULL;
		//row_ind_PE = new integer[n_a[ilevel - 1] + 1];
		row_ind_PE = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(row_ind_PE, "row_ind_PE", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));


		// Инициализация чрезвычайно важна, т.к. 
		// обязательно присутствуют пустые строки которые
		// надо корректно обрабатывать.
		for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
			row_ind_PS[ii] = -1; // инициализация.
			row_ind_PE[ii] = -2;
		}
		integer istart4 = 1 + iaddR;
		integer iend4 = nnzR - 1 + iaddR;
		for (integer i = 1; i <= n; i++) {
			flag[i] = false;
		}
		for (integer ii = istart4; ii <= iend4; ii++) {
			if (flag[P[ii].j] == false) {
				// сканируем построчно.
				integer istr = P[ii].j;
				integer ic = ii;

				integer kf = ic;

				while ((kf <= iend4) && (P[kf].j == istr)) {
					kf++;
				}
				kf--;
				row_ind_PS[istr] = ic;
				row_ind_PE[istr] = kf;
				flag[P[ii].j] = true;

			}
		}

		// Данный код подтверждает что обязательно присутствуют
		// пустые строки.
		//for (integer ii = 1; ii <= n_a[ilevel - 1]; ii++) {
		//if (row_ind_PS[ii] == -1) {
#if doubleintprecision == 1
		//printf("propusk string %lld\n", row_ind_PE[ii]);
#else
		//printf("propusk string %d\n", row_ind_PE[ii]);
#endif
		
		//getchar();
		//}
		//}

		// Накопитель результата.
		//vector_sum = new doublerealT[numberofcoarcenodes + 1];
		vector_sum = (doublerealT*)malloc((numberofcoarcenodes + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(vector_sum, "vector_sum", "classic_aglomerative_amg_5", (numberofcoarcenodes + 1));

		//integer size_v = sizeof(doublerealT)*(1 + numberofcoarcenodes);
		// Храним индексы ненулевых элементов в отсортированном порядке.
		//index_visit = new integer[n_a[ilevel - 1] + 1];
		index_visit = (integer*)malloc((n_a[ilevel - 1] + 1)*sizeof(integer));
		handle_error<integer>(index_visit, "index_visit", "classic_aglomerative_amg_5", (n_a[ilevel - 1] + 1));

		index_visit[0] = 0;
		index_size = 0;

		// Мы будем сканировать левый операнд построчно, а
		// после окончания обработки одной строки левого операнда
		// получать готовую строку результата.

		for (integer istr = 1; istr <= numberofcoarcenodes; istr++) {

			// Переход к новой строке, сброс накопителя результата.
			//#pragma omp parallel for
			//for (integer i_1 = 1; i_1 <= numberofcoarcenodes; i_1++) {
			//vector_sum[i_1] = 0.0; // обнуление.
			//}
			// хоть профайлер и показывает что на memset тратиться меньше процессорного времени,
			// но там возникает системный вызов на который тратиться столько же времени что и раньше.
			// работа перекочевала из одного места в другое.
			// Более быстрое обнуление.
			//memset(vector_sum, 0, size_v);

			node_AVL_Gus* root_Gus = 0;

			if (0) {
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						for (integer i_6 = 1; i_6 <= index_size; i_6++) {
							if (index_visit[i_6] == iaddind) {
								foundnow = true;
								//ifoundind = i_6;
								break;
							}
						}
						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else if (0) {

				// На основе АВЛ дерева.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						foundnow = isfound_Gus(root_Gus, iaddind);

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							root_Gus = insert_Gus(root_Gus, iaddind);

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}
			else {

				// На основе hash таблицы.
				// сканируем все элементы строки левого операнда.
				for (integer ii1 = row_ind_AS[istr]; ii1 <= row_ind_AE[istr]; ii1++) {
					integer col_ind = Amat[ii1].j;

					// Сканируем col_ind строку правого операнда накапливая сумму.
					for (integer ii2 = row_ind_PS[col_ind]; ii2 <= row_ind_PE[col_ind]; ii2++) {
						doublerealT left_operand = Amat[ii1].aij;
						doublerealT right_operand = P[ii2].aij;

						integer iaddind = P[ii2].i;
						bool foundnow = false;
						//integer ifoundind = -1;
						// линейный поиск позиции в массиве на добавление.
						//for (integer i_6 = 1; i_6 <= index_size; i_6++) {
						//if (index_visit[i_6] == iaddind) {
						//foundnow = true;
						//ifoundind = i_6;
						//break;
						//}
						//}

						// Бинарный поиск в АВЛ дереве.
						//foundnow = isfound_Gus(root_Gus, iaddind);
						// мгновенный поиск за O(1).
						foundnow = hash_table[iaddind];

						if (foundnow) {
							//vector_sum[index_visit[ifoundind]] += left_operand*right_operand;
							vector_sum[iaddind] += left_operand*right_operand;
						}
						else {
							// Первое добавление.
							index_size++;
							index_visit[index_size] = iaddind;
							// Вставка в АВЛ дерево .
							//root_Gus = insert_Gus(root_Gus, iaddind);
							// Мгновенная вставка в hash table за O(1).
							hash_table[iaddind] = true;

							//ifoundind = index_size;
							//vector_sum[index_visit[ifoundind]] = left_operand*right_operand;
							vector_sum[iaddind] = left_operand*right_operand;
						}
						// требуется реализовать следующую логику :
						// 1. поиск элемента по ключу 
						// 2. если элемент не найден то добавление нового узла со значением ключа сохраняя балансировку.
						// Если элемент найден то нужно просто изменить foundnow на true. 
						// Т.е. достаточно просто поиска и вставки.
						// 3. В конце дерево необходимо ликвидировать.
						// Тип данных целочисленный ключ.


						//vector_sum[P[ii2].i] += rleft*rright;
					}
				}

			}


			doublerealT maxth = -1.0;
			if (barjerA > 0.0) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // initialization hash.
					if (istr != jstr) {
						// 14 января 2016 года.
						// Правильно определить барьер только по внедиагональным элементам.
						if (fabs(vector_sum[jstr]) > maxth) maxth = vector_sum[jstr];
					}
				}
			}
			else {
				// Игнорируем барьер А.
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {
					integer jstr = index_visit[i_6];
					hash_table[jstr] = false; // initialization hash.
				}
			}

			/*
			if (nsizeA > istartAnew2 + index_size) {
			for (integer i_6 = 1; i_6 <= index_size; i_6++) {
			// 15 декабря 2015.
			// Если не принять специальных мер элементы не будут упорядочены
			// и двоичным поиском воспользоваться нельзя.
			//if (index_visit[i_6] < index_visit[i_6 - 1]) {
			//printf("Gipotesa uporqdochennosti in Fred Gustavson neverna\n");
			//system("pause");
			//}

			integer jstr = index_visit[i_6];
			if (istr != jstr) {
			// 5 декабря 2015 года. Сохранение разреженности.
			//if (fabs(vector_sum[jstr]) > 1.0e-30) {
			if (fabs(vector_sum[jstr]) > barjerA*maxth) {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			else {
			Amat[istartAnew2].aij = vector_sum[jstr];
			Amat[istartAnew2].i = istr;
			Amat[istartAnew2].j = jstr;
			istartAnew2++;
			}
			}
			}
			else {
			// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
			// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
			printf("Amat lack of memory\n");
			printf("yuo mast increase the size of the matrix Amat and restart solver\n");
			printf("please, press any key to exit.\n");
			system("pause");
			exit(1);
			}
			*/

			// Нам нужен чрезвычайно быстрый код поэтому мы принебрегаем проверками.
			doublerealT barjerA_maxth = barjerA*maxth;
			doublerealT mbarjerA_maxth = -barjerA_maxth;
			if (nsizeA > istartAnew2 + index_size) {
				for (integer i_6 = 1; i_6 <= index_size; i_6++) {

					integer jstr = index_visit[i_6];
					doublerealT vs1 = vector_sum[jstr];
					if (barjerA > 0.0) {
						// Барьер использовать можно, но главное чтобы 
						// спектральные характеристики усеченной матрицы соответствовали
						// спектральным характеристикам исходной Галёркинской матрицы.

						if ((vs1 < mbarjerA_maxth) || (vs1 > barjerA_maxth)) {
							Ak1 Atemp;
							Atemp.aij = vs1;
							Atemp.i = istr;
							Atemp.j = jstr;

							//Amat[istartAnew2].aij = vs1;
							//Amat[istartAnew2].i = istr;
							//Amat[istartAnew2].j = jstr;
							//istartAnew2++;

							Amat[istartAnew2++] = Atemp;

						}
					}
					else {
						// Игнорируем барьер А.

						Ak1 Atemp;
						Atemp.aij = vs1;
						Atemp.i = istr;
						Atemp.j = jstr;

						//Amat[istartAnew2].aij = vs1;
						//Amat[istartAnew2].i = istr;
						//Amat[istartAnew2].j = jstr;
						//istartAnew2++;

						Amat[istartAnew2++] = Atemp;
					}
				}
			}
			else {
				// Слишком мало памяти выделено под матрицу А и в неё не умещаются все данные.
				// Нужно увеличить объём выделяемой памяти для А и перезапустить приложение.
				printf("Amat lack of memory\n");
				printf("yuo mast increase the size of the matrix Amat and restart solver\n");
				printf("please, press any key to exit.\n");
				system("pause");
				exit(1);
			}

			index_size = 0;
			// Освобождение памяти из под АВЛ дерева.
			clear_AVL_Gus(root_Gus);
			root_Gus = 0;
		}

		//delete[] vector_sum;
		//delete[] index_visit;
		free(vector_sum);
		free(index_visit);


		//delete[] row_ind_AS;
		//delete[] row_ind_AE;
		//delete[] row_ind_PS;
		//delete[] row_ind_PE;
		free(row_ind_AS);
		free(row_ind_AE);
		free(row_ind_PS);
		free(row_ind_PE);




		// Есть подозрение что это избыточный код и его не надо вызывать.
		// 13  декабря 2015.
		// Это полностью подтвердилось 13 декабря 2015 года.
		/*

		if (bqs)
		{
		if (bCounting_Sort) {
		Counting_Sortj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		else
		{
		// Быстрая сортировка Хоара.
		qsj(P, 1 + iaddR, iaddR + nnzR - 1);
		}
		}
		else {
		HeapSort_j(P, 1 + iaddR, iaddR + nnzR - 1);
		}

		*/

		// Копируем матрицу А следующего уровня влево вплотную к матице первоначального уровня.
		//integer icounter3 = 1;
		integer nsize = istartAnew2 - (istartAnew);
		for (integer i_1 = nnz_a[ilevel - 1] + 1 + iadd, i_2 = 1; i_2 <= nsize; i_1++, i_2++) {
			integer i_right_position = istartAnew - 1 + i_2;
			Amat[i_1] = Amat[i_right_position];
		}

		if (bprint_mesage_diagnostic) {
			printf("Prolongation is construct.\n");
			// Общее количество узлов не являющихся соседемя, но не С соседями 
#if doubleintprecision == 1
			printf("Error interpolation is count %lld\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%lld iz nih kol-vo beznadechnjh %lld\n", ipromah_one, ipromah_oneF);
#else
			printf("Error interpolation is count %d\n", ipromah);
			// Количество F узлов у которых только один интерполяционный С сосед.
			printf("diagnostic ipromah_one=%d iz nih kol-vo beznadechnjh %d\n", ipromah_one, ipromah_oneF);
#endif
			
			//system("pause");
		}
		if (debug_reshime) system("pause");


		//delete[] C_numerate;
		free(C_numerate);

		nnz_aRP[ilevel - 1] = nnzR - 1;
		iaddR += nnzR - 1;
		n_a[ilevel] = icounter - 1;
		nnz_a[ilevel] = nsize;
		iadd += nnz_a[ilevel - 1];


		ilevel++;

		// сортировка А по i.
		//heapsort(Amat, key=i*n_a[ilevel - 1] + j, 1, nnz_a[ilevel - 1]);
		/*

		if (nnz_a[ilevel - 1] < heapsortsizelimit) {
		HeapSort(Amat, n_a[ilevel - 1], 1 + iadd, nnz_a[ilevel - 1] + iadd);
		}
		else {
		Ak1* Aorig = &Amat[1 + iadd];
		MergeSort(Aorig, nnz_a[ilevel - 1]);
		Aorig = NULL;
		}

		*/

#if doubleintprecision == 1
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%lld ",Amat[i_1].j);
		//}
		//printf("Amat[%lld].i=%lld Amat[%lld].j=%lld Amat[%lld].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#else
		// debug
		//for (integer i_1 = 1 + iadd; i_1 <= iadd + nnz_a[ilevel - 1]; i_1++) {
		//if (Amat[i_1].i > n_a[ilevel - 1]) {
		//		printf("matrix incorrect i\n");
		//}
		//if (Amat[i_1].j > n_a[ilevel - 1]) {
		//	printf("%d ",Amat[i_1].j);
		//}
		//printf("Amat[%d].i=%d Amat[%d].j=%d Amat[%d].aij=%e\n",i_1,Amat[i_1].i,i_1,Amat[i_1].j,i_1,Amat[i_1].aij);
		//system("pause");
		//}
#endif
		


		//exit(1);
		if (bprint_mesage_diagnostic) {
			printf("one level construct OK.\n");
		}
		if (debug_reshime) system("pause");


		//printf("export b\n");
		//exporttecplot(b,n);

		//doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

		// restriction
		//restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
		//for (integer ii = 1; ii <= n_a[0]; ii++) {
		//b[ii] = 0.0;
		//}

		/*{
		doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		for (integer ii = 1; ii <= n_a[1]; ii++) {
		test_coarse[ii] = 0.0;
		}

		{
		doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

		// restriction
		restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		for (integer ii = 1; ii <= n_a[2]; ii++) {
		test_coarse1[ii] = 0.0;
		}

		prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
		}

		prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
		}
		*/
		//prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

		//exporttecplot(b, n);
		// proverka start
		// на сетке 81х81 проверка успешно проходится.

		/*
		printf("proverka start\n");
		// первый уровень вложенности.
		if (ilevel > 1) {
		for (integer i = 1; i <= n; i++) {
		flag[i] = false;
		}

		for (integer ii77 = nnz_a[0] + 1; ii77 <= nnz_a[0] + nnz_a[1]; ii77++) {
		if (flag[Amat[ii77].i] == false) {
		integer istr77 = Amat[ii77].i;
		integer ic77 = ii77;
		//integer icdiag = ii77;
		doublerealT ap = 0.0;
		//x[istr] = b[istr];
		while ((ic77 <= nnz_a[0] + nnz_a[1]) && (Amat[ic77].i == istr77)) {
		if (Amat[ic77].j != istr77) {
		//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
		}
		else {
		ap = Amat[ic77].aij;
		//icdiag = ic77;
		}
		ic77++;
		}
		if (fabs(ap) < RealZERO) {
		#if doubleintprecision == 1
			printf("zero diagonal element %e in string %lld in level 1 matrix", ap, istr77);
		#else
			printf("zero diagonal element %e in string %d in level 1 matrix", ap, istr77);
		#endif
		
		system("PAUSE");
		//exit(1);
		}

		flag[Amat[ii77].i] = true;

		}
		}
		}
		*/

		//проверка конец

		//delete[] count_sosed;
		free(count_sosed);
		//delete[] row_startA;
		free(row_startA);

	}// иерархия сеток построена.

	ilevel--;
	if (n_a[ilevel] < 5) {
		// Чтобы не было последних уровней где меньше 5 узлов сетки.
		ilevel--;
	}

	// Вычисляем и запоминаем grid complexity:
	// grid complexity - операторная сложность.
	doublerealT dr_grid_complexity = (((double)(1.0*iadd)) / ((double)(1.0*nnz_a[0])));

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f %1.2f\n", (1.0*nnz_P_memo_all / nnz_P_memo_0), (1.0*nnz_P_memo_all/n_a[0]));
		doublerealT sizegb = 16 * iadd / 1.0e9;
		printf("memory usage is %e Gb. reserved %e Gb. ratio is equal = %e\n", sizegb, 16 * nsizeA / 1.0e9, sizegb / (16 * nsizeA / 1.0e9));
	}

	if (bji) {
		delete[] Atemp;
		Atemp = NULL;
	}

	// 31.224s [50.986] 2D m=81 debug x64 acumulqtor
	// 13.792 [18.156] 2D m=81 realese x64 acumulqtor
	// 8.028s 2D m=81 debug x64 rozetka
	// 3.827 2D m=81 realese x64 rozetka

	if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
		printf("ilevel=%lld\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%lld]=%lld nnz_a[%lld]=%lld nnz_a[%lld]/n_a[%lld]=%lld\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
#else
		printf("ilevel=%d\n", ilevel);
		for (integer i_1 = 0; i_1 <= ilevel; i_1++) {
			printf("n_a[%d]=%d nnz_a[%d]=%d nnz_a[%d]/n_a[%d]=%d\n", i_1, n_a[i_1], i_1, nnz_a[i_1], i_1, i_1, (integer)(nnz_a[i_1] / n_a[i_1]));
		}
#endif
		
		printf("Graph(Mesh) ierarhion is construct sucsseful...\n");
	}
	if (debug_reshime) system("pause");
	//system("pause");
	//exit(1);

	printf("memory optimization 13 november 2016.\n");
	printf("ierarhion matrix Amat...");
	// Уменьшение памяти отводимой под хранение матрицы А.
	// Матрица должна занимать в памяти не более чем под неё нужно и не мегабайтом больше.
	if (Amat != NULL) {
		Ak1* Amat_tmp= (Ak1*)realloc(Amat, (iadd + 2) * sizeof(Ak1));
		if (Amat_tmp == NULL) {
			printf("application crash for Amat. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			Amat = Amat_tmp;
		}
		Amat_tmp = NULL;
	}
	
	printf(" 1 of 3 compleated.  OK!! ierarhion matrix Amat realloc successfully...\n");

	printf("Prolongation ierarhion...\n");
	if (P != NULL) {
		Ak1* P_tmp= (Ak1*)realloc(P, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
		if (P_tmp == NULL) {
			printf("application crash for P. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			P = P_tmp;
		}
		P_tmp = NULL;
	}
	
	printf("2 of 3 compleated. OK!! ierarhion matrix Prolongation realloc successfully...\n");

	printf("Restriction ierarhion...\n");
	if (R != NULL) {
		Ak1* R_tmp= (Ak1*)realloc(R, ((integer)(nnz_P_memo_all)+2) * sizeof(Ak1));
		if (R_tmp == NULL) {
			printf("application crash for R. Please send message on email: kirill7785@mail.ru\n");
			system("pause");
			exit(1);
		}
		else {
			R = R_tmp;
		}
		R_tmp = NULL;
	}
	
	printf("3 of 3 compleated. OK!! ierarhion matrix Restriction realloc successfully...\n");
	printf("memory optimization successfully.\n");



	/*
	//exporttecplot(b,n);

	doublerealT *test_coarse = new doublerealT[n_a[1] + 1];

	// restriction
	restriction(R, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);
	for (integer ii = 1; ii <= n_a[0]; ii++) {
	b[ii] = 0.0;
	}

	{
	doublerealT *test_coarse1 = new doublerealT[n_a[2] + 1];

	// restriction
	restriction(R, 1+nnz_aRP[0], nnz_aRP[0]+nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	for (integer ii = 1; ii <= n_a[1]; ii++) {
	test_coarse[ii] = 0.0;
	}

	{
	doublerealT *test_coarse2 = new doublerealT[n_a[3] + 1];

	// restriction
	restriction(R, 1 + nnz_aRP[0]+nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1]+nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	for (integer ii = 1; ii <= n_a[2]; ii++) {
	test_coarse1[ii] = 0.0;
	}

	prolongation(P, 1 + nnz_aRP[0]+ nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, test_coarse1, test_coarse2, n_a[2], n_a[3]);
	}

	prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, test_coarse, test_coarse1, n_a[1], n_a[2]);
	}

	prolongation(P, 1, nnz_aRP[0], flag, b, test_coarse, n_a[0], n_a[1]);

	exporttecplot(b, n);
	*/

	// подготовка матрицы к cycling:
	/*
	// smoother.
	// 1 september 2015.
	void seidel(Ak1* &Amat, integer istart, integer iend, doublerealT* &x, doublerealT* &b, bool* &flag, integer n)
	{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	for (integer ii = istart; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	doublerealT ap = 0.0;
	x[istr] = b[istr];
	while ((ic<=iend)&&(Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else ap = Amat[ic].aij;
	ic++;
	}
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld",istr);
	#else
		printf("zero diagonal elements in string %d",istr);
	#endif
	
	getchar();
	exit(1);
	}
	else {
	x[istr] /= ap;
	}
	flag[Amat[ii].i] = true;
	}
	}


	} // seidel


	*/

	/*
	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = new doublerealT[n_a[0] + 1];
	doublerealT *diag1=NULL;
	if (ilevel > 1) {
	diag1 = new doublerealT[n_a[1] + 1];
	}
	doublerealT *diag2=NULL;
	if (ilevel > 2) {
	diag2 = new doublerealT[n_a[2] + 1];
	}
	doublerealT *diag3 = NULL;
	if (ilevel > 3) {
	diag3 = new doublerealT[n_a[3] + 1];
	}
	doublerealT *diag4 = NULL;
	if (ilevel > 4) {
	diag4 = new doublerealT[n_a[4] + 1];
	}
	doublerealT *diag5 = NULL;
	if (ilevel > 5) {
	diag5 = new doublerealT[n_a[5] + 1];
	}
	doublerealT *diag6 = NULL;
	if (ilevel > 6) {
	diag6 = new doublerealT[n_a[6] + 1];
	}
	doublerealT *diag7 = NULL;
	if (ilevel > 7) {
	diag7 = new doublerealT[n_a[7] + 1];
	}
	doublerealT *diag8 = NULL;
	if (ilevel > 8) {
	diag8 = new doublerealT[n_a[8] + 1];
	}
	doublerealT *diag9 = NULL;
	if (ilevel > 9) {
	diag9 = new doublerealT[n_a[9] + 1];
	}
	doublerealT *diag10 = NULL;
	if (ilevel > 10) {
	diag10 = new doublerealT[n_a[10] + 1];
	}
	doublerealT *diag11 = NULL;
	if (ilevel > 11) {
	diag11 = new doublerealT[n_a[11] + 1];
	}
	doublerealT *diag12 = NULL;
	if (ilevel > 12) {
	diag12 = new doublerealT[n_a[12] + 1];
	}
	doublerealT *diag13 = NULL;
	if (ilevel > 13) {
	diag13 = new doublerealT[n_a[13] + 1];
	}
	doublerealT *diag14 = NULL;
	if (ilevel > 14) {
	diag14 = new doublerealT[n_a[14] + 1];
	}
	doublerealT *diag15 = NULL;
	if (ilevel > 15) {
	diag15 = new doublerealT[n_a[15] + 1];
	}
	doublerealT *diag16 = NULL;
	if (ilevel > 16) {
	diag16 = new doublerealT[n_a[16] + 1];
	}
	*/

	// Т.к. деление очень медленное то мы поделим лишь один раз.
	doublerealT *diag0 = NULL;
	//diag0 = new doublerealT[n_a[0] + 1];
	diag0 = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(diag0, "diag0", "classic_aglomerative_amg_5", (n_a[0] + 1));

	doublerealT *diag1 = NULL;
	if (ilevel > 1) {
		//diag1 = new doublerealT[n_a[1] + 1];
		diag1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag1, "diag1", "classic_aglomerative_amg_5", (n_a[1] + 1));
	}
	doublerealT *diag2 = NULL;
	if (ilevel > 2) {
		//diag2 = new doublerealT[n_a[2] + 1];
		diag2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag2, "diag2", "classic_aglomerative_amg_5", (n_a[2] + 1));
	}
	doublerealT *diag3 = NULL;
	if (ilevel > 3) {
		//diag3 = new doublerealT[n_a[3] + 1];
		diag3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag3, "diag3", "classic_aglomerative_amg_5", (n_a[3] + 1));
	}
	doublerealT *diag4 = NULL;
	if (ilevel > 4) {
		//diag4 = new doublerealT[n_a[4] + 1];
		diag4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag4, "diag4", "classic_aglomerative_amg_5", (n_a[4] + 1));
	}
	doublerealT *diag5 = NULL;
	if (ilevel > 5) {
		//diag5 = new doublerealT[n_a[5] + 1];
		diag5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag5, "diag5", "classic_aglomerative_amg_5", (n_a[5] + 1));
	}
	doublerealT *diag6 = NULL;
	if (ilevel > 6) {
		//diag6 = new doublerealT[n_a[6] + 1];
		diag6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag6, "diag6", "classic_aglomerative_amg_5", (n_a[6] + 1));
	}
	doublerealT *diag7 = NULL;
	if (ilevel > 7) {
		//diag7 = new doublerealT[n_a[7] + 1];
		diag7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag7, "diag7", "classic_aglomerative_amg_5", (n_a[7] + 1));
	}
	doublerealT *diag8 = NULL;
	if (ilevel > 8) {
		// diag8 = new doublerealT[n_a[8] + 1];
		diag8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(diag8, "diag8", "classic_aglomerative_amg_5", (n_a[8] + 1));
	}
	doublerealT *diag9 = NULL;
	if (ilevel > 9) {
		// diag9 = new doublerealT[n_a[9] + 1];
		diag9 = (doublerealT*)malloc((n_a[9] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag9, "diag9", "classic_aglomerative_amg_5", (n_a[9] + 1));
	}
	doublerealT *diag10 = NULL;
	if (ilevel > 10) {
		// diag10 = new doublerealT[n_a[10] + 1];
		diag10 = (doublerealT*)malloc((n_a[10] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag10, "diag10", "classic_aglomerative_amg_5", (n_a[10] + 1));
	}
	doublerealT *diag11 = NULL;
	if (ilevel > 11) {
		// diag11 = new doublerealT[n_a[11] + 1];
		diag11 = (doublerealT*)malloc((n_a[11] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag11, "diag11", "classic_aglomerative_amg_5", (n_a[11] + 1));
	}
	doublerealT *diag12 = NULL;
	if (ilevel > 12) {
		// diag12 = new doublerealT[n_a[12] + 1];
		diag12 = (doublerealT*)malloc((n_a[12] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag12, "diag12", "classic_aglomerative_amg_5", (n_a[12] + 1));
	}
	doublerealT *diag13 = NULL;
	if (ilevel > 13) {
		// diag13 = new doublerealT[n_a[13] + 1];
		diag13 = (doublerealT*)malloc((n_a[13] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag13, "diag13", "classic_aglomerative_amg_5", (n_a[13] + 1));
	}
	doublerealT *diag14 = NULL;
	if (ilevel > 14) {
		// diag14 = new doublerealT[n_a[14] + 1];
		diag14 = (doublerealT*)malloc((n_a[14] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag14, "diag14", "classic_aglomerative_amg_5", (n_a[14] + 1));
	}
	doublerealT *diag15 = NULL;
	if (ilevel > 15) {
		// diag15 = new doublerealT[n_a[15] + 1];
		diag15 = (doublerealT*)malloc((n_a[15] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag15, "diag15", "classic_aglomerative_amg_5", (n_a[15] + 1));
	}
	doublerealT *diag16 = NULL;
	if (ilevel > 16) {
		// diag16 = new doublerealT[n_a[16] + 1];
		diag16 = (doublerealT*)malloc((n_a[16] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag16, "diag16", "classic_aglomerative_amg_5", (n_a[16] + 1));
	}
	doublerealT *diag17 = NULL;
	if (ilevel > 17) {
		// diag17 = new doublerealT[n_a[17] + 1];
		diag17 = (doublerealT*)malloc((n_a[17] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag17, "diag17", "classic_aglomerative_amg_5", (n_a[17] + 1));
	}
	doublerealT *diag18 = NULL;
	if (ilevel > 18) {
		// diag18 = new doublerealT[n_a[18] + 1];
		diag18 = (doublerealT*)malloc((n_a[18] + 1) * sizeof(doublerealT));
		handle_error<doublerealT>(diag18, "diag18", "classic_aglomerative_amg_5", (n_a[18] + 1));
	}

	bnested_desection_global_amg = NULL;
	bool *nested_desection0 = NULL;
	bool *nested_desection1 = NULL;
	bool *nested_desection2 = NULL;
	bool *nested_desection3 = NULL;
	bool *nested_desection4 = NULL;
	bool *nested_desection5 = NULL;
	bool *nested_desection6 = NULL;
	bool *nested_desection7 = NULL;
	bool *nested_desection8 = NULL;
	bool *nested_desection9 = NULL;
	bool *nested_desection10 = NULL;
	bool *nested_desection11 = NULL;
	bool *nested_desection12 = NULL;
	bool *nested_desection13 = NULL;
	bool *nested_desection14 = NULL;
	bool *nested_desection15 = NULL;
	bool *nested_desection16 = NULL;
	bool *nested_desection17 = NULL;
	bool *nested_desection18 = NULL;
	if (!bonly_serial) {
		// nested desection start
		bnested_desection_global_amg = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(bnested_desection_global_amg, "bnested_desection_global_amg", "classic_aglomerative_amg_5", (n_a[0] + 1));


		nested_desection0 = (bool*)malloc((n_a[0] + 1)*sizeof(bool));
		handle_error<bool>(nested_desection0, "nested_desection0", "classic_aglomerative_amg_5", (n_a[0] + 1));


		if (ilevel > 1) {
			nested_desection1 = (bool*)malloc((n_a[1] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection1, "nested_desection1", "classic_aglomerative_amg_5", (n_a[1] + 1));
		}

		if (ilevel > 2) {
			nested_desection2 = (bool*)malloc((n_a[2] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection2, "nested_desection2", "classic_aglomerative_amg_5", (n_a[2] + 1));
		}

		if (ilevel > 3) {
			nested_desection3 = (bool*)malloc((n_a[3] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection3, "nested_desection3", "classic_aglomerative_amg_5", (n_a[3] + 1));
		}

		if (ilevel > 4) {
			nested_desection4 = (bool*)malloc((n_a[4] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection4, "nested_desection4", "classic_aglomerative_amg_5", (n_a[4] + 1));
		}

		if (ilevel > 5) {
			nested_desection5 = (bool*)malloc((n_a[5] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection5, "nested_desection5", "classic_aglomerative_amg_5", (n_a[5] + 1));
		}

		if (ilevel > 6) {
			nested_desection6 = (bool*)malloc((n_a[6] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection6, "nested_desection6", "classic_aglomerative_amg_5", (n_a[6] + 1));
		}

		if (ilevel > 7) {
			nested_desection7 = (bool*)malloc((n_a[7] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection7, "nested_desection7", "classic_aglomerative_amg_5", (n_a[7] + 1));
		}

		if (ilevel > 8) {
			nested_desection8 = (bool*)malloc((n_a[8] + 1)*sizeof(bool));
			handle_error<bool>(nested_desection8, "nested_desection8", "classic_aglomerative_amg_5", (n_a[8] + 1));
		}

		if (ilevel > 9) {
			nested_desection9 = (bool*)malloc((n_a[9] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection9, "nested_desection9", "classic_aglomerative_amg_5", (n_a[9] + 1));
		}

		if (ilevel > 10) {
			nested_desection10 = (bool*)malloc((n_a[10] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection10, "nested_desection10", "classic_aglomerative_amg_5", (n_a[10] + 1));
		}

		if (ilevel > 11) {
			nested_desection11 = (bool*)malloc((n_a[11] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection11, "nested_desection11", "classic_aglomerative_amg_5", (n_a[11] + 1));
		}

		if (ilevel > 12) {
			nested_desection12 = (bool*)malloc((n_a[12] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection12, "nested_desection12", "classic_aglomerative_amg_5", (n_a[12] + 1));
		}

		if (ilevel > 13) {
			nested_desection13 = (bool*)malloc((n_a[13] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection13, "nested_desection13", "classic_aglomerative_amg_5", (n_a[13] + 1));
		}

		if (ilevel > 14) {
			nested_desection14 = (bool*)malloc((n_a[14] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection14, "nested_desection14", "classic_aglomerative_amg_5", (n_a[14] + 1));
		}

		if (ilevel > 15) {
			nested_desection15 = (bool*)malloc((n_a[15] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection15, "nested_desection15", "classic_aglomerative_amg_5", (n_a[15] + 1));
		}

		if (ilevel > 16) {
			nested_desection16 = (bool*)malloc((n_a[16] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection16, "nested_desection16", "classic_aglomerative_amg_5", (n_a[16] + 1));
		}

		if (ilevel > 17) {
			nested_desection17 = (bool*)malloc((n_a[17] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection17, "nested_desection17", "classic_aglomerative_amg_5", (n_a[17] + 1));
		}

		if (ilevel > 18) {
			nested_desection18 = (bool*)malloc((n_a[18] + 1) * sizeof(bool));
			handle_error<bool>(nested_desection18, "nested_desection18", "classic_aglomerative_amg_5", (n_a[18] + 1));
		}
	}
	// nested_desection_end

	integer *row_ptr_start = NULL;
	const integer isize_row_ptr = 4 * n_a[0] + 1;
	//row_ptr_start = new integer[4 * n_a[0] + 1];
	row_ptr_start = (integer*)malloc((isize_row_ptr)*sizeof(integer));
	handle_error<integer>(row_ptr_start, " row_ptr_start", "classic_aglomerative_amg_5", (isize_row_ptr));

	integer *row_ptr_end = NULL;
	//row_ptr_end = new integer[4 * n_a[0] + 1];
	row_ptr_end = (integer*)malloc((isize_row_ptr)*sizeof(integer));
	handle_error<integer>(row_ptr_end, " row_ptr_end", "classic_aglomerative_amg_5", (isize_row_ptr));

	LEVEL_ADDITIONAL_DATA* milu2 = NULL;
	// инициализация.
	init_level_additional_data(milu2, ilevel);

	// ILU0
	LEVEL_ADDITIONAL_DATA0* milu0 = NULL;
	// инициализация.
	init_level_additional_data(milu0, ilevel);

	// Освобождение общей памяти в ILU буффере.
	if (milu_gl_buffer.alu_copy != NULL) delete[] milu_gl_buffer.alu_copy;
	if (milu_gl_buffer.jlu_copy != NULL) delete[] milu_gl_buffer.jlu_copy;
	if (milu_gl_buffer.ju_copy != NULL) delete[] milu_gl_buffer.ju_copy;
	milu_gl_buffer.alu_copy = NULL;
	milu_gl_buffer.jlu_copy = NULL;
	milu_gl_buffer.ju_copy = NULL;

	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	for (integer i = 1; i <= n; i++) {
		flag[i] = false;
	}
	for (integer ii = 1; ii <= nnz_a[0]; ii++) {
		if (flag[Amat[ii].i] == false) {
			integer istr = Amat[ii].i;
			integer ic = ii;
			integer icdiag = ii;
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("nado uvelichit isize_row_ptr %lld", istr);
#else
				printf("nado uvelichit isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_start[istr] = ii;
			doublerealT ap = 0.0; // значение на диагонали.
			//x[istr] = b[istr];
			while ((ic <= nnz_a[0]) && (Amat[ic].i == istr)) {
				if (Amat[ic].j != istr) {
					//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
					// Все внедиагональные элементы должны быть строго отрицательны.
					// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
					if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
						printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %lld...\n", Amat[ic].aij, istr);
#else
						printf("polochitelnji vnediagonalnj element %e in matrix level 0 in string %d...\n", Amat[ic].aij, istr);
#endif
						
						system("PAUSE");
					}
				}
				else {
					// дмагональный элемент строго положителен.
					ap = Amat[ic].aij;
					icdiag = ic;
				}
				ic++;
			}
			if (istr >= isize_row_ptr) {
#if doubleintprecision == 1
				printf("nado uvelichit isize_row_ptr %lld", istr);
#else
				printf("nado uvelichit isize_row_ptr %d", istr);
#endif
				
				//getchar();
				system("PAUSE");
				exit(1);
			}
			row_ptr_end[istr] = ic - 1;
			if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
				printf("zero diagonal elements in string %lld in basic matrix", istr);
#else
				printf("zero diagonal elements in string %d in basic matrix", istr);
#endif
				
				system("PAUSE");
				exit(1);
			}
			else {
				//x[istr] /= ap;
			}

			flag[Amat[ii].i] = true;
			Ak1 temp = Amat[ii];
			Amat[ii] = Amat[icdiag];
			Amat[icdiag] = temp;
			if (bmemory_savings) {
				// По исходному номеру получаем текущий,
				// но теперь два текущих поменялись.
				the_original_order_of_values[the_original_order_of_values_reverse[ii]] = icdiag;
				the_original_order_of_values[the_original_order_of_values_reverse[icdiag]] = ii;
			}


			diag0[Amat[ii].i] = ap; // для ускорения вычисления невязки.
			Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
		}
	}

	if (bILU2smoother == 2) {
		// ILU2
		printf("apply ilu2 smoother for number 0 level\n");
		equation3DtoCRSRUMBA1(milu2[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	if (bILU2smoother == 1) {
		// ILU0
		printf("apply ilu0 smoother for number 0 level\n");
		equation3DtoCRSRUMBA0(milu0[0], true, Amat, 1, n_a[0], row_ptr_start, row_ptr_end, 0, 0);
	}
	bool bstop = false;


	// 14 сентября 2015 понедельник четвёртый уровень вложенности.
	// Уровни вложенности с первого по седьмой сразу. 12.07.2016.

	// Заголовочная надпись :
	if (bprint_mesage_diagnostic) {
		printf("1. positive connections %% 2. max positive/ diagonal %%\n");
	}

	for (integer ilevel_detector = 1; ilevel_detector <= 20; ilevel_detector++) {

		// Обработка матрицы действует до седьмого уровня включительно, но
		// сбор статистики желательно сделать для всех уровней.
		const integer istop_level_scan = 18;

		if (ilevel > ilevel_detector) {

			doublerealT inum_vnediagonal_all = 0.0;
			doublerealT inum_only_positive_vnediagonal = 0.0;
			doublerealT memo_diagonal_element = 0.0;
			doublerealT max_positive_connections_element = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement = -1.0;
			doublerealT ratio_positive_connections_by_diagonalelement_avg = 0.0;


			for (integer i = 1; i <= n; i++) {
				flag[i] = false;
			}
			integer ist = 1;
			for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
				ist += nnz_a[ilev];
			}
			integer iend = 0;
			for (integer ilev = 0; ilev <= ilevel_detector; ilev++) {
				iend += nnz_a[ilev];
			}
			double dn_num = 0.0;
			for (integer ii = ist; ii <= iend; ii++) {
				if (flag[Amat[ii].i] == false) {
					dn_num += 1.0;
					max_positive_connections_element = -1.0;
					integer istr = Amat[ii].i;
					integer ic = ii;
					integer icdiag = ii;
					integer istart_row_ptr = istr;
					for (integer ilev = 0; ilev < ilevel_detector; ilev++) {
						istart_row_ptr += n_a[ilev];
					}
					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("nado uvelichit isize_row_ptr %lld", istart_row_ptr);
#else
						printf("nado uvelichit isize_row_ptr %d", istart_row_ptr);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_start[istart_row_ptr] = ii;
					}
					doublerealT ap = 0.0;
					//x[istr] = b[istr];
					while ((ic <= iend) && (Amat[ic].i == istr)) {
						if (Amat[ic].j != istr) {
							//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
							inum_vnediagonal_all += 1.0;
							// Все внедиагональные элементы должны быть строго отрицательны.
							// Если это не так то надо выдавать предупреждение о логической ошибке пользователю.
							if (Amat[ic].aij >= 0.0) {
#if doubleintprecision == 1
								//printf("polochitelnji vnediagonalnj element %e in matrix level %lld in string %lld...\n", Amat[ic].aij, ilevel_detector, istr);
#else
								//printf("polochitelnji vnediagonalnj element %e in matrix level %d in string %d...\n", Amat[ic].aij, ilevel_detector, istr);
#endif
									//system("PAUSE");
								inum_only_positive_vnediagonal += 1.0;

								// Определение величины максимальной внедиагональной связи.
								if (max_positive_connections_element < Amat[ic].aij) {
									max_positive_connections_element = Amat[ic].aij;
								}
							}
						}
						else {
							ap = Amat[ic].aij;
							memo_diagonal_element = ap;
							icdiag = ic;
						}
						ic++;
					}
					if (istart_row_ptr >= isize_row_ptr) {
#if doubleintprecision == 1
						printf("nado uvelichit isize_row_ptr %lld", istart_row_ptr);
#else
						printf("nado uvelichit isize_row_ptr %d", istart_row_ptr);
#endif
						
						//getchar();
						system("PAUSE");
						exit(1);
					}
					if (ilevel_detector <= istop_level_scan) {
						row_ptr_end[istart_row_ptr] = ic - 1;
					}
					if (fabs(ap) < RealZERO) {
#if doubleintprecision == 1
						printf("zero diagonal elements in string %lld in level %lld matrix", istr, ilevel);
#else
						printf("zero diagonal elements in string %d in level %d matrix", istr, ilevel);
#endif
						

						system("PAUSE");
						exit(1);
					}
					else {
						//x[istr] /= ap;
					}
					ratio_positive_connections_by_diagonalelement_avg += max_positive_connections_element / memo_diagonal_element;
					if (ratio_positive_connections_by_diagonalelement < max_positive_connections_element / memo_diagonal_element) {
						ratio_positive_connections_by_diagonalelement = max_positive_connections_element / memo_diagonal_element;

					}
					flag[Amat[ii].i] = true;
					if (ilevel_detector <= istop_level_scan) {
						Ak1 temp = Amat[ii];
						Amat[ii] = Amat[icdiag];
						Amat[icdiag] = temp;
						switch (ilevel_detector) {
						case 1: diag1[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 2: diag2[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 3: diag3[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 4: diag4[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 5: diag5[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 6: diag6[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 7: diag7[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 8: diag8[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 9: diag9[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 10: diag10[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 11: diag11[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 12: diag12[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 13: diag13[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 14: diag14[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 15: diag15[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 16: diag16[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 17: diag17[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						case 18: diag18[Amat[ii].i] = ap; break;// для ускорения вычисления невязки.
						default: printf("ilevel_detector incorrect\n");
							//getchar();
							system("PAUSE");
							break;
						}

						Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
					}
				}
			}

			integer iadd_now = 0;
			for (integer i54 = 1; i54 <= ilevel_detector; i54++) {
				iadd_now += n_a[i54 - 1];
			}
			
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 2) {
#if doubleintprecision == 1
					printf("apply ilu2 smoother for number %lld level\n", ilevel_detector);
#else
					printf("apply ilu2 smoother for number %d level\n", ilevel_detector);
#endif
					
					equation3DtoCRSRUMBA1(milu2[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}
			if (ilevel_detector <= istop_level_scan) {
				if (bILU2smoother == 1) {
					// ILU0
#if doubleintprecision == 1
					printf("apply ilu0 smoother for number %lld level\n", ilevel_detector);
#else
					printf("apply ilu0 smoother for number %d level\n", ilevel_detector);
#endif
					
					// iadd_now=n_a[0]+...+n_a[ilevel_detector-1];
					equation3DtoCRSRUMBA0(milu0[ilevel_detector], true,
						Amat, 1, n_a[ilevel_detector], row_ptr_start, row_ptr_end, iadd_now, ilevel_detector);
				}
			}


			// statistic log :
			if (bprint_mesage_diagnostic) {
				//printf("procent positive connections %e \n", 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all);
				//printf("the ratio of the maximum positive connections to the diagonal\n");
				//printf("element in the row, in procent %e\n", 100.0*ratio_positive_connections_by_diagonalelement);
				//printf("\n");
#if doubleintprecision == 1
				printf("%lld %e  %e%% %e%%\n", ilevel_detector, 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100.0*ratio_positive_connections_by_diagonalelement, 100.0*ratio_positive_connections_by_diagonalelement_avg / dn_num);
#else
				printf("%d %e  %e%% %e%%\n", ilevel_detector, 100.0*inum_only_positive_vnediagonal / inum_vnediagonal_all, 100.0*ratio_positive_connections_by_diagonalelement, 100.0*ratio_positive_connections_by_diagonalelement_avg / dn_num);
#endif
				
				
			}
		}


	}

	if (bstop) exit(1);

	if (bILU2smoother > 0) {
		// Пауза только в случае применения ILU декомпозиции.
		//system("PAUSE");
		if (bILU2smoother == 2) {
			// Осторожно возможно код быстро устареет.
			// Выделение оперативной памяти под централизованное хранилище 
			// для ILU.
			memory_allocation_apostoriory_buffer_ilu(milu2, ilevel - 1);
		}
	}


	// ЗАКОМЕНТИРОВАННЫЙ КОД ОТНОСИТСЯ К УСТАРЕВШЕМУ. 
	// 4 ноября 2016 прописано 15 уровней вложенности.



	// восьмой уровень вложенности.
	/*
	if (ilevel > 8) {
	for (integer i = 1; i <= n; i++) {
	flag[i] = false;
	}
	integer ist = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + 1;
	integer iend = nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7] + nnz_a[8];
	for (integer ii = ist; ii <= iend; ii++) {
	if (flag[Amat[ii].i] == false) {
	integer istr = Amat[ii].i;
	integer ic = ii;
	integer icdiag = ii;
	row_ptr_start[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ii;
	doublerealT ap = 0.0;
	//x[istr] = b[istr];
	while ((ic <= iend) && (Amat[ic].i == istr)) {
	if (Amat[ic].j != istr) {
	//x[istr] += -Amat[ic].aij*x[Amat[ic].j];
	}
	else {
	ap = Amat[ic].aij;
	icdiag = ic;
	}
	ic++;
	}
	row_ptr_end[istr + n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]] = ic - 1;
	if (fabs(ap) < RealZERO) {
	#if doubleintprecision == 1
		printf("zero diagonal elements in string %lld in level 7 matrix", istr);
	#else
		printf("zero diagonal elements in string %d in level 7 matrix", istr);
	#endif
	
	system("PAUSE");
	exit(1);
	}
	else {
	//x[istr] /= ap;
	}

	flag[Amat[ii].i] = true;
	Ak1 temp = Amat[ii];
	Amat[ii] = Amat[icdiag];
	Amat[icdiag] = temp;
	diag8[Amat[ii].i] = ap; // для ускорения вычисления невязки.
	Amat[ii].aij = 1.0 / ap; // умножение быстрей деления.
	}
	}
	}
	*/


	if (!bonly_serial) {
		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 0.
		// nested_desection0
		nested_desection_patch(Amat, n_a[0], nested_desection0, row_ptr_start, row_ptr_end, 0);
		if (bprint_mesage_diagnostic) {
			printf("part1\n");
		}


		// Готовим nested desection
		// для двух потоков.
		// Самая подробная матрица 1.
		// nested_desection1
		if (ilevel > 1) {
			nested_desection_patch(Amat, n_a[1], nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
			if (bprint_mesage_diagnostic) {
				printf("part2\n");
			}
		}
		if (ilevel > 2) {
			nested_desection_patch(Amat, n_a[2], nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
			if (bprint_mesage_diagnostic) {
				printf("part3\n");
			}
		}
		if (ilevel > 3) {
			nested_desection_patch(Amat, n_a[3], nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
			if (bprint_mesage_diagnostic) {
				printf("part4\n");
			}
		}
		if (ilevel > 4) {
			nested_desection_patch(Amat, n_a[4], nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
			if (bprint_mesage_diagnostic) {
				printf("part5\n");
			}
		}
		if (ilevel > 5) {
			nested_desection_patch(Amat, n_a[5], nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
			if (bprint_mesage_diagnostic) {
				printf("part6\n");
			}
		}
		if (ilevel > 6) {
			nested_desection_patch(Amat, n_a[6], nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
			if (bprint_mesage_diagnostic) {
				printf("part7\n");
			}
		}
		if (ilevel > 7) {
			nested_desection_patch(Amat, n_a[7], nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
			if (bprint_mesage_diagnostic) {
				printf("part8 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 8) {
			nested_desection_patch(Amat, n_a[8], nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
			if (bprint_mesage_diagnostic) {
				printf("part9 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 9) {
			nested_desection_patch(Amat, n_a[9], nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
			if (bprint_mesage_diagnostic) {
				printf("part10 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 10) {
			nested_desection_patch(Amat, n_a[10], nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
			if (bprint_mesage_diagnostic) {
				printf("part11 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 11) {
			nested_desection_patch(Amat, n_a[11], nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
			if (bprint_mesage_diagnostic) {
				printf("part12 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 12) {
			nested_desection_patch(Amat, n_a[12], nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
			if (bprint_mesage_diagnostic) {
				printf("part13 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 13) {
			nested_desection_patch(Amat, n_a[13], nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
			if (bprint_mesage_diagnostic) {
				printf("part14 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 14) {
			nested_desection_patch(Amat, n_a[14], nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
			if (bprint_mesage_diagnostic) {
				printf("part15 \n");
				printf("nested desection is finish\n");
			}
		}
		if (ilevel > 15) {
			nested_desection_patch(Amat, n_a[15], nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
			if (bprint_mesage_diagnostic) {
				printf("part16 \n");
				printf("nested desection is finish\n");
			}
		}
	}


	// smoother.
	// 9 september 2015.
	// q - quick.
	// seidelq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
	//void seidelq(Ak1* &Amat, integer istartq, integer iendq, doublerealT* &x, doublerealT* &b, integer * &row_ptr_start, integer * &row_ptr_end, integer iadd)
	//{
	// istart - начальная позиция ненулевых элементов в матрице А.
	// iend - конечная позиция ненулевых элементов в матрице А.
	//integer startpos = istartq + iadd;
	//integer endpos = iendq+iadd;
	//for (integer ii = startpos; ii <= endpos; ii++) {
	//integer istr = ii - iadd;
	//x[istr] = b[istr];
	//for (integer ii1 = row_ptr_start[ii] + 1; ii1 <= row_ptr_end[ii]; ii1++)
	//{
	//x[istr] += -Amat[ii1].aij*x[Amat[ii1].j];
	//}
	//x[istr] *= Amat[row_ptr_start[ii]].aij;
	//}


	//} // seidelq

	// Освобождение памяти используемой на этапе построения иерархии матриц.

	//delete[] this_is_C_node;
	//delete[] this_is_F_node;
	if (this_is_C_node!=NULL) {
	   free(this_is_C_node);
	   this_is_C_node=NULL;
	}
	if (this_is_F_node!=NULL) {
	   free(this_is_F_node);
       this_is_F_node=NULL;
	}
	//delete[] hash_table;
	free(hash_table);
	free(hash_table2);
	//delete[] istack;
	//delete[] istack2;
	free(istack);
	free(istack2);


	if (bprint_mesage_diagnostic) {
		printf("cycling: V cycle.\n");
#if doubleintprecision == 1
		printf("level=%lld\n", ilevel);
#else
		printf("level=%d\n", ilevel);
#endif
		
		printf("multigrid R.P.Fedorenko 1961.\n");
		printf("standart aglomerative algebraic multigrid method.\n");
	}
	if (debug_reshime) system("pause");
	//exit(1);

	// 10 11 21 multigrid tutorial Вильм Бригг.
	// Высокорейнольдсовое обтекание квадрата в DavisTest,
	// решатель работал на x-компоненте скорости. Сетка сгущалась
	// к поверхности квадрата достаточно сильно. Это дало расходимость
	// amg v0.08 решателя на данной задаче с параметрами nu1=4, nu2=3.
	// Параметры nu1=8, nu2=7 обеспечили сходимость вычислительного процесса.

	// Возможно имеет смысл сделать управляемый выход из сглаживателя, допустим
	// если невязка опустилась ниже первоначальной в 0.1 раз то имеет смысл досрочно 
	// оборвать итерации сглаживателя.


	// nu1=0; nu2=2; nFinestSweeps=2 is recomended 
	// Masashi Imano. Optimization of parameter setting for GAMG
	// solver in simple solver. 
	// Aug 26th 2012. OpeanFOAM study. 
	// nu1=0 имеем расходимость на BSK Dmitrii.
	// nFinestSweeps=2 имеем расходимость на BSK Dmitrii.
	// BSK Dmitrii сходится при nu1=1, nu2=2, nFinestSweeps=3.

	integer nu1 = 1; // minimum value 1 // 4 // 8
	integer nu2 = 2; // minimum value 2 // 3 // 7

	// на задаче Finned Heat Sync из первого туториала Icepak была обнаружена расходимость 
	// для Y скорости и поправки давления. При этом обтекание куба отлично считалось на равномерной
	// сетки с nu1=1, nu2=2 даже при весьма больших числах Рейнольдса.
	// при nu1=10, nu2=10 скорости разрешаются хорошо и проблем с ними нет, но поправка давления по прежнему даёт сбой.
	// при nu==20 сбой всё равно есть.
	// не помогло.
	//nu1 = 40;
	//nu2 = 40;

	integer nFinestSweeps = 2;

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	nu1 = my_amg_manager.nu1;
	nu2 = my_amg_manager.nu2;
	nFinestSweeps = my_amg_manager.nFinnest;

	//if (iVar == PAM) {
	//nFinestSweeps = 300;
	//nu1 = 0;
	//nu2 = 20;
	//}
	// для Finner Heat Sink надо усилить сглаживания.
	// Это не помогает будет перенаправление на другой алгоритм.
	//if (iVar == PAM) {
	//nu1 = 3;
	//nu2 = 3;
	//nFinestSweeps = 6;
	//}
	const bool btheoryGuideANSYSFluent = false;
	if (iVar != PAM) {
		if (btheoryGuideANSYSFluent) {
			// Так написано в Theory Guide ANSYS Fluent.
			nu1 = 0;
			nu2 = 1;
			nFinestSweeps = 1;
		}
	}



	// Двойной вакуумный промежуток вызывает проблемы сходимости :
	//nu1 = 10;
	//nu2 = 20;

	// Смысл этих параметров в том что они экономят ресурсы процессора
	// в теории осуществляя досрочный выход из пред и пост сглаживаний.
	// Т.е. параметры nu1,nu2 задаются с запасом и алгоритм сам использует
	// сколько ему взять итераций для оптимальной работы (сходимости). 
	// Пользователь не ломает голову какие задавать параметры nu1, nu2 
	// а задаёт их верхние предельные значения. 
	doublerealT process_flow_beta = 0.7;
	doublerealT process_flow_alpha = 0.1;
	bool process_flow_logic = false;

	if (process_flow_logic) {
		nu1 = 40;
		nu2 = 40;
	}

	if (bprint_mesage_diagnostic) {
		printf("grid complexity is %1.2f\n", dr_grid_complexity);
		printf("Prolongation operator complexity is %1.2f  %1.2f\n", (1.0*nnz_P_memo_all / nnz_P_memo_0), (1.0*nnz_P_memo_all/n_a[0]));
#if doubleintprecision == 1
		printf("nu1=%lld, nu2=%lld\n", nu1, nu2);
#else
		printf("nu1=%d, nu2=%d\n", nu1, nu2);
#endif
		
	}

	//ilevel = 1; //debug
	doublerealT rho = 1.0;
	doublerealT dres = 1.0;
	integer iiter = 1;
	//const doublerealT tolerance = 1.0e-12;
	// 13 февраля 2016 калибруем точность солвера с целью ускорения получения результата.
	// Т.к. нам ненужна точность выше чем десятая доля градуса по температуре.
	// начальное значение невязки составляет примерно 7000.0.
	doublerealT tolerance =  0.0001; // точность выхода по классическому определению L2 нормы.
	tolerance = 1.0e-26; // 16 августа 2016.
	tolerance = 1.0e-8; // КОСМОС unsteady 14_10_2016.
	// 23 октября 2016
	if (bSIMPLErun_now_for_temperature) {
		// Решаем cfd задачи.
		// Сходится только с этим критерием выхода по невязке.
		tolerance = 1.0e-8;
	}


	doublerealT *residual_fine = NULL;
	//residual_fine = new doublerealT[n_a[0] + 1];
	doublerealT *residual_coarse = NULL;
	doublerealT* error_approx_coarse = NULL;
	doublerealT *residual_fine1 = NULL;
	doublerealT *residual_coarse1 = NULL;
	doublerealT* error_approx_coarse1 = NULL;
	doublerealT *error_approx_fine1 = NULL;
	doublerealT *residual_fine2 = NULL;
	doublerealT *residual_coarse2 = NULL;
	doublerealT* error_approx_coarse2 = NULL;
	doublerealT *error_approx_fine2 = NULL;
	doublerealT *residual_fine3 = NULL;
	doublerealT *residual_coarse3 = NULL;
	doublerealT* error_approx_coarse3 = NULL;
	doublerealT *error_approx_fine3 = NULL;
	doublerealT *residual_fine4 = NULL;
	doublerealT *residual_coarse4 = NULL;
	doublerealT *error_approx_coarse4 = NULL;
	doublerealT *error_approx_fine4 = NULL;
	doublerealT *residual_fine5 = NULL;
	doublerealT *residual_coarse5 = NULL;
	doublerealT* error_approx_coarse5 = NULL;
	doublerealT *error_approx_fine5 = NULL;
	doublerealT *residual_fine6 = NULL;
	doublerealT *residual_coarse6 = NULL;
	doublerealT* error_approx_coarse6 = NULL;
	doublerealT *error_approx_fine6 = NULL;
	doublerealT *residual_fine7 = NULL;
	doublerealT *residual_coarse7 = NULL;
	doublerealT* error_approx_coarse7 = NULL;
	doublerealT *error_approx_fine7 = NULL;
	doublerealT *residual_fine8 = NULL;
	doublerealT *residual_coarse8 = NULL;
	doublerealT* error_approx_coarse8 = NULL;
	doublerealT *error_approx_fine8 = NULL;
	doublerealT *residual_fine9 = NULL;
	doublerealT *residual_coarse9 = NULL;
	doublerealT* error_approx_coarse9 = NULL;
	doublerealT *error_approx_fine9 = NULL;
	doublerealT *residual_fine10 = NULL;
	doublerealT *residual_coarse10 = NULL;
	doublerealT* error_approx_coarse10 = NULL;
	doublerealT *error_approx_fine10 = NULL;
	doublerealT *residual_fine11 = NULL;
	doublerealT *residual_coarse11 = NULL;
	doublerealT* error_approx_coarse11 = NULL;
	doublerealT *error_approx_fine11 = NULL;
	doublerealT *residual_fine12 = NULL;
	doublerealT *residual_coarse12 = NULL;
	doublerealT* error_approx_coarse12 = NULL;
	doublerealT *error_approx_fine12 = NULL;
	doublerealT *residual_fine13 = NULL;
	doublerealT *residual_coarse13 = NULL;
	doublerealT* error_approx_coarse13 = NULL;
	doublerealT *error_approx_fine13 = NULL;
	doublerealT *residual_fine14 = NULL;
	doublerealT *residual_coarse14 = NULL;
	doublerealT* error_approx_coarse14 = NULL;
	doublerealT *error_approx_fine14 = NULL;
	doublerealT *residual_fine15 = NULL;
	doublerealT *residual_coarse15 = NULL;
	doublerealT* error_approx_coarse15 = NULL;
	doublerealT *error_approx_fine15 = NULL;
	doublerealT *residual_fine16 = NULL;
	doublerealT *residual_coarse16 = NULL;
	doublerealT* error_approx_coarse16 = NULL;
	doublerealT *error_approx_fine16 = NULL;
	doublerealT *residual_fine17 = NULL;
	doublerealT *residual_coarse17 = NULL;
	doublerealT* error_approx_coarse17 = NULL;
	doublerealT *error_approx_fine17 = NULL;
	doublerealT *residual_fine18 = NULL;
	doublerealT *residual_coarse18 = NULL;
	doublerealT* error_approx_coarse18 = NULL;
	doublerealT *error_approx_fine18 = NULL;


	/*
	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	if (residual_fine == NULL) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem : not enough memory on your equipment for residual_fine in classic_aglomerative_amg2 my_agregat_amg...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	if (ilevel > 1) {
	residual_coarse = new doublerealT[n_a[1] + 1];
	error_approx_coarse = new doublerealT[n_a[1] + 1];
	if (ilevel > 2) {
	// residual
	residual_fine1 = new doublerealT[n_a[1] + 1];
	residual_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_coarse1 = new doublerealT[n_a[2] + 1];
	error_approx_fine1 = new doublerealT[n_a[1] + 1];
	if (ilevel > 3) {
	// residual
	residual_fine2 = new doublerealT[n_a[2] + 1];
	residual_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_coarse2 = new doublerealT[n_a[3] + 1];
	error_approx_fine2 = new doublerealT[n_a[2] + 1];
	if (ilevel > 4) {
	// residual
	residual_fine3 = new doublerealT[n_a[3] + 1];
	residual_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_coarse3 = new doublerealT[n_a[4] + 1];
	error_approx_fine3 = new doublerealT[n_a[3] + 1];
	if (ilevel > 5) {
	// residual
	residual_fine4 = new doublerealT[n_a[4] + 1];
	residual_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_coarse4 = new doublerealT[n_a[5] + 1];
	error_approx_fine4 = new doublerealT[n_a[4] + 1];
	if (ilevel > 6) {
	// residual
	residual_fine5 = new doublerealT[n_a[5] + 1];
	residual_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_coarse5 = new doublerealT[n_a[6] + 1];
	error_approx_fine5 = new doublerealT[n_a[5] + 1];
	if (ilevel > 7) {
	// residual
	residual_fine6 = new doublerealT[n_a[6] + 1];
	residual_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_coarse6 = new doublerealT[n_a[7] + 1];
	error_approx_fine6 = new doublerealT[n_a[6] + 1];
	if (ilevel > 8) {
	// residual
	residual_fine7 = new doublerealT[n_a[7] + 1];
	residual_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_coarse7 = new doublerealT[n_a[8] + 1];
	error_approx_fine7 = new doublerealT[n_a[7] + 1];
	if (ilevel > 9) {
	// residual
	residual_fine8 = new doublerealT[n_a[8] + 1];
	residual_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_coarse8 = new doublerealT[n_a[9] + 1];
	error_approx_fine8 = new doublerealT[n_a[8] + 1];
	if (ilevel > 10) {
	// residual
	residual_fine9 = new doublerealT[n_a[9] + 1];
	residual_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_coarse9 = new doublerealT[n_a[10] + 1];
	error_approx_fine9 = new doublerealT[n_a[9] + 1];
	if (ilevel > 11) {
	// residual
	residual_fine10 = new doublerealT[n_a[10] + 1];
	residual_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_coarse10 = new doublerealT[n_a[11] + 1];
	error_approx_fine10 = new doublerealT[n_a[10] + 1];
	if (ilevel > 12) {
	// residual
	residual_fine11 = new doublerealT[n_a[11] + 1];
	residual_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_coarse11 = new doublerealT[n_a[12] + 1];
	error_approx_fine11 = new doublerealT[n_a[11] + 1];
	if (ilevel > 13) {
	// residual
	residual_fine12 = new doublerealT[n_a[12] + 1];
	residual_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_coarse12 = new doublerealT[n_a[13] + 1];
	error_approx_fine12 = new doublerealT[n_a[12] + 1];
	if (ilevel > 14) {
	// residual
	residual_fine13 = new doublerealT[n_a[13] + 1];
	residual_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_coarse13 = new doublerealT[n_a[14] + 1];
	error_approx_fine13 = new doublerealT[n_a[13] + 1];
	if (ilevel > 15) {
	// residual
	residual_fine14 = new doublerealT[n_a[14] + 1];
	residual_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_coarse14 = new doublerealT[n_a[15] + 1];
	error_approx_fine14 = new doublerealT[n_a[14] + 1];
	if (ilevel > 16) {
	// residual
	residual_fine15 = new doublerealT[n_a[15] + 1];
	residual_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_coarse15 = new doublerealT[n_a[16] + 1];
	error_approx_fine15 = new doublerealT[n_a[15] + 1];
	if (ilevel > 17) {
	// residual
	residual_fine16 = new doublerealT[n_a[16] + 1];
	residual_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_coarse16 = new doublerealT[n_a[17] + 1];
	error_approx_fine16 = new doublerealT[n_a[16] + 1];
	if (ilevel > 18) {
	// residual
	residual_fine17 = new doublerealT[n_a[17] + 1];
	residual_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_coarse17 = new doublerealT[n_a[18] + 1];
	error_approx_fine17 = new doublerealT[n_a[17] + 1];
	if (ilevel > 19) {
	// residual
	residual_fine18 = new doublerealT[n_a[18] + 1];
	residual_coarse18 = new doublerealT[n_a[19] + 1];
	error_approx_coarse18 = new doublerealT[n_a[19] + 1];
	error_approx_fine18 = new doublerealT[n_a[18] + 1];
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
	*/

	// лучше выделять оперативную память небольшими блоками т.к.
	// оперативная память фрагментирована системными dll и
	// большого свободного блока может не найтись.


	residual_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(residual_fine, "residual_fine", "classic_aglomerative_amg_5", (n_a[0] + 1));

	if (ilevel > 1) {
		//residual_coarse = new doublerealT[n_a[1] + 1];
		residual_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_coarse, "residual_coarse", "classic_aglomerative_amg_5", (n_a[1] + 1));

		//error_approx_coarse = new doublerealT[n_a[1] + 1];
		error_approx_coarse = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(error_approx_coarse, "error_approx_coarse", "classic_aglomerative_amg_5", (n_a[1] + 1));


		// residual
		//residual_fine1 = new doublerealT[n_a[1] + 1];
		residual_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
		handle_error<doublerealT>(residual_fine1, "residual_fine1", "classic_aglomerative_amg_5", (n_a[1] + 1));

		if (ilevel > 2) {

			//residual_coarse1 = new doublerealT[n_a[2] + 1];
			residual_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_coarse1, "residual_coarse1", "classic_aglomerative_amg_5", (n_a[2] + 1));

			//error_approx_coarse1 = new doublerealT[n_a[2] + 1];
			error_approx_coarse1 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_coarse1, "error_approx_coarse1", "classic_aglomerative_amg_5", (n_a[2] + 1));

			//error_approx_fine1 = new doublerealT[n_a[1] + 1];
			error_approx_fine1 = (doublerealT*)malloc((n_a[1] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(error_approx_fine1, "error_approx_fine1", "classic_aglomerative_amg_5", (n_a[1] + 1));


			// residual
			//residual_fine2 = new doublerealT[n_a[2] + 1];
			residual_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
			handle_error<doublerealT>(residual_fine2, "residual_fine2", "classic_aglomerative_amg_5", (n_a[2] + 1));

			if (ilevel > 3) {

				//residual_coarse2 = new doublerealT[n_a[3] + 1];
				residual_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_coarse2, "residual_coarse2", "classic_aglomerative_amg_5", (n_a[3] + 1));

				//error_approx_coarse2 = new doublerealT[n_a[3] + 1];
				error_approx_coarse2 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_coarse2, "error_approx_coarse2", "classic_aglomerative_amg_5", (n_a[3] + 1));

				//error_approx_fine2 = new doublerealT[n_a[2] + 1];
				error_approx_fine2 = (doublerealT*)malloc((n_a[2] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(error_approx_fine2, "error_approx_fine2", "classic_aglomerative_amg_5", (n_a[2] + 1));


				// residual
				//residual_fine3 = new doublerealT[n_a[3] + 1];
				residual_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
				handle_error<doublerealT>(residual_fine3, "residual_fine3", "classic_aglomerative_amg_5", (n_a[3] + 1));

				if (ilevel > 4) {

					//residual_coarse3 = new doublerealT[n_a[4] + 1];
					residual_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_coarse3, "residual_coarse3", "classic_aglomerative_amg_5", (n_a[4] + 1));

					//error_approx_coarse3 = new doublerealT[n_a[4] + 1];
					error_approx_coarse3 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_coarse3, "error_approx_coarse3", "classic_aglomerative_amg_5", (n_a[4] + 1));

					//error_approx_fine3 = new doublerealT[n_a[3] + 1];
					error_approx_fine3 = (doublerealT*)malloc((n_a[3] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(error_approx_fine3, "error_approx_fine3", "classic_aglomerative_amg_5", (n_a[3] + 1));


					// residual
					//residual_fine4 = new doublerealT[n_a[4] + 1];
					residual_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
					handle_error<doublerealT>(residual_fine4, "residual_fine4", "classic_aglomerative_amg_5", (n_a[4] + 1));

					if (ilevel > 5) {

						//residual_coarse4 = new doublerealT[n_a[5] + 1];
						residual_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_coarse4, "residual_coarse4", "classic_aglomerative_amg_5", (n_a[5] + 1));

						//error_approx_coarse4 = new doublerealT[n_a[5] + 1];
						error_approx_coarse4 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_coarse4, "error_approx_coarse4", "classic_aglomerative_amg_5", (n_a[5] + 1));

						//error_approx_fine4 = new doublerealT[n_a[4] + 1];
						error_approx_fine4 = (doublerealT*)malloc((n_a[4] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(error_approx_fine4, "error_approx_fine4", "classic_aglomerative_amg_5", (n_a[4] + 1));


						// residual
						//residual_fine5 = new doublerealT[n_a[5] + 1];
						residual_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
						handle_error<doublerealT>(residual_fine5, "residual_fine5", "classic_aglomerative_amg_5", (n_a[5] + 1));

						if (ilevel > 6) {

							//residual_coarse5 = new doublerealT[n_a[6] + 1];
							residual_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_coarse5, "residual_coarse5", "classic_aglomerative_amg_5", (n_a[6] + 1));

							//error_approx_coarse5 = new doublerealT[n_a[6] + 1];
							error_approx_coarse5 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_coarse5, "error_approx_coarse5", "classic_aglomerative_amg_5", (n_a[6] + 1));

							//error_approx_fine5 = new doublerealT[n_a[5] + 1];
							error_approx_fine5 = (doublerealT*)malloc((n_a[5] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(error_approx_fine5, "error_approx_fine5", "classic_aglomerative_amg_5", (n_a[5] + 1));


							// residual
							//residual_fine6 = new doublerealT[n_a[6] + 1];
							residual_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
							handle_error<doublerealT>(residual_fine6, "residual_fine6", "classic_aglomerative_amg_5", (n_a[6] + 1));

							if (ilevel > 7) {

								//residual_coarse6 = new doublerealT[n_a[7] + 1];
								residual_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_coarse6, "residual_coarse6", "classic_aglomerative_amg_5", (n_a[7] + 1));

								//error_approx_coarse6 = new doublerealT[n_a[7] + 1];
								error_approx_coarse6 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_coarse6, "error_approx_coarse6", "classic_aglomerative_amg_5", (n_a[7] + 1));

								//error_approx_fine6 = new doublerealT[n_a[6] + 1];
								error_approx_fine6 = (doublerealT*)malloc((n_a[6] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(error_approx_fine6, "error_approx_fine6", "classic_aglomerative_amg_5", (n_a[6] + 1));


								// residual
								//residual_fine7 = new doublerealT[n_a[7] + 1];
								residual_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
								handle_error<doublerealT>(residual_fine7, "residual_fine7", "classic_aglomerative_amg_5", (n_a[7] + 1));

								if (ilevel > 8) {
									//residual_coarse7 = new doublerealT[n_a[8] + 1];
									residual_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_coarse7, "residual_coarse7", "classic_aglomerative_amg_5", (n_a[8] + 1));

									//error_approx_coarse7 = new doublerealT[n_a[8] + 1];
									error_approx_coarse7 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_coarse7, "error_approx_coarse7", "classic_aglomerative_amg_5", (n_a[8] + 1));

									//error_approx_fine7 = new doublerealT[n_a[7] + 1];
									error_approx_fine7 = (doublerealT*)malloc((n_a[7] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(error_approx_fine7, "error_approx_fine7", "classic_aglomerative_amg_5", (n_a[7] + 1));


									// residual
									//residual_fine8 = new doublerealT[n_a[8] + 1];
									residual_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
									handle_error<doublerealT>(residual_fine8, "residual_fine8", "classic_aglomerative_amg_5", (n_a[8] + 1));

									if (ilevel > 9) {
										//residual_coarse8 = new doublerealT[n_a[9] + 1];
										residual_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_coarse8, "residual_coarse8", "classic_aglomerative_amg_5", (n_a[9] + 1));

										//error_approx_coarse8 = new doublerealT[n_a[9] + 1];
										error_approx_coarse8 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_coarse8, "error_approx_coarse8", "classic_aglomerative_amg_5", (n_a[9] + 1));

										//error_approx_fine8 = new doublerealT[n_a[8] + 1];
										error_approx_fine8 = (doublerealT*)malloc((n_a[8] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(error_approx_fine8, "error_approx_fine8", "classic_aglomerative_amg_5", (n_a[8] + 1));


										// residual
										//residual_fine9 = new doublerealT[n_a[9] + 1];
										residual_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
										handle_error<doublerealT>(residual_fine9, "residual_fine9", "classic_aglomerative_amg_5", (n_a[9] + 1));

										if (ilevel > 10) {

											//residual_coarse9 = new doublerealT[n_a[10] + 1];
											residual_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_coarse9, "residual_coarse9", "classic_aglomerative_amg_5", (n_a[10] + 1));

											//error_approx_coarse9 = new doublerealT[n_a[10] + 1];
											error_approx_coarse9 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_coarse9, "error_approx_coarse9", "classic_aglomerative_amg_5", (n_a[10] + 1));

											//error_approx_fine9 = new doublerealT[n_a[9] + 1];
											error_approx_fine9 = (doublerealT*)malloc((n_a[9] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(error_approx_fine9, "error_approx_fine9", "classic_aglomerative_amg_5", (n_a[9] + 1));


											// residual
											//residual_fine10 = new doublerealT[n_a[10] + 1];
											residual_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
											handle_error<doublerealT>(residual_fine10, "residual_fine10", "classic_aglomerative_amg_5", (n_a[10] + 1));

											if (ilevel > 11) {

												//residual_coarse10 = new doublerealT[n_a[11] + 1];
												residual_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_coarse10, "residual_coarse10", "classic_aglomerative_amg_5", (n_a[11] + 1));

												//error_approx_coarse10 = new doublerealT[n_a[11] + 1];
												error_approx_coarse10 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_coarse10, "error_approx_coarse10", "classic_aglomerative_amg_5", (n_a[11] + 1));

												//error_approx_fine10 = new doublerealT[n_a[10] + 1];
												error_approx_fine10 = (doublerealT*)malloc((n_a[10] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(error_approx_fine10, "error_approx_fine10", "classic_aglomerative_amg_5", (n_a[10] + 1));


												// residual
												//residual_fine11 = new doublerealT[n_a[11] + 1];
												residual_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
												handle_error<doublerealT>(residual_fine11, "residual_fine11", "classic_aglomerative_amg_5", (n_a[11] + 1));

												if (ilevel > 12) {

													//residual_coarse11 = new doublerealT[n_a[12] + 1];
													residual_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_coarse11, "residual_coarse11", "classic_aglomerative_amg_5", (n_a[12] + 1));

													//error_approx_coarse11 = new doublerealT[n_a[12] + 1];
													error_approx_coarse11 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_coarse11, "error_approx_coarse11", "classic_aglomerative_amg_5", (n_a[12] + 1));

													//error_approx_fine11 = new doublerealT[n_a[11] + 1];
													error_approx_fine11 = (doublerealT*)malloc((n_a[11] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(error_approx_fine11, "error_approx_fine11", "classic_aglomerative_amg_5", (n_a[11] + 1));


													// residual
													//residual_fine12 = new doublerealT[n_a[12] + 1];
													residual_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
													handle_error<doublerealT>(residual_fine12, "residual_fine12", "classic_aglomerative_amg_5", (n_a[12] + 1));

													if (ilevel > 13) {

														//residual_coarse12 = new doublerealT[n_a[13] + 1];
														residual_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_coarse12, "residual_coarse12", "classic_aglomerative_amg_5", (n_a[13] + 1));

														//error_approx_coarse12 = new doublerealT[n_a[13] + 1];
														error_approx_coarse12 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_coarse12, "error_approx_coarse12", "classic_aglomerative_amg_5", (n_a[13] + 1));

														//error_approx_fine12 = new doublerealT[n_a[12] + 1];
														error_approx_fine12 = (doublerealT*)malloc((n_a[12] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(error_approx_fine12, "error_approx_fine12", "classic_aglomerative_amg_5", (n_a[12] + 1));


														// residual
														//residual_fine13 = new doublerealT[n_a[13] + 1];
														residual_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
														handle_error<doublerealT>(residual_fine13, "residual_fine13", "classic_aglomerative_amg_5", (n_a[13] + 1));

														if (ilevel > 14) {

															//residual_coarse13 = new doublerealT[n_a[14] + 1];
															residual_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_coarse13, "residual_coarse13", "classic_aglomerative_amg_5", (n_a[14] + 1));

															//error_approx_coarse13 = new doublerealT[n_a[14] + 1];
															error_approx_coarse13 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_coarse13, "error_approx_coarse13", "classic_aglomerative_amg_5", (n_a[14] + 1));

															//error_approx_fine13 = new doublerealT[n_a[13] + 1];
															error_approx_fine13 = (doublerealT*)malloc((n_a[13] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(error_approx_fine13, "error_approx_fine13", "classic_aglomerative_amg_5", (n_a[13] + 1));


															// residual
															//residual_fine14 = new doublerealT[n_a[14] + 1];
															residual_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
															handle_error<doublerealT>(residual_fine14, "residual_fine14", "classic_aglomerative_amg_5", (n_a[14] + 1));

															if (ilevel > 15) {

																//residual_coarse14 = new doublerealT[n_a[15] + 1];
																residual_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_coarse14, "residual_coarse14", "classic_aglomerative_amg_5", (n_a[15] + 1));

																//error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																error_approx_coarse14 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_coarse14, "error_approx_coarse14", "classic_aglomerative_amg_5", (n_a[15] + 1));

																//error_approx_fine14 = new doublerealT[n_a[14] + 1];
																error_approx_fine14 = (doublerealT*)malloc((n_a[14] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(error_approx_fine14, "error_approx_fine14", "classic_aglomerative_amg_5", (n_a[14] + 1));


																// residual
																//residual_fine15 = new doublerealT[n_a[15] + 1];
																residual_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																handle_error<doublerealT>(residual_fine15, "residual_fine15", "classic_aglomerative_amg_5", (n_a[15] + 1));

																if (ilevel > 16) {

																	//residual_coarse15 = new doublerealT[n_a[16] + 1];
																	residual_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_coarse15, "residual_coarse15", "classic_aglomerative_amg_5", (n_a[16] + 1));

																	//error_approx_coarse15 = new doublerealT[n_a[16] + 1];
																	error_approx_coarse15 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_coarse15, "error_approx_coarse15", "classic_aglomerative_amg_5", (n_a[16] + 1));

																	//error_approx_fine15 = new doublerealT[n_a[15] + 1];
																	error_approx_fine15 = (doublerealT*)malloc((n_a[15] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(error_approx_fine15, "error_approx_fine15", "classic_aglomerative_amg_5", (n_a[15] + 1));


																	// residual
																	//residual_fine16 = new doublerealT[n_a[16] + 1];
																	residual_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																	handle_error<doublerealT>(residual_fine16, "residual_fine16", "classic_aglomerative_amg_5", (n_a[16] + 1));

																	if (ilevel > 17) {

																		//residual_coarse16 = new doublerealT[n_a[17] + 1];
																		residual_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_coarse16, "residual_coarse16", "classic_aglomerative_amg_5", (n_a[17] + 1));

																		//error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																		error_approx_coarse16 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_coarse16, "error_approx_coarse16", "classic_aglomerative_amg_5", (n_a[17] + 1));

																		//error_approx_fine16 = new doublerealT[n_a[16] + 1];
																		error_approx_fine16 = (doublerealT*)malloc((n_a[16] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(error_approx_fine16, "error_approx_fine16", "classic_aglomerative_amg_5", (n_a[16] + 1));


																		// residual
																		//residual_fine17 = new doublerealT[n_a[17] + 1];
																		residual_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																		handle_error<doublerealT>(residual_fine17, "residual_fine17", "classic_aglomerative_amg_5", (n_a[17] + 1));

																		if (ilevel > 18) {
																			//residual_coarse17 = new doublerealT[n_a[18] + 1];
																			residual_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(residual_coarse17, "residual_coarse17", "classic_aglomerative_amg_5", (n_a[18] + 1));

																			//error_approx_coarse17 = new doublerealT[n_a[18] + 1];
																			error_approx_coarse17 = (doublerealT*)malloc((n_a[18] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_coarse17, "error_approx_coarse17", "classic_aglomerative_amg_5", (n_a[18] + 1));

																			//error_approx_fine17 = new doublerealT[n_a[17] + 1];
																			error_approx_fine17 = (doublerealT*)malloc((n_a[17] + 1)*sizeof(doublerealT));
																			handle_error<doublerealT>(error_approx_fine17, "error_approx_fine17", "classic_aglomerative_amg_5", (n_a[17] + 1));

																			// residual
																			//residual_fine18 = new doublerealT[n_a[18] + 1];
																			residual_fine18 = (doublerealT*)malloc((n_a[18] + 1) * sizeof(doublerealT));
																			handle_error<doublerealT>(residual_fine18, "residual_fine18", "classic_aglomerative_amg_5", (n_a[18] + 1));

																			if (ilevel > 19) {
																				//residual_coarse18 = new doublerealT[n_a[19] + 1];
																				residual_coarse18 = (doublerealT*)malloc((n_a[19] + 1) * sizeof(doublerealT));
																				handle_error<doublerealT>(residual_coarse18, "residual_coarse18", "classic_aglomerative_amg_5", (n_a[19] + 1));

																				//error_approx_coarse18 = new doublerealT[n_a[19] + 1];
																				error_approx_coarse18 = (doublerealT*)malloc((n_a[19] + 1) * sizeof(doublerealT));
																				handle_error<doublerealT>(error_approx_coarse18, "error_approx_coarse18", "classic_aglomerative_amg_5", (n_a[19] + 1));

																				//error_approx_fine18 = new doublerealT[n_a[18] + 1];
																				error_approx_fine18 = (doublerealT*)malloc((n_a[18] + 1) * sizeof(doublerealT));
																				handle_error<doublerealT>(error_approx_fine18, "error_approx_fine18", "classic_aglomerative_amg_5", (n_a[18] + 1));
																			}

																		}
																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	doublerealT *error_approx_fine = NULL;
	//error_approx_fine = new doublerealT[n_a[0] + 1];
	error_approx_fine = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(error_approx_fine, "error_approx_fine", "classic_aglomerative_amg_5", (n_a[0] + 1));



	// 2 jan 2016. 
	integer igam = 1; // 1-V; 2-W
	const integer ZERO_INIT = 0;
	const integer RANDOM_INIT = 1;// надо увеличивать nu1, nu2 с 1,2 до 5 наверно.
	integer imyinit = ZERO_INIT; // ZERO_INIT optimum

	doublerealT* x_copy = NULL;
	x_copy = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_copy, "x_copy", "classic_aglomerative_amg_5", (n_a[0] + 1));

	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_copy[i47] = x[i47];
		//x_copy[i47] = 0.0; // 28.07.2016
	}

	doublerealT* x_best_search = NULL;
	x_best_search = (doublerealT*)malloc((n_a[0] + 1)*sizeof(doublerealT));
	handle_error<doublerealT>(x_best_search, "x_best_search", "classic_aglomerative_amg_5", (n_a[0] + 1));

	doublerealT res_best_search = 1e40;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		//x_best_search[i47] = 0.0; // 28.07.2016
	}


	// Для поправки давления возникает задача когда на всех границах стоит условие Неймана,
	// это приводит к тому что метод работает бесконечно долго и не может сойтись, поэтому нужно 
	// заложить критерий останова по превышению количества допустимых итераций (не более 1000 итераций).
	// 1000 итераций это очень долго поэтому для поправки давления надо подобрать разумное количество 
	// итераций т.к. от этого существенным образом зависит быстродействие гидродинамического алгоритма.
	integer iter_limit = 0;
	integer istop_porog_reconst = 5000;// 50

	bool ret_value = false;
	doublerealT dres_previos = 1.0e40;
	integer icount_bad_convergence_Vcycles = 0;
	integer i_count_stagnation = 0;
	doublerealT res0start = 1.0e-40;
	bool bfirst_divergence = true;

	residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
	doublerealT dres_initial = norma(residual_fine, n_a[0]);
	integer iflag_cont = 1;
	if (iVar != PAM) {
		dres = fabs(dres_initial);

		if (iVar != TEMP) {
			if (dres < dterminatedTResudual) {
				// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
				iflag_cont = 0;
			}
		}
		else {
			if (dres < 1.0e-4*dterminatedTResudual) {
				// Вектор и так точно удовлетворяет решению, его не надо уточнять из решения СЛАУ.
				iflag_cont = 0;
			}
		}
	}
	iflag_cont = 1;
	if (bprint_mesage_diagnostic) {
		// start residual.
#if doubleintprecision == 1
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#else
		printf("%d %e rho=%e\n", 0, dres_initial, dres_initial / rho);
#endif
		
	}

	integer count_iter_for_film_coef = 0;
	// Если число расходимостей превысит оговорённую константу то произойдёт выход из алгоритма.
	integer i_signal_break_pam_opening = 0;
	// x хорошее значение.
	const integer i_limit_signal_pam_break_opening = 1000;
	doublerealT delta_old_iter = 1.0e10;

	// диагностическое сообщение какую переменную мы решаем.
	if (bprint_mesage_diagnostic) {
		switch (iVar) {
		case PAM: printf("PAM\n");  break;
		case VX:  printf("VX\n"); break;
		case VY:  printf("VY\n"); break;
		case VZ:  printf("VZ\n"); break;
		case TEMP:  printf("TEMP\n"); break;
		}
	}
	else {/*
		switch (iVar) {
		case PAM: printf("PAM	");  break;
		case VX:  printf("VX	"); break;
		case VY:  printf("VY	"); break;
		case VZ:  printf("VZ	"); break;
		case TEMP:  printf("TEMP\n"); break;
		}*/
#if doubleintprecision == 1
		switch (iVar) {
			// Аляска ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VX:  printf("VX level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VY:  printf("VY level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VZ:  printf("VZ level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%lld CopA=%e CopP=%e %lld %lld %lld %lld %lld\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#else
		switch (iVar) {
			// Аляска ilevel_VX_VY_VZ=10, ilevel_PAM=5 или 6.

		case PAM: printf("PAM level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]);  break;
		case VX:  printf("VX level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VY:  printf("VY level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case VZ:  printf("VZ level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		case TEMP:  printf("TEMP level=%d CopA=%e CopP=%e %d %d %d %d %d\n", ilevel, dr_grid_complexity, (1.0*nnz_P_memo_all / n_a[0]), n_a[ilevel - 4], n_a[ilevel - 3], n_a[ilevel - 2], n_a[ilevel - 1], n_a[ilevel]); break;
		}
#endif
		

	}
	//getchar();

	//if (iVar == PAM) {// бред
	//for (integer iter = 0; iter < 2; iter++) {
	//seidelq(Amat, 1, n_a[0], b, x, row_ptr_start, row_ptr_end, 0);
	//}
	//}
	integer icount_V_cycle = 0;


	doublerealT dres_initial_ = 1e-6;
	//ilevel = 3;
	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то этинастройки должны помоч.
	// Отсекаем уровни которые выше порогового значения указанного пользователем.
	//if (ilevel > my_amg_manager.maximum_levels) {
		//ilevel = my_amg_manager.maximum_levels;
	//}

	ilevel -= my_amg_manager.maximum_delete_levels;

	doublerealT maxold = -1.0e30;
	for (integer i = 1; i <= n_a[0]; i++) {
		if (x[i] > maxold) maxold = x[i];
	}

	doublereal* x_best_search2 = new doublerealT[n_a[0] + 1];
	doublereal* x_best_search_init = new doublerealT[n_a[0] + 1];
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search_init[i47] = x[i47];
	}



	//for (integer iprohod = 0; iprohod < 20; iprohod++) {
	while ((iflag_cont==1) && (dres>tolerance)) {

		
		if (bPhysics_stop == true) {
			if (icount_V_cycle > 0) {
				doublerealT maxnew = -1.0e30;
				for (integer i = 1; i <= n_a[0]; i++) {
					if (x[i] > maxnew) maxnew = x[i];
				}
				if (iVar == TOTALDEFORMATIONVAR) {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 1.0e-9)) {
						//printf("break bPhysics_stop, dres<1e-2 && (fabs(maxnew - maxold) < 1.0e-9)\n");
						break;
					}
					else {
						maxold = maxnew;
					}
				}
				else {
					if ((fabs(dres) < 1.0e-2) && (fabs(maxnew - maxold) < 0.0005)) {
						break;
					}
					else {
						maxold = maxnew;
					}
				}

			}
		}


		if (fabs(dres / rho)<1.0) {
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search2[i47] = x[i47];
			}
		}

		//getchar();
		icount_V_cycle++;
		//if (icount_V_cycle > 8) break;
		count_iter_for_film_coef++;
		// В случае задачи Ньютона - Рихмана, Стефана-Больцмана и миксового условия не итерируем до конца обрываем, 
		// т.к. нам требуется частая пересборка матрицы. 13 марта 2016.
		// Для космических задач этот прерыватель просто необходим 14 октября 2016.
		if (((adiabatic_vs_heat_transfer_coeff > 0) || (breakRUMBAcalc_for_nonlinear_boundary_condition)) && (count_iter_for_film_coef>125)) break;


		if (iter_limit == 5000) {
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_copy[i47];
			}
			//printf("amg divergence detected...\n");
			//getchar();
			break;
		}

		if (iter_limit == 1) {
			// начальная невязка.
			res0start = fabs(dres);
		}


		if (fabs(dres) < res_best_search)
		{
			// Запоминаем лучшую попытку.
			res_best_search = fabs(dres);
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x_best_search[i47] = x[i47];
			}
		}

		if (0&&(icount_V_cycle == 2)) {
			// именно 2 должна фигурировать иначе сходимости не будет совсем.
			if (bSIMPLErun_now_for_temperature) {
				// Мы решаем уравнения Навье-Стокса.
				// Выходим в том случае если невязка стала на 4 
				// порядка меньше чем начальная.
				// 1.0e-1 нет сходимости.
				// 1.0e-3 нет сходимости.
				// 1.0e-4 неплохо но есть всплеск на 43 итерации.
				// 1.0e-5 два всплеска (один в самом конце).
				tolerance = 1.0e-4*dres;//1e-4
				dres_initial_ = dres;
			}
			else {
				tolerance = 1.0e-4;// Отдельное решение уравнения теплопроводности.
			}
		}
		if (dres < 1.0e-14) break; // 1.0e-14 не повлияло.
		if (iVar == PAM) {
			// Этот кусок кода предназначен для того чтобы не было болтанки или всплесков:
			// когда на текущей итерации сошлось очень хорошо допустим на порядок,
			// а на следующей сошлось лишь на 0.33 т.е. хуже и это вызывает всплеск, 
			// нарушение монотоности при сходимости.
			// 0.37
			//if (fabs(dres / dres_initial_) < 0.1) break;
		}

		/*
		if (iVar == PAM) {
		if (fabs(dres) < 1.0) {
		// Идея в том что нам нужна хоть какая-то поправка давления,
		// всё лучше чем тождественно нулевое распределение.
		// невязка при этом у нас менеее 1.0 что гарантирует что мы не сильно улетели.
		for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x_best_search[i47] = x[i47];
		}
		}
		}
		*/

		// debug 7 июня 2016
		//if (iter_limit > 300) {
		//printf("amg divergense detected...9 june 2016\n");
		//system("pause");
		//break;
		//}

		/*
		// 100
		if (iter_limit > 5000) { // Finned Heat Sink


			
			if (bfirst_divergence) {
				iter_limit = 3;
				nu1 += 2;
				nu2 += 2;
				nFinestSweeps += 2;
				bfirst_divergence = false;
			}
			else {
				if ((fabs(res_best_search / res0start) < 0.23) && (fabs(res_best_search) < 1.0e-3*sqrt(n_a[0]))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				else if ((fabs(res_best_search / res0start) <= 1.0) && (fabs(res_best_search) < 1.0e-4*sqrt(n_a[0]))) {
					// Если невязка меньше первоначальной на два порядка.
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
				// Эта ветвь кода вообще никогда не вызовется.
				printf("Fatal amg error : Strong divergence amg solver...%e \n", fabs(res_best_search / res0start));
				printf("res_best_search=%e, res0start=%e\n", fabs(res_best_search), fabs(res0start));
				printf("BiCGStab+ILU2 is start now...\n");
				printf("please wait...");
				system("pause");
				break; // досрочный выход из while цикла.
			}
		}
		*/
		iter_limit++;

		if (fabs(dres) < fabs(dres_previos)) {
			// все нормально процесс сходится.
			icount_bad_convergence_Vcycles = 0;
		}
		else {
			icount_bad_convergence_Vcycles++;
		}

		//if (_finite(dres) == 0) {
		//if (fabs(dres) > 1.0e30)
		//{
		//printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
		//printf("\a\a\a\a\a\a\a\a");
		//system("pause");
		//exit(1);
		//return true;
		//for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		//	x[i47] = x_copy[i47];
		//}
		//if (iter_limit > 100) {
		//	ret_value = true;
		//	break;
		//}
		//else {
		// Увеличение количества сглаживающих итераций ни коим образом не 
		// исправляет факт расходимости. 
		//	nu1++;
		//	nu2++;
		//	nFinestSweeps++;
		// По видимому надо действовать очень тонкой настройкой параметра верхней релаксации omega optimal.
		// Настройка omega optimal должна быть самообучающейся (адаптированной к задаче).
		//}
		//}
		/*
		if ((icount_bad_convergence_Vcycles >= istop_porog_reconst) || (fabs(dres) / sqrt(n_a[0]) > 1.0e30)) {
			// детектировано 10 шагов расходимости подряд по-видимому метод расходится.
			// Также о расходимости говорит невязка большая 1.0e30.

			//if (fabs(dres) < 1.0e-3) break; // Будем считать сходимость достигнута успешно.
			if ((fabs(res_best_search / res0start) < 1.0e-1) && (fabs(dres) / sqrt(n_a[0]) < 1.0e-3)) {
				// Если невязка меньше первоначальной на два порядка.
				// Обратное копирование и выход и алгоритма.
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = x_best_search[i47];
				}
				break;
			}
			i_count_stagnation++;

			printf("\ndivergence AMG detected...solver will be restart... please wait... ... ...\n");
			//printf("\a\a\a\a\a\a\a\a");
			//system("pause");
			//exit(1);
			//return true;
			if (i_count_stagnation < 20) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					x[i47] = x_best_search[i47]; // лучшее найденное решение
				}
			}
			if (i_count_stagnation == 20 || i_count_stagnation == 21) gold_const = 0.2;
			if ((i_count_stagnation >= 20) && (i_count_stagnation < 30)) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					//x[i47] = x_copy[i47];
					// Можно еще единократно немного улучшить nu1 и nu2.
					doublerealT signumnow = 1.0;
					if (rand() % 2 == 0) signumnow = -1.0;
					x[i47] = signumnow *1.0*(rand() % 90 + 10) / 100.0; // Случайное число в интервале от 0 до 1.
				}
			}
			if (i_count_stagnation == 30 || i_count_stagnation == 31) gold_const = 0.2;
			if (i_count_stagnation >= 30) {
				for (integer i47 = 1; i47 <= n_a[0]; i47++) {
					x[i47] = 1.0;
				}
			}
			if (bproblem_amg_convergence1) {
				if (bproblem_amg_convergence2) {
					if (bproblem_amg_convergence3) {
						// выход к вызову BiCGStab+ILU2.
						ret_value = true;
						break;
					}
					else {
						// смена omega.
						bproblem_amg_convergence3 = true;
						icount_bad_convergence_Vcycles = 0;
						buffers3omega = dres / dres_previos;
						printf("buffers1omega=%1.4f, buffers2omega=%1.4f, buffers3omega=%1.4f\n", buffers1omega, buffers2omega, buffers3omega);
					}
				}
				else {
					// смена omega.
					bproblem_amg_convergence2 = true;
					icount_bad_convergence_Vcycles = 0;
					buffers2omega = dres / dres_previos;
					printf("buffers1omega=%1.4f, buffers2omega=%1.4f\n", buffers1omega, buffers2omega);
					//istop_porog_reconst += 50; // 10, 20, 30, 40
					// Увеличение количества сглаживающих итераций ничего не даёт.
					//nu1++;
					//nu2++;
					//nFinestSweeps++;
				}
			}
			else {

				bproblem_amg_convergence1 = true; // переход с SOR на стабильный Зейдель.
				icount_bad_convergence_Vcycles = 0;
				buffers1omega = dres / dres_previos;
			}
		}
		*/

		dres_previos = dres;


		doublerealT R0_0 = 0.0;
		doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			R0_0 = norma(residual_fine, n_a[0]);
			Rprev_0 = R0_0;

			// smother
			integer iter = 0;
			for (iter = 0; iter < nu1; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 > process_flow_beta*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nu1) {
				printf("level 0 limit presmother iteration is reached\n");
			}

		}
		else {
			// smoother
			for (integer iter = 0; iter < nu1; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						// ILU0
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if (bILU2smoother == 2) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}

		//exporttecplot(x, n);

		move_down(nu1, nu2);

		if (!process_flow_logic) {
			// residual_r
			//doublerealT *residual_fine = new doublerealT[n_a[0] + 1];
			//residual(Amat, 1, nnz_a[0], x, b, flag, n_a[0], residual_fine);
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
		}
		dres = norma(residual_fine, n_a[0]);
		ret74 += fabs(dres);
		if (bprint_mesage_diagnostic) {
#if doubleintprecision == 1
			printf("%lld %e rho=%e\n", iiter, dres, dres / rho);
#else
			printf("%d %e rho=%e\n", iiter, dres, dres / rho);
#endif
			
			if (fabs(1.0 - fabs(dres / rho)) < 1.0e-3) {
				printf("stagnation in amg solver determinate ...\n");
				// 28_10_2016.
				// Осуществляем досрочный выход из итерирования, 
				// т.к. невязка перестала меняться.
				break;
			}
		}
		iiter++;
		// 28.07.2016
		if (fabs(dres) > 1.0e7) {
			for (integer i47 = 1; i47 <= n_a[0]; i47++) {
				x[i47] = x_best_search[i47];
			}
			//printf("amg divergence detected.");
			//getchar();
			break;
		}

		if (1&&(iVar == PAM)) {
			if ((fabs(dres / rho) > 0.99999) || (fabs(dres) > 1.0e7)) {
				// Выход из мультигрида ести достигнуто 20 циклов расходимости.
				delta_old_iter = fabs(dres);
				i_signal_break_pam_opening++;
				if (i_signal_break_pam_opening > i_limit_signal_pam_break_opening) {
#if doubleintprecision == 1
					printf("iter = %lld\n", iiter);
#else
					printf("iter = %d\n", iiter);
#endif
					
					// Обратное копирование и выход и алгоритма.
					for (integer i47 = 1; i47 <= n_a[0]; i47++) {
						x[i47] = x_best_search[i47];
					}
					break;
				}
				if (i_signal_break_pam_opening > 50) {
				//	signal_omega_correct = true;
				}
			}
		}
		if (signal_omega_correct) {
			//getchar();
			system("PAUSE");
		}

		//rho=norma(residual_fine, n_a[0]);
		rho = dres;

		//if (iprohod%5==0) getchar();
		if (ilevel > 1) {

			//doublerealT *residual_coarse = new doublerealT[n_a[1] + 1];
		
			for (integer ii = 1; ii <= n_a[1]; ii++) {
				residual_coarse[ii] = 0.0;
			}

			//exporttecplotxy360T_3D_part2amg(residual_fine, false, 1);

			// restriction
			// из residual fine получает residual coarce.
			restriction(R, 1, nnz_aRP[0], flag, residual_fine, residual_coarse, n_a[0], n_a[1]);

			// Amat*e=r;
			//doublerealT* error_approx_coarse = new doublerealT[n_a[1] + 1];
			if (imyinit == ZERO_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = 0.0;
				}
			}

			if (imyinit == RANDOM_INIT) {
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] = (rand() / ((doublerealT)RAND_MAX));
				}
			}


			for (integer i_37 = 1; i_37 <= igam; i_37++) {
				doublerealT R0_1 = 0.0;
				doublerealT Rprev_1 = 0.0, Rnext_1 = 0.0;
				if (process_flow_logic) {
					// calculate initial residual.
					//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

					R0_1 = norma(residual_fine1, n_a[1]);
					Rprev_1 = R0_1;

					// smother
					integer iter = 0;
					for (iter = 0; iter < nu1; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 > process_flow_beta*Rprev_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu1) {
						printf("level 1 limit presmother iteration is reached\n");
					}

				}
				else {

					// pre smothing
					for (integer iter = 0; iter < nu1; iter++) {
						//seidel(Amat, 1 + 2 * nnz_a[0], 2 * nnz_a[0] + nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1]);
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += milu0[1].zbuf2[i43 + 1];
								}


							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += milu2[1].zbuf2[i43 + 1];
								}


							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}

				move_down(nu1, nu2);


				if (ilevel > 2) {
					// residual
					if (!process_flow_logic) {
						//doublerealT *residual_fine1 = new doublerealT[n_a[1] + 1];
						//residual(Amat, 1+2*nnz_a[0], 2*nnz_a[0]+nnz_a[1], error_approx_coarse, residual_coarse, flag, n_a[1], residual_fine1);
						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);
						//residualqspeshial(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1);
					}

					//doublerealT *residual_coarse1 = new doublerealT[n_a[2] + 1];


					/*
					doublerealT* residual_fine_for_plot = new doublerealT[n_a[0] + 1];
					for (integer i_4 = 0; i_4 <= n_a[0]; i_4++) {
						residual_fine_for_plot[i_4] = 0.0;
					}
					// restriction
					exporttecplotxy360T_3D_part2amg(residual_fine, false, 1);
					// из residual fine получает residual coarce.
					prolongation(P, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					exporttecplotxy360T_3D_part2amg(residual_fine_for_plot, false, 1);
					restriction(R, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					prolongation(P, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					exporttecplotxy360T_3D_part2amg(residual_fine_for_plot, false, 1);
					restriction(R, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					prolongation(P, 1, nnz_aRP[0], flag, residual_fine_for_plot, residual_coarse, n_a[0], n_a[1]);
					exporttecplotxy360T_3D_part2amg(residual_fine_for_plot, false, 1);


					delete[] residual_fine_for_plot;
					*/


					// restriction
					restriction(R, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, residual_fine1, residual_coarse1, n_a[1], n_a[2]);

					// Amat*e=r;
					//doublerealT* error_approx_coarse1 = new doublerealT[n_a[2] + 1];
					if (imyinit == ZERO_INIT) {
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = 0.0;
						}
					}
					if (imyinit == RANDOM_INIT) {
						for (integer ii = 1; ii <= n_a[2]; ii++) {
							error_approx_coarse1[ii] = (rand() / ((doublerealT)RAND_MAX));
						}
					}

					//for (integer i_37 = 1; i_37 <= igam; i_37++)
				{
					doublerealT R0_2 = 0.0;
					doublerealT Rprev_2 = 0.0, Rnext_2 = 0.0;
					if (process_flow_logic) {
						// calculate initial residual.
						//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

						R0_2 = norma(residual_fine2, n_a[2]);
						Rprev_2 = R0_2;

						// smother
						integer iter = 0;
						for (iter = 0; iter < nu1; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 > process_flow_beta*Rprev_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu1) {
							printf("level 2 limit presmother iteration is reached\n");
						}

					}
					else {

						// pre smothing
						for (integer iter = 0; iter < nu1; iter++) {
							//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2]);
							if (bonly_serial) {
								if (bILU2smoother == 1) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu0[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu0[2].zbuf, milu0[2].zbuf2, milu0[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += milu0[2].zbuf2[i43 + 1];
									}
								}
								else if (1 && bILU2smoother == 2) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu2[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu2[2].zbuf, milu2[2].zbuf2, milu2[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += milu2[2].zbuf2[i43 + 1];
									}
								}
								else {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
								}
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}

					}

					move_down(nu1, nu2);

					if (ilevel > 3) {
						// residual
						if (!process_flow_logic) {
							//doublerealT *residual_fine2 = new doublerealT[n_a[2] + 1];
							//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1], 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2], error_approx_coarse1, residual_coarse1, flag, n_a[2], residual_fine2);
							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);
							//residualqspeshial(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
						}

						//doublerealT *residual_coarse2 = new doublerealT[n_a[3] + 1];

						// restriction
						restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, residual_fine2, residual_coarse2, n_a[2], n_a[3]);

						// Amat*e=r;
						//doublerealT* error_approx_coarse2 = new doublerealT[n_a[3] + 1];
						if (imyinit == ZERO_INIT) {
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = 0.0;
							}
						}
						if (imyinit == RANDOM_INIT) {
							for (integer ii = 1; ii <= n_a[3]; ii++) {
								error_approx_coarse2[ii] = (rand() / ((doublerealT)RAND_MAX));
							}
						}
						//for (integer i_37 = 1; i_37 <= igam; i_37++)
					{
						doublerealT R0_3 = 0.0;
						doublerealT Rprev_3 = 0.0, Rnext_3 = 0.0;
						if (process_flow_logic) {
							// calculate initial residual.
							//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


							R0_3 = norma(residual_fine3, n_a[3]);
							Rprev_3 = R0_3;

							// smother
							integer iter = 0;
							for (iter = 0; iter < nu1; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 > process_flow_beta*Rprev_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu1) {
								printf("level 3 limit presmother iteration is reached\n");
							}

						}
						else {
							// pre smothing
							for (integer iter = 0; iter < nu1; iter++) {
								//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3]);
								if (bonly_serial) {
									if (bILU2smoother == 1) {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu0[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu0[3].zbuf, milu0[3].zbuf2, milu0[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += milu0[3].zbuf2[i43 + 1];
										}
									}
									else if (1 && bILU2smoother == 2) {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu2[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu2[3].zbuf, milu2[3].zbuf2, milu2[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += milu2[3].zbuf2[i43 + 1];
										}
									}
									else {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
									}
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}


						move_down(nu1, nu2);


						if (ilevel > 4) {
							// residual
							if (!process_flow_logic) {
								//doublerealT *residual_fine3 = new doublerealT[n_a[3] + 1];
								//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + nnz_a[3], error_approx_coarse2, residual_coarse2, flag, n_a[3], residual_fine3);
								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

								//speshial
								//residualqspeshial(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3);
							}


							//doublerealT *residual_coarse3 = new doublerealT[n_a[4] + 1];

							// restriction
							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, residual_fine3, residual_coarse3, n_a[3], n_a[4]);

							// Amat*e=r;
							//doublerealT* error_approx_coarse3 = new doublerealT[n_a[4] + 1];
							if (imyinit == ZERO_INIT) {
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = 0.0;
								}
							}
							if (imyinit == RANDOM_INIT) {
								for (integer ii = 1; ii <= n_a[4]; ii++) {
									error_approx_coarse3[ii] = (rand() / ((doublerealT)RAND_MAX));
								}
							}

							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
						{
							doublerealT R0_4 = 0.0;
							doublerealT Rprev_4 = 0.0, Rnext_4 = 0.0;
							if (process_flow_logic) {
								// calculate initial residual.
								//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


								R0_4 = norma(residual_fine4, n_a[4]);
								Rprev_4 = R0_4;

								// smother
								integer iter = 0;
								for (iter = 0; iter < nu1; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 > process_flow_beta*Rprev_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu1) {
									printf("level 4 limit presmother iteration is reached\n");
								}

							}
							else {
								// pre smothing
								for (integer iter = 0; iter < nu1; iter++) {
									//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4]);
									if (bonly_serial) {
										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu0[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu0[4].zbuf, milu0[4].zbuf2, milu0[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += milu0[4].zbuf2[i43 + 1];
											}
										}
										else if (1 && bILU2smoother == 2) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu2[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu2[4].zbuf, milu2[4].zbuf2, milu2[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += milu2[4].zbuf2[i43 + 1];
											}
										}
										else {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
										}
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}


							move_down(nu1, nu2);

							if (ilevel > 5) {
								// residual
								if (!process_flow_logic) {
									//doublerealT *residual_fine4 = new doublerealT[n_a[4] + 1];
									//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + nnz_a[4], error_approx_coarse3, residual_coarse3, flag, n_a[4], residual_fine4);
									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

									//speshial 14 september 2015.
									//residualqspeshial(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4);
								}


								//doublerealT *residual_coarse4 = new doublerealT[n_a[5] + 1];

								// restriction
								restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, residual_fine4, residual_coarse4, n_a[4], n_a[5]);

								// Amat*e=r;
								//doublerealT* error_approx_coarse4 = new doublerealT[n_a[5] + 1];
								if (imyinit == ZERO_INIT) {
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = 0.0;
									}
								}
								if (imyinit == RANDOM_INIT) {
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] = (rand() / ((doublerealT)RAND_MAX));
									}
								}

								// pre smothing
								//for (integer i_37 = 1; i_37 <= igam; i_37++)
							{
								doublerealT R0_5 = 0.0;
								doublerealT Rprev_5 = 0.0, Rnext_5 = 0.0;
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
									residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);



									R0_5 = norma(residual_fine5, n_a[5]);
									Rprev_5 = R0_5;

									// smother
									integer iter = 0;
									for (iter = 0; iter < nu1; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 > process_flow_beta*Rprev_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu1) {
										printf("level 5 limit presmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu1; iter++) {
										//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5]);
										if (bonly_serial) {
											if (bILU2smoother == 1) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu0[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu0[5].zbuf, milu0[5].zbuf2, milu0[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += milu0[5].zbuf2[i43 + 1];
												}
											}
											else if (1 && bILU2smoother == 2) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu2[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu2[5].zbuf, milu2[5].zbuf2, milu2[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += milu2[5].zbuf2[i43 + 1];
												}
											}
											else {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
											}
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}


								move_down(nu1, nu2);

								if (ilevel > 6) {
									// residual
									if (!process_flow_logic) {
										//doublerealT *residual_fine5 = new doublerealT[n_a[5] + 1];
										//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + nnz_a[5], error_approx_coarse4, residual_coarse4, flag, n_a[5], residual_fine5);
										//if (ilevel <= 15) {
										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

										//}
										//else {
										// приводит к расходимости.
										//speshial 14 september 2015.
										// это уже приводит к увеличению числа итераций на примере сетки в 1млн узлов. остановимся.
										//residualqspeshial(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5);
										//}
									}

									//doublerealT *residual_coarse5 = new doublerealT[n_a[6] + 1];

									// restriction
									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, residual_fine5, residual_coarse5, n_a[5], n_a[6]);

									// Amat*e=r;
									//doublerealT* error_approx_coarse5 = new doublerealT[n_a[6] + 1];
									if (imyinit == ZERO_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = 0.0;
										}
									}
									if (imyinit == RANDOM_INIT) {
										for (integer ii = 1; ii <= n_a[6]; ii++) {
											error_approx_coarse5[ii] = (rand() / ((doublerealT)RAND_MAX));
										}
									}

									//for (integer i_37 = 1; i_37 <= igam; i_37++) 
									{
										// pre smothing

										doublerealT R0_6 = 0.0;
										doublerealT Rprev_6 = 0.0, Rnext_6 = 0.0;
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
											residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



											R0_6 = norma(residual_fine6, n_a[6]);
											Rprev_6 = R0_6;

											// smother
											integer iter = 0;
											for (iter = 0; iter < nu1; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);


												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 > process_flow_beta*Rprev_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu1) {
												printf("level 6 limit presmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu1; iter++) {
												//seidel(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6]);
												if (bonly_serial) {
													if (bILU2smoother == 1) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu0[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu0[6].zbuf, milu0[6].zbuf2, milu0[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += milu0[6].zbuf2[i43 + 1];
														}
													}
													else if (1 && bILU2smoother == 2) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu2[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu2[6].zbuf, milu2[6].zbuf2, milu2[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += milu2[6].zbuf2[i43 + 1];
														}
													}
													else {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
													}
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}


										move_down(nu1, nu2);

										if (ilevel > 7) {
											// residual
											if (!process_flow_logic) {
												//doublerealT *residual_fine6 = new doublerealT[n_a[6] + 1];
												//residual(Amat, 1 + 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] +2*nnz_a[5], 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2] + 2 * nnz_a[3] + 2 * nnz_a[4] + 2 * nnz_a[5] + nnz_a[6], error_approx_coarse5, residual_coarse5, flag, n_a[6], residual_fine6);
												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);
											}

											//doublerealT *residual_coarse6 = new doublerealT[n_a[7] + 1];

											// restriction
											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, residual_fine6, residual_coarse6, n_a[6], n_a[7]);

											// Amat*e=r;
											//doublerealT* error_approx_coarse6 = new doublerealT[n_a[7] + 1];
											if (imyinit == ZERO_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = 0.0;
												}
											}
											if (imyinit == RANDOM_INIT) {
												for (integer ii = 1; ii <= n_a[7]; ii++) {
													error_approx_coarse6[ii] = (rand() / ((doublerealT)RAND_MAX));
												}
											}

											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
											{

												// pre smothing


												doublerealT R0_7 = 0.0;
												doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
													residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);



													R0_7 = norma(residual_fine7, n_a[7]);
													Rprev_7 = R0_7;

													// smother
													integer iter = 0;
													for (iter = 0; iter < nu1; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 > process_flow_beta*Rprev_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu1) {
														printf("level 7 limit presmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu1; iter++) {
														if (bonly_serial) {
															if (bILU2smoother == 1) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu0[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu0[7].zbuf, milu0[7].zbuf2, milu0[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += milu0[7].zbuf2[i43 + 1];
																}

															}
															else if (1 && bILU2smoother == 2) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu2[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu2[7].zbuf, milu2[7].zbuf2, milu2[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += milu2[7].zbuf2[i43 + 1];
																}

															}
															else {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
															}
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}


												move_down(nu1, nu2);

												if (ilevel > 8) {
													// residual
													if (!process_flow_logic) {
														//doublerealT *residual_fine7 = new doublerealT[n_a[7] + 1];
														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7], error_approx_coarse6, residual_coarse6, flag, n_a[7], residual_fine7);
														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

													}


													//doublerealT *residual_coarse7 = new doublerealT[n_a[8] + 1];

													// restriction
													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, residual_fine7, residual_coarse7, n_a[7], n_a[8]);

													// Amat*e=r;
													//doublerealT* error_approx_coarse7 = new doublerealT[n_a[8] + 1];
													if (imyinit == ZERO_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = 0.0;
														}
													}
													if (imyinit == RANDOM_INIT) {
														for (integer ii = 1; ii <= n_a[8]; ii++) {
															error_approx_coarse7[ii] = (rand() / ((doublerealT)RAND_MAX));
														}
													}

													//for (integer i_37 = 1; i_37 <= igam; i_37++)
													{
														// pre smothing
														doublerealT R0_8 = 0.0;
														doublerealT Rprev_8 = 0.0, Rnext_8 = 0.0;
														if (process_flow_logic) {
															// calculate initial residual.
															//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8);
															residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);



															R0_8 = norma(residual_fine8, n_a[8]);
															Rprev_8 = R0_8;

															// smother
															integer iter = 0;
															for (iter = 0; iter < nu1; iter++) {
																//quick seidel
																if (bonly_serial) {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}

																//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7], residual_fine8);
																residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);


																Rnext_8 = norma(residual_fine8, n_a[8]);
																// this is process flow logic
																if (Rnext_8 > process_flow_beta*Rprev_8) {
																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																}
																else {
																	Rprev_8 = Rnext_8;
																}
															}

															if (iter == nu1) {
																printf("level 8 limit presmother iteration is reached\n");
															}

														}
														else {
															for (integer iter = 0; iter < nu1; iter++) {
																if (bonly_serial) {
																	if (bILU2smoother == 1) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu0[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu0[8].zbuf, milu0[8].zbuf2, milu0[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += milu0[8].zbuf2[i43 + 1];
																		}

																	}
																	else if (1 && bILU2smoother == 2) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu2[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu2[8].zbuf, milu2[8].zbuf2, milu2[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += milu2[8].zbuf2[i43 + 1];
																		}

																	}
																	else {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																	}
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
															}
														}


														move_down(nu1, nu2);


														if (ilevel > 9) {
															// residual
															if (!process_flow_logic) {
																//doublerealT *residual_fine8 = new doublerealT[n_a[8] + 1];
																//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8], error_approx_coarse7, residual_coarse7, flag, n_a[8], residual_fine8);
																//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8);
																residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);
															}


															//doublerealT *residual_coarse8 = new doublerealT[n_a[9] + 1];

															// restriction
															restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], flag, residual_fine8, residual_coarse8, n_a[8], n_a[9]);


															// Amat*e=r;
															//doublerealT* error_approx_coarse8 = new doublerealT[n_a[9] + 1];
															if (imyinit == ZERO_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = 0.0;
																}
															}
															if (imyinit == RANDOM_INIT) {
																for (integer ii = 1; ii <= n_a[9]; ii++) {
																	error_approx_coarse8[ii] = (rand() / ((doublerealT)RAND_MAX));
																}
															}

															//for (integer i_37 = 1; i_37 <= igam; i_37++) 
															{
																// pre smothing
																doublerealT R0_9 = 0.0;
																doublerealT Rprev_9 = 0.0, Rnext_9 = 0.0;
																if (process_flow_logic) {
																	// calculate initial residual.
																	//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8], residual_fine9);
																	residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);



																	R0_9 = norma(residual_fine9, n_a[9]);
																	Rprev_9 = R0_9;

																	// smother
																	integer iter = 0;
																	for (iter = 0; iter < nu1; iter++) {
																		//quick seidel
																		if (bonly_serial) {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}

																		//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8], residual_fine9);
																		residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);


																		Rnext_9 = norma(residual_fine9, n_a[9]);
																		// this is process flow logic
																		if (Rnext_9 > process_flow_beta*Rprev_9) {
																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																		}
																		else {
																			Rprev_9 = Rnext_9;
																		}
																	}

																	if (iter == nu1) {
																		printf("level 9 limit presmother iteration is reached\n");
																	}

																}
																else {
																	for (integer iter = 0; iter < nu1; iter++) {
																		if (bonly_serial) {
																			if (bILU2smoother == 1) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu0[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu0[9].zbuf, milu0[9].zbuf2, milu0[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += milu0[9].zbuf2[i43 + 1];
																				}

																			}
																			else if (1 && bILU2smoother == 2) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu2[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu2[9].zbuf, milu2[9].zbuf2, milu2[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += milu2[9].zbuf2[i43 + 1];
																				}

																			}
																			else {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																			}
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																	}
																}


																// точное решение на подробном уровне лишь замедляет время счёта и нисколько не
																// улучшает сходимость.



																move_down(nu1, nu2);

																if (ilevel > 10) {
																	// 8 сентября 2015 РИМИНИ пляж 

																	// residual
																	if (!process_flow_logic) {
																		//doublerealT *residual_fine9 = new doublerealT[n_a[9] + 1];
																		//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9], error_approx_coarse8, residual_coarse8, flag, n_a[9], residual_fine9);
																		//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8], residual_fine9);
																		residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);
																	}

																	//doublerealT *residual_coarse9 = new doublerealT[n_a[10] + 1];

																	// restriction
																	restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], flag, residual_fine9, residual_coarse9, n_a[9], n_a[10]);



																	// Amat*e=r;
																	//doublerealT* error_approx_coarse9 = new doublerealT[n_a[10] + 1];


																	if (imyinit == ZERO_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = 0.0;
																		}
																	}
																	if (imyinit == RANDOM_INIT) {
																		for (integer ii = 1; ii <= n_a[10]; ii++) {
																			error_approx_coarse9[ii] = (rand() / ((doublerealT)RAND_MAX));
																		}
																	}

																	//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																	{
																		// pre smothing
																		doublerealT R0_10 = 0.0;
																		doublerealT Rprev_10 = 0.0, Rnext_10 = 0.0;
																		if (process_flow_logic) {
																			// calculate initial residual.
																			//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9], residual_fine10);
																			residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);



																			R0_10 = norma(residual_fine10, n_a[10]);
																			Rprev_10 = R0_10;

																			// smother
																			integer iter = 0;
																			for (iter = 0; iter < nu1; iter++) {
																				//quick seidel
																				if (bonly_serial) {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}

																				//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9], residual_fine10);
																				residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);


																				Rnext_10 = norma(residual_fine10, n_a[10]);
																				// this is process flow logic
																				if (Rnext_10 > process_flow_beta*Rprev_10) {
																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																				}
																				else {
																					Rprev_10 = Rnext_10;
																				}
																			}

																			if (iter == nu1) {
																				printf("level 10 limit presmother iteration is reached\n");
																			}

																		}
																		else {
																			for (integer iter = 0; iter < nu1; iter++) {
																				if (bonly_serial) {
																					if (bILU2smoother == 1) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu0[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu0[10].zbuf, milu0[10].zbuf2, milu0[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += milu0[10].zbuf2[i43 + 1];
																						}

																					}
																					else if (1 && bILU2smoother == 2) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu2[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu2[10].zbuf, milu2[10].zbuf2, milu2[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += milu2[10].zbuf2[i43 + 1];
																						}

																					}
																					else {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																					}
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																			}
																		}

																		// до 11 уровня вроде всё верно 3 января 2016

																		move_down(nu1, nu2);

																		if (ilevel > 11) {
																			// 8 сентября 2015 РИМИНИ пляж 

																			// residual
																			if (!process_flow_logic) {
																				//doublerealT *residual_fine10 = new doublerealT[n_a[10] + 1];
																				//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10], error_approx_coarse9, residual_coarse9, flag, n_a[10], residual_fine10);
																				//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9], residual_fine10);
																				residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);
																			}

																			//doublerealT *residual_coarse10 = new doublerealT[n_a[11] + 1];

																			// restriction
																			restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], flag, residual_fine10, residual_coarse10, n_a[10], n_a[11]);


																			
																			// Amat*e=r;
																			//doublerealT* error_approx_coarse10 = new doublerealT[n_a[11] + 1];


																			if (imyinit == ZERO_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = 0.0;
																				}
																			}
																			if (imyinit == RANDOM_INIT) {
																				for (integer ii = 1; ii <= n_a[11]; ii++) {
																					error_approx_coarse10[ii] = (rand() / ((doublerealT)RAND_MAX));
																				}
																			}

																			//for (integer i_37 = 1; i_37 <= igam; i_37++)
																			{
																				// pre smothing
																				doublerealT R0_11 = 0.0;
																				doublerealT Rprev_11 = 0.0, Rnext_11 = 0.0;
																				if (process_flow_logic) {
																					// calculate initial residual.
																					//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10], residual_fine11);
																					residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);



																					R0_11 = norma(residual_fine11, n_a[11]);
																					Rprev_11 = R0_11;

																					// smother
																					integer iter = 0;
																					for (iter = 0; iter < nu1; iter++) {
																						//quick seidel
																						if (bonly_serial) {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}

																						//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9]+ n_a[10], residual_fine11);
																						residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);


																						Rnext_11 = norma(residual_fine11, n_a[11]);
																						// this is process flow logic
																						if (Rnext_11 > process_flow_beta*Rprev_11) {
																							// Смысл модификации в том что мы экономим итерации на пресмутере.
																							break; // досрочно опускаемся на следующий уровень если он есть конечно.
																						}
																						else {
																							Rprev_11 = Rnext_11;
																						}
																					}

																					if (iter == nu1) {
																						printf("level 11 limit presmother iteration is reached\n");
																					}

																				}
																				else {
																					for (integer iter = 0; iter < nu1; iter++) {
																						if (bonly_serial) {
																							if (bILU2smoother == 1) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu0[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu0[11].zbuf, milu0[11].zbuf2, milu0[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += milu0[11].zbuf2[i43 + 1];
																								}

																							}
																							else if (1 && bILU2smoother == 2) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu2[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu2[11].zbuf, milu2[11].zbuf2, milu2[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += milu2[11].zbuf2[i43 + 1];
																								}

																							}
																							else {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																							}
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																					}
																				}

																				move_down(nu1, nu2);

																				if (ilevel > 12) {
																					// 11 сентября 2015 РИМИНИ пляж 

																					// residual
																					if (!process_flow_logic) {
																						//doublerealT *residual_fine11 = new doublerealT[n_a[11] + 1];
																						//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11], error_approx_coarse10, residual_coarse10, flag, n_a[11], residual_fine11);
																						//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10], residual_fine11);
																						residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);
																					}

																					//doublerealT *residual_coarse11 = new doublerealT[n_a[12] + 1];

																					// restriction
																					restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], flag, residual_fine11, residual_coarse11, n_a[11], n_a[12]);



																					// Amat*e=r;
																					//doublerealT* error_approx_coarse11 = new doublerealT[n_a[12] + 1];

																					if (imyinit == ZERO_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = 0.0;
																						}
																					}
																					if (imyinit == RANDOM_INIT) {
																						for (integer ii = 1; ii <= n_a[12]; ii++) {
																							error_approx_coarse11[ii] = (rand() / ((doublerealT)RAND_MAX));
																						}
																					}

																					//for (integer i_37 = 1; i_37 <= igam; i_37++)
																					{
																						// pre smothing
																						doublerealT R0_12 = 0.0;
																						doublerealT Rprev_12 = 0.0, Rnext_12 = 0.0;
																						if (process_flow_logic) {
																							// calculate initial residual.
																							//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);
																							residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);



																							R0_12 = norma(residual_fine12, n_a[12]);
																							Rprev_12 = R0_12;

																							// smother
																							integer iter = 0;
																							for (iter = 0; iter < nu1; iter++) {
																								//quick seidel
																								if (bonly_serial) {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}

																								//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12);
																								residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);


																								Rnext_12 = norma(residual_fine12, n_a[12]);
																								// this is process flow logic
																								if (Rnext_12 > process_flow_beta*Rprev_12) {
																									// Смысл модификации в том что мы экономим итерации на пресмутере.
																									break; // досрочно опускаемся на следующий уровень если он есть конечно.
																								}
																								else {
																									Rprev_12 = Rnext_12;
																								}
																							}

																							if (iter == nu1) {
																								printf("level 12 limit presmother iteration is reached\n");
																							}

																						}
																						else {
																							for (integer iter = 0; iter < nu1; iter++) {
																								if (bonly_serial) {
																									if (bILU2smoother == 1) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu0[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu0[12].zbuf, milu0[12].zbuf2, milu0[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += milu0[12].zbuf2[i43 + 1];
																										}

																									}
																									else if (1 && bILU2smoother == 2) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu2[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu2[12].zbuf, milu2[12].zbuf2, milu2[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += milu2[12].zbuf2[i43 + 1];
																										}

																									}
																									else {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																									}
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																							}
																						}

																						move_down(nu1, nu2);

																						if (ilevel > 13) {
																							// 11 сентября 2015 РИМИНИ пляж 

																							// residual
																							if (!process_flow_logic) {
																								//doublerealT *residual_fine12 = new doublerealT[n_a[12] + 1];
																								//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12], error_approx_coarse11, residual_coarse11, flag, n_a[12], residual_fine12);
																								//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);
																								residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);
																							}

																							//doublerealT *residual_coarse12 = new doublerealT[n_a[13] + 1];

																							// restriction
																							restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], flag, residual_fine12, residual_coarse12, n_a[12], n_a[13]);



																							// Amat*e=r;
																							//doublerealT* error_approx_coarse12 = new doublerealT[n_a[13] + 1];

																							if (imyinit == ZERO_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = 0.0;
																								}
																							}
																							if (imyinit == RANDOM_INIT) {
																								for (integer ii = 1; ii <= n_a[13]; ii++) {
																									error_approx_coarse12[ii] = (rand() / ((doublerealT)RAND_MAX));
																								}
																							}

																							//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																							{
																								// pre smothing
																								doublerealT R0_13 = 0.0;
																								doublerealT Rprev_13 = 0.0, Rnext_13 = 0.0;
																								if (process_flow_logic) {
																									// calculate initial residual.
																									//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);
																									residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);



																									R0_13 = norma(residual_fine13, n_a[13]);
																									Rprev_13 = R0_13;

																									// smother
																									integer iter = 0;
																									for (iter = 0; iter < nu1; iter++) {
																										//quick seidel
																										if (bonly_serial) {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}

																										//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13);
																										residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);


																										Rnext_13 = norma(residual_fine13, n_a[13]);
																										// this is process flow logic
																										if (Rnext_13 > process_flow_beta*Rprev_13) {
																											// Смысл модификации в том что мы экономим итерации на пресмутере.
																											break; // досрочно опускаемся на следующий уровень если он есть конечно.
																										}
																										else {
																											Rprev_13 = Rnext_13;
																										}
																									}

																									if (iter == nu1) {
																										printf("level 13 limit presmother iteration is reached\n");
																									}

																								}
																								else {
																									for (integer iter = 0; iter < nu1; iter++) {
																										if (bonly_serial) {
																											if (bILU2smoother == 1) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu0[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu0[13].zbuf, milu0[13].zbuf2, milu0[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += milu0[13].zbuf2[i43 + 1];
																												}

																											}
																											else if (1 && bILU2smoother == 2) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu2[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu2[13].zbuf, milu2[13].zbuf2, milu2[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += milu2[13].zbuf2[i43 + 1];
																												}

																											}
																											else {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																											}
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																									}
																								}


																								move_down(nu1, nu2);

																								if (ilevel > 14) {
																									// 11 сентября 2015 РИМИНИ пляж 

																									// residual
																									if (!process_flow_logic) {
																										//doublerealT *residual_fine13 = new doublerealT[n_a[13] + 1];
																										//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13], error_approx_coarse12, residual_coarse12, flag, n_a[13], residual_fine13);
																										//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);
																										residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);
																									}

																									//doublerealT *residual_coarse13 = new doublerealT[n_a[14] + 1];

																									// restriction
																									restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], flag, residual_fine13, residual_coarse13, n_a[13], n_a[14]);


																									// Amat*e=r;
																									//doublerealT* error_approx_coarse13 = new doublerealT[n_a[14] + 1];

																									if (imyinit == ZERO_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = 0.0;
																										}
																									}
																									if (imyinit == RANDOM_INIT) {
																										for (integer ii = 1; ii <= n_a[14]; ii++) {
																											error_approx_coarse13[ii] = (rand() / ((doublerealT)RAND_MAX));
																										}
																									}


																									//for (integer i_37 = 1; i_37 <= igam; i_37++)
																									{
																										// pre smothing
																										doublerealT R0_14 = 0.0;
																										doublerealT Rprev_14 = 0.0, Rnext_14 = 0.0;
																										if (process_flow_logic) {
																											// calculate initial residual.
																											//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);
																											residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);



																											R0_14 = norma(residual_fine14, n_a[14]);
																											Rprev_14 = R0_14;

																											// smother
																											integer iter = 0;
																											for (iter = 0; iter < nu1; iter++) {
																												//quick seidel
																												if (bonly_serial) {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}

																												//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13], residual_fine14);
																												residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);


																												Rnext_14 = norma(residual_fine14, n_a[14]);
																												// this is process flow logic
																												if (Rnext_14 > process_flow_beta*Rprev_14) {
																													// Смысл модификации в том что мы экономим итерации на пресмутере.
																													break; // досрочно опускаемся на следующий уровень если он есть конечно.
																												}
																												else {
																													Rprev_14 = Rnext_14;
																												}
																											}

																											if (iter == nu1) {
																												printf("level 14 limit presmother iteration is reached\n");
																											}

																										}
																										else {
																											for (integer iter = 0; iter < nu1; iter++) {
																												if (bonly_serial) {
																													if (bILU2smoother == 1) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu0[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu0[14].zbuf, milu0[14].zbuf2, milu0[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += milu0[14].zbuf2[i43 + 1];
																														}

																													}
																													else if (1 && bILU2smoother == 2) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu2[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu2[14].zbuf, milu2[14].zbuf2, milu2[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += milu2[14].zbuf2[i43 + 1];
																														}

																													}
																													else {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																													}
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																											}
																										}


																										move_down(nu1, nu2);

																										if (ilevel > 15) {
																											// 14 сентября 2015 Москва на работе в пн. 

																											// residual
																											if (!process_flow_logic) {
																												//doublerealT *residual_fine14 = new doublerealT[n_a[14] + 1];
																												//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14], error_approx_coarse13, residual_coarse13, flag, n_a[14], residual_fine14);
																												//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);
																												residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);
																											}

																											//doublerealT *residual_coarse14 = new doublerealT[n_a[15] + 1];

																											// restriction
																											restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], flag, residual_fine14, residual_coarse14, n_a[14], n_a[15]);

																											// Amat*e=r;
																											//doublerealT* error_approx_coarse14 = new doublerealT[n_a[15] + 1];
																											if (imyinit == ZERO_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = 0.0;
																												}
																											}
																											if (imyinit == RANDOM_INIT) {
																												for (integer ii = 1; ii <= n_a[15]; ii++) {
																													error_approx_coarse14[ii] = (rand() / ((doublerealT)RAND_MAX));
																												}
																											}

																											//for (integer i_37 = 1; i_37 <= igam; i_37++) 
																											{
																												// pre smothing
																												doublerealT R0_15 = 0.0;
																												doublerealT Rprev_15 = 0.0, Rnext_15 = 0.0;
																												if (process_flow_logic) {
																													// calculate initial residual.
																													//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																													residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);



																													R0_15 = norma(residual_fine15, n_a[15]);
																													Rprev_15 = R0_15;

																													// smother
																													integer iter = 0;
																													for (iter = 0; iter < nu1; iter++) {
																														//quick seidel
																														if (bonly_serial) {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}

																														//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																														residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);


																														Rnext_15 = norma(residual_fine15, n_a[15]);
																														// this is process flow logic
																														if (Rnext_15 > process_flow_beta*Rprev_15) {
																															// Смысл модификации в том что мы экономим итерации на пресмутере.
																															break; // досрочно опускаемся на следующий уровень если он есть конечно.
																														}
																														else {
																															Rprev_15 = Rnext_15;
																														}
																													}

																													if (iter == nu1) {
																														printf("level 15 limit presmother iteration is reached\n");
																													}

																												}
																												else {
																													for (integer iter = 0; iter < nu1; iter++) {
																														if (bonly_serial) {
																															if (bILU2smoother == 1) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu0[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu0[15].zbuf, milu0[15].zbuf2, milu0[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse15[i43 + 1] += milu0[15].zbuf2[i43 + 1];
																																}

																															}
																															else if (1 && bILU2smoother == 2) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu2[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu2[15].zbuf, milu2[15].zbuf2, milu2[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse14[i43 + 1] += milu2[15].zbuf2[i43 + 1];
																																}

																															}
																															else {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																															}
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																													}
																												}


																												move_down(nu1, nu2);

																												if (ilevel > 16) {
																													// 10 октября 2015. 

																													// residual
																													if (!process_flow_logic) {
																														//doublerealT *residual_fine15 = new doublerealT[n_a[15] + 1];
																														//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15], error_approx_coarse14, residual_coarse14, flag, n_a[15], residual_fine15);
																														//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																														residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);
																													}

																													//doublerealT *residual_coarse15 = new doublerealT[n_a[16] + 1];

																													// restriction
																													restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], flag, residual_fine15, residual_coarse15, n_a[15], n_a[16]);

																													
																													// Amat*e=r;
																													//doublerealT* error_approx_coarse15 = new doublerealT[n_a[16] + 1];

																													if (imyinit == ZERO_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = 0.0;
																														}
																													}
																													if (imyinit == RANDOM_INIT) {
																														for (integer ii = 1; ii <= n_a[16]; ii++) {
																															error_approx_coarse15[ii] = (rand() / ((doublerealT)RAND_MAX));
																														}
																													}

																													//for (integer i_37 = 1; i_37 <= igam; i_37++)
																													{
																														// pre smothing
																														doublerealT R0_16 = 0.0;
																														doublerealT Rprev_16 = 0.0, Rnext_16 = 0.0;
																														if (process_flow_logic) {
																															// calculate initial residual.
																															//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																															residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);



																															R0_16 = norma(residual_fine16, n_a[16]);
																															Rprev_16 = R0_16;

																															// smother
																															integer iter = 0;
																															for (iter = 0; iter < nu1; iter++) {
																																//quick seidel
																																if (bonly_serial) {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}

																																//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																																residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);


																																Rnext_16 = norma(residual_fine16, n_a[16]);
																																// this is process flow logic
																																if (Rnext_16 > process_flow_beta*Rprev_16) {
																																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																}
																																else {
																																	Rprev_16 = Rnext_16;
																																}
																															}

																															if (iter == nu1) {
																																printf("level 16 limit presmother iteration is reached\n");
																															}

																														}
																														else {
																															for (integer iter = 0; iter < nu1; iter++) {
																																if (bonly_serial) {
																																	if (bILU2smoother == 1) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu0[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu0[16].zbuf, milu0[16].zbuf2, milu0[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse16[i43 + 1] += milu0[16].zbuf2[i43 + 1];
																																		}

																																	}
																																	else if (1 && bILU2smoother == 2) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu2[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu2[16].zbuf, milu2[16].zbuf2, milu2[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse15[i43 + 1] += milu2[16].zbuf2[i43 + 1];
																																		}

																																	}
																																	else {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																	}
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																															}
																														}


																														move_down(nu1, nu2);

																														if (ilevel > 17) {
																															// 10 октября 2015. 

																															// residual
																															if (!process_flow_logic) {
																																//doublerealT *residual_fine16 = new doublerealT[n_a[16] + 1];
																																//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16], error_approx_coarse15, residual_coarse15, flag, n_a[16], residual_fine16);
																																//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																																residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);
																															}

																															
																															//doublerealT *residual_coarse16 = new doublerealT[n_a[17] + 1];

																															// restriction
																															restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], flag, residual_fine16, residual_coarse16, n_a[16], n_a[17]);

																																																														
																															// Amat*e=r;
																															//doublerealT* error_approx_coarse16 = new doublerealT[n_a[17] + 1];
																															if (imyinit == ZERO_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = 0.0;
																																}
																															}
																															if (imyinit == RANDOM_INIT) {
																																for (integer ii = 1; ii <= n_a[17]; ii++) {
																																	error_approx_coarse16[ii] = (rand() / ((doublerealT)RAND_MAX));
																																}
																															}


																															//for (integer i_37 = 1; i_37 <= igam; i_37++)
																															{
																																// pre smothing
																																doublerealT R0_17 = 0.0;
																																doublerealT Rprev_17 = 0.0, Rnext_17 = 0.0;
																																if (process_flow_logic) {
																																	// calculate initial residual.
																																	//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																	residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);



																																	R0_17 = norma(residual_fine17, n_a[17]);
																																	Rprev_17 = R0_17;

																																	// smother
																																	integer iter = 0;
																																	for (iter = 0; iter < nu1; iter++) {
																																		//quick seidel
																																		if (bonly_serial) {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}

																																		//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																		residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);


																																		Rnext_17 = norma(residual_fine17, n_a[17]);
																																		// this is process flow logic
																																		if (Rnext_17 > process_flow_beta*Rprev_17) {
																																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																		}
																																		else {
																																			Rprev_17 = Rnext_17;
																																		}
																																	}

																																	if (iter == nu1) {
																																		printf("level 17 limit presmother iteration is reached\n");
																																	}

																																}
																																else {
																																	for (integer iter = 0; iter < nu1; iter++) {
																																		if (bonly_serial) {
																																			if (bILU2smoother == 1) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu0[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu0[17].zbuf, milu0[17].zbuf2, milu0[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse17[i43 + 1] += milu0[17].zbuf2[i43 + 1];
																																				}

																																			}
																																			else if (1 && bILU2smoother == 2) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu2[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu2[17].zbuf, milu2[17].zbuf2, milu2[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse16[i43 + 1] += milu2[17].zbuf2[i43 + 1];
																																				}

																																			}
																																			else {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																			}
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																	}
																																}

																																move_down(nu1, nu2);


																																if (ilevel > 18) {
																																	// 5 декабря 2015. 

																																	// residual
																																	if (!process_flow_logic) {
																																		//doublerealT *residual_fine17 = new doublerealT[n_a[17] + 1];
																																		//residual(Amat, 1 + nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6]+ nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16], nnz_a[0] + nnz_a[1] + nnz_a[2] + nnz_a[3] + nnz_a[4] + nnz_a[5] + nnz_a[6] + nnz_a[7]+ nnz_a[8]+ nnz_a[9]+ nnz_a[10]+ nnz_a[11]+ nnz_a[12]+ nnz_a[13]+ nnz_a[14]+ nnz_a[15]+ nnz_a[16]+ nnz_a[17], error_approx_coarse16, residual_coarse16, flag, n_a[17], residual_fine17);
																																		//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																		residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);
																																	}

																																	//doublerealT *residual_coarse17 = new doublerealT[n_a[18] + 1];

																																	// restriction
																																	restriction(R, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17], flag, residual_fine17, residual_coarse17, n_a[17], n_a[18]);


																																	// Amat*e=r;
																																	//doublerealT* error_approx_coarse17 = new doublerealT[n_a[18] + 1];

																																	if (imyinit == ZERO_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = 0.0;
																																		}
																																	}
																																	if (imyinit == RANDOM_INIT) {
																																		for (integer ii = 1; ii <= n_a[18]; ii++) {
																																			error_approx_coarse17[ii] = (rand() / ((doublerealT)RAND_MAX));
																																		}
																																	}


																																	//for (integer i_37 = 1; i_37 <= igam; i_37++)
																																	{
																																		// pre smothing
																																		doublerealT R0_18 = 0.0;
																																		doublerealT Rprev_18 = 0.0, Rnext_18 = 0.0;
																																		if (process_flow_logic) {
																																			// calculate initial residual.
																																			//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);
																																			residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);



																																			R0_18 = norma(residual_fine18, n_a[18]);
																																			Rprev_18 = R0_18;

																																			// smother
																																			integer iter = 0;
																																			for (iter = 0; iter < nu1; iter++) {
																																				//quick seidel
																																				if (bonly_serial) {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}

																																				//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);
																																				residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);


																																				Rnext_18 = norma(residual_fine18, n_a[18]);
																																				// this is process flow logic
																																				if (Rnext_18 > process_flow_beta*Rprev_18) {
																																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																				}
																																				else {
																																					Rprev_18 = Rnext_18;
																																				}
																																			}

																																			if (iter == nu1) {
																																				printf("level 18 limit presmother iteration is reached\n");
																																			}

																																		}
																																		else {
																																			for (integer iter = 0; iter < nu1; iter++) {
																																				if (bonly_serial) {
																																					if (bILU2smoother == 1) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu0[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu0[18].zbuf, milu0[18].zbuf2, milu0[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse18[i43 + 1] += milu0[18].zbuf2[i43 + 1];
																																						}

																																					}
																																					else if (1 && bILU2smoother == 2) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu2[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu2[18].zbuf, milu2[18].zbuf2, milu2[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse17[i43 + 1] += milu2[18].zbuf2[i43 + 1];
																																						}

																																					}
																																					else {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																					}
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																			}
																																		}

																																		// ЭТО сердцевина SOLUTION PHASE.

																																		// post smothing
																																		// doublerealT R0_18 = 0.0;
																																		///doublerealT Rprev_18 = 0.0, Rnext_18 = 0.0;
																																		if (process_flow_logic) {
																																			// calculate initial residual.
																																			//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);



																																			//Rprev_18 = norma(residual_fine18, n_a[18]);


																																			// smother
																																			integer iter = 0;
																																			for (iter = 0; iter < nu2; iter++) {
																																				//quick seidel
																																				if (bonly_serial) {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}

																																				//residualq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16]+ n_a[17], residual_fine18);
																																				residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);


																																				Rnext_18 = norma(residual_fine18, n_a[18]);
																																				// this is process flow logic
																																				if (Rnext_18 < process_flow_alpha*R0_18) {
																																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																				}
																																				else {
																																					Rprev_18 = Rnext_18;
																																				}
																																			}

																																			if (iter == nu2) {
																																				printf("level 18 limit postsmother iteration is reached\n");
																																			}

																																		}
																																		else {
																																			for (integer iter = 0; iter < nu2; iter++) {
																																				if (bonly_serial) {


																																					if (bILU2smoother == 1) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu0[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu0[18].zbuf, milu0[18].zbuf2, milu0[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse17[i43 + 1] += milu0[18].zbuf2[i43 + 1];
																																						}
																																					}
																																					else if (1 && bILU2smoother == 2) {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																						residualq2(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17], residual_fine18, diag18);

																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							milu2[18].zbuf[i43 + 1] = residual_fine18[i43 + 1];
																																						}
																																						lusol_1patchforRUMBA(n_a[18], milu2[18].zbuf, milu2[18].zbuf2, milu2[18]);
																																						for (integer i43 = 0; i43 < n_a[18]; i43++) {
																																							error_approx_coarse17[i43 + 1] += milu2[18].zbuf2[i43 + 1];
																																						}
																																					}
																																					else {
																																						seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																					}
																																				}
																																				else {
																																					seidelq(Amat, 1, n_a[18], error_approx_coarse17, residual_coarse17, nested_desection18, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16] + n_a[17]);
																																				}
																																			}
																																		}


																																	}

																																	// prolongation
																																	// residual_r
																																	//doublerealT *error_approx_fine17 = new doublerealT[n_a[17] + 1];
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_fine17[ii] = 0.0;
																																	}


																																	prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16] + nnz_aRP[17], flag, error_approx_fine17, error_approx_coarse17, n_a[17], n_a[18]);

																																	
																																	// correction
																																	for (integer ii = 1; ii <= n_a[17]; ii++) {
																																		error_approx_coarse16[ii] += error_approx_fine17[ii];
																																	}

																																	// free
																																	//delete[] error_approx_fine17;
																																	//delete[] error_approx_coarse17;
																																	//delete[] residual_coarse17;
																																	//delete[] residual_fine17;

																																}



																																// post smothing
																																// doublerealT R0_17 = 0.0;
																																///doublerealT Rprev_17 = 0.0, Rnext_17 = 0.0;
																																if (process_flow_logic) {
																																	// calculate initial residual.
																																	//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);



																																	//Rprev_17 = norma(residual_fine17, n_a[17]);


																																	// smother
																																	integer iter = 0;
																																	for (iter = 0; iter < nu2; iter++) {
																																		//quick seidel
																																		if (bonly_serial) {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}

																																		//residualq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15]+ n_a[16], residual_fine17);
																																		residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);


																																		Rnext_17 = norma(residual_fine17, n_a[17]);
																																		// this is process flow logic
																																		if (Rnext_17 < process_flow_alpha*R0_17) {
																																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																		}
																																		else {
																																			Rprev_17 = Rnext_17;
																																		}
																																	}

																																	if (iter == nu2) {
																																		printf("level 17 limit postsmother iteration is reached\n");
																																	}

																																}
																																else {
																																	for (integer iter = 0; iter < nu2; iter++) {
																																		if (bonly_serial) {


																																			if (bILU2smoother == 1) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu0[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu0[17].zbuf, milu0[17].zbuf2, milu0[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse16[i43 + 1] += milu0[17].zbuf2[i43 + 1];
																																				}
																																			}
																																			else if (1 && bILU2smoother == 2) {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																				residualq2(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16], residual_fine17, diag17);

																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					milu2[17].zbuf[i43 + 1] = residual_fine17[i43 + 1];
																																				}
																																				lusol_1patchforRUMBA(n_a[17], milu2[17].zbuf, milu2[17].zbuf2, milu2[17]);
																																				for (integer i43 = 0; i43 < n_a[17]; i43++) {
																																					error_approx_coarse16[i43 + 1] += milu2[17].zbuf2[i43 + 1];
																																				}
																																			}
																																			else {
																																				seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																			}
																																		}
																																		else {
																																			seidelq(Amat, 1, n_a[17], error_approx_coarse16, residual_coarse16, nested_desection17, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15] + n_a[16]);
																																		}
																																	}
																																}
																															}
																															move_up(nu1, nu2);

																															// prolongation
																															// residual_r
																															//doublerealT *error_approx_fine16 = new doublerealT[n_a[16] + 1];
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_fine16[ii] = 0.0;
																															}


																															prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15] + nnz_aRP[16], flag, error_approx_fine16, error_approx_coarse16, n_a[16], n_a[17]);

																															
																															// correction
																															for (integer ii = 1; ii <= n_a[16]; ii++) {
																																error_approx_coarse15[ii] += error_approx_fine16[ii];
																															}

																															// free
																															//delete[] error_approx_fine16;
																															//delete[] error_approx_coarse16;
																															//delete[] residual_coarse16;
																															//delete[] residual_fine16;

																														}


																														// post smothing
																														// doublerealT R0_16 = 0.0;
																														///doublerealT Rprev_16 = 0.0, Rnext_16 = 0.0;
																														if (process_flow_logic) {
																															// calculate initial residual.
																															//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);



																															//Rprev_16 = norma(residual_fine16, n_a[16]);


																															// smother
																															integer iter = 0;
																															for (iter = 0; iter < nu2; iter++) {
																																//quick seidel
																																if (bonly_serial) {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}

																																//residualq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14]+ n_a[15], residual_fine16);
																																residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);


																																Rnext_16 = norma(residual_fine16, n_a[16]);
																																// this is process flow logic
																																if (Rnext_16 < process_flow_alpha*R0_16) {
																																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																																}
																																else {
																																	Rprev_16 = Rnext_16;
																																}
																															}

																															if (iter == nu2) {
																																printf("level 16 limit postsmother iteration is reached\n");
																															}

																														}
																														else {
																															for (integer iter = 0; iter < nu2; iter++) {
																																if (bonly_serial) {


																																	if (bILU2smoother == 1) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu0[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu0[16].zbuf, milu0[16].zbuf2, milu0[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse15[i43 + 1] += milu0[16].zbuf2[i43 + 1];
																																		}
																																	}
																																	else if (1 && bILU2smoother == 2) {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																		residualq2(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15], residual_fine16, diag16);

																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			milu2[16].zbuf[i43 + 1] = residual_fine16[i43 + 1];
																																		}
																																		lusol_1patchforRUMBA(n_a[16], milu2[16].zbuf, milu2[16].zbuf2, milu2[16]);
																																		for (integer i43 = 0; i43 < n_a[16]; i43++) {
																																			error_approx_coarse15[i43 + 1] += milu2[16].zbuf2[i43 + 1];
																																		}
																																	}
																																	else {
																																		seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																	}
																																}
																																else {
																																	seidelq(Amat, 1, n_a[16], error_approx_coarse15, residual_coarse15, nested_desection16, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14] + n_a[15]);
																																}
																															}
																														}



																													}
																													move_up(nu1, nu2);

																													// prolongation
																													// residual_r
																													//doublerealT *error_approx_fine15 = new doublerealT[n_a[15] + 1];
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_fine15[ii] = 0.0;
																													}


																													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14] + nnz_aRP[15], flag, error_approx_fine15, error_approx_coarse15, n_a[15], n_a[16]);

																													
																													// correction
																													for (integer ii = 1; ii <= n_a[15]; ii++) {
																														error_approx_coarse14[ii] += error_approx_fine15[ii];
																													}

																													// free
																													//delete[] error_approx_fine15;
																													//delete[] error_approx_coarse15;
																													//delete[] residual_coarse15;
																													//delete[] residual_fine15;

																												}

																												// post smothing
																												// doublerealT R0_15 = 0.0;
																												///doublerealT Rprev_15 = 0.0, Rnext_15 = 0.0;
																												if (process_flow_logic) {
																													// calculate initial residual.
																													//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);



																													//Rprev_15 = norma(residual_fine15, n_a[15]);


																													// smother
																													integer iter = 0;
																													for (iter = 0; iter < nu2; iter++) {
																														//quick seidel
																														if (bonly_serial) {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}

																														//residualq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13]+ n_a[14], residual_fine15);
																														residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);


																														Rnext_15 = norma(residual_fine15, n_a[15]);
																														// this is process flow logic
																														if (Rnext_15 < process_flow_alpha*R0_15) {
																															// Смысл модификации в том что мы экономим итерации на пресмутере.
																															break; // досрочно опускаемся на следующий уровень если он есть конечно.
																														}
																														else {
																															Rprev_15 = Rnext_15;
																														}
																													}

																													if (iter == nu2) {
																														printf("level 15 limit postsmother iteration is reached\n");
																													}

																												}
																												else {
																													for (integer iter = 0; iter < nu2; iter++) {
																														if (bonly_serial) {


																															if (bILU2smoother == 1) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu0[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu0[15].zbuf, milu0[15].zbuf2, milu0[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse14[i43 + 1] += milu0[15].zbuf2[i43 + 1];
																																}
																															}
																															else if (1 && bILU2smoother == 2) {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																																residualq2(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14], residual_fine15, diag15);

																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	milu2[15].zbuf[i43 + 1] = residual_fine15[i43 + 1];
																																}
																																lusol_1patchforRUMBA(n_a[15], milu2[15].zbuf, milu2[15].zbuf2, milu2[15]);
																																for (integer i43 = 0; i43 < n_a[15]; i43++) {
																																	error_approx_coarse14[i43 + 1] += milu2[15].zbuf2[i43 + 1];
																																}
																															}
																															else {
																																seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																															}
																														}
																														else {
																															seidelq(Amat, 1, n_a[15], error_approx_coarse14, residual_coarse14, nested_desection15, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13] + n_a[14]);
																														}
																													}
																												}


																											}
																											move_up(nu1, nu2);

																											// prolongation
																											// residual_r
																											//doublerealT *error_approx_fine14 = new doublerealT[n_a[14] + 1];
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_fine14[ii] = 0.0;
																											}


																											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13] + nnz_aRP[14], flag, error_approx_fine14, error_approx_coarse14, n_a[14], n_a[15]);

																											
																											// correction
																											for (integer ii = 1; ii <= n_a[14]; ii++) {
																												error_approx_coarse13[ii] += error_approx_fine14[ii];
																											}

																											// free
																											//delete[] error_approx_fine14;
																											//delete[] error_approx_coarse14;
																											//delete[] residual_coarse14;
																											//delete[] residual_fine14;

																										}


																										// post smothing
																										// doublerealT R0_14 = 0.0;
																										///doublerealT Rprev_14 = 0.0, Rnext_14 = 0.0;
																										if (process_flow_logic) {
																											// calculate initial residual.
																											//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);



																											//Rprev_14 = norma(residual_fine14, n_a[14]);


																											// smother
																											integer iter = 0;
																											for (iter = 0; iter < nu2; iter++) {
																												//quick seidel
																												if (bonly_serial) {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}

																												//residualq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12]+ n_a[13], residual_fine14);
																												residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);


																												Rnext_14 = norma(residual_fine14, n_a[14]);
																												// this is process flow logic
																												if (Rnext_14 < process_flow_alpha*R0_14) {
																													// Смысл модификации в том что мы экономим итерации на пресмутере.
																													break; // досрочно опускаемся на следующий уровень если он есть конечно.
																												}
																												else {
																													Rprev_14 = Rnext_14;
																												}
																											}

																											if (iter == nu2) {
																												printf("level 14 limit postsmother iteration is reached\n");
																											}

																										}
																										else {
																											for (integer iter = 0; iter < nu2; iter++) {
																												if (bonly_serial) {


																													if (bILU2smoother == 1) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu0[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu0[14].zbuf, milu0[14].zbuf2, milu0[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += milu0[14].zbuf2[i43 + 1];
																														}
																													}
																													else if (1 && bILU2smoother == 2) {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																														residualq2(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13], residual_fine14, diag14);

																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															milu2[14].zbuf[i43 + 1] = residual_fine14[i43 + 1];
																														}
																														lusol_1patchforRUMBA(n_a[14], milu2[14].zbuf, milu2[14].zbuf2, milu2[14]);
																														for (integer i43 = 0; i43 < n_a[14]; i43++) {
																															error_approx_coarse13[i43 + 1] += milu2[14].zbuf2[i43 + 1];
																														}
																													}
																													else {
																														seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																													}
																												}
																												else {
																													seidelq(Amat, 1, n_a[14], error_approx_coarse13, residual_coarse13, nested_desection14, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12] + n_a[13]);
																												}
																											}
																										}


																									}

																									move_up(nu1, nu2);

																									// prolongation
																									// residual_r
																									//doublerealT *error_approx_fine13 = new doublerealT[n_a[13] + 1];
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_fine13[ii] = 0.0;
																									}

#if doubleintprecision == 1
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%lld]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%lld]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#else
																									//for (integer ii = 1; ii <= n_a[14]; ii++) {// debug
																									//printf("error_approx_coarse13[%d]=%e\n",ii, error_approx_coarse13[ii]);

																									//printf("residual_coarse13[%d]=%e\n", ii, residual_coarse13[ii]);
																									//getchar();
																									//}
																									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+2*nnz_a[13]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12] +2*nnz_a[13]+ nnz_a[14]; ii++) {// debug
																									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																									//if (ii % 20 == 0) getchar();
																									//}
#endif
																									

																									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12] + nnz_aRP[13], flag, error_approx_fine13, error_approx_coarse13, n_a[13], n_a[14]);

																																																		
																									// correction
																									for (integer ii = 1; ii <= n_a[13]; ii++) {
																										error_approx_coarse12[ii] += error_approx_fine13[ii];
																									}

																									// free
																									//delete[] error_approx_fine13;
																									//delete[] error_approx_coarse13;
																									//delete[] residual_coarse13;
																									//delete[] residual_fine13;

																								}


																								// post smothing
																								// doublerealT R0_13 = 0.0;
																								///doublerealT Rprev_13 = 0.0, Rnext_13 = 0.0;
																								if (process_flow_logic) {
																									// calculate initial residual.
																									//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);



																									//Rprev_13 = norma(residual_fine13, n_a[13]);


																									// smother
																									integer iter = 0;
																									for (iter = 0; iter < nu2; iter++) {
																										//quick seidel
																										if (bonly_serial) {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}

																										//residualq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11]+ n_a[12], residual_fine13);
																										residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);


																										Rnext_13 = norma(residual_fine13, n_a[13]);
																										// this is process flow logic
																										if (Rnext_13 < process_flow_alpha*R0_13) {
																											// Смысл модификации в том что мы экономим итерации на пресмутере.
																											break; // досрочно опускаемся на следующий уровень если он есть конечно.
																										}
																										else {
																											Rprev_13 = Rnext_13;
																										}
																									}

																									if (iter == nu2) {
																										printf("level 13 limit postsmother iteration is reached\n");
																									}

																								}
																								else {
																									for (integer iter = 0; iter < nu2; iter++) {
																										if (bonly_serial) {


																											if (bILU2smoother == 1) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu0[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu0[13].zbuf, milu0[13].zbuf2, milu0[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += milu0[13].zbuf2[i43 + 1];
																												}
																											}
																											else if (1 && bILU2smoother == 2) {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																												residualq2(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12], residual_fine13, diag13);

																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													milu2[13].zbuf[i43 + 1] = residual_fine13[i43 + 1];
																												}
																												lusol_1patchforRUMBA(n_a[13], milu2[13].zbuf, milu2[13].zbuf2, milu2[13]);
																												for (integer i43 = 0; i43 < n_a[13]; i43++) {
																													error_approx_coarse12[i43 + 1] += milu2[13].zbuf2[i43 + 1];
																												}
																											}
																											else {
																												seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																											}
																										}
																										else {
																											seidelq(Amat, 1, n_a[13], error_approx_coarse12, residual_coarse12, nested_desection13, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11] + n_a[12]);
																										}
																									}
																								}
																							}

																							move_up(nu1, nu2);

																							// prolongation
																							// residual_r
																							//doublerealT *error_approx_fine12 = new doublerealT[n_a[12] + 1];
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_fine12[ii] = 0.0;
																							}

#if doubleintprecision == 1
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%lld]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%lld]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#else
																							//for (integer ii = 1; ii <= n_a[13]; ii++) {// debug
																							//printf("error_approx_coarse12[%d]=%e\n",ii, error_approx_coarse12[ii]);

																							//printf("residual_coarse12[%d]=%e\n", ii, residual_coarse12[ii]);
																							//getchar();
																							//}
																							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+2*nnz_a[12]+ nnz_a[13]; ii++) {// debug
																							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																							//if (ii % 20 == 0) getchar();
																							//}
#endif

																							

																							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11] + nnz_aRP[12], flag, error_approx_fine12, error_approx_coarse12, n_a[12], n_a[13]);
																		

																							// correction
																							for (integer ii = 1; ii <= n_a[12]; ii++) {
																								error_approx_coarse11[ii] += error_approx_fine12[ii];
																							}

																							// free
																							//delete[] error_approx_fine12;
																							//delete[] error_approx_coarse12;
																							//delete[] residual_coarse12;
																							//delete[] residual_fine12;

																						}



																						// post smothing
																						//doublerealT R0_12 = 0.0;
																						///doublerealT Rprev_12 = 0.0, Rnext_12 = 0.0;
																						if (process_flow_logic) {
																							// calculate initial residual.
																							//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);



																							//Rprev_12 = norma(residual_fine12, n_a[12]);


																							// smother
																							integer iter = 0;
																							for (iter = 0; iter < nu2; iter++) {
																								//quick seidel
																								if (bonly_serial) {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}

																								//residualq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10]+ n_a[11], residual_fine12);
																								residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);


																								Rnext_12 = norma(residual_fine12, n_a[12]);
																								// this is process flow logic
																								if (Rnext_12 < process_flow_alpha*R0_12) {
																									// Смысл модификации в том что мы экономим итерации на пресмутере.
																									break; // досрочно опускаемся на следующий уровень если он есть конечно.
																								}
																								else {
																									Rprev_12 = Rnext_12;
																								}
																							}

																							if (iter == nu2) {
																								printf("level 12 limit postsmother iteration is reached\n");
																							}

																						}
																						else {
																							for (integer iter = 0; iter < nu2; iter++) {
																								if (bonly_serial) {


																									if (bILU2smoother == 1) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu0[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu0[12].zbuf, milu0[12].zbuf2, milu0[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += milu0[12].zbuf2[i43 + 1];
																										}
																									}
																									else if (1 && bILU2smoother == 2) {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																										residualq2(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11], residual_fine12, diag12);

																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											milu2[12].zbuf[i43 + 1] = residual_fine12[i43 + 1];
																										}
																										lusol_1patchforRUMBA(n_a[12], milu2[12].zbuf, milu2[12].zbuf2, milu2[12]);
																										for (integer i43 = 0; i43 < n_a[12]; i43++) {
																											error_approx_coarse11[i43 + 1] += milu2[12].zbuf2[i43 + 1];
																										}
																									}
																									else {
																										seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																									}
																								}
																								else {
																									seidelq(Amat, 1, n_a[12], error_approx_coarse11, residual_coarse11, nested_desection12, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10] + n_a[11]);
																								}
																							}
																						}
																					}
																					move_up(nu1, nu2);

																					// prolongation
																					// residual_r
																					//doublerealT *error_approx_fine11 = new doublerealT[n_a[11] + 1];
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_fine11[ii] = 0.0;
																					}

#if doubleintprecision == 1
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%lld]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%lld]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#else
																					//for (integer ii = 1; ii <= n_a[12]; ii++) {// debug
																					//printf("error_approx_coarse11[%d]=%e\n",ii, error_approx_coarse11[ii]);

																					//printf("residual_coarse11[%d]=%e\n", ii, residual_coarse11[ii]);
																					//getchar();
																					//}
																					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+2*nnz_a[11]+ nnz_a[12]; ii++) {// debug
																					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																					//if (ii % 20 == 0) getchar();
																					//}
#endif

																					

																					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10] + nnz_aRP[11], flag, error_approx_fine11, error_approx_coarse11, n_a[11], n_a[12]);
																					
																					
																					// correction
																					for (integer ii = 1; ii <= n_a[11]; ii++) {
																						error_approx_coarse10[ii] += error_approx_fine11[ii];
																					}

																					// free
																					//delete[] error_approx_fine11;
																					//delete[] error_approx_coarse11;
																					//delete[] residual_coarse11;
																					//delete[] residual_fine11;

																				}


																				// post smothing
																				//doublerealT R0_11 = 0.0;
																				///doublerealT Rprev_11 = 0.0, Rnext_11 = 0.0;
																				if (process_flow_logic) {
																					// calculate initial residual.
																					//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9]+ n_a[10], residual_fine11);



																					//Rprev_11 = norma(residual_fine11, n_a[11]);


																					// smother
																					integer iter = 0;
																					for (iter = 0; iter < nu2; iter++) {
																						//quick seidel
																						if (bonly_serial) {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}

																						//residualq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9]+ n_a[10], residual_fine11);
																						residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);


																						Rnext_11 = norma(residual_fine11, n_a[11]);
																						// this is process flow logic
																						if (Rnext_11 < process_flow_alpha*R0_11) {
																							// Смысл модификации в том что мы экономим итерации на пресмутере.
																							break; // досрочно опускаемся на следующий уровень если он есть конечно.
																						}
																						else {
																							Rprev_11 = Rnext_11;
																						}
																					}

																					if (iter == nu2) {
																						printf("level 11 limit postsmother iteration is reached\n");
																					}

																				}
																				else {
																					for (integer iter = 0; iter < nu2; iter++) {
																						if (bonly_serial) {


																							if (bILU2smoother == 1) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu0[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu0[11].zbuf, milu0[11].zbuf2, milu0[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += milu0[11].zbuf2[i43 + 1];
																								}
																							}
																							else if (1 && bILU2smoother == 2) {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																								residualq2(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10], residual_fine11, diag11);

																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									milu2[11].zbuf[i43 + 1] = residual_fine11[i43 + 1];
																								}
																								lusol_1patchforRUMBA(n_a[11], milu2[11].zbuf, milu2[11].zbuf2, milu2[11]);
																								for (integer i43 = 0; i43 < n_a[11]; i43++) {
																									error_approx_coarse10[i43 + 1] += milu2[11].zbuf2[i43 + 1];
																								}
																							}
																							else {
																								seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																							}
																						}
																						else {
																							seidelq(Amat, 1, n_a[11], error_approx_coarse10, residual_coarse10, nested_desection11, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9] + n_a[10]);
																						}
																					}
																				}
																				
																			}
																			move_up(nu1, nu2);

																			// prolongation
																			// residual_r
																			//doublerealT *error_approx_fine10 = new doublerealT[n_a[10] + 1];
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_fine10[ii] = 0.0;
																			}

#if doubleintprecision == 1
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%lld]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%lld]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#else
																			//for (integer ii = 1; ii <= n_a[11]; ii++) {// debug
																			//printf("error_approx_coarse10[%d]=%e\n",ii, error_approx_coarse10[ii]);

																			//printf("residual_coarse10[%d]=%e\n", ii, residual_coarse10[ii]);
																			//getchar();
																			//}
																			//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+2*nnz_a[10]+ nnz_a[11]; ii++) {// debug
																			//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																			//if (ii % 20 == 0) getchar();
																			//}
#endif

																			

																			prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9] + nnz_aRP[10], flag, error_approx_fine10, error_approx_coarse10, n_a[10], n_a[11]);

																			
																			// correction
																			for (integer ii = 1; ii <= n_a[10]; ii++) {
																				error_approx_coarse9[ii] += error_approx_fine10[ii];
																			}

																			// free
																			//delete[] error_approx_fine10;
																			//delete[] error_approx_coarse10;
																			//delete[] residual_coarse10;
																			//delete[] residual_fine10;

																		}



																		// post smothing
																		//doublerealT R0_10 = 0.0;
																		///doublerealT Rprev_10 = 0.0, Rnext_10 = 0.0;
																		if (process_flow_logic) {
																			// calculate initial residual.
																			//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]+ n_a[9], residual_fine10);



																			//Rprev_10 = norma(residual_fine10, n_a[10]);


																			// smother
																			integer iter = 0;
																			for (iter = 0; iter < nu2; iter++) {
																				//quick seidel
																				if (bonly_serial) {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}

																				//residualq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8]+ n_a[9], residual_fine10);
																				residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);


																				Rnext_10 = norma(residual_fine10, n_a[10]);
																				// this is process flow logic
																				if (Rnext_10 < process_flow_alpha*R0_10) {
																					// Смысл модификации в том что мы экономим итерации на пресмутере.
																					break; // досрочно опускаемся на следующий уровень если он есть конечно.
																				}
																				else {
																					Rprev_10 = Rnext_10;
																				}
																			}

																			if (iter == nu2) {
																				printf("level 10 limit postsmother iteration is reached\n");
																			}

																		}
																		else {
																			for (integer iter = 0; iter < nu2; iter++) {
																				if (bonly_serial) {


																					if (bILU2smoother == 1) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu0[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu0[10].zbuf, milu0[10].zbuf2, milu0[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += milu0[10].zbuf2[i43 + 1];
																						}
																					}
																					else if (1 && bILU2smoother == 2) {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																						residualq2(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9], residual_fine10, diag10);

																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							milu2[10].zbuf[i43 + 1] = residual_fine10[i43 + 1];
																						}
																						lusol_1patchforRUMBA(n_a[10], milu2[10].zbuf, milu2[10].zbuf2, milu2[10]);
																						for (integer i43 = 0; i43 < n_a[10]; i43++) {
																							error_approx_coarse9[i43 + 1] += milu2[10].zbuf2[i43 + 1];
																						}
																					}
																					else {
																						seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																					}
																				}
																				else {
																					seidelq(Amat, 1, n_a[10], error_approx_coarse9, residual_coarse9, nested_desection10, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8] + n_a[9]);
																				}
																			}
																		}
																		
																	}

																	move_up(nu1, nu2);

																	// prolongation
																	// residual_r
																	//doublerealT *error_approx_fine9 = new doublerealT[n_a[9] + 1];
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_fine9[ii] = 0.0;
																	}

#if doubleintprecision == 1
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%lld]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%lld]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#else
																	//for (integer ii = 1; ii <= n_a[10]; ii++) {// debug
																	//printf("error_approx_coarse9[%d]=%e\n",ii, error_approx_coarse9[ii]);

																	//printf("residual_coarse9[%d]=%e\n", ii, residual_coarse9[ii]);
																	//getchar();
																	//}
																	//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+2*nnz_a[9]+ nnz_a[10]; ii++) {// debug
																	//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
																	//if (ii % 20 == 0) getchar();
																	//}
#endif

																	

																	prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8] + nnz_aRP[9], flag, error_approx_fine9, error_approx_coarse9, n_a[9], n_a[10]);

																	
																	// correction
																	for (integer ii = 1; ii <= n_a[9]; ii++) {
																		error_approx_coarse8[ii] += error_approx_fine9[ii];
																	}

																	// free
																	//delete[] error_approx_fine9;
																	//delete[] error_approx_coarse9;
																	//delete[] residual_coarse9;
																	//delete[] residual_fine9;

																}

																// post smothing
																//doublerealT R0_9 = 0.0;
																///doublerealT Rprev_9 = 0.0, Rnext_9 = 0.0;
																if (process_flow_logic) {
																	// calculate initial residual.
																	//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9);



																	//Rprev_9 = norma(residual_fine9, n_a[9]);


																	// smother
																	integer iter = 0;
																	for (iter = 0; iter < nu2; iter++) {
																		//quick seidel
																		if (bonly_serial) {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}

																		//residualq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7]+ n_a[8], residual_fine9);
																		residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);


																		Rnext_9 = norma(residual_fine9, n_a[9]);
																		// this is process flow logic
																		if (Rnext_9 < process_flow_alpha*R0_9) {
																			// Смысл модификации в том что мы экономим итерации на пресмутере.
																			break; // досрочно опускаемся на следующий уровень если он есть конечно.
																		}
																		else {
																			Rprev_9 = Rnext_9;
																		}
																	}

																	if (iter == nu2) {
																		printf("level 9 limit postsmother iteration is reached\n");
																	}

																}
																else {
																	for (integer iter = 0; iter < nu2; iter++) {
																		if (bonly_serial) {


																			if (bILU2smoother == 1) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu0[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu0[9].zbuf, milu0[9].zbuf2, milu0[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += milu0[9].zbuf2[i43 + 1];
																				}
																			}
																			else if (1 && bILU2smoother == 2) {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																				residualq2(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8], residual_fine9, diag9);

																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					milu2[9].zbuf[i43 + 1] = residual_fine9[i43 + 1];
																				}
																				lusol_1patchforRUMBA(n_a[9], milu2[9].zbuf, milu2[9].zbuf2, milu2[9]);
																				for (integer i43 = 0; i43 < n_a[9]; i43++) {
																					error_approx_coarse8[i43 + 1] += milu2[9].zbuf2[i43 + 1];
																				}
																			}
																			else {
																				seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																			}
																		}
																		else {
																			seidelq(Amat, 1, n_a[9], error_approx_coarse8, residual_coarse8, nested_desection9, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7] + n_a[8]);
																		}
																	}
																}


															}

															move_up(nu1, nu2);

															// prolongation
															// residual_r
															//doublerealT *error_approx_fine8 = new doublerealT[n_a[8] + 1];
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_fine8[ii] = 0.0;
															}

#if doubleintprecision == 1
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%lld]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%lld]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#else
															//for (integer ii = 1; ii <= n_a[9]; ii++) {// debug
															//printf("error_approx_coarse8[%d]=%e\n",ii, error_approx_coarse8[ii]);

															//printf("residual_coarse8[%d]=%e\n", ii, residual_coarse8[ii]);
															//getchar();
															//}
															//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+2*nnz_a[8]+ nnz_a[9]; ii++) {// debug
															//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
															//if (ii % 20 == 0) getchar();
															//}
#endif

															

															prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7] + nnz_aRP[8], flag, error_approx_fine8, error_approx_coarse8, n_a[8], n_a[9]);



															// correction
															for (integer ii = 1; ii <= n_a[8]; ii++) {
																error_approx_coarse7[ii] += error_approx_fine8[ii];
															}

															// free
															//delete[] error_approx_fine8;
															//delete[] error_approx_coarse8;
															//delete[] residual_coarse8;
															//delete[] residual_fine8;

														}




														// post smothing
														//doublerealT R0_8 = 0.0;
														//doublerealT Rprev_8 = 0.0, Rnext_8 = 0.0;
														if (process_flow_logic) {
															// calculate initial residual.
															//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8);



															//Rprev_8 = norma(residual_fine8, n_a[8]);


															// smother
															integer iter = 0;
															for (iter = 0; iter < nu2; iter++) {
																//quick seidel
																if (bonly_serial) {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}

																//residualq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]+ n_a[7], residual_fine8);
																residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);


																Rnext_8 = norma(residual_fine8, n_a[8]);
																// this is process flow logic
																if (Rnext_8 < process_flow_alpha*R0_8) {
																	// Смысл модификации в том что мы экономим итерации на пресмутере.
																	break; // досрочно опускаемся на следующий уровень если он есть конечно.
																}
																else {
																	Rprev_8 = Rnext_8;
																}
															}

															if (iter == nu2) {
																printf("level 8 limit postsmother iteration is reached\n");
															}

														}
														else {
															for (integer iter = 0; iter < nu2; iter++) {
																if (bonly_serial) {
																	if (bILU2smoother == 1) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu0[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu0[8].zbuf, milu0[8].zbuf2, milu0[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += milu0[8].zbuf2[i43 + 1];
																		}
																	}
																	else if (1 && bILU2smoother == 2) {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																		residualq2(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7], residual_fine8, diag8);

																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			milu2[8].zbuf[i43 + 1] = residual_fine8[i43 + 1];
																		}
																		lusol_1patchforRUMBA(n_a[8], milu2[8].zbuf, milu2[8].zbuf2, milu2[8]);
																		for (integer i43 = 0; i43 < n_a[8]; i43++) {
																			error_approx_coarse7[i43 + 1] += milu2[8].zbuf2[i43 + 1];
																		}
																	}
																	else {
																		seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																	}
																}
																else {
																	seidelq(Amat, 1, n_a[8], error_approx_coarse7, residual_coarse7, nested_desection8, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6] + n_a[7]);
																}
															}
														}

													}
													move_up(nu1, nu2);

													// prolongation
													// residual_r
													//doublerealT *error_approx_fine7 = new doublerealT[n_a[7] + 1];
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_fine7[ii] = 0.0;
													}

#if doubleintprecision == 1
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%lld]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%lld]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#else
													//for (integer ii = 1; ii <= n_a[8]; ii++) {// debug
													//printf("error_approx_coarse7[%d]=%e\n",ii, error_approx_coarse7[ii]);

													//printf("residual_coarse7[%d]=%e\n", ii, residual_coarse7[ii]);
													//getchar();
													//}
													//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+2*nnz_a[7]+ nnz_a[8]; ii++) {// debug
													//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
													//if (ii % 20 == 0) getchar();
													//}
#endif

													

													prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6] + nnz_aRP[7], flag, error_approx_fine7, error_approx_coarse7, n_a[7], n_a[8]);

													// correction
													for (integer ii = 1; ii <= n_a[7]; ii++) {
														error_approx_coarse6[ii] += error_approx_fine7[ii];
													}

													// free
													//delete[] error_approx_fine7;
													//delete[] error_approx_coarse7;
													//delete[] residual_coarse7;
													//delete[] residual_fine7;

												}

												// post smothing
												//doublerealT R0_7 = 0.0;
												//doublerealT Rprev_7 = 0.0, Rnext_7 = 0.0;
												if (process_flow_logic) {
													// calculate initial residual.
													//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);



													//Rprev_7 = norma(residual_fine7, n_a[7]);


													// smother
													integer iter = 0;
													for (iter = 0; iter < nu2; iter++) {
														//quick seidel
														if (bonly_serial) {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}

														//residualq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7);
														residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);


														Rnext_7 = norma(residual_fine7, n_a[7]);
														// this is process flow logic
														if (Rnext_7 < process_flow_alpha*R0_7) {
															// Смысл модификации в том что мы экономим итерации на пресмутере.
															break; // досрочно опускаемся на следующий уровень если он есть конечно.
														}
														else {
															Rprev_7 = Rnext_7;
														}
													}

													if (iter == nu2) {
														printf("level 7 limit postsmother iteration is reached\n");
													}

												}
												else {
													for (integer iter = 0; iter < nu2; iter++) {
														if (bonly_serial) {
															if (bILU2smoother == 1) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu0[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu0[7].zbuf, milu0[7].zbuf2, milu0[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += milu0[7].zbuf2[i43 + 1];
																}
															}
															else if (1 && bILU2smoother == 2) {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
																residualq2(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6], residual_fine7, diag7);

																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	milu2[7].zbuf[i43 + 1] = residual_fine7[i43 + 1];
																}
																lusol_1patchforRUMBA(n_a[7], milu2[7].zbuf, milu2[7].zbuf2, milu2[7]);
																for (integer i43 = 0; i43 < n_a[7]; i43++) {
																	error_approx_coarse6[i43 + 1] += milu2[7].zbuf2[i43 + 1];
																}
															}
															else {
																seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
															}
													    }
														else {
															seidelq(Amat, 1, n_a[7], error_approx_coarse6, residual_coarse6, nested_desection7, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5] + n_a[6]);
														}
													}
												}
											}

											move_up(nu1, nu2);


											// prolongation
											// residual_r
											//doublerealT *error_approx_fine6 = new doublerealT[n_a[6] + 1];
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_fine6[ii] = 0.0;
											}

#if doubleintprecision == 1
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%lld]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%lld]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#else
											//for (integer ii = 1; ii <= n_a[7]; ii++) {// debug
											//printf("error_approx_coarse6[%d]=%e\n",ii, error_approx_coarse6[ii]);

											//printf("residual_coarse6[%d]=%e\n", ii, residual_coarse6[ii]);
											//getchar();
											//}
											//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+2*nnz_a[6]+ nnz_a[7]; ii++) {// debug
											//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
											//if (ii % 20 == 0) getchar();
											//}
#endif

											

											prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5] + nnz_aRP[6], flag, error_approx_fine6, error_approx_coarse6, n_a[6], n_a[7]);

											// correction
											for (integer ii = 1; ii <= n_a[6]; ii++) {
												error_approx_coarse5[ii] += error_approx_fine6[ii];
											}

											// free
											//delete[] error_approx_fine6;
											//delete[] error_approx_coarse6;
											//delete[] residual_coarse6;
											//delete[] residual_fine6;

										}



										// post smothing
										if (process_flow_logic) {
											// calculate initial residual.
											//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);



											//Rprev_6 = norma(residual_fine6, n_a[6]);


											// smother
											integer iter = 0;
											for (iter = 0; iter < nu2; iter++) {
												//quick seidel
												if (bonly_serial) {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}

												//residualq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6);
												residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);



												Rnext_6 = norma(residual_fine6, n_a[6]);
												// this is process flow logic
												if (Rnext_6 < process_flow_alpha*R0_6) {
													// Смысл модификации в том что мы экономим итерации на пресмутере.
													break; // досрочно опускаемся на следующий уровень если он есть конечно.
												}
												else {
													Rprev_6 = Rnext_6;
												}
											}

											if (iter == nu2) {
												printf("level 6 limit postsmother iteration is reached\n");
											}

										}
										else {
											for (integer iter = 0; iter < nu2; iter++) {
												if (bonly_serial) {
													if (bILU2smoother == 1) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu0[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu0[6].zbuf, milu0[6].zbuf2, milu0[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += milu0[6].zbuf2[i43 + 1];
														}
													}
													else if (1 && bILU2smoother == 2) {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
														residualq2(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5], residual_fine6, diag6);

														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															milu2[6].zbuf[i43 + 1] = residual_fine6[i43 + 1];
														}
														lusol_1patchforRUMBA(n_a[6], milu2[6].zbuf, milu2[6].zbuf2, milu2[6]);
														for (integer i43 = 0; i43 < n_a[6]; i43++) {
															error_approx_coarse5[i43 + 1] += milu2[6].zbuf2[i43 + 1];
														}
													}
													else {
														seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
													}
												}
												else {
													seidelq(Amat, 1, n_a[6], error_approx_coarse5, residual_coarse5, nested_desection6, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] + n_a[5]);
												}
											}
										}
									}

									move_up(nu1, nu2);

									// prolongation
									// residual_r
									//doublerealT *error_approx_fine5 = new doublerealT[n_a[5] + 1];
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_fine5[ii] = 0.0;
									}


#if doubleintprecision == 1
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%lld]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%lld]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#else
									//for (integer ii = 1; ii <= n_a[6]; ii++) {// debug
									//printf("error_approx_coarse5[%d]=%e\n",ii, error_approx_coarse5[ii]);

									//printf("residual_coarse5[%d]=%e\n", ii, residual_coarse5[ii]);
									//getchar();
									//}
									//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ 2 * nnz_a[5]+ nnz_a[6]; ii++) {// debug
									//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
									//if (ii % 20 == 0) getchar();
									//}
#endif

									

									prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4] + nnz_aRP[5], flag, error_approx_fine5, error_approx_coarse5, n_a[5], n_a[6]);

									// correction
									for (integer ii = 1; ii <= n_a[5]; ii++) {
										error_approx_coarse4[ii] += error_approx_fine5[ii];
									}

									// free
									//delete[] error_approx_fine5;
									//delete[] error_approx_coarse5;
									//delete[] residual_coarse5;
									//delete[] residual_fine5;

								}



								// post smothing
								if (process_flow_logic) {
									// calculate initial residual.
									//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);



									//Rprev_5 = norma(residual_fine5, n_a[5]);


									// smother
									integer iter = 0;
									for (iter = 0; iter < nu2; iter++) {
										//quick seidel
										if (bonly_serial) {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
										else {
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}

										//residualq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4] , residual_fine5);
										residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);


										Rnext_5 = norma(residual_fine5, n_a[5]);
										// this is process flow logic
										if (Rnext_5 < process_flow_alpha*R0_5) {
											// Смысл модификации в том что мы экономим итерации на пресмутере.
											break; // досрочно опускаемся на следующий уровень если он есть конечно.
										}
										else {
											Rprev_5 = Rnext_5;
										}
									}

									if (iter == nu2) {
										printf("level 5 limit postsmother iteration is reached\n");
									}

								}
								else {
									for (integer iter = 0; iter < nu2; iter++) {
										if (bonly_serial) {
											if (bILU2smoother == 1) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu0[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu0[5].zbuf, milu0[5].zbuf2, milu0[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += milu0[5].zbuf2[i43 + 1];
												}
											}
											else if (1 && bILU2smoother == 2) {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
												residualq2(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4], residual_fine5, diag5);

												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													milu2[5].zbuf[i43 + 1] = residual_fine5[i43 + 1];
												}
												lusol_1patchforRUMBA(n_a[5], milu2[5].zbuf, milu2[5].zbuf2, milu2[5]);
												for (integer i43 = 0; i43 < n_a[5]; i43++) {
													error_approx_coarse4[i43 + 1] += milu2[5].zbuf2[i43 + 1];
												}
											}
											else {
												seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
											}
										}
										else
										{
											seidelq(Amat, 1, n_a[5], error_approx_coarse4, residual_coarse4, nested_desection5, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] + n_a[4]);
										}
									}
								}
							}

							move_up(nu1, nu2);

							// prolongation
							// residual_r
							//doublerealT *error_approx_fine4 = new doublerealT[n_a[4] + 1];
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_fine4[ii] = 0.0;
							}

#if doubleintprecision == 1
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%lld]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%lld]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#else
							//for (integer ii = 1; ii <= n_a[5]; ii++) {// debug
							//printf("error_approx_coarse4[%d]=%e\n",ii, error_approx_coarse4[ii]);

							//printf("residual_coarse4[%d]=%e\n", ii, residual_coarse4[ii]);
							//getchar();
							//}
							//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ 2 * nnz_a[4]+ nnz_a[5]; ii++) {// debug
							//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
							//if (ii % 20 == 0) getchar();
							//}
#endif

							

							prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3] + nnz_aRP[4], flag, error_approx_fine4, error_approx_coarse4, n_a[4], n_a[5]);

							// correction
							for (integer ii = 1; ii <= n_a[4]; ii++) {
								error_approx_coarse3[ii] += error_approx_fine4[ii];
							}

							// free
							//delete[] error_approx_fine4;
							//delete[] error_approx_coarse4;
							//delete[] residual_coarse4;
							//delete[] residual_fine4;

							}




							// post smothing
							if (process_flow_logic) {


								// smother
								integer iter = 0;
								for (iter = 0; iter < nu2; iter++) {
									//quick seidel
									if (bonly_serial) {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}

									//residualq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3] , residual_fine4);
									residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);


									Rnext_4 = norma(residual_fine4, n_a[4]);
									// this is process flow logic
									if (Rnext_4 < process_flow_alpha*R0_4) {
										// Смысл модификации в том что мы экономим итерации на пресмутере.
										break; // досрочно опускаемся на следующий уровень если он есть конечно.
									}
									else {
										Rprev_4 = Rnext_4;
									}
								}

								if (iter == nu2) {
									printf("level 4 limit postsmother iteration is reached\n");
								}

							}
							else {
								for (integer iter = 0; iter < nu2; iter++) {
									if (bonly_serial) {
										if (bILU2smoother == 1) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu0[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu0[4].zbuf, milu0[4].zbuf2, milu0[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += milu0[4].zbuf2[i43 + 1];
											}
										}
										else if (1 && bILU2smoother == 2) {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
											residualq2(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3], residual_fine4, diag4);

											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												milu2[4].zbuf[i43 + 1] = residual_fine4[i43 + 1];
											}
											lusol_1patchforRUMBA(n_a[4], milu2[4].zbuf, milu2[4].zbuf2, milu2[4]);
											for (integer i43 = 0; i43 < n_a[4]; i43++) {
												error_approx_coarse3[i43 + 1] += milu2[4].zbuf2[i43 + 1];
											}
										}
										else {
											seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
										}
									}
									else {
										seidelq(Amat, 1, n_a[4], error_approx_coarse3, residual_coarse3, nested_desection4, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] + n_a[3]);
									}
								}
							}
						}
						move_up(nu1, nu2);

						// prolongation
						// residual_r
						//doublerealT *error_approx_fine3 = new doublerealT[n_a[3] + 1];
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_fine3[ii] = 0.0;
						}


#if doubleintprecision == 1
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%lld]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%lld]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#else
						//for (integer ii = 1; ii <= n_a[4]; ii++) {// debug
						//printf("error_approx_coarse3[%d]=%e\n",ii, error_approx_coarse3[ii]);

						//printf("residual_coarse3[%d]=%e\n", ii, residual_coarse3[ii]);
						//getchar();
						//}
						//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]+ 2 * nnz_a[3]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ 2 * nnz_a[3]+ nnz_a[4]; ii++) {// deug
						//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
						//if (ii % 20 == 0) getchar();
						//}
#endif

						

						prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2] + nnz_aRP[3], flag, error_approx_fine3, error_approx_coarse3, n_a[3], n_a[4]);

						// correction
						for (integer ii = 1; ii <= n_a[3]; ii++) {
							error_approx_coarse2[ii] += error_approx_fine3[ii];
						}

						// free
						//delete[] error_approx_fine3;
						//delete[] error_approx_coarse3;
						//delete[] residual_coarse3;
						//delete[] residual_fine3;

						}



						// post smothing
						if (process_flow_logic) {


							// smother
							integer iter = 0;
							for (iter = 0; iter < nu2; iter++) {
								//quick seidel
								if (bonly_serial) {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}

								//residualq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2] , residual_fine3);
								residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);


								Rnext_3 = norma(residual_fine3, n_a[3]);
								// this is process flow logic
								if (Rnext_3 < process_flow_alpha*R0_3) {
									// Смысл модификации в том что мы экономим итерации на пресмутере.
									break; // досрочно опускаемся на следующий уровень если он есть конечно.
								}
								else {
									Rprev_3 = Rnext_3;
								}
							}

							if (iter == nu2) {
								printf("level 3 limit postsmother iteration is reached\n");
							}

						}
						else {
							for (integer iter = 0; iter < nu2; iter++) {
								if (bonly_serial) {
									if (bILU2smoother == 1) {
										// ILU0
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu0[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu0[3].zbuf, milu0[3].zbuf2, milu0[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += milu0[3].zbuf2[i43 + 1];
										}
									}
									else if (1 && bILU2smoother == 2) {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
										residualq2(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2], residual_fine3, diag3);

										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											milu2[3].zbuf[i43 + 1] = residual_fine3[i43 + 1];
										}
										lusol_1patchforRUMBA(n_a[3], milu2[3].zbuf, milu2[3].zbuf2, milu2[3]);
										for (integer i43 = 0; i43 < n_a[3]; i43++) {
											error_approx_coarse2[i43 + 1] += milu2[3].zbuf2[i43 + 1];
										}
									}
									else {
										seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
									}
								}
								else {
									seidelq(Amat, 1, n_a[3], error_approx_coarse2, residual_coarse2, nested_desection3, row_ptr_start, row_ptr_end, n_a[0] + n_a[1] + n_a[2]);
								}
							}
						}
					}

					move_up(nu1, nu2);

					// prolongation
					// residual_r
					//doublerealT *error_approx_fine2 = new doublerealT[n_a[2] + 1];
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_fine2[ii] = 0.0;
					}

#if doubleintprecision == 1
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%lld]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%lld]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#else
					//for (integer ii = 1; ii <= n_a[3]; ii++) {// deug
					//printf("error_approx_coarse2[%d]=%e\n",ii, error_approx_coarse2[ii]);

					//printf("residual_coarse2[%d]=%e\n", ii, residual_coarse2[ii]);
					//getchar();
					//}
					//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]+ 2 * nnz_a[2]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + 2 * nnz_a[2]+ nnz_a[3]; ii++) {// deug
					//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
					//if (ii % 20 == 0) getchar();
					//}
#endif

					

					prolongation(P, 1 + nnz_aRP[0] + nnz_aRP[1], nnz_aRP[0] + nnz_aRP[1] + nnz_aRP[2], flag, error_approx_fine2, error_approx_coarse2, n_a[2], n_a[3]);

					// correction
					for (integer ii = 1; ii <= n_a[2]; ii++) {
						error_approx_coarse1[ii] += error_approx_fine2[ii];
					}

					// free
					//delete[] error_approx_fine2;
					//delete[] error_approx_coarse2;
					//delete[] residual_coarse2;
					//delete[] residual_fine2;

					}


					// post smothing
					if (process_flow_logic) {


						// smother
						integer iter = 0;
						for (iter = 0; iter < nu2; iter++) {
							//quick seidel
							if (bonly_serial) {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}

							//residualq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2);
							residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);



							Rnext_2 = norma(residual_fine2, n_a[2]);
							// this is process flow logic
							if (Rnext_2 < process_flow_alpha*R0_2) {
								// Смысл модификации в том что мы экономим итерации на пресмутере.
								break; // досрочно опускаемся на следующий уровень если он есть конечно.
							}
							else {
								Rprev_2 = Rnext_2;
							}
						}

						if (iter == nu2) {
							printf("level 2 limit postsmother iteration is reached\n");
						}

					}
					else {
						for (integer iter = 0; iter < nu2; iter++) {
							if (bonly_serial) {
								if (bILU2smoother == 1) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu0[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu0[2].zbuf, milu0[2].zbuf2, milu0[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += milu0[2].zbuf2[i43 + 1];
									}
								}
								else if (1 && bILU2smoother == 2) {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
									residualq2(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1], residual_fine2, diag2);

									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										milu2[2].zbuf[i43 + 1] = residual_fine2[i43 + 1];
									}
									lusol_1patchforRUMBA(n_a[2], milu2[2].zbuf, milu2[2].zbuf2, milu2[2]);
									for (integer i43 = 0; i43 < n_a[2]; i43++) {
										error_approx_coarse1[i43 + 1] += milu2[2].zbuf2[i43 + 1];
									}
								}
								else {
									seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
								}
							}
							else {
								seidelq(Amat, 1, n_a[2], error_approx_coarse1, residual_coarse1, nested_desection2, row_ptr_start, row_ptr_end, n_a[0] + n_a[1]);
							}
						}
					}
				}

				move_up(nu1, nu2);

				// prolongation
				// residual_r
				//doublerealT *error_approx_fine1 = new doublerealT[n_a[1] + 1];
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_fine1[ii] = 0.0;
				}

#if doubleintprecision == 1
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%lld]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%lld]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%lld].aij=%e, Amat[%lld].i=%lld, Amat[%lld].j=%lld\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#else
				//for (integer ii = 1; ii <= n_a[2]; ii++) {// deug
				//printf("error_approx_coarse1[%d]=%e\n",ii, error_approx_coarse1[ii]);

				//printf("residual_coarse1[%d]=%e\n", ii, residual_coarse1[ii]);
				//getchar();
				//}
				//for (integer ii = 1 + 2 * nnz_a[0] + 2 * nnz_a[1]; ii <= 2 * nnz_a[0] + 2 * nnz_a[1] + nnz_a[2]; ii++) {// deug
				//printf("Amat[%d].aij=%e, Amat[%d].i=%d, Amat[%d].j=%d\n", ii, Amat[ii].aij, ii, Amat[ii].i, ii, Amat[ii].j);
				//if (ii % 20 == 0) getchar();
				//}
#endif

				

				prolongation(P, 1 + nnz_aRP[0], nnz_aRP[0] + nnz_aRP[1], flag, error_approx_fine1, error_approx_coarse1, n_a[1], n_a[2]);

				// correction
				for (integer ii = 1; ii <= n_a[1]; ii++) {
					error_approx_coarse[ii] += error_approx_fine1[ii];
				}

				// free
				//delete[] error_approx_fine1;
				//delete[] error_approx_coarse1;
				//delete[] residual_coarse1;
				//delete[] residual_fine1;

				}



				// post smothing
				if (process_flow_logic) {


					// smother
					integer iter = 0;
					for (iter = 0; iter < nu2; iter++) {
						//quick seidel
						if (bonly_serial) {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}

						//residualq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0] , residual_fine1);
						residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);


						Rnext_1 = norma(residual_fine1, n_a[1]);
						// this is process flow logic
						if (Rnext_1 < process_flow_alpha*R0_1) {
							// Смысл модификации в том что мы экономим итерации на пресмутере.
							break; // досрочно опускаемся на следующий уровень если он есть конечно.
						}
						else {
							Rprev_1 = Rnext_1;
						}
					}

					if (iter == nu2) {
						printf("level 1 limit postsmother iteration is reached\n");
					}

				}
				else {
					for (integer iter = 0; iter < nu2; iter++) {
						if (bonly_serial) {
							if (bILU2smoother == 1) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu0[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu0[1].zbuf, milu0[1].zbuf2, milu0[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += milu0[1].zbuf2[i43 + 1];
								}
							}
							else if (1 && bILU2smoother == 2) {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
								residualq2(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0], residual_fine1, diag1);

								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									milu2[1].zbuf[i43 + 1] = residual_fine1[i43 + 1];
								}
								lusol_1patchforRUMBA(n_a[1], milu2[1].zbuf, milu2[1].zbuf2, milu2[1]);
								for (integer i43 = 0; i43 < n_a[1]; i43++) {
									error_approx_coarse[i43 + 1] += milu2[1].zbuf2[i43 + 1];
								}
							}
							else {
								seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, row_ptr_start, row_ptr_end, n_a[0]);
							}
						}
						else {
							seidelq(Amat, 1, n_a[1], error_approx_coarse, residual_coarse, nested_desection1, row_ptr_start, row_ptr_end, n_a[0]);
						}
					}
				}
			}

			move_up(nu1, nu2);

			// prolongation
			// residual_r
			//doublerealT *error_approx_fine = new doublerealT[n_a[0] + 1];
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				error_approx_fine[ii] = 0.0;
			}

			prolongation(P, 1, nnz_aRP[0], flag, error_approx_fine, error_approx_coarse, n_a[0], n_a[1]);

			//exporttecplotxy360T_3D_part2amg(x, false, 1);
			//exporttecplotxy360T_3D_part2amg(error_approx_fine, false, 1);

			// correction
			for (integer ii = 1; ii <= n_a[0]; ii++) {
				x[ii] += error_approx_fine[ii];
			}
			//exporttecplotxy360T_3D_part2amg(x, false, 1);
			// free
			//delete[] error_approx_fine;
			//delete[] error_approx_coarse;
			//delete[] residual_coarse;
			//delete[] residual_fine;
		}



		//doublerealT R0_0 = 0.0;
		//doublerealT Rprev_0 = 0.0, Rnext_0 = 0.0;
		// post smothing
		if (process_flow_logic) {
			// calculate initial residual.
			//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
			residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
			Rprev_0 = norma(residual_fine, n_a[0]);

			// smother
			integer iter = 0;
			for (iter = 0; iter < nFinestSweeps; iter++) {
				//quick seidel
				if (bonly_serial) {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
				//residualq(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine);
				residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);
				Rnext_0 = norma(residual_fine, n_a[0]);
				// this is process flow logic
				if (Rnext_0 < process_flow_alpha*Rprev_0) {
					// Смысл модификации в том что мы экономим итерации на пресмутере.
					break; // досрочно опускаемся на следующий уровень если он есть конечно.
				}
				else {
					Rprev_0 = Rnext_0;
				}
			}
			if (iter == nFinestSweeps) {
				printf("level 0 limit postsmother iteration is reached\n");
			}

		}
		else {
			// nFinnestSweeps new logic 14 jan 2016.
			// smother
			for (integer iter = 0; iter < nFinestSweeps; iter++) {
				//seidel(Amat, 1, nnz_a[0], x, b, flag, n_a[0]);
				//quick seidel
				if (bonly_serial) {
					if (bILU2smoother == 1) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);

						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu0[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu0[0].zbuf, milu0[0].zbuf2, milu0[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu0[0].zbuf2[i43 + 1];
						}
					}
					else if (bILU2smoother == 2) {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
						residualq2(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0, residual_fine, diag0);

						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							milu2[0].zbuf[i43 + 1] = residual_fine[i43 + 1];
						}
						lusol_1patchforRUMBA(n_a[0], milu2[0].zbuf, milu2[0].zbuf2, milu2[0]);
						for (integer i43 = 0; i43 < n_a[0]; i43++) {
							x[i43 + 1] += milu2[0].zbuf2[i43 + 1];
						}
					}
					else {
						seidelq<doublereal>(Amat, 1, n_a[0], x, b, row_ptr_start, row_ptr_end, 0);
					}
				}
				else {
					seidelq<doublereal>(Amat, 1, n_a[0], x, b, nested_desection0, row_ptr_start, row_ptr_end, 0);
				}
			}
		}


		//if (bfirst_start_nonlinear_process) {
		// Во избежании расходимости по начальному условию в двойном 
		// вакуумном промежутке.
		//bfirst_start_nonlinear_process = false;
		//break;
		//}
		if (iVar != PAM) {
			if (btheoryGuideANSYSFluent) break; // Делаем лишь один V  цикл.
		}
		//system("pause");
	}

	if (debug_reshime) system("pause");
	//system("pause");

	// Внимание : именно эта строчка обеспечивает сходимость.
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		x[i47] = x_best_search[i47];
	}

	bool identiti = true;
	for (integer i47 = 1; i47 <= n_a[0]; i47++) {
		if (fabs(x[i47] - x_best_search_init[i47]) > 1e-5) {
			identiti = false;
		}
	}
	if (identiti) {
		// если техника x_best_search вообще не дала результатов.
		for (integer i47 = 1; i47 <= n_a[0]; i47++) {
			x[i47] = x_best_search2[i47];
		}
	}

	// free
	delete[] x_best_search2;
	delete[] x_best_search_init;

	// free
	/*
	delete[] diag0;
	delete[] error_approx_fine;
	if (ilevel > 1) {
	delete[] diag1;
	delete[] error_approx_coarse;
	delete[] residual_coarse;
	if (ilevel > 2) {
	// free
	delete[] diag2;
	delete[] error_approx_fine1;
	delete[] error_approx_coarse1;
	delete[] residual_coarse1;
	delete[] residual_fine1;
	if (ilevel > 3) {
	// free
	delete[] diag3;
	delete[] error_approx_fine2;
	delete[] error_approx_coarse2;
	delete[] residual_coarse2;
	delete[] residual_fine2;
	if (ilevel > 4) {
	// free
	delete[] diag4;
	delete[] error_approx_fine3;
	delete[] error_approx_coarse3;
	delete[] residual_coarse3;
	delete[] residual_fine3;
	if (ilevel > 5) {
	// free
	delete[] diag5;
	delete[] error_approx_fine4;
	delete[] error_approx_coarse4;
	delete[] residual_coarse4;
	delete[] residual_fine4;
	if (ilevel > 6) {
	// free
	delete[] diag6;
	delete[] error_approx_fine5;
	delete[] error_approx_coarse5;
	delete[] residual_coarse5;
	delete[] residual_fine5;
	if (ilevel > 7) {
	// free
	delete[] diag7;
	delete[] error_approx_fine6;
	delete[] error_approx_coarse6;
	delete[] residual_coarse6;
	delete[] residual_fine6;
	if (ilevel > 8) {
	// free
	delete[] diag8;
	delete[] error_approx_fine7;
	delete[] error_approx_coarse7;
	delete[] residual_coarse7;
	delete[] residual_fine7;
	if (ilevel > 9) {
	// free
	delete[] diag9;
	delete[] error_approx_fine8;
	delete[] error_approx_coarse8;
	delete[] residual_coarse8;
	delete[] residual_fine8;
	if (ilevel > 10) {
	// free
	delete[] diag10;
	delete[] error_approx_fine9;
	delete[] error_approx_coarse9;
	delete[] residual_coarse9;
	delete[] residual_fine9;
	if (ilevel > 11) {
	// free
	delete[] diag11;
	delete[] error_approx_fine10;
	delete[] error_approx_coarse10;
	delete[] residual_coarse10;
	delete[] residual_fine10;
	if (ilevel > 12) {
	// free
	delete[] diag12;
	delete[] error_approx_fine11;
	delete[] error_approx_coarse11;
	delete[] residual_coarse11;
	delete[] residual_fine11;
	if (ilevel > 13) {
	// free
	delete[] diag13;
	delete[] error_approx_fine12;
	delete[] error_approx_coarse12;
	delete[] residual_coarse12;
	delete[] residual_fine12;
	if (ilevel > 14) {
	// free
	delete[] diag14;
	delete[] error_approx_fine13;
	delete[] error_approx_coarse13;
	delete[] residual_coarse13;
	delete[] residual_fine13;
	if (ilevel > 15) {
	// free
	delete[] diag15;
	delete[] error_approx_fine14;
	delete[] error_approx_coarse14;
	delete[] residual_coarse14;
	delete[] residual_fine14;
	if (ilevel > 16) {
	// free
	delete[] diag16;
	delete[] error_approx_fine15;
	delete[] error_approx_coarse15;
	delete[] residual_coarse15;
	delete[] residual_fine15;
	if (ilevel > 17) {
	// free
	delete[] diag17;
	delete[] error_approx_fine16;
	delete[] error_approx_coarse16;
	delete[] residual_coarse16;
	delete[] residual_fine16;
	if (ilevel > 18) {
	// free
	delete[] diag18;
	delete[] error_approx_fine17;
	delete[] error_approx_coarse17;
	delete[] residual_coarse17;
	delete[] residual_fine17;
	// free
	//delete[] diag19;
	delete[] error_approx_fine18;
	delete[] error_approx_coarse18;
	delete[] residual_coarse18;
	delete[] residual_fine18;
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	}
	*/

	// Мы могли искусственно понизить количетсво уровней и значит память из кучи потеряется.
	// Здесь важно выполнить полное освобождение оперативной памяти из под всех имеющихся уровней. 
	// Поэтомуна данном этапе номеру уровня присваивается максимально возможное значение 11 ноября 2016.
integer ilevel_memo = ilevel; // Запоминаем текущее число уровней.
ilevel = 200;
// free
if (diag0 != NULL) {
	free(diag0);
	diag0 = NULL;
}
if (bnested_desection_global_amg != NULL) {
	free(bnested_desection_global_amg);  // Глобальная память.
	bnested_desection_global_amg = NULL;
}
if (nested_desection0 != NULL) {
	free(nested_desection0);
	nested_desection0 = NULL;
}
if (error_approx_fine != NULL) {
	free(error_approx_fine);
	error_approx_fine = NULL;
}
if (ilevel_memo > 1) {
	if (diag1 != NULL) {
		free(diag1);
		diag1 = NULL;
	}
	if (nested_desection1 != NULL) {
		free(nested_desection1);
		nested_desection1 = NULL;
	}
	if (error_approx_coarse != NULL) {
		free(error_approx_coarse);
		error_approx_coarse = NULL;
	}
	if (residual_coarse != NULL) {
		free(residual_coarse);
		residual_coarse = NULL;
	}
	if (residual_fine1 != NULL) {
		free(residual_fine1);
		residual_fine1 = NULL;
	}
	if (ilevel_memo > 2) {
		// free
		if (diag2 != NULL) {
			free(diag2);
			diag2 = NULL;
		}
		if (nested_desection2 != NULL) {
			free(nested_desection2);
			nested_desection2 = NULL;
		}
		if (error_approx_fine1 != NULL) {
			free(error_approx_fine1);
			error_approx_fine1 = NULL;
		}
		if (error_approx_coarse1 != NULL) {
			free(error_approx_coarse1);
			error_approx_coarse1 = NULL;
		}
		if (residual_coarse1 != NULL) {
			free(residual_coarse1);
			residual_coarse1 = NULL;
		}
		if (residual_fine2 != NULL) {
			free(residual_fine2);
			residual_fine2 = NULL;
		}
		if (ilevel_memo > 3) {
			// free
			if (diag3 != NULL) {
				free(diag3);
				diag3 = NULL;
			}
			if (nested_desection3 != NULL) {
				free(nested_desection3);
				nested_desection3 = NULL;
			}
			if (error_approx_fine2 != NULL) {
				free(error_approx_fine2);
				error_approx_fine2 = NULL;
			}
			if (error_approx_coarse2 != NULL) {
				free(error_approx_coarse2);
				error_approx_coarse2 = NULL;
			}
			if (residual_coarse2 != NULL) {
				free(residual_coarse2);
				residual_coarse2 = NULL;
			}
			if (residual_fine3 != NULL) {
				free(residual_fine3);
				residual_fine3 = NULL;
			}
			if (ilevel_memo > 4) {
				// free
				if (diag4 != NULL) {
					free(diag4);
					diag4 = NULL;
				}
				if (nested_desection4 != NULL) {
					free(nested_desection4);
					nested_desection4 = NULL;
				}
				if (error_approx_fine3 != NULL) {
					free(error_approx_fine3);
					error_approx_fine3 = NULL;
				}
				if (error_approx_coarse3 != NULL) {
					free(error_approx_coarse3);
					error_approx_coarse3 = NULL;
				}
				if (residual_coarse3 != NULL) {
					free(residual_coarse3);
					residual_coarse3 = NULL;
				}
				free(residual_fine4);
				if (ilevel_memo > 5) {
					// free
					if (diag5 != NULL) {
						free(diag5);
						diag5 = NULL;
					}
					if (nested_desection5 != NULL) {
						free(nested_desection5);
						nested_desection5 = NULL;
					}
					if (error_approx_fine4 != NULL) {
						free(error_approx_fine4);
						error_approx_fine4 = NULL;
					}
					if (error_approx_coarse4 != NULL) {
						free(error_approx_coarse4);
						error_approx_coarse4 = NULL;
					}
					if (residual_coarse4 != NULL) {
						free(residual_coarse4);
						residual_coarse4 = NULL;
					}

					free(residual_fine5);
					if (ilevel_memo > 6) {
						// free
						if (diag6 != NULL) {
							free(diag6);
							diag6 = NULL;
						}
						if (nested_desection6 != NULL) {
							free(nested_desection6);
							nested_desection6 = NULL;
						}

						if (error_approx_fine5 != NULL) {
							free(error_approx_fine5);
							error_approx_fine5 = NULL;
						}
						if (error_approx_coarse5 != NULL) {
							free(error_approx_coarse5);
							error_approx_coarse5 = NULL;
						}
						if (residual_coarse5 != NULL) {
							free(residual_coarse5);
							residual_coarse5 = NULL;
						}

						free(residual_fine6);
						if (ilevel_memo > 7) {
							// free
							if (diag7 != NULL) {
								free(diag7);
								diag7 = NULL;
							}
							if (nested_desection7 != NULL) {
								free(nested_desection7);
								nested_desection7 = NULL;
							}
							if (error_approx_fine6 != NULL) {
								free(error_approx_fine6);
								error_approx_fine6 = NULL;
							}
							if (error_approx_coarse6 != NULL) {
								free(error_approx_coarse6);
								error_approx_coarse6 = NULL;
							}

							if (residual_coarse6 != NULL) {
								free(residual_coarse6);
								residual_coarse6 = NULL;
							}

							free(residual_fine7);
							if (ilevel_memo > 8) {
								// free
								if (diag8 != NULL) {
									free(diag8);
									diag8 = NULL;
								}
								if (nested_desection8 != NULL) {
									free(nested_desection8);
									nested_desection8 = NULL;
								}
								if (error_approx_fine7 != NULL) {
									free(error_approx_fine7);
									error_approx_fine7 = NULL;
								}
								if (error_approx_coarse7 != NULL) {
									free(error_approx_coarse7);
									error_approx_coarse7 = NULL;
								}
								if (residual_coarse7 != NULL) {
									free(residual_coarse7);
									residual_coarse7 = NULL;
								}

								free(residual_fine8);
								if (ilevel_memo > 9) {
									// free
									if (diag9 != NULL) {
										free(diag9);
										diag9 = NULL;
									}
									if (nested_desection9 != NULL) {
										free(nested_desection9);
										nested_desection9 = NULL;
									}
									if (error_approx_fine8 != NULL) {
										free(error_approx_fine8);
										error_approx_fine8 = NULL;
									}
									if (error_approx_coarse8 != NULL) {
										free(error_approx_coarse8);
										error_approx_coarse8 = NULL;
									}
									if (residual_coarse8 != NULL) {
										free(residual_coarse8);
										residual_coarse8 = NULL;
									}

									free(residual_fine9);
									if (ilevel_memo > 10) {
										// free
										if (diag10 != NULL) {
											free(diag10);
											diag10 = NULL;
										}
										if (nested_desection10 != NULL) {
											free(nested_desection10);
											nested_desection10 = NULL;
										}
										if (error_approx_fine9 != NULL) {
											free(error_approx_fine9);
											error_approx_fine9 = NULL;
										}
										if (error_approx_coarse9 != NULL) {
											free(error_approx_coarse9);
											error_approx_coarse9 = NULL;
										}
										if (residual_coarse9 != NULL) {
											free(residual_coarse9);
											residual_coarse9 = NULL;
										}

										free(residual_fine10);
										if (ilevel_memo > 11) {
											// free
											if (diag11 != NULL) {
												free(diag11);
												diag11 = NULL;
											}
											if (nested_desection11 != NULL) {
												free(nested_desection11);
												nested_desection11 = NULL;
											}
											if (error_approx_fine10 != NULL) {
												free(error_approx_fine10);
												error_approx_fine10 = NULL;
											}
											if (error_approx_coarse10 != NULL) {
												free(error_approx_coarse10);
												error_approx_coarse10 = NULL;
											}
											if (residual_coarse10 != NULL) {
												free(residual_coarse10);
												residual_coarse10 = NULL;
											}

											free(residual_fine11);
											if (ilevel_memo > 12) {
												// free
												if (diag12 != NULL) {
													free(diag12);
													diag12 = NULL;
												}
												if (nested_desection12 != NULL) {
													free(nested_desection12);
													nested_desection12 = NULL;
												}
												if (error_approx_fine11 != NULL) {
													free(error_approx_fine11);
													error_approx_fine11 = NULL;
												}
												if (error_approx_coarse11 != NULL) {
													free(error_approx_coarse11);
													error_approx_coarse11 = NULL;
												}
												if (residual_coarse11 != NULL) {
													free(residual_coarse11);
													residual_coarse11 = NULL;
												}

												free(residual_fine12);
												if (ilevel_memo > 13) {
													// free
													if (diag13 != NULL) {
														free(diag13);
														diag13 = NULL;
													}
													if (nested_desection13 != NULL) {
														free(nested_desection13);
														nested_desection13 = NULL;
													}
													if (error_approx_fine12 != NULL) {
														free(error_approx_fine12);
														error_approx_fine12 = NULL;
													}
													if (error_approx_coarse12 != NULL) {
														free(error_approx_coarse12);
														error_approx_coarse12 = NULL;
													}
													if (residual_coarse12 != NULL) {
														free(residual_coarse12);
														residual_coarse12 = NULL;
													}

													free(residual_fine13);
													if (ilevel_memo > 14) {
														// free
														if (diag14 != NULL) {
															free(diag14);
															diag14 = NULL;
														}
														if (nested_desection14 != NULL) {
															free(nested_desection14);
															nested_desection14 = NULL;
														}
														if (error_approx_fine13 != NULL) {
															free(error_approx_fine13);
															error_approx_fine13 = NULL;
														}
														if (error_approx_coarse13 != NULL) {
															free(error_approx_coarse13);
															error_approx_coarse13 = NULL;
														}
														if (residual_coarse13 != NULL) {
															free(residual_coarse13);
															residual_coarse13 = NULL;
														}

														free(residual_fine14);
														if (ilevel_memo > 15) {
															// free
															if (diag15 != NULL) {
																free(diag15);
																diag15 = NULL;
															}
															if (nested_desection15 != NULL) {
																free(nested_desection15);
																nested_desection15 = NULL;
															}
															if (error_approx_fine14 != NULL) {
																free(error_approx_fine14);
																error_approx_fine14 = NULL;
															}
															if (error_approx_coarse14 != NULL) {
																free(error_approx_coarse14);
																error_approx_coarse14 = NULL;
															}
															if (residual_coarse14 != NULL) {
																free(residual_coarse14);
																residual_coarse14 = NULL;
															}
															free(residual_fine15);
															if (ilevel_memo > 16) {
																// free
																if (diag16 != NULL) {
																	free(diag16);
																	diag16 = NULL;
																}
																if (nested_desection16 != NULL) {
																	free(nested_desection16);
																	nested_desection16 = NULL;
																}
																if (error_approx_fine15 != NULL) {
																	free(error_approx_fine15);
																	error_approx_fine15 = NULL;
																}

																if (error_approx_coarse15 != NULL) {
																	free(error_approx_coarse15);
																	error_approx_coarse15 = NULL;
																}
																if (residual_coarse15 != NULL) {
																	free(residual_coarse15);
																	residual_coarse15 = NULL;
																}

																free(residual_fine16);
																if (ilevel_memo > 17) {
																	// free
																	if (diag17 != NULL) {
																		free(diag17);
																		diag17 = NULL;
																	}
																	if (nested_desection17 != NULL) {
																		free(nested_desection17);
																		nested_desection17 = NULL;
																	}
																	if (error_approx_fine16 != NULL) {
																		free(error_approx_fine16);
																		error_approx_fine16 = NULL;
																	}
																	if (error_approx_coarse16 != NULL) {
																		free(error_approx_coarse16);
																		error_approx_coarse16 = NULL;
																	}
																	if (residual_coarse16 != NULL) {
																		free(residual_coarse16);
																		residual_coarse16 = NULL;
																	}
																	free(residual_fine17);
																	if (ilevel_memo > 18) {
																		// free
																		if (diag18 != NULL) {
																			free(diag18);
																			diag18 = NULL;
																		}
																		if (nested_desection18 != NULL) {
																			free(nested_desection18);
																			nested_desection18 = NULL;
																		}
																		if (error_approx_fine17 != NULL) {
																			free(error_approx_fine17);
																			error_approx_fine17 = NULL;
																		}

																		if (error_approx_coarse17 != NULL) {
																			free(error_approx_coarse17);
																			error_approx_coarse17 = NULL;
																		}

																		if (residual_coarse17 != NULL) {
																			free(residual_coarse17);
																			residual_coarse17 = NULL;
																		}

																		free(residual_fine18);
																		if (ilevel_memo > 19) {
																			// free
																			//if (diag19 != NULL) {
																			//  free(diag19);
																			// diag19 = NULL;
																			//}
																			//if (nested_desection19 != NULL) {
																			// free(nested_desection19);
																			//}
																			if (error_approx_fine18 != NULL) {
																				free(error_approx_fine18);
																				error_approx_fine18 = NULL;
																			}
																			if (error_approx_coarse18 != NULL) {
																				free(error_approx_coarse18);
																				error_approx_coarse18 = NULL;
																			}
																			if (residual_coarse18 != NULL) {
																				free(residual_coarse18);
																				residual_coarse18 = NULL;
																			}

																			//free(residual_fine19);
																		}

																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
ilevel = ilevel_memo;

    // освобождение оперативной памяти.
    free_level_additional_data(milu0, ilevel);
    free_level_additional_data(milu2, ilevel);

   // Освобождение общей памяти в ILU буффере.
   if (milu_gl_buffer.alu_copy != NULL) delete[] milu_gl_buffer.alu_copy;
   if (milu_gl_buffer.jlu_copy != NULL) delete[] milu_gl_buffer.jlu_copy;
   if (milu_gl_buffer.ju_copy != NULL) delete[] milu_gl_buffer.ju_copy;
   milu_gl_buffer.alu_copy = NULL;
   milu_gl_buffer.jlu_copy = NULL;
   milu_gl_buffer.ju_copy = NULL;

   //delete[] residual_fine;
   if (residual_fine != NULL) {
   	  free(residual_fine);
	  residual_fine = NULL;
   }

   //delete[] row_ptr_start;
   //delete[] row_ptr_end;
   if (row_ptr_start != NULL) {
	   free(row_ptr_start);
	   row_ptr_start = NULL;
   }
   if (row_ptr_end != NULL) {
	   free(row_ptr_end);
	   row_ptr_end = NULL;
   }


   //delete[] flag_shadow;
   if (flag_shadow != NULL) {
 	  free(flag_shadow);
	  flag_shadow = NULL;
   }

   //delete[] flag;
   if (flag != NULL) {
	  free(flag);
      flag = NULL;
   }

   //delete[] flag85;
   if (flag85 != NULL) {
	   free(flag85);
	   flag85 = NULL;
   }

   if (x_copy != NULL) {
	   free(x_copy);
	   x_copy = NULL;
   }
   if (x_best_search != NULL) {
      free(x_best_search);
      x_best_search = NULL;
    }
	
    // Для подстраховки:

    if (row_ptr_start != NULL) {
	    free(row_ptr_start);
    	row_ptr_start = NULL;
    }
    if (row_ptr_end != NULL) {
	    free(row_ptr_end);
	    row_ptr_end = NULL;
    }

	if (x_jacoby_buffer != NULL) {
		delete[] x_jacoby_buffer;
		x_jacoby_buffer = NULL;
	}

	//return false;
	return ret_value;

} // classic_aglomerative_amg5


/*
  // 9 декабря 2015 для 3D повидимому требуется АВЛ дерево, т.к. в 3D 
  // очень большое число соседей. Начинаем разработку такого кода.
  // 21 окт 2015. Нужно реализовать Писсанецки и Густавсона, поиск можно сделать через хеш.
  // 6 september 2015 кажется заработало.
integer main()
//integer _tmain(integer argc, _TCHAR* argv[])
{

	// тестирование АВЛ дерева 12 декабря 2015.
	//test_AVL();

	//errno_t err;
	//FILE* fp;
	//err = fopen_s(&fp, "report_stat.txt", "a");

	//doublerealT mul_theta = 0.131; // 0.111 optimal 20step
	//for (integer i_1 = 1; i_1 <= 120; i_1++) {
	//mul_theta -= 0.001;
	//fprintf_s(fp, "%1.5f ", mul_theta);
	//for (integer i_2 = 1; i_2 <= 5; i_2++) {

	//float ts = clock();



	// Тестовая обвязка.
	// недостаток данного тестирования отсутствие условий Неймана, условий задания ненулевого теплового потока.
	// Отсутствие сборки на примере матрицы полученной аппроксимацией конвективной задачи с одной из противопоточных схем.
	// 14 сентября 2015 года реальное тестирование на примере расчёта теплового сопротивления транзисторной структуры, 
	// вставляем код в AliceFlow.

	// Условия Неймана действительно сильно замедляют сходимость. Пока можно сказать что константа 1/16  не подходит и с ней 
	// алгоритм расходится.


	// 30min 25s 40x40x40. (7min 50s Писанецки) (1min 18s , 3min 32s Густавсон) (1min 04s Густавсон от сети)
	// 6min 201x201 5.40 lite and quick  15 it
	// 201x201  37.132, 35.761
	// Густавсон ускорение 50.0% по сравнению с версией 0.04.
	// 1.01min 121x121 v0_03time=29.983, v0_04time=20.116; PGO=19.695. (v0_05=12.136 Густавсон).

	// m=81; 9.3Mb.
	// m=101; 14.3Mb.
	// speed up 38%
	// Идея Писсанецки ускорила код на 15% от версии 0.04.
	// time cube (40) 33.54s 
	// Сравнение быстродействия cube(40) от сети:
	// 3D 1min 12s. (11 iteracii)
	// 2D  1000  28.5c
	// 3D 120 36.1% 34%  11min. 
	integer m = 120; // 37.6с     (Слияние 2.24-2.29min) (2.02-2.07 Писсанецки).
	doublerealT h = 1.0 / (m - 1);
	doublerealT h2 = h*h;

	// 4040

	doublerealT theta = 0.25; // Контроль числа сильных связей между переменными.

	const integer dim_2D = 0;

	// 8 декабря 2015 Единый параметр theta=0.25 и для 2D и для 3D. 
	switch (dim_2D) {
	case 1: theta = 0.25; break; // 2D
	case 0: theta = 0.25; break; // 3D
	}

	Ak1* Amat = NULL;
	//Ak1* Atemp = NULL;
	//Ak1* Atemp2 = NULL;
	Ak1* R = NULL;
	Ak1* P = NULL;
	integer n, nnz;
	doublerealT* x = NULL;
	doublerealT* b = NULL;

	if (0) {
		// 18 ноября реальное тестирование с привлечением кода DavisTestDelphi.

		FILE* fp;
		errno_t err;
		if ((err = fopen_s(&fp, "amg_input.txt", "r")) != 0) {
			printf("error input file : amg_input.txt \n");
			//getchar();
			system("pause");
			exit(1);
		}
		else {
			integer din = 0;
			float fin = 0.0;

			#if doubleintprecision == 1
				fscanf_s(fp, "%lld", &din);
				n = din;
				printf("%lld\n", n);
			#else
				fscanf_s(fp, "%d", &din);
				n = din;
				printf("%d\n", n);
			#endif

			
			system("pause");
			x = new doublerealT[n + 1]; // решение.
			for (integer i = 0; i <= n; i++) x[i] = 0.0; // инициалзация.

			b = new doublerealT[n + 1]; // Правая часть.
			b[0] = 0.0;
			for (integer i_1 = 1; i_1 <= n; i_1++) {
				fscanf_s(fp, "%f", &fin);
				b[i_1] = fin;
			}
			#if doubleintprecision == 1
				fscanf_s(fp, "%lld", &din);
				nnz = din;
				printf("nnz=%lld\n", nnz);
			#else
				fscanf_s(fp, "%d", &din);
				nnz = din;
				printf("nnz=%d\n", nnz);
			#endif

			
			system("pause");
			// 31 aug 2015
			Amat = new Ak1[8 * nnz + 1];
			//Atemp = new Ak1[3 * nnz + 1];
			//Atemp2 = new Ak1[3 * nnz + 1];
			R = new Ak1[10 * n + 1];
			P = new Ak1[10 * n + 1];
			integer i_2 = 1;
			for (integer i_1 = 1; i_1 <= nnz; i_1++) {
				fscanf_s(fp, "%f", &fin);
				if (fabs(fin) > 1.0e-30) {
					Amat[i_2].aij = fin;
					#if doubleintprecision == 1
						fscanf_s(fp, "%lld", &din);
						Amat[i_2].i = din;
						fscanf_s(fp, "%lld", &din);
					#else
						fscanf_s(fp, "%d", &din);
						Amat[i_2].i = din;
						fscanf_s(fp, "%d", &din);
					#endif
					
					Amat[i_2].j = din;
					i_2++;
				}
				else {
				#if doubleintprecision == 1
					fscanf_s(fp, "%lld", &din);
					fscanf_s(fp, "%lld", &din);
				#else
					fscanf_s(fp, "%d", &din);
					fscanf_s(fp, "%d", &din);
				#endif
					
				}
			}
			nnz = i_2 - 1;
			#if doubleintprecision == 1
				printf("nnz=%lld\n", nnz);
			#else
				printf("nnz=%d\n", nnz);
			#endif
			
			system("pause");

			fclose(fp);
			classic_aglomerative_amg2(Amat, nnz, n, R, P,  x, b, theta);
		}
	}
	else {


		if (dim_2D) {
			// Finite Volume Method matrix assemble. 6 september 2015

			#if doubleintprecision == 1
				printf("%lldx%lld\n", m, m);
			#else
				printf("%dx%d\n", m, m);
			#endif
			



			n = m*m;
			nnz = 5 * ((m - 2)*(m - 2)) + 4 + 4 * (m - 2);
			#if doubleintprecision == 1
				printf("nnz=%lld\n", nnz);
			#else
				printf("nnz=%d\n", nnz);
			#endif
			
			//getchar();

			// 31 aug 2015
			Amat = new Ak1[8 * nnz + 1];
			//Atemp = new Ak1[3 * nnz + 1];
			//Atemp2 = new Ak1[3 * nnz + 1];
			R = new Ak1[10 * n + 1];
			P = new Ak1[10 * n + 1];
			// 19684 3*n+1.
			#if doubleintprecision == 1
				//printf("%lld",3*n+1);
			#else
				//printf("%d",3*n+1);
			#endif
			
			//getchar();
			integer ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					if ((i > 1) && (j > 1) && (i < m) && (j < m)) {
						//Amat[ic].aij = 4.0 / h2;
						Amat[ic].aij = 4.0; // h/h
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j + 1;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j - 1;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j + m;
						ic++;
						//Amat[ic].aij = -1.0 / h2;
						Amat[ic].aij = -1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j - m;
						ic++;
					}
					if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j > 1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
						Amat[ic].aij = 1.0;
						Amat[ic].i = (i - 1)*m + j;
						Amat[ic].j = (i - 1)*m + j;
						ic++;

					}
				}
			}

			#if doubleintprecision == 1
				printf("nnz=%lld ic-1=%lld\n", nnz, ic - 1);
			#else
				printf("nnz=%d ic-1=%d\n", nnz, ic - 1);
			#endif
			


			x = new doublerealT[n + 1]; // решение.
			for (integer i = 0; i <= n; i++) x[i] = 0.0;
			b = new doublerealT[n + 1]; // Правая часть.

			ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					if ((i > 1) && (j > 1) && (i < m) && (j < m)) {
						b[ic++] = 8.0*3.141*3.141*sin(2 * 3.141*(i - 1)*h)*sin(2 * 3.141*(j - 1)*h)*h2;
					}
					if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j > 1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
						b[ic++] = sin(2 * 3.141*(i - 1)*h)*sin(2 * 3.141*(j - 1)*h);
					}
				}
			}

		}
		else {
			// 6 сентября пляж РИМИНИ

			// Finite volume method matrix assemble. 
			// volume = h2*h; Square=h2; delta_x=delta_y=delta_z=h;
			// диагональный член положителен остальные отрицательны.

			// 3D
			n = m*m*m;
			nnz = 7 * ((m - 2)*(m - 2)*(m - 2)) + 8 + 6 * (m - 2)*(m - 2) + 12 * (m - 2);
			// куб : 8 вершин, 12 рёбер, 6 граней.

			#if doubleintprecision == 1
				printf("%lldx%lldx%lld\n", m, m, m);
				printf("nnz=%lld\n", nnz);
			#else
				printf("%dx%dx%d\n", m, m, m);
				printf("nnz=%d\n", nnz);
			#endif
			

			// 31 aug 2015
			// 6 3 3 с запасом. реально 4.52 2.26 2.26
			// real size 22.6 on thermal resistance.
			Amat = new Ak1[(integer)(13 * nnz) + 1]; // 6
												 // Иногда на следующем уровне вложенности число ненулевых элементов больше чем 
												 // в начальной матрице.
												 // real size 9.4 for resistor thermal resistor.
												 // 
												 //Atemp = new Ak1[3 * nnz + 1];
												 // real size 9.4 for resistor thermal resistor.
												 //Atemp2 = new Ak1[3 * nnz + 1];
			R = new Ak1[(integer)(10 * n) + 1]; // 3*nnz 2.4
			P = new Ak1[(integer)(10 * n) + 1]; // 3*nnz 2.4
			integer ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					for (integer k = 1; k <= m; k++) {
						if ((i > 1) && (j > 1) && (k > 1) && (i < m) && (j < m) && (k < m)) {
							Amat[ic].aij = 6.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j + 1;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j - 1;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j + m;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j - m;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j + m*m;
							ic++;
							Amat[ic].aij = -1.0 *h;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j - m*m;
							ic++;
						}
						else {
							//if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j > 1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
							Amat[ic].aij = 1.0;
							Amat[ic].i = (k - 1)*m*m + (i - 1)*m + j;
							Amat[ic].j = (k - 1)*m*m + (i - 1)*m + j;
							ic++;

						}
					}
				}
			}

			#if doubleintprecision == 1
				printf("nnz=%lld ic-1=%lld\n", nnz, ic - 1);
			#else
				printf("nnz=%d ic-1=%d\n", nnz, ic - 1);
			#endif
			


			x = new doublerealT[n + 1]; // решение.
			for (integer i = 0; i <= n; i++) x[i] = 0.0; // инициалзация.
			b = new doublerealT[n + 1]; // Правая часть.

			ic = 1;
			for (integer i = 1; i <= m; i++) {
				for (integer j = 1; j <= m; j++) {
					for (integer k = 1; k <= m; k++) {
						if ((i > 1) && (j > 1) && (k > 1) && (i < m) && (j < m) && (k < m)) {
							b[ic++] = 16.0*3.141*3.141*3.141*sin(2 * 3.141*(i - 1)*h)*sin(2 * 3.141*(j - 1)*h)*sin(2 * 3.141*(k - 1)*h)*h2*h;
						}
						else {
							//if (((i == m) && (j == m)) || ((i == m) && (j == 1)) || ((i == 1) && (j == m)) || ((i == 1) && (j == 1)) || ((i == 1) && (j>1) && (j < m)) || ((i == m) && (j>1) && (j < m)) || ((j == 1) && (i>1) && (i < m)) || ((j == m) && (i>1) && (i < m))) {
							b[ic++] = sin(2 * 3.141*(k - 1)*h)*sin(2 * 3.141*(i - 1)*h)*sin(2 * 3.141*(j - 1)*h);
						}
					}
				}
			}
		}

		classic_aglomerative_amg2(Amat, nnz, n, R, P,  x, b, theta);
	}



	// m in 3D memorysize mb
	// 21  14.8Mb
	// 31  49.7Mb
	// 41  119.4Mb

	//getchar();
	delete[] Amat;
	delete[] R;
	delete[] P;
	//delete[] Atemp;
	//delete[] Atemp2;
	delete[] x;
	delete[] b;

	// 2D m=81 debug от акумулятора. 
	// nu1=1 nu2=0 47.904
	// nu1=1 nu2=1 34.548
	// nu1=2 nu2=1 29.465
	// nu1=2 nu2=2 27.76
	// 2D m=81 realese от акумулятора.
	// nu1=2 nu2=1 8.898
	// nu1=2 nu2=2 8.109
	// nu1=3 nu2=2 7.247
	// nu1=3 nu2=3 6.962
	// nu1=4 nu2=3 6.555 6.799
	// seidelq 1 level
	// nu1=4 nu2=3 5.691 5.605 
	// от сети.
	// seidelq 2 level
	// nu1=4 nu2=3 1.121 1.9 1.672
	// 1.9 792 0.982
	// 1.174 273 0.94248 // оставлен residual на втором левеле а не residualq.
	// от аккумулятора.
	// nu1=4 nu2=3 3.412  оставлен residual на втором левеле а не residualq.
	// nu1=4 nu2=3 5.503 residualq.
	// оставлен residual на втором левеле а не residualq.
	// m=81 12 level
	// nu1=4 nu2=3 2.916 3.081 2.899 2.89
	// nu1=4 nu2=3 2.487  (третий патч 1.715)


	// от акумулятора 1.091
	//(msvcr120.dll 3.94 2.06 2.33 3.1) 1.234 1.072
	// 2.893 2.788 2.892 2.8 2.814
	// m=121 от акумулятора. 13 level.
	// 2.556 2.546 2.627 2.533 2.602 2.501 2.542 2.487 2.589 5.131
	// 1.686 1.742 от сети. 1.763
	// m=221 2D 14 level
	// 33.857 32.649 (6.809s 3 патча. 6.984).


	// m=24 3D от сети
	// без патча 957мс.
	// без патча m=48 8.713c. с патчем 5.7s. 110тыс узлов.

	// etalon 27s. или 36с. от сети. etalon 47s от аккумулятора.
	// m=100 3D 1 million nodes
	// 15 level 117 iteration.
	// 2 min 42s. в 6 раз медленнее.
	// 47.16s от сети. 47.276
	//system("pause");

	// time
	// 1000x1000  1min 19s. 16 iteracii
	// 1000x1000 1min 28s 19 iteracii
	// 1000x1000 1 min 26 s 23 iteracii
	// 1M 0.5Gb 3D 100x100x100 11min 31s 200 iteracii
	// 1.7M 1.8Gb  3D 120x120x120 25min 317 iteracii
	//float t_calc = clock() - ts;
	//fprintf_s(fp, " %1.8f", t_calc);
	//}
	//fprintf_s(fp, "\n");
	//}

	//fclose(fp);
	return 0;
}

*/


// Здесь содержится обвязка вызывающая РУМБА.
// локальное выдление памяти :всё внутри, многократные alloc и free.
// РУМБА для решения задачи напряженно-деформированнного состояния.
// Нет сходимости. Дата успешного подключения 24 сентября 2017.
void my_agr_amg_loc_memory_Stress_old(SIMPLESPARSE &sparseM, integer n,
	doublereal* &dV, doublereal* &dX0,
	QuickMemVorst& m, BLOCK* &b, integer &lb)
{

	// 11 января 2016. классический агломеративный алгебраический многосеточный метод.
	// Это моя собственная разработка РУМБА 0.14.
	//if (iVar != PAM) {
	//doublereal theta82 = 0.24;
	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	//-->doublereal theta82 = 0.24;// 0.25; //0.24
	//-->doublereal theta83 = 0.23;// 0.25; // 0.23
	// 0.3 0.4 0.44 0.45  0.5
	// 16  25   38        17
	//--->doublereal magic82 = 0.4; // 0.35; // 0.4 // 0.43
	//----->doublereal magic83 = 0.4;// 0.35; // 0.42

	doublereal theta82 = my_amg_manager.theta;
	doublereal theta83 = my_amg_manager.theta;
	doublereal magic82 = my_amg_manager.magic;
	doublereal magic83 = my_amg_manager.magic;

	doublereal ret74 = 0.0;

	my_amg_manager.theta = my_amg_manager.theta_Stress;
	my_amg_manager.maximum_delete_levels = my_amg_manager.maximum_delete_levels_Stress;
	my_amg_manager.nFinnest = my_amg_manager.nFinnest_Stress;
	my_amg_manager.nu1 = my_amg_manager.nu1_Stress;
	my_amg_manager.nu2 = my_amg_manager.nu2_Stress;
	my_amg_manager.memory_size = my_amg_manager.memory_size_Stress;
	my_amg_manager.ilu2_smoother = my_amg_manager.ilu2_smoother_Stress;
	my_amg_manager.icoarseningtype = my_amg_manager.icoarseningStress; // standart vs RS 2.
	my_amg_manager.istabilization = my_amg_manager.istabilizationStress; // Stabilization : 0 - none, 1 - bicgstab + amg (РУМБА).
	my_amg_manager.magic = my_amg_manager.F_to_F_Stress; // magic
	my_amg_manager.number_interpolation_procedure = my_amg_manager.number_interpolation_procedure_Stress;
	my_amg_manager.iCFalgorithm_and_data_structure=my_amg_manager.iCFalgorithm_and_data_structure_Stress;
	my_amg_manager.iprint_log = my_amg_manager.iprint_log_Stress;
	my_amg_manager.itruncation_interpolation = my_amg_manager.itruncation_interpolation_Stress;
	my_amg_manager.truncation_interpolation = my_amg_manager.truncation_interpolation_Stress;
	my_amg_manager.gold_const = my_amg_manager.gold_const_Stress;
	my_amg_manager.b_gmres = my_amg_manager.b_gmresStress;
	my_amg_manager.bMatrixPortrait = my_amg_manager.bStressMatrixPortrait;


	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.

#ifdef _OPENMP
	int i_my_num_core_parallelesation = omp_get_num_threads();
	omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif

	doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	// На случай если память не была выделена.
	if (dX0 == NULL) {
		dX0 = new doublereal[n];
		for (integer i = 0; i<n; i++) {
			dX0[i] = 0.0;
		}
	}

	integer id = 0;

	simplesparsetoCRS(sparseM, m.val, m.col_ind, m.row_ptr, n); // преобразование матрицы из одного формата хранения в другой.
																//m.ballocCRScfd = true;
	simplesparsefree(sparseM, n);

	integer ierr = 0;
	doublereal eps = 1.0e-12;

	ierr = 0; // изначальное состояние безошибочное.
			  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
	eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

				   // Требования к оперативной памяти.
				   /*     VECTOR         NEEDED LENGTH (GUESS) */
				   /*       Amat               3*NNA + 5*NNU */
				   /*       JA              3*NNA + 5*NNU */
				   /*       IA              2.2*NNU */
				   /*       U               2.2*NNU */
				   /*       F               2.2*NNU */
				   /*       IG              5.4*NNU */

	integer nna = 0;
	for (integer k = 0; k < m.row_ptr[n]; k++) {

		if (fabs(m.val[k]) > nonzeroEPS) {
			nna++;
		}
	}
	//printf("nna=%d istinnoe=%d\n", nna, m.row_ptr[n]);
	//getchar();
	//integer nna = m.row_ptr[n]; // количество ненулевых элементов в матрице СЛАУ.



	integer nnu = n; // число неизвестных.

					 // данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
					 //doublerealT rsize=1.51; // 1048416
					 // Вынужденные течения достаточно 2.5.
					 // значения 3.5 недостаточно для 8 модулей Пионер. 
	//doublerealT rsize = 4.5; // на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.
	/*
	integer nda = 0; // память под вектор значений матрицы слау.
	nda = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndia = 0;
	ndia = (integer)(rsize*2.2*(nnu));
	integer ndja = 0;
	ndja = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndu = 0;
	ndu = (integer)(rsize*2.2*(nnu));
	integer ndf = 0;
	ndf = (integer)(rsize*2.2*(nnu));
	integer ndig = 0;
	ndig = (integer)(rsize*5.4*(nnu));
	*/


	/*     CLASS 3 - PARAMETERS: */

	/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

	/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

	/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
	/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
	/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
	/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
	/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
	/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
	/*                        BY THE FOLLWING DIGITS. */

	/*                  REST OF IFIRST  --  RNDU: */
	/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
	/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
	/*                    IFIRST=1372815) */

	/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
	/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

	/*                  1ST DIGIT OF NCYC  --  IGAM: */
	/*                    =1: V -CYCLE, */
	/*                    =2: V*-CYCLE, */
	/*                    =3: F -CYCLE, */
	/*                    =4: W -CYCLE. */
	/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
	/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
	/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

	/*                  2ND DIGIT OF NCYC  --  ICGR: */
	/*                    =0: NO CONJUGATE GRADIENT, */
	/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
	/*                    =2: CONJUGATE GRADIENT (FULL CG). */

	/*                  3RD DIGIT OF NCYC  --  ICONV: */
	/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
	/*                    (FINEST GRID): */
	/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
	/*                        NCYCLE (SEE BELOW) */
	/*                    =2: STOP, IF  ||RES|| < EPS */
	/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
	/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
	/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
	/*                           EPS     (SEE INPUT PARAMETER EPS) */
	/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
	/*                           |U|   = SUPREMUM NORM OF SOLUTION */
	/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
	/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
	/*                    AFTER AT MOST NCYCLE CYCLES. */

	/*                  REST OF NCYC  --  NCYCLE: */
	/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
	/*                    NCYCLE=0: NO CYCLING. */

	/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
	/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
	/*                  ARE PERFORMED, REGARDLESS OF EPS. */

	/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
	/*                  GRID IN CYCLING: */

	/*                  1ST DIGIT OF MADAPT  --  MSEL: */
	/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
	/*                        PHASE ARE USED WITHOUT CHECK. */
	/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
	/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
	/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
	/*                        (SEE BELOW). */

	/*                  REST OF MADAPT  --  FAC */
	/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
	/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
	/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
	/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
	/*                        BY DEFAULT. */


	/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

	/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF NRD  --  NRDX: */
	/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
	/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

	/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
	/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
	/*                    =2: FULL GS SWEEP */
	/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
	/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

	/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

	/*                  1ST DIGIT  --  NSC: */
	/*                    =1: GAUSS-SEIDEL METHOD */
	/*                    =2: DIRECT SOLVER (YALE SMP) */

	/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
	/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
	/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
	/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
	/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

	/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

	/*         -------------------------------------------------------------- */

	/*     CLASS 4 - PARAMETERS: */

	/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
	/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
	/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
	/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
	/*                        OPERATORS */
	/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



	/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

	/*          ISWTCH = 4 */
	/*          IOUT   = 12 */
	/*          IPRINT = 10606 */

	/*          LEVELX = 25 */
	/*          IFIRST = 13 */
	/*          NCYC   = 10110 */
	/*          EPS    = 1.D-12 */
	/*          MADAPT = 27 */
	/*          NRD    = 1131 */
	/*          NSOLCO = 110 */
	/*          NRU    = 1131 */

	/*          ECG1   = 0. */
	/*          ECG2   = 0.25 */
	/*          EWT2   = 0.35 */
	/*          NWT    = 2 */
	/*          NTR    = 0 */



	// рекомедуемые параметры по дефолту.
/*
	integer iswtch = 0;
	iswtch = 4;
	integer iout = 0;
	iout = 13; // 13 обеспечивает печать изменения невязки в процессе счёта.
	integer iprint = 0;
	iprint = 10606;
	integer levelx = 0;
	levelx = 25;
	integer ifirst = 0;
	// начальное приближение :
	// 0 - используется из вне.
	// 1 - нулевое.
	// 2 - единицы.
	// 3 - случайная последовательность.
	ifirst = 13;//13 по умолчанию.
				//ifirst=11; // нулевое начальное приближение.
				//ifirst=10; // вроде как начальное приближение берётся из dX0.
				// но 10 никоим образом не улучшает сходимость.
	integer ncyc = 0;
	ncyc = 10110;
	integer madapt = 0;
	madapt = 27;
	integer nrd = 0;
	nrd = 1131;
	integer nsolco = 0;
	nsolco = 110;
	integer nru = 0;
	nru = 1131;
	doublereal ecg1 = 0.0;
	ecg1 = 0.0;
	doublereal ecg2 = 0.0;
	ecg2 = 0.25;
	doublereal ewt2 = 0.0;
	ewt2 = 0.35;
	integer nwt = 0;
	nwt = 2;
	integer ntr = 0;
	ntr = 0;

	integer matrix = 0;
	matrix = 11; // symmetric SPD.
				 //matrix = 22;
	ncyc = 10199;
	*/

    Ak1* Amat = NULL;
    Ak1* R = NULL;
    Ak1* P = NULL;
    //Ak1* Atemp = NULL;
    //Ak1* Atemp2 = NULL;
    doublereal* rthdsd_amg = NULL;
    doublereal* result_amg = NULL;
    // 18 августа 2016
    // граничные узлы требуют особой обработки.
    // true - граничный узел, false - внутренний.
    bool* bamg_bound = NULL;

	// allocate memory.
	// allocate memory 2 jan 2016.
	// BSK Dmitrii 3.012  (2.892 для прямой интерполляции с элементами непрямой). 
	// tgf series no metalization
	// tgf2023-2_01 2.64 643mb
	// tgf2023-2-02 2.58 988mb
	// tgf2023-2-05 2.44 2022mb
	// tgf2023-2-20 3.58 2967mb
	// CGHV1J metalization 3.133 (2.84 для прямой интерполляции с элементами непрямой). 
	// тор Докторович 2.89
	// Концевой 3.05
	// Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
	// Вывод : максимальное значение 3.14 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
	// Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
	// Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
	// Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
	//Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
	// памяти надо много для 6 варианта интерполяции.
	// 9,35,35 28
	integer nsizeA = ((integer)(9 * nna) + 1);
	integer nsizePR = 35;

	if (bPhysics_PTBSH_memory == true) {
		// ПТБШ.
		//printf("bPhysics_PTBSH_memory==true\n");
		nsizeA = ((integer)(4 * nna) + 1);
		nsizePR = 13;
	}

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
	// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
	// пользовательской геометрии (того что пользователь начертил в интерфейсе).
	// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
	// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
	nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
	if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
		printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
		printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif

	}
	nsizePR = 35;
	if (bonly_solid_calculation) {
		// 31 октября 2016.
		// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
		// задач должно хватить значения 12.
		nsizePR = 12;
	}

	MEMORYSTATUSEX statex;
	statex.dwLength = sizeof(statex);
	GlobalMemoryStatusEx(&statex);
	char divisor[2] = "M";
	if (my_amg_manager.iprint_log == 1) {
		printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024 * 1024), divisor);
		printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
		printf("required %zu %sbytes\n", ((nsizeA / (1024 * 1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024 * 1024))* nnu) + 1) * sizeof(Ak1)), divisor);
		//system("pause");
	}

	Amat = (Ak1*)malloc(nsizeA * sizeof(Ak1));  // 9
	char c1[5] = "Amat";
	char c2[22] = "my_agr_amg_loc_memory";
	char c3[11] = "bamg_bound";
	handle_error<Ak1>(Amat, c1, c2, (nsizeA));


	bamg_bound = new bool[((nsizePR * nnu) + 1)];
	handle_error<bool>(bamg_bound, c3, c2, ((nsizePR * nnu) + 1));


	// real size 9.4 for resistor.
	// 
	/*
	Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp == NULL) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem : not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	// real size 9.4 for resistor.
	Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp2 == NULL) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem : not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	*/

	//result_amg = new doublerealT[nnu + 1];
	result_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c4[11] = "result_amg";
	handle_error<doublereal>(result_amg, c4, c2, (nnu + 1));


	//rthdsd_amg = new doublerealT[nnu + 1];
	rthdsd_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c5[11] = "rthdsd_amg";
	handle_error<doublereal>(rthdsd_amg, c5, c2, (nnu + 1));



	// правая часть.
	/*
	for (integer i = 0; i < nnu; i++) {
	rthdsd_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	rthdsd_amg[i + 1] = dV[i];
	}
	}
	rthdsd_amg[0] = 0.0;
	*/
	/*
	// вектор решения.
	for (integer i = 0; i < nnu; i++) {
	result_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	result_amg[i + 1] = dX0[i];
	}
	}
	result_amg[0] = 0.0;
	*/

	// см. equation3DtoCRS.

    integer ik = 0; // счётчик ненулевых элементов СЛАУ
	id = 1;

	//if (iVar == PAM) {
	//printf("alpharelax=%e\n", alpharelax);
	//	getchar();
	//}


	for (integer k = 0; k <= n; k++) {
		bamg_bound[k] = false;
	}

	

	//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	char c6[2] = "R";
	handle_error<Ak1>(R, c6, c2, ((nsizePR * nnu) + 1));

	//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	char c7[2] = "P";
	handle_error<Ak1>(P, c7, c2, ((nsizePR * nnu) + 1));

	// Блок инициализации нулём, возможно будет работоспособно и без него.

	



	// начальное приближение.
	for (integer i = 0; i < nnu; i++) {
		
		    result_amg[i+id] = 0.0;
			// обязательно нужно проверить была ли выделена оперативная память. 
			result_amg[i + id] = dX0[i];
		
	}

	// правая часть.
	for (integer i = 0; i < nnu; i++) {
		 rthdsd_amg[i+id] = 0.0;		
		 // обязательно нужно проверить была ли выделена оперативная память. 
		 rthdsd_amg[i + id] = dV[i];
	}

	


	// см. equation3DtoCRS.

	ik = 0; // счётчик ненулевых элементов СЛАУ

					// для внутренних узлов расчётной области:
	for (integer k = 0; k < n; k++) {

		integer idiagonal_first_ik = ik;

		//сканируем строку.
		for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {

			if (fabs(m.val[k1]) > nonzeroEPS) {
				if (m.col_ind[k1] != k) {
					// Внедиагональный элемент
					Amat[ik + 1 + id].aij = m.val[k1];
					Amat[ik + 1 + id].j = m.col_ind[k1] + 1;
					Amat[ik + 1 + id].i = k + 1;
					ik++;
				}
				else {
					// диагональный элемент
					Amat[idiagonal_first_ik + id].aij = m.val[k1];
					Amat[idiagonal_first_ik + id].j = m.col_ind[k1] + 1;
					Amat[idiagonal_first_ik + id].i= m.col_ind[k1] + 1;
					//ik++;
				}
			}
		}
		ik++;

	}

	/*
	for (integer k = 0; k < n; k++) {
	//сканируем строку.
	for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {
	printf("val=%e col_ind=%d row_ptr=%d\n",a[k1+id],ja[k1+id],ia[k]);
	}
	getchar();
	}
	*/

	// в каждой строке элементы отсортированы по номерам столбцов:
	// Но диагональный элемент всегда на первом месте в строке матрицы.
	integer imove = 0;
	if (id == 0) imove = -1;

	// сортировка ненужна порядок следования любой, но главное чтобы первый в строке был имено диагональный элемент.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+1+imove, ia[k+2]-1+imove); // первый элемент всегда диагональный.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+imove, ia[k+2]-1+imove); 

	

	//printf("getready ...");
	//getchar();
	// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
	// свой алгоритм 2015 года.


	//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

	//printf("allocation memory is Ok. start ready...\n");
	//system("pause");
	doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
							 //theta = 0.5; // может поможет  для конвективных задач
	doublereal* x_copy = NULL;
	x_copy = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c8[7] = "x_copy";
	handle_error<doublereal>(x_copy, c8, c2, (nnu + 1));

	for (integer i47 = 1; i47 <= nnu; i47++) {
		x_copy[i47] = result_amg[i47];
	}

	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	bool bdivergence_detected = false;


	
	// режим экономии оперативной памяти.
	bool bmemory_savings = false;

	integer  maxelm_out = n;// это для radiosity patch.Излучение в вакуумном промежутке.
	// iVar нужен для настройки BiCGStab.
	integer iVar = TOTALDEFORMATIONVAR;

	

	//if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
		//bdivergence_detected = classic_aglomerative_amg4<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
		bdivergence_detected = classic_aglomerative_amg4<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
		//bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);

		//}
	//else {
		//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
		//bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
	//}



		
		// Работа amg была успешна.
		for (integer i47 = 1; i47 <= nnu; i47++) {
			result_amg[i47] = x_copy[i47];
		}
		
		if (x_copy != NULL) {
			free(x_copy);
			x_copy = NULL;
		}

		//system("pause");



		// возвращаем решение СЛАУ.
		// вектор решения. 
		for (integer i = 0; i < nnu; i++) {
			if (i<n) {
				// обязательно нужно проверить была ли выделена оперативная память. 
				dX0[i] = result_amg[i + 1];
			}
		}



		if (R != NULL) {
			//delete[] R;
			free(R);
		}
		if (P != NULL) {
			//delete[] P;
			free(P);
		}
		if (bamg_bound != NULL) {
			delete[] bamg_bound;
			bamg_bound = NULL;
		}
		//if (Atemp != NULL) {
		//delete[] Atemp;
		//}
		//if (Atemp2 != NULL) {
		//delete[] Atemp2;
		//}
		if (result_amg != NULL) {
			//delete[] result_amg;
			free(result_amg);
		}
		if (rthdsd_amg != NULL) {
			//delete[] rthdsd_amg;
			free(rthdsd_amg);
		}		


		// освобождение памяти.
		if (Amat != NULL) {
			//delete[] Amat;
			free(Amat);
			Amat = NULL;
		}	


	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif
	///getchar();

}//my_agr_amg_loc_memory_Stress_old

// Здесь содержится обвязка вызывающая РУМБА.
// локальное выдление памяти :всё внутри, многократные alloc и free.
// РУМБА для решения задачи напряженно-деформированнного состояния.
// Нет сходимости. Дата успешного подключения 24 сентября 2017.
void my_agr_amg_loc_memory_Stress(SIMPLESPARSE &sparseM, integer n,
	doublereal* &dV, doublereal* &dX0,
	QuickMemVorst& m, BLOCK* &b, integer &lb)
{

	// 11 января 2016. классический агломеративный алгебраический многосеточный метод.
	// Это моя собственная разработка РУМБА 0.14.
	//if (iVar != PAM) {
	//doublereal theta82 = 0.24;
	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	//-->doublereal theta82 = 0.24;// 0.25; //0.24
	//-->doublereal theta83 = 0.23;// 0.25; // 0.23
	// 0.3 0.4 0.44 0.45  0.5
	// 16  25   38        17
	//--->doublereal magic82 = 0.4; // 0.35; // 0.4 // 0.43
	//----->doublereal magic83 = 0.4;// 0.35; // 0.42

	doublereal theta82 = my_amg_manager.theta;
	doublereal theta83 = my_amg_manager.theta;
	doublereal magic82 = my_amg_manager.magic;
	doublereal magic83 = my_amg_manager.magic;

	doublereal ret74 = 0.0;

	my_amg_manager.theta = my_amg_manager.theta_Stress;
	my_amg_manager.maximum_delete_levels = my_amg_manager.maximum_delete_levels_Stress;
	my_amg_manager.nFinnest = my_amg_manager.nFinnest_Stress;
	my_amg_manager.nu1 = my_amg_manager.nu1_Stress;
	my_amg_manager.nu2 = my_amg_manager.nu2_Stress;
	my_amg_manager.memory_size = my_amg_manager.memory_size_Stress;
	my_amg_manager.ilu2_smoother = my_amg_manager.ilu2_smoother_Stress;
	my_amg_manager.icoarseningtype = my_amg_manager.icoarseningStress; // standart vs RS 2.
	my_amg_manager.istabilization = my_amg_manager.istabilizationStress; // Stabilization : 0 - none, 1 - bicgstab + amg (РУМБА).
	my_amg_manager.magic = my_amg_manager.F_to_F_Stress; // magic
	my_amg_manager.number_interpolation_procedure = my_amg_manager.number_interpolation_procedure_Stress;
	my_amg_manager.iCFalgorithm_and_data_structure = my_amg_manager.iCFalgorithm_and_data_structure_Stress;
	my_amg_manager.iprint_log = my_amg_manager.iprint_log_Stress;
	my_amg_manager.itruncation_interpolation = my_amg_manager.itruncation_interpolation_Stress;
	my_amg_manager.truncation_interpolation = my_amg_manager.truncation_interpolation_Stress;
	my_amg_manager.gold_const = my_amg_manager.gold_const_Stress;
	my_amg_manager.b_gmres = my_amg_manager.b_gmresStress;
	my_amg_manager.bMatrixPortrait = my_amg_manager.bStressMatrixPortrait;


	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.
#ifdef _OPENMP
	int i_my_num_core_parallelesation = omp_get_num_threads();
	omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif

	doublereal nonzeroEPS = 1e-37; // для отделения вещественного нуля

	// На случай если память не была выделена.
	if (dX0 == NULL) {
		dX0 = new doublereal[n];
		for (integer i = 0; i < n; i++) {
			dX0[i] = 0.0;
		}
	}

	integer id = 0;

	simplesparsetoCRS(sparseM, m.val, m.col_ind, m.row_ptr, n); // преобразование матрицы из одного формата хранения в другой.
																//m.ballocCRScfd = true;
	simplesparsefree(sparseM, n);

	integer ierr = 0;
	doublereal eps = 1.0e-12;

	ierr = 0; // изначальное состояние безошибочное.
			  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
	eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

				   // Требования к оперативной памяти.
				   /*     VECTOR         NEEDED LENGTH (GUESS) */
				   /*       Amat               3*NNA + 5*NNU */
				   /*       JA              3*NNA + 5*NNU */
				   /*       IA              2.2*NNU */
				   /*       U               2.2*NNU */
				   /*       F               2.2*NNU */
				   /*       IG              5.4*NNU */

	integer nna = 0;
	for (integer k = 0; k < m.row_ptr[n]; k++) {

		if (fabs(m.val[k]) > nonzeroEPS) {
			nna++;
		}
	}
	//printf("nna=%d istinnoe=%d\n", nna, m.row_ptr[n]);
	//getchar();
	//integer nna = m.row_ptr[n]; // количество ненулевых элементов в матрице СЛАУ.



	integer nnu = n; // число неизвестных.

					 // данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
					 //doublerealT rsize=1.51; // 1048416
					 // Вынужденные течения достаточно 2.5.
					 // значения 3.5 недостаточно для 8 модулей Пионер. 
	//doublerealT rsize = 4.5; // на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.
	/*
	integer nda = 0; // память под вектор значений матрицы слау.
	nda = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndia = 0;
	ndia = (integer)(rsize*2.2*(nnu));
	integer ndja = 0;
	ndja = (integer)(rsize*(3 * (nna)+5 * (nnu)));
	integer ndu = 0;
	ndu = (integer)(rsize*2.2*(nnu));
	integer ndf = 0;
	ndf = (integer)(rsize*2.2*(nnu));
	integer ndig = 0;
	ndig = (integer)(rsize*5.4*(nnu));
	*/


	/*     CLASS 3 - PARAMETERS: */

	/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

	/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

	/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
	/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
	/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
	/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
	/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
	/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
	/*                        BY THE FOLLWING DIGITS. */

	/*                  REST OF IFIRST  --  RNDU: */
	/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
	/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
	/*                    IFIRST=1372815) */

	/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
	/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

	/*                  1ST DIGIT OF NCYC  --  IGAM: */
	/*                    =1: V -CYCLE, */
	/*                    =2: V*-CYCLE, */
	/*                    =3: F -CYCLE, */
	/*                    =4: W -CYCLE. */
	/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
	/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
	/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

	/*                  2ND DIGIT OF NCYC  --  ICGR: */
	/*                    =0: NO CONJUGATE GRADIENT, */
	/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
	/*                    =2: CONJUGATE GRADIENT (FULL CG). */

	/*                  3RD DIGIT OF NCYC  --  ICONV: */
	/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
	/*                    (FINEST GRID): */
	/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
	/*                        NCYCLE (SEE BELOW) */
	/*                    =2: STOP, IF  ||RES|| < EPS */
	/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
	/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
	/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
	/*                           EPS     (SEE INPUT PARAMETER EPS) */
	/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
	/*                           |U|   = SUPREMUM NORM OF SOLUTION */
	/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
	/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
	/*                    AFTER AT MOST NCYCLE CYCLES. */

	/*                  REST OF NCYC  --  NCYCLE: */
	/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
	/*                    NCYCLE=0: NO CYCLING. */

	/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
	/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
	/*                  ARE PERFORMED, REGARDLESS OF EPS. */

	/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
	/*                  GRID IN CYCLING: */

	/*                  1ST DIGIT OF MADAPT  --  MSEL: */
	/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
	/*                        PHASE ARE USED WITHOUT CHECK. */
	/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
	/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
	/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
	/*                        (SEE BELOW). */

	/*                  REST OF MADAPT  --  FAC */
	/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
	/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
	/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
	/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
	/*                        BY DEFAULT. */


	/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

	/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

	/*                  2ND DIGIT OF NRD  --  NRDX: */
	/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
	/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

	/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
	/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
	/*                    =2: FULL GS SWEEP */
	/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
	/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

	/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

	/*                  1ST DIGIT  --  NSC: */
	/*                    =1: GAUSS-SEIDEL METHOD */
	/*                    =2: DIRECT SOLVER (YALE SMP) */

	/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
	/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
	/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
	/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
	/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

	/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

	/*         -------------------------------------------------------------- */

	/*     CLASS 4 - PARAMETERS: */

	/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
	/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
	/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
	/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
	/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

	/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
	/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
	/*                        OPERATORS */
	/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



	/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

	/*          ISWTCH = 4 */
	/*          IOUT   = 12 */
	/*          IPRINT = 10606 */

	/*          LEVELX = 25 */
	/*          IFIRST = 13 */
	/*          NCYC   = 10110 */
	/*          EPS    = 1.D-12 */
	/*          MADAPT = 27 */
	/*          NRD    = 1131 */
	/*          NSOLCO = 110 */
	/*          NRU    = 1131 */

	/*          ECG1   = 0. */
	/*          ECG2   = 0.25 */
	/*          EWT2   = 0.35 */
	/*          NWT    = 2 */
	/*          NTR    = 0 */



	// рекомедуемые параметры по дефолту.
/*
	integer iswtch = 0;
	iswtch = 4;
	integer iout = 0;
	iout = 13; // 13 обеспечивает печать изменения невязки в процессе счёта.
	integer iprint = 0;
	iprint = 10606;
	integer levelx = 0;
	levelx = 25;
	integer ifirst = 0;
	// начальное приближение :
	// 0 - используется из вне.
	// 1 - нулевое.
	// 2 - единицы.
	// 3 - случайная последовательность.
	ifirst = 13;//13 по умолчанию.
				//ifirst=11; // нулевое начальное приближение.
				//ifirst=10; // вроде как начальное приближение берётся из dX0.
				// но 10 никоим образом не улучшает сходимость.
	integer ncyc = 0;
	ncyc = 10110;
	integer madapt = 0;
	madapt = 27;
	integer nrd = 0;
	nrd = 1131;
	integer nsolco = 0;
	nsolco = 110;
	integer nru = 0;
	nru = 1131;
	doublereal ecg1 = 0.0;
	ecg1 = 0.0;
	doublereal ecg2 = 0.0;
	ecg2 = 0.25;
	doublereal ewt2 = 0.0;
	ewt2 = 0.35;
	integer nwt = 0;
	nwt = 2;
	integer ntr = 0;
	ntr = 0;

	integer matrix = 0;
	matrix = 11; // symmetric SPD.
				 //matrix = 22;
	ncyc = 10199;
	*/

    Ak2 Amat;
    Amat.i= NULL;
	Amat.j = NULL;
	Amat.aij = NULL;
	Amat.abs_aij = NULL;

	//Ak1* R = NULL;
	//Ak1* P = NULL;
	//Ak1* Atemp = NULL;
	//Ak1* Atemp2 = NULL;
	doublereal* rthdsd_amg = NULL;
	doublereal* result_amg = NULL;
	// 18 августа 2016
	// граничные узлы требуют особой обработки.
	// true - граничный узел, false - внутренний.
	bool* bamg_bound = NULL;

	// allocate memory.
	// allocate memory 2 jan 2016.
	// BSK Dmitrii 3.012  (2.892 для прямой интерполляции с элементами непрямой). 
	// tgf series no metalization
	// tgf2023-2_01 2.64 643mb
	// tgf2023-2-02 2.58 988mb
	// tgf2023-2-05 2.44 2022mb
	// tgf2023-2-20 3.58 2967mb
	// CGHV1J metalization 3.133 (2.84 для прямой интерполляции с элементами непрямой). 
	// тор Докторович 2.89
	// Концевой 3.05
	// Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
	// Вывод : максимальное значение 3.14 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
	// Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
	// Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
	// Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
	//Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
	// памяти надо много для 6 варианта интерполяции.
	// 9,35,35 28
	integer nsizeA = ((integer)(9 * nna) + 1);
	integer nsizePR = 35;

	if (bPhysics_PTBSH_memory == true) {
		// ПТБШ.
		//printf("bPhysics_PTBSH_memory==true\n");
		nsizeA = ((integer)(4 * nna) + 1);
		nsizePR = 13;
	}

	// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
	// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
	// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
	// пользовательской геометрии (того что пользователь начертил в интерфейсе).
	// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
	// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
	nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
	if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
		printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
		printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif

	}
	nsizePR = 35;
	if (bonly_solid_calculation) {
		// 31 октября 2016.
		// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
		// задач должно хватить значения 12.
		nsizePR = 12;
	}

	MEMORYSTATUSEX statex;
	statex.dwLength = sizeof(statex);
	GlobalMemoryStatusEx(&statex);
	char divisor[2] = "M";
	if (my_amg_manager.iprint_log == 1) {
		printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024 * 1024), divisor);
		printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
		printf("required %zu %sbytes\n", ((nsizeA / (1024 * 1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024 * 1024))* nnu) + 1) * sizeof(Ak1)), divisor);
		//system("pause");
	}

	Amat.i = (integer*)malloc(nsizeA * sizeof(integer));  // 9
	char c1[5] = "Amat";
	char c2[22] = "my_agr_amg_loc_memory";
	char c3[11] = "bamg_bound";
	handle_error<integer>(Amat.i, c1, c2, (nsizeA));
	Amat.j = (integer*)malloc(nsizeA * sizeof(integer));  // 9
	handle_error<integer>(Amat.j, c1, c2, (nsizeA));
	Amat.aij = (doublereal*)malloc(nsizeA * sizeof(doublereal));  // 9
	handle_error<doublereal>(Amat.aij, c1, c2, (nsizeA));
	Amat.abs_aij = (doublereal*)malloc(nsizeA * sizeof(doublereal));  // 9
	handle_error<doublereal>(Amat.abs_aij, c1, c2, (nsizeA));

	bamg_bound = new bool[((nsizePR * nnu) + 1)];
	handle_error<bool>(bamg_bound, c3, c2, ((nsizePR * nnu) + 1));


	// real size 9.4 for resistor.
	// 
	/*
	Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp == NULL) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem : not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	// real size 9.4 for resistor.
	Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
	if (Atemp2 == NULL) {
	// недостаточно памяти на данном оборудовании.
	printf("Problem : not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
	printf("Please any key to exit...\n");
	//getchar();
	system("pause");
	exit(1);
	}
	*/

	//result_amg = new doublerealT[nnu + 1];
	result_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c4[11] = "result_amg";
	handle_error<doublereal>(result_amg, c4, c2, (nnu + 1));


	//rthdsd_amg = new doublerealT[nnu + 1];
	rthdsd_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c5[11] = "rthdsd_amg";
	handle_error<doublereal>(rthdsd_amg, c5, c2, (nnu + 1));



	// правая часть.
	/*
	for (integer i = 0; i < nnu; i++) {
	rthdsd_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	rthdsd_amg[i + 1] = dV[i];
	}
	}
	rthdsd_amg[0] = 0.0;
	*/
	/*
	// вектор решения.
	for (integer i = 0; i < nnu; i++) {
	result_amg[i] = 0.0;
	if (i<maxelm + maxbound) {
	// обязательно нужно проверить была ли выделена оперативная память.
	result_amg[i + 1] = dX0[i];
	}
	}
	result_amg[0] = 0.0;
	*/

	// см. equation3DtoCRS.

	integer ik = 0; // счётчик ненулевых элементов СЛАУ
	id = 1;

	//if (iVar == PAM) {
	//printf("alpharelax=%e\n", alpharelax);
	//	getchar();
	//}


	for (integer k = 0; k <= n; k++) {
		bamg_bound[k] = false;
	}



	//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	//R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	//char c6[2] = "R";
	//handle_error<Ak1>(R, c6, c2, ((nsizePR * nnu) + 1));

	//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
	//P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
	//char c7[2] = "P";
	//handle_error<Ak1>(P, c7, c2, ((nsizePR * nnu) + 1));

	// Блок инициализации нулём, возможно будет работоспособно и без него.





	// начальное приближение.
	for (integer i = 0; i < nnu; i++) {

		result_amg[i + id] = 0.0;
		// обязательно нужно проверить была ли выделена оперативная память. 
		result_amg[i + id] = dX0[i];

	}

	// правая часть.
	for (integer i = 0; i < nnu; i++) {
		rthdsd_amg[i + id] = 0.0;
		// обязательно нужно проверить была ли выделена оперативная память. 
		rthdsd_amg[i + id] = dV[i];
	}




	// см. equation3DtoCRS.

	ik = 0; // счётчик ненулевых элементов СЛАУ

					// для внутренних узлов расчётной области:
	for (integer k = 0; k < n; k++) {

		integer idiagonal_first_ik = ik;

		//сканируем строку.
		for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {

			if (fabs(m.val[k1]) > nonzeroEPS) {
				if (m.col_ind[k1] != k) {
					// Внедиагональный элемент
					Amat.aij[ik + 1 + id] = m.val[k1];
					Amat.j[ik + 1 + id] = m.col_ind[k1] + 1;
					Amat.i[ik + 1 + id] = k + 1;
					ik++;
				}
				else {
					// диагональный элемент
					Amat.aij[idiagonal_first_ik + id] = m.val[k1];
					Amat.j[idiagonal_first_ik + id] = m.col_ind[k1] + 1;
					Amat.i[idiagonal_first_ik + id] = m.col_ind[k1] + 1;
					//ik++;
				}
			}
		}
		ik++;

	}

	/*
	for (integer k = 0; k < n; k++) {
	//сканируем строку.
	for (integer k1 = m.row_ptr[k]; k1 < m.row_ptr[k + 1]; k1++) {
	printf("val=%e col_ind=%d row_ptr=%d\n",a[k1+id],ja[k1+id],ia[k]);
	}
	getchar();
	}
	*/

	// в каждой строке элементы отсортированы по номерам столбцов:
	// Но диагональный элемент всегда на первом месте в строке матрицы.
	integer imove = 0;
	if (id == 0) imove = -1;

	// сортировка ненужна порядок следования любой, но главное чтобы первый в строке был имено диагональный элемент.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+1+imove, ia[k+2]-1+imove); // первый элемент всегда диагональный.
	//for (integer k=0; k<(maxelm+maxbound); k++) QuickSortCSIR_amg(ja, a, ia[k+1]+imove, ia[k+2]-1+imove); 



	//printf("getready ...");
	//getchar();
	// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
	// свой алгоритм 2015 года.


	//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

	//printf("allocation memory is Ok. start ready...\n");
	//system("pause");
	doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
							 //theta = 0.5; // может поможет  для конвективных задач
	doublereal* x_copy = NULL;
	x_copy = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
	char c8[7] = "x_copy";
	handle_error<doublereal>(x_copy, c8, c2, (nnu + 1));

	for (integer i47 = 1; i47 <= nnu; i47++) {
		x_copy[i47] = result_amg[i47];
	}

	//doublereal theta83 = 0.23;
	//doublereal magic82 = 0.4;
	//doublereal magic83 = 0.5; 
	//doublereal ret74 = 0.0;
	bool bdivergence_detected = false;



	// режим экономии оперативной памяти.
	bool bmemory_savings = false;

	integer  maxelm_out = n;// это для radiosity patch.Излучение в вакуумном промежутке.
	// iVar нужен для настройки BiCGStab.
	integer iVar = TOTALDEFORMATIONVAR;



	//if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
		//bdivergence_detected = classic_aglomerative_amg4<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
		//bdivergence_detected = classic_aglomerative_amg4<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);
	bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA, nna, nnu,  x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm_out);

	//}
//else {
	//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
	//bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
//}




	// Работа amg была успешна.
	for (integer i47 = 1; i47 <= nnu; i47++) {
		result_amg[i47] = x_copy[i47];
	}

	if (x_copy != NULL) {
		free(x_copy);
		x_copy = NULL;
	}

	//system("pause");



	// возвращаем решение СЛАУ.
	// вектор решения. 
	for (integer i = 0; i < nnu; i++) {
		if (i < n) {
			// обязательно нужно проверить была ли выделена оперативная память. 
			dX0[i] = result_amg[i + 1];
		}
	}



	//if (R != NULL) {
		//delete[] R;
		//free(R);
	//}
	//if (P != NULL) {
		//delete[] P;
		//free(P);
	//}
	if (bamg_bound != NULL) {
		delete[] bamg_bound;
		bamg_bound = NULL;
	}
	//if (Atemp != NULL) {
	//delete[] Atemp;
	//}
	//if (Atemp2 != NULL) {
	//delete[] Atemp2;
	//}
	if (result_amg != NULL) {
		//delete[] result_amg;
		free(result_amg);
	}
	if (rthdsd_amg != NULL) {
		//delete[] rthdsd_amg;
		free(rthdsd_amg);
	}


	// освобождение памяти.
	if (Amat.i != NULL) {
		//delete[] Amat.i;
		free(Amat.i);
		Amat.i = NULL;
	}
	if (Amat.j != NULL) {
		//delete[] Amat.j;
		free(Amat.j);
		Amat.j = NULL;
	}
	if (Amat.aij != NULL) {
		//delete[] Amat.aij;
		free(Amat.aij);
		Amat.aij = NULL;
	}
	if (Amat.abs_aij != NULL) {
		//delete[] Amat.aij;
		free(Amat.abs_aij);
		Amat.abs_aij = NULL;
	}

	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif

	///getchar();

}//my_agr_amg_loc_memory_Stress


// Здесь содержится обвязка вызывающая РУМБА v0_14 решатель.
// локальное выдление памяти :всё внутри, многократные alloc и free.
void my_agr_amg_loc_memory_old(equation3D* &sl, equation3D_bon* &slb,
	integer maxelm, integer maxbound,
	doublereal *dV, doublereal* &dX0,
	doublereal alpharelax, integer iVar, bool bLRfree, QuickMemVorst& m,
	doublereal &theta82, doublereal &theta83, doublereal &magic82,
	doublereal &magic83, doublereal &ret74, BLOCK* b, integer lb,
	integer* &ifrontregulationgl, integer* &ibackregulationgl,
	SOURCE* &s_loc, integer &ls)
{
#ifdef _OPENMP
	int i_my_num_core_parallelesation = omp_get_num_threads();
	omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif
	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.

	
	// режим экономии оперативной памяти.
	bool bmemory_savings = true; // true работает только с counting Sort.
	switch (my_amg_manager.imySortAlgorithm) {
	case COUNTING_SORT_ALG: 
		bmemory_savings = true;
		break;
	case QUICK_SORT_ALG:
		bmemory_savings = false;
		break;
	case HEAP_SORT_ALG:
		bmemory_savings = false;
		break;
	case TIM_PETERSON_SORT_ALG:
		bmemory_savings = false;
		break;
	default :
		bmemory_savings = true;
		break;
	}

	// На случай если память не была выделена.
	if (dX0 == NULL) {
		dX0 = new doublereal[maxelm + maxbound];
		if (dX0 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for dX0 my_agregat_amg.cpp...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		for (integer i = 0; i<maxelm + maxbound; i++) {
			dX0[i] = 0.0;
		}
		printf("allocation memory for dX0... Ok. dX0 initialization 0.0 value.\n");
	}


	doublereal tmaxloc = -272.15e6;
	for (integer i = 0; i<maxelm; i++) tmaxloc = fmax(tmaxloc, dX0[i]);
	if (iVar==TEMP) {
		printf("Intermediate maximum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tmaxloc);
	}
	doublereal tminloc = 1.0e7;
	for (integer i = 0; i<maxelm; i++) tminloc = fmin(tminloc, dX0[i]);
	if (iVar==TEMP) {
		printf("Intermediate minimum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tminloc);
	}


	const doublereal nonzeroEPS = 1.0e-37; // для отделения вещественного нуля
	doublereal res_sum = 0.0;
	res_sum = 0.0;
	for (integer i = 0; i<maxelm; i++) {
		// внутренность матрицы.
		doublereal buf = 0.0;
		buf = (sl[i].ap*dX0[sl[i].iP] - dV[sl[i].iP]);
		if ((sl[i].iB>-1) && (fabs(sl[i].ab) > nonzeroEPS)) buf -= sl[i].ab*dX0[sl[i].iB];
		if ((sl[i].iE>-1) && (fabs(sl[i].ae) > nonzeroEPS)) buf -= sl[i].ae*dX0[sl[i].iE];
		if ((sl[i].iN>-1) && (fabs(sl[i].an) > nonzeroEPS)) buf -= sl[i].an*dX0[sl[i].iN];
		if ((sl[i].iS>-1) && (fabs(sl[i].as) > nonzeroEPS)) buf -= sl[i].as*dX0[sl[i].iS];
		if ((sl[i].iT>-1) && (fabs(sl[i].at) > nonzeroEPS)) buf -= sl[i].at*dX0[sl[i].iT];
		if ((sl[i].iW>-1) && (fabs(sl[i].aw) > nonzeroEPS)) buf -= sl[i].aw*dX0[sl[i].iW];
		// Дополнение на АЛИС сетке.
		if ((sl[i].iB2>-1) && (fabs(sl[i].ab2) > nonzeroEPS)) buf -= sl[i].ab2*dX0[sl[i].iB2];
		if ((sl[i].iE2>-1) && (fabs(sl[i].ae2) > nonzeroEPS)) buf -= sl[i].ae2*dX0[sl[i].iE2];
		if ((sl[i].iN2>-1) && (fabs(sl[i].an2) > nonzeroEPS)) buf -= sl[i].an2*dX0[sl[i].iN2];
		if ((sl[i].iS2>-1) && (fabs(sl[i].as2) > nonzeroEPS)) buf -= sl[i].as2*dX0[sl[i].iS2];
		if ((sl[i].iT2>-1) && (fabs(sl[i].at2) > nonzeroEPS)) buf -= sl[i].at2*dX0[sl[i].iT2];
		if ((sl[i].iW2>-1) && (fabs(sl[i].aw2) > nonzeroEPS)) buf -= sl[i].aw2*dX0[sl[i].iW2];

		if ((sl[i].iB3>-1) && (fabs(sl[i].ab3) > nonzeroEPS)) buf -= sl[i].ab3*dX0[sl[i].iB3];
		if ((sl[i].iE3>-1) && (fabs(sl[i].ae3) > nonzeroEPS)) buf -= sl[i].ae3*dX0[sl[i].iE3];
		if ((sl[i].iN3>-1) && (fabs(sl[i].an3) > nonzeroEPS)) buf -= sl[i].an3*dX0[sl[i].iN3];
		if ((sl[i].iS3>-1) && (fabs(sl[i].as3) > nonzeroEPS)) buf -= sl[i].as3*dX0[sl[i].iS3];
		if ((sl[i].iT3>-1) && (fabs(sl[i].at3) > nonzeroEPS)) buf -= sl[i].at3*dX0[sl[i].iT3];
		if ((sl[i].iW3>-1) && (fabs(sl[i].aw3) > nonzeroEPS)) buf -= sl[i].aw3*dX0[sl[i].iW3];

		if ((sl[i].iB4>-1) && (fabs(sl[i].ab4) > nonzeroEPS)) buf -= sl[i].ab4*dX0[sl[i].iB4];
		if ((sl[i].iE4>-1) && (fabs(sl[i].ae4) > nonzeroEPS)) buf -= sl[i].ae4*dX0[sl[i].iE4];
		if ((sl[i].iN4>-1) && (fabs(sl[i].an4) > nonzeroEPS)) buf -= sl[i].an4*dX0[sl[i].iN4];
		if ((sl[i].iS4>-1) && (fabs(sl[i].as4) > nonzeroEPS)) buf -= sl[i].as4*dX0[sl[i].iS4];
		if ((sl[i].iT4>-1) && (fabs(sl[i].at4) > nonzeroEPS)) buf -= sl[i].at4*dX0[sl[i].iT4];
		if ((sl[i].iW4>-1) && (fabs(sl[i].aw4) > nonzeroEPS)) buf -= sl[i].aw4*dX0[sl[i].iW4];

		buf *= buf;
		res_sum += buf;
	}
	for (integer i = 0; i<maxbound; i++) {
		// граничные узлы.
		doublereal buf = 0.0;
		buf = slb[i].aw*dX0[slb[i].iW] - dV[slb[i].iW];
		if ((slb[i].iI>-1) && (fabs(slb[i].ai) > nonzeroEPS)) buf -= slb[i].ai*dX0[slb[i].iI];
		buf *= buf;
		res_sum += buf;
	}
	res_sum = sqrt(res_sum);
	printf("input diagnostic residual =%e\n",res_sum);

	if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
		if (res_sum > 20.0) {
			printf("Speed diagnostic problem analysys....\n");
		}
	}

	//printf("residual start=%1.4e\n",res_sum);
	//getchar();

	// результаты тестирования
	// задача, начальная невязка , значение евклидовой нормы невязки при которой решение является полученным.
	// tgf01 5.4357e-1 1.0209e-11
	// CGHV1J с метализацией 3.3667e-1 5.0712e-12
	// tgf02 7.6872e-11 1.434e-11
	// tgf05 1.0871e+0  2.2895e-11
	// резистор на 1мм поликоре 5.0e-2 4.9174e-14
	//Diamond ZUb 4 4.0016e-1  4.64444e-11
	// DiamondZUB 4.0016e-1 1.1443e-8
	// NXP100 4.3399e+0  7.8347e-11 (для решения хватило 8Гб ОЗУ.)

	doublereal res_sum_previos = 1.05*finish_residual;
	if ((adiabatic_vs_heat_transfer_coeff > 0) || (breakRUMBAcalc_for_nonlinear_boundary_condition)) {
		// Надо пересобирать матрицу и запускать всё по новой т.к. задача 
		// существенно нелинейна.

		// Работает задача Ньютона Рихмана или
		// Стефана Больцмана или миксовая.
		res_sum_previos = 1.0e-12;
	}

	//if (res_sum>1.0E-10) 
	if (res_sum>res_sum_previos) // защита от повторного холостого запуска экономит время конечного пользователя.
	{

		//yes_print_amg=false;
		//yes_print_amg = false;





		integer ierr = 0;
		doublereal eps = 1.0e-12;

		ierr = 0; // изначальное состояние безошибочное.
				  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
		eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

					   // Требования к оперативной памяти.
					   /*     VECTOR         NEEDED LENGTH (GUESS) */
					   /*       Amat               3*NNA + 5*NNU */
					   /*       JA              3*NNA + 5*NNU */
					   /*       IA              2.2*NNU */
					   /*       U               2.2*NNU */
					   /*       F               2.2*NNU */
					   /*       IG              5.4*NNU */


		integer nna = 0; // количество ненулевых элементов в матрице СЛАУ.


						 // подсчёт числа ненулевых элементов в матрице.
		nna = 0;
		for (integer i = 0; i<maxelm; i++) {
			// внутренность матрицы.
			if ((sl[i].iB>-1) && (fabs(sl[i].ab) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE>-1) && (fabs(sl[i].ae) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN>-1) && (fabs(sl[i].an) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS>-1) && (fabs(sl[i].as) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT>-1) && (fabs(sl[i].at) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW>-1) && (fabs(sl[i].aw) > nonzeroEPS)) (nna)++;
			if ((sl[i].iP>-1) && (fabs(sl[i].ap) > nonzeroEPS)) (nna)++;

			// Дополнение на АЛИС сетке:
			if ((sl[i].iB2>-1) && (fabs(sl[i].ab2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE2>-1) && (fabs(sl[i].ae2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN2>-1) && (fabs(sl[i].an2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS2>-1) && (fabs(sl[i].as2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT2>-1) && (fabs(sl[i].at2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW2>-1) && (fabs(sl[i].aw2) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB3>-1) && (fabs(sl[i].ab3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE3>-1) && (fabs(sl[i].ae3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN3>-1) && (fabs(sl[i].an3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS3>-1) && (fabs(sl[i].as3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT3>-1) && (fabs(sl[i].at3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW3>-1) && (fabs(sl[i].aw3) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB4>-1) && (fabs(sl[i].ab4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE4>-1) && (fabs(sl[i].ae4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN4>-1) && (fabs(sl[i].an4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS4>-1) && (fabs(sl[i].as4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT4>-1) && (fabs(sl[i].at4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW4>-1) && (fabs(sl[i].aw4) > nonzeroEPS)) (nna)++;

		}
		for (integer i = 0; i<maxbound; i++) {
			// граничные узлы.
			if ((slb[i].iW>-1) && (fabs(slb[i].aw) > nonzeroEPS)) (nna)++;
			if ((slb[i].iI>-1) && (fabs(slb[i].ai) > nonzeroEPS)) (nna)++;
		}

		integer nnu = 0; // число неизвестных.
		nnu = maxelm + maxbound;

		/*
		// Рекомендуемые по умолчанию параметры.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=3*(nna)+5*(nnu);
		integer ndia=0;
		ndia=(integer)(2.2*(nnu));
		integer ndja=0;
		ndja=3*(nna)+5*(nnu);
		integer ndu=0;
		ndu=(integer)(2.2*(nnu));
		integer ndf=0;
		ndf=(integer)(2.2*(nnu));
		integer ndig=0;
		ndig=(integer)(5.4*(nnu));
		*/

		/*
		// в двое больше памяти чем рекомендовано.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=6*(nna)+10*(nnu);
		integer ndia=0;
		ndia=(integer)(4.4*(nnu));
		integer ndja=0;
		ndja=6*(nna)+10*(nnu);
		integer ndu=0;
		ndu=(integer)(4.4*(nnu));
		integer ndf=0;
		ndf=(integer)(4.4*(nnu));
		integer ndig=0;
		ndig=(integer)(10.8*(nnu));
		*/

		// данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
		//doublereal rsize=1.51; // 1048416
		// Вынужденные течения достаточно 2.5. 
		// на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.


		Ak1* Amat = NULL;
		Ak1* R = NULL;
		Ak1* P = NULL;
		//Ak1* Atemp = NULL;
		//Ak1* Atemp2 = NULL;
		doublereal* rthdsd_amg = NULL;
		doublereal* result_amg = NULL;
		// 18 августа 2016
		// граничные узлы требуют особой обработки.
		// true - граничный узел, false - внутренний.
		bool* bamg_bound = NULL;




		/*     CLASS 3 - PARAMETERS: */

		/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

		/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

		/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
		/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
		/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
		/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
		/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
		/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
		/*                        BY THE FOLLWING DIGITS. */

		/*                  REST OF IFIRST  --  RNDU: */
		/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
		/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
		/*                    IFIRST=1372815) */

		/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
		/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

		/*                  1ST DIGIT OF NCYC  --  IGAM: */
		/*                    =1: V -CYCLE, */
		/*                    =2: V*-CYCLE, */
		/*                    =3: F -CYCLE, */
		/*                    =4: W -CYCLE. */
		/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
		/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
		/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

		/*                  2ND DIGIT OF NCYC  --  ICGR: */
		/*                    =0: NO CONJUGATE GRADIENT, */
		/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
		/*                    =2: CONJUGATE GRADIENT (FULL CG). */

		/*                  3RD DIGIT OF NCYC  --  ICONV: */
		/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
		/*                    (FINEST GRID): */
		/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
		/*                        NCYCLE (SEE BELOW) */
		/*                    =2: STOP, IF  ||RES|| < EPS */
		/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
		/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
		/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
		/*                           EPS     (SEE INPUT PARAMETER EPS) */
		/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
		/*                           |U|   = SUPREMUM NORM OF SOLUTION */
		/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
		/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
		/*                    AFTER AT MOST NCYCLE CYCLES. */

		/*                  REST OF NCYC  --  NCYCLE: */
		/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
		/*                    NCYCLE=0: NO CYCLING. */

		/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
		/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
		/*                  ARE PERFORMED, REGARDLESS OF EPS. */

		/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
		/*                  GRID IN CYCLING: */

		/*                  1ST DIGIT OF MADAPT  --  MSEL: */
		/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
		/*                        PHASE ARE USED WITHOUT CHECK. */
		/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
		/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
		/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
		/*                        (SEE BELOW). */

		/*                  REST OF MADAPT  --  FAC */
		/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
		/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
		/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
		/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
		/*                        BY DEFAULT. */


		/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

		/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF NRD  --  NRDX: */
		/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
		/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

		/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
		/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
		/*                    =2: FULL GS SWEEP */
		/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
		/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

		/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

		/*                  1ST DIGIT  --  NSC: */
		/*                    =1: GAUSS-SEIDEL METHOD */
		/*                    =2: DIRECT SOLVER (YALE SMP) */

		/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
		/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
		/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
		/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
		/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

		/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

		/*         -------------------------------------------------------------- */

		/*     CLASS 4 - PARAMETERS: */

		/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
		/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
		/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
		/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
		/*                        OPERATORS */
		/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



		/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

		/*          ISWTCH = 4 */
		/*          IOUT   = 12 */
		/*          IPRinteger = 10606 */

		/*          LEVELX = 25 */
		/*          IFIRST = 13 */
		/*          NCYC   = 10110 */
		/*          EPS    = 1.D-12 */
		/*          MADAPT = 27 */
		/*          NRD    = 1131 */
		/*          NSOLCO = 110 */
		/*          NRU    = 1131 */

		/*          ECG1   = 0. */
		/*          ECG2   = 0.25 */
		/*          EWT2   = 0.35 */
		/*          NWT    = 2 */
		/*          NTR    = 0 */



		// рекомедуемые параметры по дефолту.
		/*
		integer iswtch = 0;
		iswtch = 4;
		integer iout = 0;
		iout = 12;
		integer iprinteger = 0;
		iprinteger = 10606;
		integer levelx = 0;
		levelx = 25;
		integer ifirst = 0;
		// начальное приближение :
		// 0 - используется из вне.
		// 1 - нулевое.
		// 2 - единицы.
		// 3 - случайная последовательность.
		ifirst = 13;//13 по умолчанию.
		//ifirst=11; // нулевое начальное приближение.
		//ifirst=10; // вроде как начальное приближение берётся из dX0.
		// но 10 никоим образом не улучшает сходимость.
		integer ncyc = 0;
		ncyc = 10110;
		integer madapt = 0;
		madapt = 27;
		integer nrd = 0;
		nrd = 1131;
		integer nsolco = 0;
		nsolco = 110;
		integer nru = 0;
		nru = 1131;
		doublereal ecg1 = 0.0;
		ecg1 = 0.0;
		doublereal ecg2 = 0.0;
		ecg2 = 0.25;
		doublereal ewt2 = 0.0;
		ewt2 = 0.35;
		integer nwt = 0;
		nwt = 2;
		integer ntr = 0;
		ntr = 0;

		integer matrix = 0;
		//matrix=11; // symmetric SPD.
		matrix = 22;

		if ((iVar == PAM) && (bLRfree)) {
		//printf("work amg1r5\n");
		//getchar();
		// Симметричная положительно определённая матрица это такая матрица
		// которая возникает для поправки давления при решении вязких несжимаемых уравнений Навье-Стокса в
		// случае задач : каверна, тест Валь-Девиса. Для задач промышленного масштаба это всякие естественные
		// конвекции охлаждающие висящие в воздухе без контакта с теплоотводом греющиеся изделия.
		// Это особый специфический класс задач.
		matrix = 11;
		}
		*/
       // для прямой интерполляции с элементами непрямой можно выставить коэффициент 3 и освободить память из под 
       // исходной матрицы (для той структуры на которой была выполнена сборка матрицы изначально). 

		// allocate memory 2 jan 2016.
        // BSK Dmitrii 3.012  (2.892 для прямой интерполляции с элементами непрямой). 
        // tgf series no metalization
        // tgf2023-2_01 2.64 643mb
        // tgf2023-2-02 2.58 988mb
        // tgf2023-2-05 2.44 2022mb
        // tgf2023-2-20 3.58 2967mb
        // CGHV1J metalization 3.133 (2.84 для прямой интерполляции с элементами непрямой). 
        // тор Докторович 2.89
        // Концевой 3.05
        // Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
        // Вывод : максимальное значение 3.14 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
        // Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
        // Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
        // Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
		//Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
        // памяти надо много для 6 варианта интерполяции.
// 9,35,35 28
        integer nsizeA = ((integer)(9 * nna) + 1);
		integer nsizePR = 35;

		if (bPhysics_PTBSH_memory==true) {
			// ПТБШ.
			//printf("bPhysics_PTBSH_memory==true\n");
			nsizeA = ((integer)(4 * nna) + 1);
			nsizePR = 13;
		}

		// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
		// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
		// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
		// пользовательской геометрии (того что пользователь начертил в интерфейсе).
		// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
		// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
		nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
		if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
			printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
			printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif
			
		}
		nsizePR = 35;
		if (bonly_solid_calculation) {
			// 31 октября 2016.
			// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
			// задач должно хватить значения 12.
			nsizePR = 12;
		}

		MEMORYSTATUSEX statex;
		statex.dwLength = sizeof(statex);
		GlobalMemoryStatusEx(&statex);
		char divisor[2] = "M";
		if (my_amg_manager.iprint_log == 1) {
			printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024 * 1024), divisor);
			printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
			printf("required %zu %sbytes\n", ((nsizeA / (1024 * 1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024 * 1024))* nnu) + 1) * sizeof(Ak1)), divisor);
			//system("pause");
		}

		char c1[22] = "my_agr_amg_loc_memory";
		char c2[5] = "Amat";
		Amat = (Ak1*)malloc(nsizeA*sizeof(Ak1));  // 9
		handle_error<Ak1>(Amat, c2, c1, (nsizeA));
		
		char c0[11] = "bamg_bound";
		bamg_bound = new bool[((nsizePR * nnu) + 1)];
		handle_error<bool>(bamg_bound, c0, c1, ((nsizePR * nnu) + 1));
		
		
		// real size 9.4 for resistor.
		// 
		/*
		Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		// real size 9.4 for resistor.
		Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp2 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/

		//result_amg = new doublereal[nnu + 1];
		result_amg = (doublereal*)malloc((nnu + 1)*sizeof(doublereal));
		char c3[11] = "result_amg";
		handle_error<doublereal>(result_amg, c3, c1, (nnu + 1));
		

		//rthdsd_amg = new doublereal[nnu + 1];
		rthdsd_amg = (doublereal*)malloc((nnu + 1)*sizeof(doublereal));
		char c4[11] = "rthdsd_amg";
		handle_error<doublereal>(rthdsd_amg,c4 , c1, (nnu + 1));
		


		// правая часть.
		/*
		for (integer i = 0; i < nnu; i++) {
		rthdsd_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		rthdsd_amg[i + 1] = dV[i];
		}
		}
		rthdsd_amg[0] = 0.0;
		*/
		/*
		// вектор решения.
		for (integer i = 0; i < nnu; i++) {
		result_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		result_amg[i + 1] = dX0[i];
		}
		}
		result_amg[0] = 0.0;
		*/

		// см. equation3DtoCRS.

		integer ik = 0; // счётчик ненулевых элементов СЛАУ
		integer id = 1;

		//if (iVar == PAM) {
			//printf("alpharelax=%e\n", alpharelax);
		//	getchar();
		//}
		
		integer* icompression = NULL;
		doublereal* rcompressionb = NULL;
		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			icompression= (integer*)malloc((7*maxelm + 1) * sizeof(integer)); // +1 запас.
			char c5[13] = "icompression";
			handle_error<integer>(icompression, c5, c1, (7 * maxelm + 1));
			for (integer i_1 = 0; i_1 < (7 * maxelm + 1); i_1++) {
				icompression[i_1] = -1;
			}
			rcompressionb= (doublereal*)malloc(( maxelm + 1) * sizeof(doublereal)); // +1 запас.
			char c6[14] = "rcompressionb";
			handle_error<doublereal>(rcompressionb,c6, c1, (maxelm + 1));
			for (integer i_1 = 0; i_1 < (maxelm); i_1++) {
				rcompressionb[i_1] = sl[i_1].b;
			}
		}

		integer iscan1 = 0;
		//printf("alpharelax=%e\n", alpharelax);
		//getchar();
		// для внутренних узлов расчётной области:
		for (integer k = 0; k<maxelm; k++) {
			//printf("%e %e %e %e %e %e %e\n", sl[k].ap / alpharelax, -sl[k].ae, -sl[k].aw, -sl[k].an, -sl[k].as, -sl[k].at, -sl[k].ab);
			//system("pause");

			if (fabs(sl[k].ap) > nonzeroEPS) {
				Amat[ik + id].aij = sl[k].ap / alpharelax;
				Amat[ik + id].j = sl[k].iP + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				bamg_bound[Amat[ik + id].i] = false;
				rthdsd_amg[sl[k].iP + 1] = dV[sl[k].iP];
				result_amg[sl[k].iP + 1] = dX0[sl[k].iP];
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iE>-1) && (fabs(sl[k].ae) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ae;
				Amat[ik + id].j = sl[k].iE + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iN>-1) && (fabs(sl[k].an) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].an;
				Amat[ik + id].j = sl[k].iN + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iT>-1) && (fabs(sl[k].at) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].at;
				Amat[ik + id].j = sl[k].iT + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iS>-1) && (fabs(sl[k].as) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].as;
				Amat[ik + id].j = sl[k].iS + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iW>-1) && (fabs(sl[k].aw) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].aw;
				Amat[ik + id].j = sl[k].iW + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iB>-1) && (fabs(sl[k].ab) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ab;
				Amat[ik + id].j = sl[k].iB + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			// icompression - применяется только для структурированной сетки.
			// Дополнение на АЛИС сетке:
			if ((sl[k].iE2>-1) && (fabs(sl[k].ae2) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ae2;
				Amat[ik + id].j = sl[k].iE2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN2>-1) && (fabs(sl[k].an2) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].an2;
				Amat[ik + id].j = sl[k].iN2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT2>-1) && (fabs(sl[k].at2) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].at2;
				Amat[ik + id].j = sl[k].iT2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS2>-1) && (fabs(sl[k].as2) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].as2;
				Amat[ik + id].j = sl[k].iS2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW2>-1) && (fabs(sl[k].aw2) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].aw2;
				Amat[ik + id].j = sl[k].iW2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB2>-1) && (fabs(sl[k].ab2) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ab2;
				Amat[ik + id].j = sl[k].iB2 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE3>-1) && (fabs(sl[k].ae3) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ae3;
				Amat[ik + id].j = sl[k].iE3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN3>-1) && (fabs(sl[k].an3) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].an3;
				Amat[ik + id].j = sl[k].iN3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT3>-1) && (fabs(sl[k].at3) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].at3;
				Amat[ik + id].j = sl[k].iT3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS3>-1) && (fabs(sl[k].as3) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].as3;
				Amat[ik + id].j = sl[k].iS3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW3>-1) && (fabs(sl[k].aw3) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].aw3;
				Amat[ik + id].j = sl[k].iW3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB3>-1) && (fabs(sl[k].ab3) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ab3;
				Amat[ik + id].j = sl[k].iB3 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE4>-1) && (fabs(sl[k].ae4) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ae4;
				Amat[ik + id].j = sl[k].iE4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN4>-1) && (fabs(sl[k].an4) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].an4;
				Amat[ik + id].j = sl[k].iN4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;				
			}
			if ((sl[k].iT4>-1) && (fabs(sl[k].at4) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].at4;
				Amat[ik + id].j = sl[k].iT4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS4>-1) && (fabs(sl[k].as4) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].as4;
				Amat[ik + id].j = sl[k].iS4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW4>-1) && (fabs(sl[k].aw4) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].aw4;
				Amat[ik + id].j = sl[k].iW4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB4>-1) && (fabs(sl[k].ab4) > nonzeroEPS)) {
				Amat[ik + id].aij = -sl[k].ab4;
				Amat[ik + id].j = sl[k].iB4 + 1;
				Amat[ik + id].i = sl[k].iP + 1;
				ik++;
			}

		}

		
		
		// для внутренних узлов расчётной области:
		for (integer k = 0; k<maxbound; k++) {
			if (fabs(slb[k].aw) > nonzeroEPS) {
				// val[ik]=slb[k].aw/alpharelax;
				Amat[ik + id].aij = slb[k].aw; // релаксация для граничных узлов не применяется.
											/*if ((slb[k].iI>-1) && (fabs(slb[k].ai) > nonzeroEPS)) {
											// Внимание !!! было произведено тестирование : один вариант был с нижней релаксацией для граничных узлов,
											// а второй вариант был без нижней релаксации на граничных узлах. Было выяснено, что для сходимости
											// более благоприятен вариант без нижней релаксации на граничных узлах.
											// Данное изменение согласовано с функцией solve.

											val[ik]/=alpharelax; // Если условия Неймана то нижняя релаксация.
											}*/
				Amat[ik + id].j = slb[k].iW + 1;
				Amat[ik + id].i = slb[k].iW + 1; // dirichlet
				if (!((slb[k].iI > -1) && (fabs(slb[k].ai) > nonzeroEPS))) {
					// Dirichlet value.
					// Значения Дирихле мы сразу априорно помещаем в C nodes.
					//bamg_bound[Amat[ik + id].i] = true;
					// Это глупость. Наоборот все узлы Дирихле становятся С узлами сразу.
				}
				else {
					// Neiman.
					// Условия Неймана при построении C-F разбиения обрабатываем как обычно как внутренний узел.
					bamg_bound[Amat[ik + id].i] = false;
				}
				rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				ik++;
			}
			if ((slb[k].iI>-1) && (fabs(slb[k].ai) > nonzeroEPS)) {
				Amat[ik + id].aij = -slb[k].ai;
				Amat[ik + id].j = slb[k].iI + 1;
				Amat[ik + id].i = slb[k].iW + 1;
				//rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				//result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				// Это очень важный вопрос и он требует проверки !

				ik++;
			}

		}


		for (integer k = 0; k <= maxelm + maxbound; k++) {
			bamg_bound[k] = false;
		}

		// Освободим немного памяти.
		// Т.к. мы оперируем в мультигриде в девять раз большим объёмом памяти то это уничтожение не является
		// чем-то медленным по сравнению с ресурсами мультигрида.
		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			// Только в случае структурированной сетки  мы компрессируем исходную матрицу чтобы высвободить оперативную память.
			delete[] sl;
			sl = NULL;
		}
		//delete[] slb;
		//slb = NULL;

		//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		char c7[2] = "R";
		handle_error<Ak1>(R, c7, c1, ((nsizePR * nnu) + 1));
	     	
		//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		char c8[2] = "P";
		handle_error<Ak1>(P, c8, c1, ((nsizePR * nnu) + 1));


		// TODO : 
		// нужно акуратно прописать выделения и уничтожения памяти с учётом того что было сделано в BiCGStabP.

		// Экономим 1 размер матрицы для мультигрида.
		//delete[] sl;
		//delete[] slb;



		//printf("getready ...");
		//getchar();
		// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
		// свой алгоритм 2015 года.


		//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

		//printf("allocation memory is Ok. start ready...\n");
		//system("pause");
		doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
		//theta = 0.5; // может поможет  для конвективных задач
		doublereal* x_copy = NULL;
		x_copy = (doublereal*)malloc((nnu + 1)*sizeof(doublereal));
		char c9[7] = "x_copy";
		handle_error<doublereal>(x_copy, c9,c1, (nnu + 1));

		for (integer i47 = 1; i47 <= nnu; i47++) {
			x_copy[i47] = result_amg[i47];
		}

		//doublereal theta83 = 0.23;
		//doublereal magic82 = 0.4;
		//doublereal magic83 = 0.5; 
		//doublereal ret74 = 0.0;
		bool bdivergence_detected = false;


		//Внимание можно использовать только double, с float сходимости нет.
		if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
			//float theta82f=(float)theta82, theta83f= (float)theta83, magic82f= (float)magic82, magic83f= (float)magic83, ret74f= (float)ret74;
			doublereal theta82f = (doublereal)theta82, theta83f = (doublereal)theta83, magic82f = (doublereal)magic82, magic83f = (doublereal)magic83, ret74f = (doublereal)ret74;
			bdivergence_detected = classic_aglomerative_amg4<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg,  theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings,b, lb, maxelm);
			//bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm);
		}
		else {
			//float theta82f = (float)theta82, theta83f = (float)theta83, magic82f = (float)magic82, magic83f = (float)magic83, ret74f = (float)ret74;
			doublereal theta82f = (doublereal)theta82, theta83f = (doublereal)theta83, magic82f = (doublereal)magic82, magic83f = (doublereal)magic83, ret74f = (doublereal)ret74;
			//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings);
			bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
		}
		// если работа amg была неудачна то мы не портим переполнение рабочий вектор результата.
		// Перенаправление на стабильную версию алгоритма.
		if (bdivergence_detected) {
			//system("pause");
			integer maxit = 2000;
			bool bprintmessage = false;
			Bi_CGStab_internal3(sl, slb, maxelm, maxbound, dV, dX0, maxit, alpharelax, bprintmessage, iVar, m, ifrontregulationgl, ibackregulationgl, b, lb, s_loc, ls, 100000000);
		}
		else
		{
			// Работа amg была успешна.
			for (integer i47 = 1; i47 <= nnu; i47++) {
				result_amg[i47] = x_copy[i47];
			}
		}
		if (x_copy != NULL) {
			free(x_copy);
			x_copy = NULL;
		}

	    //system("pause");

		

		// возвращаем решение СЛАУ.
		// вектор решения. 
		for (integer i = 0; i < nnu; i++) {
			if (i<maxelm + maxbound) {
				// обязательно нужно проверить была ли выделена оперативная память. 
				dX0[i] = result_amg[i + 1];
			}
		}

		
		
		if (R != NULL) {
			//delete[] R;
			free(R);
		}
		if (P != NULL) {
		    //delete[] P;
			free(P);
		}
		if (bamg_bound != NULL) {
			delete[] bamg_bound;
			bamg_bound = NULL;
		}
		//if (Atemp != NULL) {
			//delete[] Atemp;
		//}
		//if (Atemp2 != NULL) {
			//delete[] Atemp2;
		//}
		if (result_amg != NULL) {
			//delete[] result_amg;
			free(result_amg);
		}
		if (rthdsd_amg != NULL) {
			//delete[] rthdsd_amg;
			free(rthdsd_amg);
		}

		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			sl = new equation3D[maxelm]; // коэффициенты матрицы СЛАУ для внутренних КО.
			if (sl == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for slau temperature constr struct...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
		}


		/*
		slb = new equation3D_bon[maxbound]; // коэффициенты матрицы СЛАУ для граничных КО
		if (slb == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for slau boundary temperature constr struct...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/
		if (bmemory_savings &&(!b_on_adaptive_local_refinement_mesh)) {
			// Разархивация исходной матрицы А в первоначальном формате.
			// Предполагается что матрица на структурированной декартовой прямоугольной сетке.
			// Как бы мы не пытались здесь, но матрица не сохраняемая в файл не подлежит здесь восстановлению,
			// а операция записи в файл чрезвычайно медленная.
			for (integer k = 0; k < maxelm; k++) {
				
				sl[k].bB2 = false;
				sl[k].bB3 = false;
				sl[k].bB4 = false;
				sl[k].bE2 = false;
				sl[k].bE3 = false;
				sl[k].bE4 = false;
				sl[k].bN2 = false;
				sl[k].bN3 = false;
				sl[k].bN4 = false;
				sl[k].bT2 = false;
				sl[k].bT3 = false;
				sl[k].bT4 = false;
				sl[k].bW2 = false;
				sl[k].bW3 = false;
				sl[k].bW4 = false;
				sl[k].bS2 = false;
				sl[k].bS3 = false;
				sl[k].bS4 = false;
				
				sl[k].iB = -1;
				sl[k].iB2 = -1;
				sl[k].iB3 = -1;
				sl[k].iB4 = -1;
				sl[k].iE = -1;
				sl[k].iE2 = -1;
				sl[k].iE3 = -1;
				sl[k].iE4 = -1;
				sl[k].iN = -1;
				sl[k].iN2 = -1;
				sl[k].iN3 = -1;
				sl[k].iN4 = -1;
				sl[k].iS = -1;
				sl[k].iS2 = -1;
				sl[k].iS3 = -1;
				sl[k].iS4 = -1;
				sl[k].iT = -1;
				sl[k].iT2 = -1;
				sl[k].iT3 = -1;
				sl[k].iT4 = -1;
				sl[k].iW = -1;
				sl[k].iW2 = -1;
				sl[k].iW3 = -1;
				sl[k].iW4 = -1;
				sl[k].ab = 0.0;
				sl[k].ae = 0.0;
				sl[k].an = 0.0;
				sl[k].as = 0.0;
				sl[k].at = 0.0;
				sl[k].aw = 0.0;
				sl[k].ab2 = 0.0;
				sl[k].ae2 = 0.0;
				sl[k].an2 = 0.0;
				sl[k].as2 = 0.0;
				sl[k].at2 = 0.0;
				sl[k].aw2 = 0.0;
				sl[k].ab3 = 0.0;
				sl[k].ae3 = 0.0;
				sl[k].an3 = 0.0;
				sl[k].as3 = 0.0;
				sl[k].at3 = 0.0;
				sl[k].aw3 = 0.0;
				sl[k].ab4 = 0.0;
				sl[k].ae4 = 0.0;
				sl[k].an4 = 0.0;
				sl[k].as4 = 0.0;
				sl[k].at4 = 0.0;
				sl[k].aw4 = 0.0;
				sl[k].ap = 0.0;
				integer iadd = 7 * k;
				sl[k].b = rcompressionb[k];
				//p e n t s w b
				sl[k].ap = 1.0/Amat[the_original_order_of_values[icompression[iadd + 0]]].aij;
				sl[k].iP = Amat[the_original_order_of_values[icompression[iadd + 0]]].i - 1;
				if (icompression[iadd + 1] > -1) {
					// E
					sl[k].ae = -Amat[the_original_order_of_values[icompression[iadd + 1]]].aij;
					sl[k].iE = Amat[the_original_order_of_values[icompression[iadd + 1]]].j - 1;
				}
				if (icompression[iadd + 2] > -1) {
					// N
					sl[k].an = -Amat[the_original_order_of_values[icompression[iadd + 2]]].aij;
					sl[k].iN = Amat[the_original_order_of_values[icompression[iadd + 2]]].j - 1;
				}
				if (icompression[iadd + 3] > -1) {
					// T
					sl[k].at = -Amat[the_original_order_of_values[icompression[iadd + 3]]].aij;
					sl[k].iT = Amat[the_original_order_of_values[icompression[iadd + 3]]].j - 1;
				}
				if (icompression[iadd + 4] > -1) {
					// S
					sl[k].as = -Amat[the_original_order_of_values[icompression[iadd + 4]]].aij;
					sl[k].iS = Amat[the_original_order_of_values[icompression[iadd + 4]]].j - 1;
				}
				if (icompression[iadd + 5] > -1) {
					// W
					sl[k].aw = -Amat[the_original_order_of_values[icompression[iadd + 5]]].aij;
					sl[k].iW = Amat[the_original_order_of_values[icompression[iadd + 5]]].j - 1;
				}
				if (icompression[iadd + 6] > -1) {
					// B
					sl[k].ab = -Amat[the_original_order_of_values[icompression[iadd + 6]]].aij;
					sl[k].iB = Amat[the_original_order_of_values[icompression[iadd + 6]]].j - 1;
				}

				//if ((k == 6867418)||(k==68675507)) {
					//printf("ap=%e aw=%e ae=%e as=%e an=%e ab=%e at=%e \n", sl[k].ap, sl[k].aw, sl[k].ae, sl[k].as, sl[k].an, sl[k].ab, sl[k].at);
					//getchar();
				//}
			}

			if (icompression != NULL) free(icompression);
			icompression = NULL;
			
			if (rcompressionb != NULL) free(rcompressionb);
			rcompressionb = NULL;

			

		}

		if (the_original_order_of_values != NULL) {
			free(the_original_order_of_values);
			the_original_order_of_values = NULL;
		}
		if (the_original_order_of_values_reverse != NULL) {
			free(the_original_order_of_values_reverse);
			the_original_order_of_values_reverse = NULL;
		}

		/*
		for (integer i1 = 0; i1 < maxbound; i1++) {
			slb[i1].iI = -1;
			slb[i1].ai = 0.0;
			slb[i1].aw = 0.0;
		}
		// Если это раскоментировать то res_sum надо извлекать из нутра мультигрида.
		*/

		
		// освобождение памяти.
		if (Amat != NULL) {
			//delete[] Amat;
			free(Amat);
			Amat = NULL;
		}

		res_sum = 0.0;
		for (integer i1 = 0; i1<maxelm; i1++) {
			// внутренность матрицы.
			doublereal buf = 0.0;
			buf = (sl[i1].ap*dX0[sl[i1].iP] - dV[sl[i1].iP]);
			if ((sl[i1].iB>-1) && (fabs(sl[i1].ab) > nonzeroEPS)) buf -= sl[i1].ab*dX0[sl[i1].iB];
			if ((sl[i1].iE>-1) && (fabs(sl[i1].ae) > nonzeroEPS)) buf -= sl[i1].ae*dX0[sl[i1].iE];
			if ((sl[i1].iN>-1) && (fabs(sl[i1].an) > nonzeroEPS)) buf -= sl[i1].an*dX0[sl[i1].iN];
			if ((sl[i1].iS>-1) && (fabs(sl[i1].as) > nonzeroEPS)) buf -= sl[i1].as*dX0[sl[i1].iS];
			if ((sl[i1].iT>-1) && (fabs(sl[i1].at) > nonzeroEPS)) buf -= sl[i1].at*dX0[sl[i1].iT];
			if ((sl[i1].iW>-1) && (fabs(sl[i1].aw) > nonzeroEPS)) buf -= sl[i1].aw*dX0[sl[i1].iW];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB2>-1) && (fabs(sl[i1].ab2) > nonzeroEPS)) buf -= sl[i1].ab2*dX0[sl[i1].iB2];
			if ((sl[i1].iE2>-1) && (fabs(sl[i1].ae2) > nonzeroEPS)) buf -= sl[i1].ae2*dX0[sl[i1].iE2];
			if ((sl[i1].iN2>-1) && (fabs(sl[i1].an2) > nonzeroEPS)) buf -= sl[i1].an2*dX0[sl[i1].iN2];
			if ((sl[i1].iS2>-1) && (fabs(sl[i1].as2) > nonzeroEPS)) buf -= sl[i1].as2*dX0[sl[i1].iS2];
			if ((sl[i1].iT2>-1) && (fabs(sl[i1].at2) > nonzeroEPS)) buf -= sl[i1].at2*dX0[sl[i1].iT2];
			if ((sl[i1].iW2>-1) && (fabs(sl[i1].aw2) > nonzeroEPS)) buf -= sl[i1].aw2*dX0[sl[i1].iW2];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB3>-1) && (fabs(sl[i1].ab3) > nonzeroEPS)) buf -= sl[i1].ab3*dX0[sl[i1].iB3];
			if ((sl[i1].iE3>-1) && (fabs(sl[i1].ae3) > nonzeroEPS)) buf -= sl[i1].ae3*dX0[sl[i1].iE3];
			if ((sl[i1].iN3>-1) && (fabs(sl[i1].an3) > nonzeroEPS)) buf -= sl[i1].an3*dX0[sl[i1].iN3];
			if ((sl[i1].iS3>-1) && (fabs(sl[i1].as3) > nonzeroEPS)) buf -= sl[i1].as3*dX0[sl[i1].iS3];
			if ((sl[i1].iT3>-1) && (fabs(sl[i1].at3) > nonzeroEPS)) buf -= sl[i1].at3*dX0[sl[i1].iT3];
			if ((sl[i1].iW3>-1) && (fabs(sl[i1].aw3) > nonzeroEPS)) buf -= sl[i1].aw3*dX0[sl[i1].iW3];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB4>-1) && (fabs(sl[i1].ab4) > nonzeroEPS)) buf -= sl[i1].ab4*dX0[sl[i1].iB4];
			if ((sl[i1].iE4>-1) && (fabs(sl[i1].ae4) > nonzeroEPS)) buf -= sl[i1].ae4*dX0[sl[i1].iE4];
			if ((sl[i1].iN4>-1) && (fabs(sl[i1].an4) > nonzeroEPS)) buf -= sl[i1].an4*dX0[sl[i1].iN4];
			if ((sl[i1].iS4>-1) && (fabs(sl[i1].as4) > nonzeroEPS)) buf -= sl[i1].as4*dX0[sl[i1].iS4];
			if ((sl[i1].iT4>-1) && (fabs(sl[i1].at4) > nonzeroEPS)) buf -= sl[i1].at4*dX0[sl[i1].iT4];
			if ((sl[i1].iW4>-1) && (fabs(sl[i1].aw4) > nonzeroEPS)) buf -= sl[i1].aw4*dX0[sl[i1].iW4];

			buf *= buf;
			res_sum += buf;
		}
		for (integer i1 = 0; i1<maxbound; i1++) {
			// граничные узлы.
			doublereal buf = 0.0;
			buf = slb[i1].aw*dX0[slb[i1].iW] - dV[slb[i1].iW];
			if ((slb[i1].iI>-1) && (fabs(slb[i1].ai) > nonzeroEPS)) buf -= slb[i1].ai*dX0[slb[i1].iI];
			buf *= buf;
			res_sum += buf;
		}
		res_sum = sqrt(res_sum);
		printf("output diagnostic residual =%e\n", res_sum);
		//printf("residual finish=%1.4e\n",res_sum);
		//getchar();
		if (bsolid_static_only) {
			// используется только для теплопередачи в твёрдом теле для ускорения
			// решения задачи - защита от рестарта.
			finish_residual = res_sum; // значение невязки решённой задачи.
		}

	}

	/*doublerealT fsum1 = 0.0, fsum2 = 0.0;

	// внутренние контрольные объёмы.
	for (integer i = 0; i<maxelm; i++) {
		// числитель
		doublerealT sE, sW, sN, sS, sT, sB;
		if (sl[i].iE>-1) sE = sl[i].ae*dX0[sl[i].iE]; else sE = 0.0;
		if (sl[i].iW>-1) sW = sl[i].aw*dX0[sl[i].iW]; else sW = 0.0;
		if (sl[i].iN>-1) sN = sl[i].an*dX0[sl[i].iN]; else sN = 0.0;
		if (sl[i].iS>-1) sS = sl[i].as*dX0[sl[i].iS]; else sS = 0.0;
		if (sl[i].iT>-1) sT = sl[i].at*dX0[sl[i].iT]; else sT = 0.0;
		if (sl[i].iB>-1) sB = sl[i].ab*dX0[sl[i].iB]; else sB = 0.0;

		doublerealT sE2, sW2, sN2, sS2, sT2, sB2;
		if (sl[i].iE2>-1) sE2 = sl[i].ae2*dX0[sl[i].iE2]; else sE2 = 0.0;
		if (sl[i].iW2>-1) sW2 = sl[i].aw2*dX0[sl[i].iW2]; else sW2 = 0.0;
		if (sl[i].iN2>-1) sN2 = sl[i].an2*dX0[sl[i].iN2]; else sN2 = 0.0;
		if (sl[i].iS2>-1) sS2 = sl[i].as2*dX0[sl[i].iS2]; else sS2 = 0.0;
		if (sl[i].iT2>-1) sT2 = sl[i].at2*dX0[sl[i].iT2]; else sT2 = 0.0;
		if (sl[i].iB2>-1) sB2 = sl[i].ab2*dX0[sl[i].iB2]; else sB2 = 0.0;

		doublerealT sE3, sW3, sN3, sS3, sT3, sB3;
		if (sl[i].iE3>-1) sE3 = sl[i].ae3*dX0[sl[i].iE3]; else sE3 = 0.0;
		if (sl[i].iW3>-1) sW3 = sl[i].aw3*dX0[sl[i].iW3]; else sW3 = 0.0;
		if (sl[i].iN3>-1) sN3 = sl[i].an3*dX0[sl[i].iN3]; else sN3 = 0.0;
		if (sl[i].iS3>-1) sS3 = sl[i].as3*dX0[sl[i].iS3]; else sS3 = 0.0;
		if (sl[i].iT3>-1) sT3 = sl[i].at3*dX0[sl[i].iT3]; else sT3 = 0.0;
		if (sl[i].iB3>-1) sB3 = sl[i].ab3*dX0[sl[i].iB3]; else sB3 = 0.0;

		doublerealT sE4, sW4, sN4, sS4, sT4, sB4;
		if (sl[i].iE4>-1) sE4 = sl[i].ae4*dX0[sl[i].iE4]; else sE4 = 0.0;
		if (sl[i].iW4>-1) sW4 = sl[i].aw4*dX0[sl[i].iW4]; else sW4 = 0.0;
		if (sl[i].iN4>-1) sN4 = sl[i].an4*dX0[sl[i].iN4]; else sN4 = 0.0;
		if (sl[i].iS4>-1) sS4 = sl[i].as4*dX0[sl[i].iS4]; else sS4 = 0.0;
		if (sl[i].iT4>-1) sT4 = sl[i].at4*dX0[sl[i].iT4]; else sT4 = 0.0;
		if (sl[i].iB4>-1) sB4 = sl[i].ab4*dX0[sl[i].iB4]; else sB4 = 0.0;

		fsum1 += fabs(sE + sW + sN + sS + sT + sB + sE2 + sW2 + sN2 + sS2 + sT2 + sB2 + sE3 + sW3 + sN3 + sS3 + sT3 + sB3 + sE4 + sW4 + sN4 + sS4 + sT4 + sB4 +sl[i].b - sl[i].ap*dX0[sl[i].iP]);
		fsum2 += fabs(sl[i].ap*dX0[sl[i].iP]); // знаменатель.
	}//ok
	*/

	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif
	///getchar();
} // my_agr_amg_loc_memory_old


// Здесь содержится обвязка вызывающая РУМБА v0_14 решатель.
// локальное выдление памяти :всё внутри, многократные alloc и free.
void my_agr_amg_loc_memory(equation3D* &sl, equation3D_bon* &slb,
	integer maxelm, integer maxbound,
	doublereal *dV, doublereal* &dX0,
	doublereal alpharelax, integer iVar, bool bLRfree, QuickMemVorst& m,
	doublereal &theta82, doublereal &theta83, doublereal &magic82,
	doublereal &magic83, doublereal &ret74, BLOCK* b, integer lb,
	integer* &ifrontregulationgl, integer* &ibackregulationgl,
	SOURCE* &s_loc, integer &ls, integer inumber_iteration_SIMPLE)
{
#ifdef _OPENMP
	int i_my_num_core_parallelesation = omp_get_num_threads();
	omp_set_num_threads(8); // оптимально 8 потоков, 10 потоков уже проигрыш по времени.
#else
	int i_my_num_core_parallelesation = 1;
#endif

	// Замер времени.
	unsigned int calculation_main_start_time; // начало счёта мс.
	unsigned int calculation_main_end_time; // окончание счёта мс.

	calculation_main_start_time = clock(); // момент начала счёта.


	// режим экономии оперативной памяти.
	bool bmemory_savings = true; // true работает только с counting Sort.
	switch (my_amg_manager.imySortAlgorithm) {
	case COUNTING_SORT_ALG:
		bmemory_savings = true;
		break;
	case QUICK_SORT_ALG:
		bmemory_savings = false;
		break;
	case HEAP_SORT_ALG:
		bmemory_savings = false;
		break;
	case TIM_PETERSON_SORT_ALG:
		bmemory_savings = false;
		break;
	default:
		bmemory_savings = true;
		break;
	}
	if ((iVar == VX) || (iVar == VY) || (iVar == VZ)||(iVar == PAM)||(iVar==TEMP)||
		(iVar== NUSHA)||(iVar== TURBULENT_KINETIK_ENERGY)||(iVar== TURBULENT_SPECIFIC_DISSIPATION_RATE_OMEGA) ||
		(iVar == TURBULENT_KINETIK_ENERGY_STD_K_EPS) || (iVar == TURBULENT_DISSIPATION_RATE_EPSILON_STD_K_EPS)) {
		// 4.05.2019 Обнаружено что гидродинамические невязки неправильно
		// отображаются, портятся искажаются при включенной опции 
		// bmemory_savings==true. После ее выключения невязки стали отображаться 
		// корректно. Причина аномалии пока неясна.
		bmemory_savings = false; // Должно быть false для всех переменных.
	}


	// На случай если память не была выделена.
	if (dX0 == NULL) {
		dX0 = new doublereal[maxelm + maxbound];
		if (dX0 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for dX0 my_agregat_amg.cpp...\n");
			printf("Please any key to exit...\n");
			exit(1);
		}
		for (integer i = 0; i < maxelm + maxbound; i++) {
			dX0[i] = 0.0;
		}
		printf("allocation memory for dX0... Ok. dX0 initialization 0.0 value.\n");
	}


	doublereal tmaxloc = -272.15e6;
	for (integer i = 0; i < maxelm; i++) tmaxloc = fmax(tmaxloc, dX0[i]);
	if (iVar == TEMP) {
		printf("Intermediate maximum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tmaxloc);
	}
	doublereal tminloc = 1.0e7;
	for (integer i = 0; i < maxelm; i++) tminloc = fmin(tminloc, dX0[i]);
	if (iVar == TEMP) {
		printf("Intermediate minimum temperature in default interior\n");
		printf("is equal %e degrees Celsius.\n", tminloc);
	}


	const doublereal nonzeroEPS = 1.0e-37; // для отделения вещественного нуля
	doublereal res_sum = 0.0;
	res_sum = 0.0;
	for (integer i = 0; i < maxelm; i++) {
		// внутренность матрицы.
		doublereal buf = 0.0;
		buf = (sl[i].ap*dX0[sl[i].iP] - dV[sl[i].iP]);
		if ((sl[i].iB > -1) && (fabs(sl[i].ab) > nonzeroEPS)) buf -= sl[i].ab*dX0[sl[i].iB];
		if ((sl[i].iE > -1) && (fabs(sl[i].ae) > nonzeroEPS)) buf -= sl[i].ae*dX0[sl[i].iE];
		if ((sl[i].iN > -1) && (fabs(sl[i].an) > nonzeroEPS)) buf -= sl[i].an*dX0[sl[i].iN];
		if ((sl[i].iS > -1) && (fabs(sl[i].as) > nonzeroEPS)) buf -= sl[i].as*dX0[sl[i].iS];
		if ((sl[i].iT > -1) && (fabs(sl[i].at) > nonzeroEPS)) buf -= sl[i].at*dX0[sl[i].iT];
		if ((sl[i].iW > -1) && (fabs(sl[i].aw) > nonzeroEPS)) buf -= sl[i].aw*dX0[sl[i].iW];
		// Дополнение на АЛИС сетке.
		if ((sl[i].iB2 > -1) && (fabs(sl[i].ab2) > nonzeroEPS)) buf -= sl[i].ab2*dX0[sl[i].iB2];
		if ((sl[i].iE2 > -1) && (fabs(sl[i].ae2) > nonzeroEPS)) buf -= sl[i].ae2*dX0[sl[i].iE2];
		if ((sl[i].iN2 > -1) && (fabs(sl[i].an2) > nonzeroEPS)) buf -= sl[i].an2*dX0[sl[i].iN2];
		if ((sl[i].iS2 > -1) && (fabs(sl[i].as2) > nonzeroEPS)) buf -= sl[i].as2*dX0[sl[i].iS2];
		if ((sl[i].iT2 > -1) && (fabs(sl[i].at2) > nonzeroEPS)) buf -= sl[i].at2*dX0[sl[i].iT2];
		if ((sl[i].iW2 > -1) && (fabs(sl[i].aw2) > nonzeroEPS)) buf -= sl[i].aw2*dX0[sl[i].iW2];

		if ((sl[i].iB3 > -1) && (fabs(sl[i].ab3) > nonzeroEPS)) buf -= sl[i].ab3*dX0[sl[i].iB3];
		if ((sl[i].iE3 > -1) && (fabs(sl[i].ae3) > nonzeroEPS)) buf -= sl[i].ae3*dX0[sl[i].iE3];
		if ((sl[i].iN3 > -1) && (fabs(sl[i].an3) > nonzeroEPS)) buf -= sl[i].an3*dX0[sl[i].iN3];
		if ((sl[i].iS3 > -1) && (fabs(sl[i].as3) > nonzeroEPS)) buf -= sl[i].as3*dX0[sl[i].iS3];
		if ((sl[i].iT3 > -1) && (fabs(sl[i].at3) > nonzeroEPS)) buf -= sl[i].at3*dX0[sl[i].iT3];
		if ((sl[i].iW3 > -1) && (fabs(sl[i].aw3) > nonzeroEPS)) buf -= sl[i].aw3*dX0[sl[i].iW3];

		if ((sl[i].iB4 > -1) && (fabs(sl[i].ab4) > nonzeroEPS)) buf -= sl[i].ab4*dX0[sl[i].iB4];
		if ((sl[i].iE4 > -1) && (fabs(sl[i].ae4) > nonzeroEPS)) buf -= sl[i].ae4*dX0[sl[i].iE4];
		if ((sl[i].iN4 > -1) && (fabs(sl[i].an4) > nonzeroEPS)) buf -= sl[i].an4*dX0[sl[i].iN4];
		if ((sl[i].iS4 > -1) && (fabs(sl[i].as4) > nonzeroEPS)) buf -= sl[i].as4*dX0[sl[i].iS4];
		if ((sl[i].iT4 > -1) && (fabs(sl[i].at4) > nonzeroEPS)) buf -= sl[i].at4*dX0[sl[i].iT4];
		if ((sl[i].iW4 > -1) && (fabs(sl[i].aw4) > nonzeroEPS)) buf -= sl[i].aw4*dX0[sl[i].iW4];

		buf *= buf;
		res_sum += buf;
	}
	for (integer i = 0; i < maxbound; i++) {
		// граничные узлы.
		doublereal buf = 0.0;
		buf = slb[i].aw*dX0[slb[i].iW] - dV[slb[i].iW];
		if ((slb[i].iI > -1) && (fabs(slb[i].ai) > nonzeroEPS)) buf -= slb[i].ai*dX0[slb[i].iI];
		buf *= buf;
		res_sum += buf;
	}
	res_sum = sqrt(res_sum);
	printf("input diagnostic residual =%e\n", res_sum);

	if ((iVar == VX) || (iVar == VY) || (iVar == VZ)) {
		if (res_sum > 20.0) {
			printf("Speed diagnostic problem analysys....\n");
		}
	}
	if ((iVar == NUSHA) || (iVar == TURBULENT_KINETIK_ENERGY) || (iVar == TURBULENT_SPECIFIC_DISSIPATION_RATE_OMEGA) ||
		(iVar == TURBULENT_KINETIK_ENERGY_STD_K_EPS) || (iVar == TURBULENT_DISSIPATION_RATE_EPSILON_STD_K_EPS)) {
		if (res_sum > 20.0) {
			printf("Turbulent equations diagnostic problem analysys....\n");
		}
	}
	//printf("residual start=%1.4e\n",res_sum);
	//getchar();

	// результаты тестирования
	// задача, начальная невязка , значение евклидовой нормы невязки при которой решение является полученным.
	// tgf01 5.4357e-1 1.0209e-11
	// CGHV1J с метализацией 3.3667e-1 5.0712e-12
	// tgf02 7.6872e-11 1.434e-11
	// tgf05 1.0871e+0  2.2895e-11
	// резистор на 1мм поликоре 5.0e-2 4.9174e-14
	//Diamond ZUb 4 4.0016e-1  4.64444e-11
	// DiamondZUB 4.0016e-1 1.1443e-8
	// NXP100 4.3399e+0  7.8347e-11 (для решения хватило 8Гб ОЗУ.)

	doublereal res_sum_previos = 1.05*finish_residual;
	if ((adiabatic_vs_heat_transfer_coeff > 0) || (breakRUMBAcalc_for_nonlinear_boundary_condition)) {
		// Надо пересобирать матрицу и запускать всё по новой т.к. задача 
		// существенно нелинейна.

		// Работает задача Ньютона Рихмана или
		// Стефана Больцмана или миксовая.
		res_sum_previos = 1.0e-12;
	}

	//if (res_sum>1.0E-10) 
	if (res_sum > res_sum_previos) // защита от повторного холостого запуска экономит время конечного пользователя.
	{

		//yes_print_amg=false;
		//yes_print_amg = false;





		integer ierr = 0;
		doublereal eps = 1.0e-12;

		ierr = 0; // изначальное состояние безошибочное.
				  // Порог точности решения СЛАУ. Значение 1.0E-12 достаточно что проверено в ANSYS icepak.
		eps = 1.0e-12; // рекомендуемое значение которого достаточно. 

					   // Требования к оперативной памяти.
					   /*     VECTOR         NEEDED LENGTH (GUESS) */
					   /*       Amat               3*NNA + 5*NNU */
					   /*       JA              3*NNA + 5*NNU */
					   /*       IA              2.2*NNU */
					   /*       U               2.2*NNU */
					   /*       F               2.2*NNU */
					   /*       IG              5.4*NNU */


		integer nna = 0; // количество ненулевых элементов в матрице СЛАУ.


						 // подсчёт числа ненулевых элементов в матрице.
		nna = 0;
		for (integer i = 0; i < maxelm; i++) {
			// внутренность матрицы.
			if ((sl[i].iB > -1) && (fabs(sl[i].ab) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE > -1) && (fabs(sl[i].ae) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN > -1) && (fabs(sl[i].an) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS > -1) && (fabs(sl[i].as) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT > -1) && (fabs(sl[i].at) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW > -1) && (fabs(sl[i].aw) > nonzeroEPS)) (nna)++;
			if ((sl[i].iP > -1) && (fabs(sl[i].ap) > nonzeroEPS)) (nna)++;

			// Дополнение на АЛИС сетке:
			if ((sl[i].iB2 > -1) && (fabs(sl[i].ab2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE2 > -1) && (fabs(sl[i].ae2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN2 > -1) && (fabs(sl[i].an2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS2 > -1) && (fabs(sl[i].as2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT2 > -1) && (fabs(sl[i].at2) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW2 > -1) && (fabs(sl[i].aw2) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB3 > -1) && (fabs(sl[i].ab3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE3 > -1) && (fabs(sl[i].ae3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN3 > -1) && (fabs(sl[i].an3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS3 > -1) && (fabs(sl[i].as3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT3 > -1) && (fabs(sl[i].at3) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW3 > -1) && (fabs(sl[i].aw3) > nonzeroEPS)) (nna)++;

			if ((sl[i].iB4 > -1) && (fabs(sl[i].ab4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iE4 > -1) && (fabs(sl[i].ae4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iN4 > -1) && (fabs(sl[i].an4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iS4 > -1) && (fabs(sl[i].as4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iT4 > -1) && (fabs(sl[i].at4) > nonzeroEPS)) (nna)++;
			if ((sl[i].iW4 > -1) && (fabs(sl[i].aw4) > nonzeroEPS)) (nna)++;

		}
		for (integer i = 0; i < maxbound; i++) {
			// граничные узлы.
			if ((slb[i].iW > -1) && (fabs(slb[i].aw) > nonzeroEPS)) (nna)++;
			if ((slb[i].iI > -1) && (fabs(slb[i].ai) > nonzeroEPS)) (nna)++;
		}

		integer nnu = 0; // число неизвестных.
		nnu = maxelm + maxbound;

		/*
		// Рекомендуемые по умолчанию параметры.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=3*(nna)+5*(nnu);
		integer ndia=0;
		ndia=(integer)(2.2*(nnu));
		integer ndja=0;
		ndja=3*(nna)+5*(nnu);
		integer ndu=0;
		ndu=(integer)(2.2*(nnu));
		integer ndf=0;
		ndf=(integer)(2.2*(nnu));
		integer ndig=0;
		ndig=(integer)(5.4*(nnu));
		*/

		/*
		// в двое больше памяти чем рекомендовано.
		integer nda=0; // память под вектор значений матрицы слау.
		nda=6*(nna)+10*(nnu);
		integer ndia=0;
		ndia=(integer)(4.4*(nnu));
		integer ndja=0;
		ndja=6*(nna)+10*(nnu);
		integer ndu=0;
		ndu=(integer)(4.4*(nnu));
		integer ndf=0;
		ndf=(integer)(4.4*(nnu));
		integer ndig=0;
		ndig=(integer)(10.8*(nnu));
		*/

		// данная константа работоспособна вплоть до размерностей сетки равных 34млн 463тысячи 250узлов.
		//doublereal rsize=1.51; // 1048416
		// Вынужденные течения достаточно 2.5. 
		// на задаче Концевого Ю.А. Электростатика со столбиком в случае сетки со сгущением достаточно 2.0.


		Ak2 Amat;
		Amat.i = NULL;
		Amat.j = NULL;
		Amat.aij = NULL;
		Amat.abs_aij = NULL;
		//Ak1* R = NULL;
		//Ak1* P = NULL;
		//Ak1* Atemp = NULL;
		//Ak1* Atemp2 = NULL;
		doublereal* rthdsd_amg = NULL;
		doublereal* result_amg = NULL;
		// 18 августа 2016
		// граничные узлы требуют особой обработки.
		// true - граничный узел, false - внутренний.
		bool* bamg_bound = NULL;




		/*     CLASS 3 - PARAMETERS: */

		/*     LEVELX   -   MAXIMUM NUMBER OF MG-LEVELS TO BE CREATED (>=1). */

		/*     IFIRST   -   PARAMETER FOR FIRST APPROXIMATION. */

		/*                  1ST DIGIT OF IFIRST: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF IFIRST  --  ITYPU: */
		/*                    =0: NO SETTING OF FIRST APPROXIMATION, */
		/*                    =1: FIRST APPROXIMATION CONSTANT TO ZERO, */
		/*                    =2: FIRST APPROXIMATION CONSTANT TO ONE, */
		/*                    =3: FIRST APPROXIMATION IS RANDOM FUNCTION WITH */
		/*                        THE CONCRETE RANDOM SEQUENCE BEING DETERMINED */
		/*                        BY THE FOLLWING DIGITS. */

		/*                  REST OF IFIRST  --  RNDU: */
		/*                    DETERMINES THE CONCRETE RANDOM SEQUENCE USED IN */
		/*                    THE CASE ITYPU=3. (IFIRST=13 IS EQUIVALENT TO */
		/*                    IFIRST=1372815) */

		/*     NCYC     -   INTEGER PARAMETER DESCRIBING THE TYPE OF CYCLE TO BE */
		/*                  USED AND THE NUMBER OF CYCLES TO BE PERFORMED. */

		/*                  1ST DIGIT OF NCYC  --  IGAM: */
		/*                    =1: V -CYCLE, */
		/*                    =2: V*-CYCLE, */
		/*                    =3: F -CYCLE, */
		/*                    =4: W -CYCLE. */
		/*                  IF NCYC IS NEGATIV, THEN THE APPROXIMATION OF THE */
		/*                  PROBLEM ON THE SECOND FINEST GRID IS COMPUTED BY */
		/*                  IGAM V-CYCLES ON THAT PARTICULAR GRID. */

		/*                  2ND DIGIT OF NCYC  --  ICGR: */
		/*                    =0: NO CONJUGATE GRADIENT, */
		/*                    =1: CONJUGATE GRADIENT (ONLY FIRST STEP OF CG), */
		/*                    =2: CONJUGATE GRADIENT (FULL CG). */

		/*                  3RD DIGIT OF NCYC  --  ICONV: */
		/*                    CONVERGENCE CRITERION FOR THE USER-DEFINED PROBLEM */
		/*                    (FINEST GRID): */
		/*                    =1: PERFORM Amat FIXED NUMBER OF CYCLES AS GIVEN BY */
		/*                        NCYCLE (SEE BELOW) */
		/*                    =2: STOP, IF  ||RES|| < EPS */
		/*                    =3: STOP, IF  ||RES|| < EPS * |F| */
		/*                    =4: STOP, IF  ||RES|| < EPS * |U| * |DIAG| */
		/*                    WITH ||RES|| = L2-NORM OF RESIDUAL, */
		/*                           EPS     (SEE INPUT PARAMETER EPS) */
		/*                           |F|   = SUPREMUM NORM OF RIGHT HAND SIDE */
		/*                           |U|   = SUPREMUM NORM OF SOLUTION */
		/*                         |DIAG|  = MAXIMAL DIAGONAL ENTRY IN MATRIX L */
		/*                    NOTE THAT IN ANY CASE THE SOLUTION PROCESS STOPS */
		/*                    AFTER AT MOST NCYCLE CYCLES. */

		/*                  REST OF NCYC  --  NCYCLE: */
		/*                    MAXIMAL NUMBER OF CYCLES TO BE PERFORMED (>0) OR */
		/*                    NCYCLE=0: NO CYCLING. */

		/*     EPS      -   CONVERGENCE CRITERION FOR SOLUTION PROCESS: (SEE */
		/*                  PARAMETER NCYC). NOTE THAT NO MORE THAN NCYCLE CYCLES */
		/*                  ARE PERFORMED, REGARDLESS OF EPS. */

		/*     MADAPT   -   INTEGER VALUE SPECIFYING THE CHOICE OF COARSEST */
		/*                  GRID IN CYCLING: */

		/*                  1ST DIGIT OF MADAPT  --  MSEL: */
		/*                    =1: IN CYCLING, ALL GRIDS CONSTRUCTED IN THE SETUP */
		/*                        PHASE ARE USED WITHOUT CHECK. */
		/*                    =2: THE NUMBER OF GRIDS IS AUTOMATICALLY REDUCED */
		/*                        IF THE CONVERGENCE FACTOR ON THE COARSER GRIDS */
		/*                        IS FOUND TO BE LARGER THAN Amat GIVEN VALUE FAC */
		/*                        (SEE BELOW). */

		/*                  REST OF MADAPT  --  FAC */
		/*                        THE REST OF MADAPT DEFINES THE FRACTIONAL PART */
		/*                        OF Amat REAL NUMBER FAC BETWEEN 0.1 AND 0.99, E.G. */
		/*                        MADAPT=258 MEANS MSEL=2 AND FAC=0.58. IF MADAPT */
		/*                        CONSISTS OF ONLY ONE DIGIT, FAC IS SET TO 0.7 */
		/*                        BY DEFAULT. */


		/*     NRD      -   PARAMETER DESCRIBING RELAXATION (DOWNWARDS): */

		/*                  1ST DIGIT OF NRD: NOT USED; HAS TO BE NON-ZERO. */

		/*                  2ND DIGIT OF NRD  --  NRDX: */
		/*                    ACTUAL NUMBER OF SMOOTHING STEPS TO BE PERFORMED */
		/*                    THE TYPE OF WHICH IS GIVEN BY THE FOLLOWING DIGITS */

		/*                  FOLLOWING DIGITS  --  ARRAY NRDTYP: */
		/*                    =1: RELAXATION OVER THE F-POINTS ONLY */
		/*                    =2: FULL GS SWEEP */
		/*                    =3: RELAXATION OVER THE C-POINTS ONLY */
		/*                    =4: FULL MORE COLOR SWEEP, HIGHEST COLOR FIRST */

		/*     NSOLCO   -   PARAMETER CONTROLLING THE SOLUTION ON COARSEST GRID: */

		/*                  1ST DIGIT  --  NSC: */
		/*                    =1: GAUSS-SEIDEL METHOD */
		/*                    =2: DIRECT SOLVER (YALE SMP) */

		/*                  REST OF NSOLCO  --  NRCX: (ONLY IF NSC=1) */
		/*                  NUMBER OF GS SWEEPS ON COARSEST GRID (>=0). */
		/*                  IF NRCX=0, THEN AS MANY GS SWEEPS ARE PERFORMED */
		/*                  AS ARE NEEDED TO REDUCE THE RESIDUAL BY TWO ORDERS */
		/*                  OF MAGNITUDE. (MAXIMAL 100 RELAXATION SWEEPS) */

		/*     NRU      -   PARAMETER FOR RELAXATION (UPWARDS), ANALOGOUS TO NRD. */

		/*         -------------------------------------------------------------- */

		/*     CLASS 4 - PARAMETERS: */

		/*     ECG1,ECG2-   REAL PARAMETERS AFFECTING THE CREATION OF COARSER */
		/*     EWT2     -   GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THESE PARAMETERS DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NWT      -   INTEGER PARAMETER AFFECTING THE CREATION OF COARSER */
		/*                  GRIDS AND/OR THE DEFINITION OF THE INTERPOLATION. */
		/*                  THE CHOICE OF THIS PARAMETER DEPENDS ON */
		/*                  THE ACTUAL AMG VERSION (SEE SUBROUTINE CRSNG) */

		/*     NTR      -   PARAMETER CONTROLLING COARSE-GRID OPERATOR TRUNCATION */
		/*                    =0: PAIRS OF ZEROES ARE REMOVED FROM COARSE GRID */
		/*                        OPERATORS */
		/*                    =1: NO COARSE-GRID OPERATOR TRUNCATION */



		/*     STANDARD CHOICES OF PARAMETERS (AS FAR AS MEANINGFUL): */

		/*          ISWTCH = 4 */
		/*          IOUT   = 12 */
		/*          IPRinteger = 10606 */

		/*          LEVELX = 25 */
		/*          IFIRST = 13 */
		/*          NCYC   = 10110 */
		/*          EPS    = 1.D-12 */
		/*          MADAPT = 27 */
		/*          NRD    = 1131 */
		/*          NSOLCO = 110 */
		/*          NRU    = 1131 */

		/*          ECG1   = 0. */
		/*          ECG2   = 0.25 */
		/*          EWT2   = 0.35 */
		/*          NWT    = 2 */
		/*          NTR    = 0 */



		// рекомедуемые параметры по дефолту.
		/*
		integer iswtch = 0;
		iswtch = 4;
		integer iout = 0;
		iout = 12;
		integer iprinteger = 0;
		iprinteger = 10606;
		integer levelx = 0;
		levelx = 25;
		integer ifirst = 0;
		// начальное приближение :
		// 0 - используется из вне.
		// 1 - нулевое.
		// 2 - единицы.
		// 3 - случайная последовательность.
		ifirst = 13;//13 по умолчанию.
		//ifirst=11; // нулевое начальное приближение.
		//ifirst=10; // вроде как начальное приближение берётся из dX0.
		// но 10 никоим образом не улучшает сходимость.
		integer ncyc = 0;
		ncyc = 10110;
		integer madapt = 0;
		madapt = 27;
		integer nrd = 0;
		nrd = 1131;
		integer nsolco = 0;
		nsolco = 110;
		integer nru = 0;
		nru = 1131;
		doublereal ecg1 = 0.0;
		ecg1 = 0.0;
		doublereal ecg2 = 0.0;
		ecg2 = 0.25;
		doublereal ewt2 = 0.0;
		ewt2 = 0.35;
		integer nwt = 0;
		nwt = 2;
		integer ntr = 0;
		ntr = 0;

		integer matrix = 0;
		//matrix=11; // symmetric SPD.
		matrix = 22;

		if ((iVar == PAM) && (bLRfree)) {
		//printf("work amg1r5\n");
		//getchar();
		// Симметричная положительно определённая матрица это такая матрица
		// которая возникает для поправки давления при решении вязких несжимаемых уравнений Навье-Стокса в
		// случае задач : каверна, тест Валь-Девиса. Для задач промышленного масштаба это всякие естественные
		// конвекции охлаждающие висящие в воздухе без контакта с теплоотводом греющиеся изделия.
		// Это особый специфический класс задач.
		matrix = 11;
		}
		*/
		// для прямой интерполляции с элементами непрямой можно выставить коэффициент 3 и освободить память из под 
		// исходной матрицы (для той структуры на которой была выполнена сборка матрицы изначально). 

		 // allocate memory 2 jan 2016.
		 // BSK Dmitrii 3.012  (2.892 для прямой интерполляции с элементами непрямой). 
		 // tgf series no metalization
		 // tgf2023-2_01 2.64 643mb
		 // tgf2023-2-02 2.58 988mb
		 // tgf2023-2-05 2.44 2022mb
		 // tgf2023-2-20 3.58 2967mb
		 // CGHV1J metalization 3.133 (2.84 для прямой интерполляции с элементами непрямой). 
		 // тор Докторович 2.89
		 // Концевой 3.05
		 // Концевой со столбиком 3.7М 2.97 (6.0 у amg1r5) 4110.6Мb.
		 // Вывод : максимальное значение 3.14 а значит значения 4 должно хватить с запасом У amg1r5 максимальное значение 9.0.
		 // Можно сказать что данный amg требует вдвое меньше памяти по сравнению с amg1r5.
		 // Была найдена статья в интернете которая подтверждала что константа памяти у amg1r5 равна 8.
		 // Также был найден ряд статей в которых подтверждается констата близкая к 3 для CAMG.
		 //Amat = new Ak1[(integer)(7 * nna) + 1]; // 6 // 45 // 4
		 // памяти надо много для 6 варианта интерполяции.
 // 9,35,35 28
		integer nsizeA = ((integer)(9 * nna) + 1);
		integer nsizePR = 35;

		if (bPhysics_PTBSH_memory == true) {
			// ПТБШ.
			//printf("bPhysics_PTBSH_memory==true\n");
			nsizeA = ((integer)(4 * nna) + 1);
			nsizePR = 13;
		}

		// с 26 октября 2016 мы передаём настройки из интерфейса AliceMesh_v0_39.
		// Т.к. есть трудносходящиеся задачи, то эти настройки должны помоч.
		// Истина в том что количество потребляемой оперативной памяти очень сильно зависит от особеностей
		// пользовательской геометрии (того что пользователь начертил в интерфейсе).
		// Иногда достаточно 4 размеров матрицы, а иногда нехватает и 12. Каждая новая задача должна настраиваться 
		// в идеале индивидуально, если пользователь хочет выжить максимум из своего оборудования.
		nsizeA = ((integer)(my_amg_manager.memory_size * nna) + 1);
		if (my_amg_manager.iprint_log == 1) {
#if doubleintprecision == 1
			printf("memory size const is=%lld\n", my_amg_manager.memory_size);
#else
			printf("memory size const is=%d\n", my_amg_manager.memory_size);
#endif

		}
		nsizePR = 35;
		if (bonly_solid_calculation) {
			// 31 октября 2016.
			// По моим замерам с надёжным запасом в 30% для всех твёрдотельных 
			// задач должно хватить значения 12.
			nsizePR = 12;
		}

		MEMORYSTATUSEX statex;
		statex.dwLength = sizeof(statex);
		GlobalMemoryStatusEx(&statex);
		char divisor[2] = "M";
		if (my_amg_manager.iprint_log == 1) {
			printf("physical memory is %lld total  %sbytes \n", statex.ullTotalPhys / (1024*1024), divisor);
			printf("%ld %% of memory is in use.\n", statex.dwMemoryLoad);
			printf("required %zu %sbytes\n", ((nsizeA / (1024*1024)) * sizeof(Ak1) + 2 * (((nsizePR / (1024*1024))* nnu) + 1) * sizeof(Ak1)),divisor);
			//system("pause");
		}

		char c1[22] = "my_agr_amg_loc_memory";
		char c2[5] = "Amat";
		Amat.i = (integer*)malloc(nsizeA * sizeof(integer));  // 9
		handle_error<integer>(Amat.i, c2, c1, (nsizeA));
		Amat.j = (integer*)malloc(nsizeA * sizeof(integer));  // 9
		handle_error<integer>(Amat.j, c2, c1, (nsizeA));
		Amat.aij = (doublereal*)malloc(nsizeA * sizeof(doublereal));  // 9
		handle_error<doublereal>(Amat.aij, c2, c1, (nsizeA));
		Amat.abs_aij = (doublereal*)malloc(nsizeA * sizeof(doublereal));  // 9
		handle_error<doublereal>(Amat.abs_aij, c2, c1, (nsizeA));


		char c0[11] = "bamg_bound";
		bamg_bound = new bool[((nsizePR * nnu) + 1)];
		handle_error<bool>(bamg_bound, c0, c1, ((nsizePR * nnu) + 1));


		// real size 9.4 for resistor.
		// 
		/*
		Atemp = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for Atemp matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		// real size 9.4 for resistor.
		Atemp2 = new Ak1[(integer)(22 * nna) + 1]; // 3*nnz 2.4
		if (Atemp2 == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for Atemp2 matrix in my_agregat_amg.cpp algorithm...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/

		//result_amg = new doublereal[nnu + 1];
		result_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
		char c3[11] = "result_amg";
		handle_error<doublereal>(result_amg, c3, c1, (nnu + 1));


		//rthdsd_amg = new doublereal[nnu + 1];
		rthdsd_amg = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
		char c4[11] = "rthdsd_amg";
		handle_error<doublereal>(rthdsd_amg, c4, c1, (nnu + 1));



		// правая часть.
		/*
		for (integer i = 0; i < nnu; i++) {
		rthdsd_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		rthdsd_amg[i + 1] = dV[i];
		}
		}
		rthdsd_amg[0] = 0.0;
		*/
		/*
		// вектор решения.
		for (integer i = 0; i < nnu; i++) {
		result_amg[i] = 0.0;
		if (i<maxelm + maxbound) {
		// обязательно нужно проверить была ли выделена оперативная память.
		result_amg[i + 1] = dX0[i];
		}
		}
		result_amg[0] = 0.0;
		*/

		// см. equation3DtoCRS.

		integer ik = 0; // счётчик ненулевых элементов СЛАУ
		integer id = 1;

		//if (iVar == PAM) {
			//printf("alpharelax=%e\n", alpharelax);
		//	getchar();
		//}

		integer* icompression = NULL;
		doublereal* rcompressionb = NULL;
		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			icompression = (integer*)malloc((7 * maxelm + 1) * sizeof(integer)); // +1 запас.
			char c5[13] = "icompression";
			handle_error<integer>(icompression, c5, c1, (7 * maxelm + 1));
			for (integer i_1 = 0; i_1 < (7 * maxelm + 1); i_1++) {
				icompression[i_1] = -1;
			}
			rcompressionb = (doublereal*)malloc((maxelm + 1) * sizeof(doublereal)); // +1 запас.
			char c6[14] = "rcompressionb";
			handle_error<doublereal>(rcompressionb, c6, c1, (maxelm + 1));
			for (integer i_1 = 0; i_1 < (maxelm); i_1++) {
				rcompressionb[i_1] = sl[i_1].b;
			}
		}

		integer iscan1 = 0;
		//printf("alpharelax=%e\n", alpharelax);
		//getchar();
		// для внутренних узлов расчётной области:
		for (integer k = 0; k < maxelm; k++) {
			//printf("%e %e %e %e %e %e %e\n", sl[k].ap / alpharelax, -sl[k].ae, -sl[k].aw, -sl[k].an, -sl[k].as, -sl[k].at, -sl[k].ab);
			//system("pause");

			if (fabs(sl[k].ap) > nonzeroEPS) {
				Amat.aij[ik + id] = sl[k].ap / alpharelax;
				Amat.j[ik + id] = sl[k].iP + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				bamg_bound[Amat.i[ik + id]] = false;
				rthdsd_amg[sl[k].iP + 1] = dV[sl[k].iP];
				result_amg[sl[k].iP + 1] = dX0[sl[k].iP];
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iE > -1) && (fabs(sl[k].ae) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ae;
				Amat.j[ik + id] = sl[k].iE + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iN > -1) && (fabs(sl[k].an) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].an;
				Amat.j[ik + id] = sl[k].iN + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iT > -1) && (fabs(sl[k].at) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].at;
				Amat.j[ik + id] = sl[k].iT + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iS > -1) && (fabs(sl[k].as) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].as;
				Amat.j[ik + id] = sl[k].iS + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iW > -1) && (fabs(sl[k].aw) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].aw;
				Amat.j[ik + id] = sl[k].iW + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			if ((sl[k].iB > -1) && (fabs(sl[k].ab) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ab;
				Amat.j[ik + id] = sl[k].iB + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				if (icompression != NULL) {
					icompression[iscan1] = ik + id;
				}
				iscan1++;
				ik++;
			}
			else {
				iscan1++;
			}
			// icompression - применяется только для структурированной сетки.
			// Дополнение на АЛИС сетке:
			if ((sl[k].iE2 > -1) && (fabs(sl[k].ae2) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ae2;
				Amat.j[ik + id] = sl[k].iE2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN2 > -1) && (fabs(sl[k].an2) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].an2;
				Amat.j[ik + id] = sl[k].iN2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT2 > -1) && (fabs(sl[k].at2) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].at2;
				Amat.j[ik + id] = sl[k].iT2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS2 > -1) && (fabs(sl[k].as2) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].as2;
				Amat.j[ik + id] = sl[k].iS2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW2 > -1) && (fabs(sl[k].aw2) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].aw2;
				Amat.j[ik + id] = sl[k].iW2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB2 > -1) && (fabs(sl[k].ab2) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ab2;
				Amat.j[ik + id] = sl[k].iB2 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE3 > -1) && (fabs(sl[k].ae3) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ae3;
				Amat.j[ik + id] = sl[k].iE3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN3 > -1) && (fabs(sl[k].an3) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].an3;
				Amat.j[ik + id] = sl[k].iN3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT3 > -1) && (fabs(sl[k].at3) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].at3;
				Amat.j[ik + id] = sl[k].iT3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS3 > -1) && (fabs(sl[k].as3) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].as3;
				Amat.j[ik + id] = sl[k].iS3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW3 > -1) && (fabs(sl[k].aw3) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].aw3;
				Amat.j[ik + id] = sl[k].iW3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB3 > -1) && (fabs(sl[k].ab3) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ab3;
				Amat.j[ik + id] = sl[k].iB3 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}

			if ((sl[k].iE4 > -1) && (fabs(sl[k].ae4) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ae4;
				Amat.j[ik + id] = sl[k].iE4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iN4 > -1) && (fabs(sl[k].an4) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].an4;
				Amat.j[ik + id] = sl[k].iN4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iT4 > -1) && (fabs(sl[k].at4) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].at4;
				Amat.j[ik + id] = sl[k].iT4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iS4 > -1) && (fabs(sl[k].as4) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].as4;
				Amat.j[ik + id] = sl[k].iS4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iW4 > -1) && (fabs(sl[k].aw4) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].aw4;
				Amat.j[ik + id] = sl[k].iW4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}
			if ((sl[k].iB4 > -1) && (fabs(sl[k].ab4) > nonzeroEPS)) {
				Amat.aij[ik + id] = -sl[k].ab4;
				Amat.j[ik + id] = sl[k].iB4 + 1;
				Amat.i[ik + id] = sl[k].iP + 1;
				ik++;
			}

		}



		// для внутренних узлов расчётной области:
		for (integer k = 0; k < maxbound; k++) {
			if (fabs(slb[k].aw) > nonzeroEPS) {
				// val[ik]=slb[k].aw/alpharelax;
				Amat.aij[ik + id] = slb[k].aw; // релаксация для граничных узлов не применяется.
											/*if ((slb[k].iI>-1) && (fabs(slb[k].ai) > nonzeroEPS)) {
											// Внимание !!! было произведено тестирование : один вариант был с нижней релаксацией для граничных узлов,
											// а второй вариант был без нижней релаксации на граничных узлах. Было выяснено, что для сходимости
											// более благоприятен вариант без нижней релаксации на граничных узлах.
											// Данное изменение согласовано с функцией solve.

											val[ik]/=alpharelax; // Если условия Неймана то нижняя релаксация.
											}*/
				Amat.j[ik + id] = slb[k].iW + 1;
				Amat.i[ik + id] = slb[k].iW + 1; // dirichlet
				if (!((slb[k].iI > -1) && (fabs(slb[k].ai) > nonzeroEPS))) {
					// Dirichlet value.
					// Значения Дирихле мы сразу априорно помещаем в C nodes.
					//bamg_bound[Amat[ik + id].i] = true;
					// Это глупость. Наоборот все узлы Дирихле становятся С узлами сразу.
				}
				else {
					// Neiman.
					// Условия Неймана при построении C-F разбиения обрабатываем как обычно как внутренний узел.
					bamg_bound[Amat.i[ik + id]] = false;
				}
				rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				ik++;
			}
			if ((slb[k].iI > -1) && (fabs(slb[k].ai) > nonzeroEPS)) {
				Amat.aij[ik + id] = -slb[k].ai;
				Amat.j[ik + id] = slb[k].iI + 1;
				Amat.i[ik + id] = slb[k].iW + 1;
				//rthdsd_amg[slb[k].iW + 1] = dV[slb[k].iW];
				//result_amg[slb[k].iW + 1] = dX0[slb[k].iW];
				// Это очень важный вопрос и он требует проверки !

				ik++;
			}

		}


		for (integer k = 0; k <= maxelm + maxbound; k++) {
			bamg_bound[k] = false;
		}

		// Освободим немного памяти.
		// Т.к. мы оперируем в мультигриде в девять раз большим объёмом памяти то это уничтожение не является
		// чем-то медленным по сравнению с ресурсами мультигрида.
		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			// Только в случае структурированной сетки  мы компрессируем исходную матрицу чтобы высвободить оперативную память.
			delete[] sl;
			sl = NULL;
		}
		//delete[] slb;
		//slb = NULL;

		//R = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		//R = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		//char c7[2] = "R";
		//handle_error<Ak1>(R, c7, c1, ((nsizePR * nnu) + 1));

		//P = new Ak1[(integer)(35 * nnu) + 1]; // 3*nnz 2.4 // 35
		//P = (Ak1*)malloc(((nsizePR * nnu) + 1) * sizeof(Ak1));
		//char c8[2] = "P";
		//handle_error<Ak1>(P, c8, c1, ((nsizePR * nnu) + 1));


		// TODO : 
		// нужно акуратно прописать выделения и уничтожения памяти с учётом того что было сделано в BiCGStabP.

		// Экономим 1 размер матрицы для мультигрида.
		//delete[] sl;
		//delete[] slb;



		//printf("getready ...");
		//getchar();
		// amg - особенно хорош для поправки давления в SIMPLE алгоритме.
		// свой алгоритм 2015 года.


		//aggregative_amg(Amat, nna, nnu, R, P, result_amg, rthdsd_amg);

		//printf("allocation memory is Ok. start ready...\n");
		//system("pause");
		doublereal theta = 0.24; // 3D // 0.25 по литературным  данным. 0.24 оптимально из практики (реальное тестирование).
		//theta = 0.5; // может поможет  для конвективных задач
		doublereal* x_copy = NULL;
		x_copy = (doublereal*)malloc((nnu + 1) * sizeof(doublereal));
		char c9[7] = "x_copy";
		handle_error<doublereal>(x_copy, c9, c1, (nnu + 1));

		for (integer i47 = 1; i47 <= nnu; i47++) {
			x_copy[i47] = result_amg[i47];
		}

		//doublereal theta83 = 0.23;
		//doublereal magic82 = 0.4;
		//doublereal magic83 = 0.5; 
		//doublereal ret74 = 0.0;
		bool bdivergence_detected = false;


		//Внимание можно использовать только double, с float сходимости нет.
		if (iswitchsolveramg_vs_BiCGstab_plus_ILU2 == 7) {
			//float theta82f=(float)theta82, theta83f= (float)theta83, magic82f= (float)magic82, magic83f= (float)magic83, ret74f= (float)ret74;
			doublereal theta82f = (doublereal)theta82, theta83f = (doublereal)theta83, magic82f = (doublereal)magic82, magic83f = (doublereal)magic83, ret74f = (doublereal)ret74;
			//bdivergence_detected = classic_aglomerative_amg4<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg,  theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings,b, lb, maxelm);
			bdivergence_detected = classic_aglomerative_amg6<doublereal>(Amat, nsizeA,  nna, nnu, x_copy, rthdsd_amg, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings, b, lb, maxelm);
		}
		else {
			//float theta82f = (float)theta82, theta83f = (float)theta83, magic82f = (float)magic82, magic83f = (float)magic83, ret74f = (float)ret74;
			doublereal theta82f = (doublereal)theta82, theta83f = (doublereal)theta83, magic82f = (doublereal)magic82, magic83f = (doublereal)magic83, ret74f = (doublereal)ret74;
			//bdivergence_detected = classic_aglomerative_amg5<float>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82f, theta83f, magic82f, magic83f, ret74f, iVar, bmemory_savings);
			//---->bdivergence_detected = classic_aglomerative_amg5<doublereal>(Amat, nsizeA, nsizePR, nna, nnu, R, P, x_copy, rthdsd_amg, bamg_bound, theta82, theta83, magic82, magic83, ret74, iVar, bmemory_savings);
		}
		// если работа amg была неудачна то мы не портим переполнение рабочий вектор результата.
		// Перенаправление на стабильную версию алгоритма.
		if (bdivergence_detected) {
			//system("pause");
			integer maxit = 2000;
			bool bprintmessage = false;
			Bi_CGStab_internal3(sl, slb, maxelm, maxbound, dV, dX0, maxit, alpharelax, bprintmessage, iVar, m, ifrontregulationgl, ibackregulationgl, b, lb, s_loc, ls, inumber_iteration_SIMPLE);
		}
		else
		{
			// Работа amg была успешна.
			for (integer i47 = 1; i47 <= nnu; i47++) {
				result_amg[i47] = x_copy[i47];
			}
		}
		if (x_copy != NULL) {
			free(x_copy);
			x_copy = NULL;
		}

		//system("pause");



		// возвращаем решение СЛАУ.
		// вектор решения. 
		for (integer i = 0; i < nnu; i++) {
			if (i < maxelm + maxbound) {
				// обязательно нужно проверить была ли выделена оперативная память. 
				dX0[i] = result_amg[i + 1];
			}
		}



		//if (R != NULL) {
			//delete[] R;
			//free(R);
		//}
		//if (P != NULL) {
			//delete[] P;
			//free(P);
		//}
		if (bamg_bound != NULL) {
			delete[] bamg_bound;
			bamg_bound = NULL;
		}
		//if (Atemp != NULL) {
			//delete[] Atemp;
		//}
		//if (Atemp2 != NULL) {
			//delete[] Atemp2;
		//}
		if (result_amg != NULL) {
			//delete[] result_amg;
			free(result_amg);
		}
		if (rthdsd_amg != NULL) {
			//delete[] rthdsd_amg;
			free(rthdsd_amg);
		}

		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			sl = new equation3D[maxelm]; // коэффициенты матрицы СЛАУ для внутренних КО.
			if (sl == NULL) {
				// недостаточно памяти на данном оборудовании.
				printf("Problem : not enough memory on your equipment for slau temperature constr struct...\n");
				printf("Please any key to exit...\n");
				//getchar();
				system("pause");
				exit(1);
			}
		}


		/*
		slb = new equation3D_bon[maxbound]; // коэффициенты матрицы СЛАУ для граничных КО
		if (slb == NULL) {
			// недостаточно памяти на данном оборудовании.
			printf("Problem : not enough memory on your equipment for slau boundary temperature constr struct...\n");
			printf("Please any key to exit...\n");
			//getchar();
			system("pause");
			exit(1);
		}
		*/
		if (bmemory_savings && (!b_on_adaptive_local_refinement_mesh)) {
			// Разархивация исходной матрицы А в первоначальном формате.
			// Предполагается что матрица на структурированной декартовой прямоугольной сетке.
			// Как бы мы не пытались здесь, но матрица не сохраняемая в файл не подлежит здесь восстановлению,
			// а операция записи в файл чрезвычайно медленная.
			for (integer k = 0; k < maxelm; k++) {
				
				sl[k].bB2 = false;
				sl[k].bB3 = false;
				sl[k].bB4 = false;
				sl[k].bE2 = false;
				sl[k].bE3 = false;
				sl[k].bE4 = false;
				sl[k].bN2 = false;
				sl[k].bN3 = false;
				sl[k].bN4 = false;
				sl[k].bT2 = false;
				sl[k].bT3 = false;
				sl[k].bT4 = false;
				sl[k].bW2 = false;
				sl[k].bW3 = false;
				sl[k].bW4 = false;
				sl[k].bS2 = false;
				sl[k].bS3 = false;
				sl[k].bS4 = false;

				sl[k].iB = -1;
				sl[k].iB2 = -1;
				sl[k].iB3 = -1;
				sl[k].iB4 = -1;
				sl[k].iE = -1;
				sl[k].iE2 = -1;
				sl[k].iE3 = -1;
				sl[k].iE4 = -1;
				sl[k].iN = -1;
				sl[k].iN2 = -1;
				sl[k].iN3 = -1;
				sl[k].iN4 = -1;
				sl[k].iS = -1;
				sl[k].iS2 = -1;
				sl[k].iS3 = -1;
				sl[k].iS4 = -1;
				sl[k].iT = -1;
				sl[k].iT2 = -1;
				sl[k].iT3 = -1;
				sl[k].iT4 = -1;
				sl[k].iW = -1;
				sl[k].iW2 = -1;
				sl[k].iW3 = -1;
				sl[k].iW4 = -1;
				sl[k].ab = 0.0;
				sl[k].ae = 0.0;
				sl[k].an = 0.0;
				sl[k].as = 0.0;
				sl[k].at = 0.0;
				sl[k].aw = 0.0;
				sl[k].ab2 = 0.0;
				sl[k].ae2 = 0.0;
				sl[k].an2 = 0.0;
				sl[k].as2 = 0.0;
				sl[k].at2 = 0.0;
				sl[k].aw2 = 0.0;
				sl[k].ab3 = 0.0;
				sl[k].ae3 = 0.0;
				sl[k].an3 = 0.0;
				sl[k].as3 = 0.0;
				sl[k].at3 = 0.0;
				sl[k].aw3 = 0.0;
				sl[k].ab4 = 0.0;
				sl[k].ae4 = 0.0;
				sl[k].an4 = 0.0;
				sl[k].as4 = 0.0;
				sl[k].at4 = 0.0;
				sl[k].aw4 = 0.0;
				sl[k].ap = 0.0;
				integer iadd = 7 * k;
				sl[k].b = rcompressionb[k];
				//p e n t s w b
				sl[k].ap = 1.0 / Amat.aij[the_original_order_of_values[icompression[iadd + 0]]];
				//sl[k].iP = Amat.i[the_original_order_of_values[icompression[iadd + 0]]] - 1;
				sl[k].iP = k;
				//if (Amat.i[the_original_order_of_values[icompression[iadd + 0]]] - 1 != k) {
					//printf("non comparison\n");
					//getchar();
				//}
				if (icompression[iadd + 1] > -1) {
					// E
					sl[k].ae = -Amat.aij[the_original_order_of_values[icompression[iadd + 1]]];
					sl[k].iE = Amat.j[the_original_order_of_values[icompression[iadd + 1]]] - 1;
				}
				if (icompression[iadd + 2] > -1) {
					// N
					sl[k].an = -Amat.aij[the_original_order_of_values[icompression[iadd + 2]]];
					sl[k].iN = Amat.j[the_original_order_of_values[icompression[iadd + 2]]] - 1;
				}
				if (icompression[iadd + 3] > -1) {
					// T
					sl[k].at = -Amat.aij[the_original_order_of_values[icompression[iadd + 3]]];
					sl[k].iT = Amat.j[the_original_order_of_values[icompression[iadd + 3]]] - 1;
				}
				if (icompression[iadd + 4] > -1) {
					// S
					sl[k].as = -Amat.aij[the_original_order_of_values[icompression[iadd + 4]]];
					sl[k].iS = Amat.j[the_original_order_of_values[icompression[iadd + 4]]] - 1;
				}
				if (icompression[iadd + 5] > -1) {
					// W
					sl[k].aw = -Amat.aij[the_original_order_of_values[icompression[iadd + 5]]];
					sl[k].iW = Amat.j[the_original_order_of_values[icompression[iadd + 5]]] - 1;
				}
				if (icompression[iadd + 6] > -1) {
					// B
					sl[k].ab = -Amat.aij[the_original_order_of_values[icompression[iadd + 6]]];
					sl[k].iB = Amat.j[the_original_order_of_values[icompression[iadd + 6]]] - 1;
				}

				//if ((k == 6867418)||(k==68675507)) {
					//printf("ap=%e aw=%e ae=%e as=%e an=%e ab=%e at=%e \n", sl[k].ap, sl[k].aw, sl[k].ae, sl[k].as, sl[k].an, sl[k].ab, sl[k].at);
					//getchar();
				//}
			}

			if (icompression != NULL) free(icompression);
			icompression = NULL;

			if (rcompressionb != NULL) free(rcompressionb);
			rcompressionb = NULL;



		}

		if (the_original_order_of_values != NULL) {
			free(the_original_order_of_values);
			the_original_order_of_values = NULL;
		}
		if (the_original_order_of_values_reverse != NULL) {
			free(the_original_order_of_values_reverse);
			the_original_order_of_values_reverse = NULL;
		}

		/*
		for (integer i1 = 0; i1 < maxbound; i1++) {
			slb[i1].iI = -1;
			slb[i1].ai = 0.0;
			slb[i1].aw = 0.0;
		}
		// Если это раскоментировать то res_sum надо извлекать из нутра мультигрида.
		*/


		// освобождение памяти.
		if (Amat.i != NULL) {
			//delete[] Amat;
			free(Amat.i);
			Amat.i = NULL;
		}
		if (Amat.j != NULL) {
			//delete[] Amat;
			free(Amat.j);
			Amat.j = NULL;
		}
		if (Amat.aij != NULL) {
			//delete[] Amat;
			free(Amat.aij);
			Amat.aij = NULL;
		}
		if (Amat.abs_aij != NULL) {
			//delete[] Amat;
			free(Amat.abs_aij);
			Amat.abs_aij = NULL;
		}

		res_sum = 0.0;
		for (integer i1 = 0; i1 < maxelm; i1++) {
			// внутренность матрицы.
			doublereal buf = 0.0;
			buf = (sl[i1].ap*dX0[sl[i1].iP] - dV[sl[i1].iP]);
			if ((sl[i1].iB > -1) && (fabs(sl[i1].ab) > nonzeroEPS)) buf -= sl[i1].ab*dX0[sl[i1].iB];
			if ((sl[i1].iE > -1) && (fabs(sl[i1].ae) > nonzeroEPS)) buf -= sl[i1].ae*dX0[sl[i1].iE];
			if ((sl[i1].iN > -1) && (fabs(sl[i1].an) > nonzeroEPS)) buf -= sl[i1].an*dX0[sl[i1].iN];
			if ((sl[i1].iS > -1) && (fabs(sl[i1].as) > nonzeroEPS)) buf -= sl[i1].as*dX0[sl[i1].iS];
			if ((sl[i1].iT > -1) && (fabs(sl[i1].at) > nonzeroEPS)) buf -= sl[i1].at*dX0[sl[i1].iT];
			if ((sl[i1].iW > -1) && (fabs(sl[i1].aw) > nonzeroEPS)) buf -= sl[i1].aw*dX0[sl[i1].iW];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB2 > -1) && (fabs(sl[i1].ab2) > nonzeroEPS)) buf -= sl[i1].ab2*dX0[sl[i1].iB2];
			if ((sl[i1].iE2 > -1) && (fabs(sl[i1].ae2) > nonzeroEPS)) buf -= sl[i1].ae2*dX0[sl[i1].iE2];
			if ((sl[i1].iN2 > -1) && (fabs(sl[i1].an2) > nonzeroEPS)) buf -= sl[i1].an2*dX0[sl[i1].iN2];
			if ((sl[i1].iS2 > -1) && (fabs(sl[i1].as2) > nonzeroEPS)) buf -= sl[i1].as2*dX0[sl[i1].iS2];
			if ((sl[i1].iT2 > -1) && (fabs(sl[i1].at2) > nonzeroEPS)) buf -= sl[i1].at2*dX0[sl[i1].iT2];
			if ((sl[i1].iW2 > -1) && (fabs(sl[i1].aw2) > nonzeroEPS)) buf -= sl[i1].aw2*dX0[sl[i1].iW2];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB3 > -1) && (fabs(sl[i1].ab3) > nonzeroEPS)) buf -= sl[i1].ab3*dX0[sl[i1].iB3];
			if ((sl[i1].iE3 > -1) && (fabs(sl[i1].ae3) > nonzeroEPS)) buf -= sl[i1].ae3*dX0[sl[i1].iE3];
			if ((sl[i1].iN3 > -1) && (fabs(sl[i1].an3) > nonzeroEPS)) buf -= sl[i1].an3*dX0[sl[i1].iN3];
			if ((sl[i1].iS3 > -1) && (fabs(sl[i1].as3) > nonzeroEPS)) buf -= sl[i1].as3*dX0[sl[i1].iS3];
			if ((sl[i1].iT3 > -1) && (fabs(sl[i1].at3) > nonzeroEPS)) buf -= sl[i1].at3*dX0[sl[i1].iT3];
			if ((sl[i1].iW3 > -1) && (fabs(sl[i1].aw3) > nonzeroEPS)) buf -= sl[i1].aw3*dX0[sl[i1].iW3];

			// Дополнение на АЛИС сетке:
			if ((sl[i1].iB4 > -1) && (fabs(sl[i1].ab4) > nonzeroEPS)) buf -= sl[i1].ab4*dX0[sl[i1].iB4];
			if ((sl[i1].iE4 > -1) && (fabs(sl[i1].ae4) > nonzeroEPS)) buf -= sl[i1].ae4*dX0[sl[i1].iE4];
			if ((sl[i1].iN4 > -1) && (fabs(sl[i1].an4) > nonzeroEPS)) buf -= sl[i1].an4*dX0[sl[i1].iN4];
			if ((sl[i1].iS4 > -1) && (fabs(sl[i1].as4) > nonzeroEPS)) buf -= sl[i1].as4*dX0[sl[i1].iS4];
			if ((sl[i1].iT4 > -1) && (fabs(sl[i1].at4) > nonzeroEPS)) buf -= sl[i1].at4*dX0[sl[i1].iT4];
			if ((sl[i1].iW4 > -1) && (fabs(sl[i1].aw4) > nonzeroEPS)) buf -= sl[i1].aw4*dX0[sl[i1].iW4];

			buf *= buf;
			res_sum += buf;
		}
		for (integer i1 = 0; i1 < maxbound; i1++) {
			// граничные узлы.
			doublereal buf = 0.0;
			buf = slb[i1].aw*dX0[slb[i1].iW] - dV[slb[i1].iW];
			if ((slb[i1].iI > -1) && (fabs(slb[i1].ai) > nonzeroEPS)) buf -= slb[i1].ai*dX0[slb[i1].iI];
			buf *= buf;
			res_sum += buf;
		}
		res_sum = sqrt(res_sum);
		printf("output diagnostic residual =%e\n", res_sum);
		//printf("residual finish=%1.4e\n",res_sum);
		//getchar();
		if (bsolid_static_only) {
			// используется только для теплопередачи в твёрдом теле для ускорения
			// решения задачи - защита от рестарта.
			finish_residual = res_sum; // значение невязки решённой задачи.
		}

	}

	/*doublerealT fsum1 = 0.0, fsum2 = 0.0;

	// внутренние контрольные объёмы.
	for (integer i = 0; i<maxelm; i++) {
		// числитель
		doublerealT sE, sW, sN, sS, sT, sB;
		if (sl[i].iE>-1) sE = sl[i].ae*dX0[sl[i].iE]; else sE = 0.0;
		if (sl[i].iW>-1) sW = sl[i].aw*dX0[sl[i].iW]; else sW = 0.0;
		if (sl[i].iN>-1) sN = sl[i].an*dX0[sl[i].iN]; else sN = 0.0;
		if (sl[i].iS>-1) sS = sl[i].as*dX0[sl[i].iS]; else sS = 0.0;
		if (sl[i].iT>-1) sT = sl[i].at*dX0[sl[i].iT]; else sT = 0.0;
		if (sl[i].iB>-1) sB = sl[i].ab*dX0[sl[i].iB]; else sB = 0.0;

		doublerealT sE2, sW2, sN2, sS2, sT2, sB2;
		if (sl[i].iE2>-1) sE2 = sl[i].ae2*dX0[sl[i].iE2]; else sE2 = 0.0;
		if (sl[i].iW2>-1) sW2 = sl[i].aw2*dX0[sl[i].iW2]; else sW2 = 0.0;
		if (sl[i].iN2>-1) sN2 = sl[i].an2*dX0[sl[i].iN2]; else sN2 = 0.0;
		if (sl[i].iS2>-1) sS2 = sl[i].as2*dX0[sl[i].iS2]; else sS2 = 0.0;
		if (sl[i].iT2>-1) sT2 = sl[i].at2*dX0[sl[i].iT2]; else sT2 = 0.0;
		if (sl[i].iB2>-1) sB2 = sl[i].ab2*dX0[sl[i].iB2]; else sB2 = 0.0;

		doublerealT sE3, sW3, sN3, sS3, sT3, sB3;
		if (sl[i].iE3>-1) sE3 = sl[i].ae3*dX0[sl[i].iE3]; else sE3 = 0.0;
		if (sl[i].iW3>-1) sW3 = sl[i].aw3*dX0[sl[i].iW3]; else sW3 = 0.0;
		if (sl[i].iN3>-1) sN3 = sl[i].an3*dX0[sl[i].iN3]; else sN3 = 0.0;
		if (sl[i].iS3>-1) sS3 = sl[i].as3*dX0[sl[i].iS3]; else sS3 = 0.0;
		if (sl[i].iT3>-1) sT3 = sl[i].at3*dX0[sl[i].iT3]; else sT3 = 0.0;
		if (sl[i].iB3>-1) sB3 = sl[i].ab3*dX0[sl[i].iB3]; else sB3 = 0.0;

		doublerealT sE4, sW4, sN4, sS4, sT4, sB4;
		if (sl[i].iE4>-1) sE4 = sl[i].ae4*dX0[sl[i].iE4]; else sE4 = 0.0;
		if (sl[i].iW4>-1) sW4 = sl[i].aw4*dX0[sl[i].iW4]; else sW4 = 0.0;
		if (sl[i].iN4>-1) sN4 = sl[i].an4*dX0[sl[i].iN4]; else sN4 = 0.0;
		if (sl[i].iS4>-1) sS4 = sl[i].as4*dX0[sl[i].iS4]; else sS4 = 0.0;
		if (sl[i].iT4>-1) sT4 = sl[i].at4*dX0[sl[i].iT4]; else sT4 = 0.0;
		if (sl[i].iB4>-1) sB4 = sl[i].ab4*dX0[sl[i].iB4]; else sB4 = 0.0;

		fsum1 += fabs(sE + sW + sN + sS + sT + sB + sE2 + sW2 + sN2 + sS2 + sT2 + sB2 + sE3 + sW3 + sN3 + sS3 + sT3 + sB3 + sE4 + sW4 + sN4 + sS4 + sT4 + sB4 +sl[i].b - sl[i].ap*dX0[sl[i].iP]);
		fsum2 += fabs(sl[i].ap*dX0[sl[i].iP]); // знаменатель.
	}//ok
	*/

	calculation_main_end_time = clock();
	calculation_vorst_seach_time += calculation_main_end_time - calculation_main_start_time;

#ifdef _OPENMP
	omp_set_num_threads(i_my_num_core_parallelesation);
#endif
	///getchar();
} // my_agr_amg_loc_memory


/*
program output // пример из pamg.

multilevel_solver
Number of Levels : 6
Operator Complexity : 2.198
Grid Complexity : 1.666
Coarse Solver : 'pinv2'
level   unknowns     nonzeros
0       250000      1248000[45.50%]
1       125000      1121002[40.87%]
2        31252       280662[10.23%]
3         7825        70657[2.58%]
4         1937        17973[0.66%]
5          484         4728[0.17%]

residual norm is 1.86112114946e-06
*/


#endif /* MY_AGREGAT_AMG_CPP*/