unit VisualUnit;
// визуализатор для трёхмерных тепловых расчётов
// распространяется на условиях FreeBSD подобной лицензии.

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ExtCtrls, ComCtrls, Buttons, ImgList, Menus;

type
  // вершинва трёхмерного тела
  TVertex = record
    x,y,z : real;
  end;
  TEdge=record
     p1,p2 : word; // номера вершин
  end;
  // трёхмерное тело
  TBody = record
     // массив начальных положений вершин тела
     Vertexs : array of TVertex;
     // Массив текущих положений вершин тела
     Vertext : array of TVertex;
     Edges : array of TEdge; // массив рёбер тела
     xS, yS, zS : Real; // координаты прямоугольной
     xE, yE, zE : Real; // области
     sxS, syS, szS : String; // параметризованные координаты прямоугольной
     sxE, syE, szE : String; // области заданные пользователем
     name : string; // имя объекта
     itype : Integer; // SOLID 1, HOLLOW 2, FLUID 3.
     power : Real; // мощность тепловыделения  блока
     spower : String; // параметризованная мощность тепловыделения внутри блока.
     iunion : Integer; // номер union`a которому принадлежит если 0 значит самый высокий уровень на уровне кабинета
     bvisible : Boolean; // видимость элемента

     imatid : Integer;  // уникальный номер в списке рабочих материалов
  end;

  // Объединение
  TMyAssembles = record
      name : string; // имя объекта
      identifire : Integer; // идентификатор объединения.
  end;

  TMYMat = record
     // Ниже приведено всё относящееся к свойствам материала:
     namemat : string; // имя материала
     rho, cp, lambda, beta_t: Real; // тепловые свойства блока
     bBoussinesq : Integer; // 0 - false, 1 - true;
     blibmat : Integer; // 1 - использовать внутрипрограммный библиотечный материал
     // 0 - использовать материал заданный пользователем.
     ilibident : Integer; // идентификатор билиотечного материала.
     // Динамическая вязкость
     mu : Real; // постоянное значение динамической вязкости для Ньютоновской жидкости
     // ilawmu :
     // 0 - const value
     // для псевдопластических неньютоновских материалов.
     // 1 - закон Оствальда-де Вела
     // 2 - Кессона
     // 3 - Прандтля
     // 4 - Carreau
     // 5 - Пауэлл-Эйринг
     // 6 - Уильямсон
     ilawmu : Integer; // номер закона для зависимости вязкости от скорости деформаций
     // Ограничители динамической вязкости (минимальное и максимальное значения)
     mumin, mumax : Real;
     // константы для законов предложенных выше
     Amu, Bmu, Cmu : Real;
     degreennmu : Real; // показатель степени в законе для не Ньютоновской жидкости
  end;

  // либо источник тепла либо стенка  (идеальный теплоотвод или
  // граничное условие 2 или 3 рода)
  // В задачах гидродинамики это может быть место входа жидкости
  // в расчётную область, место выхода жидкости из расчётной области
  // или это может быть например граница с условиями симметрии, ну и
  // конечно же твёрдая стенка.
  TPlane = record
      // Массив начальных положений вершин тела
      Vertexs : array of TVertex;
      // иассив текущих положений вершин тела
      Vertext : array of TVertex;
      Edges : array of TEdge; // массив рёбер тела
      // плоскость в которой лежит источник тепла :
      // 1 - XY, 2 - XZ, 3 - YZ
      iPlane : word;
      xS, yS, zS : Real; // координаты плоской
      xE, yE, zE : Real; // фигуры
      sxS, syS, szS : String; // параметризованные координаты прямоугольной
      sxE, syE, szE : String; // области заданные пользователем
      name : string; // имя источника
      // параметры для источника тепла
      Power : Real; // мощность тепловыделения
      spower : String; // параметризованная пользователем мощность тепловыделения
      itempdep : Integer; // 0 const, 1 table.
      id_table : Integer; // номер таблицы
      operatingoffsetdrain : Real; // значение смещения стока.
      soperatingoffsetdrain : String; // параметризованное значение.
      // параметры для стенок
      family : word; // тип краевого условия
      Tamb : Real; // температура
      HF : Real; // тепловой поток
      // граничное условие 3 рода
      // заётся используя оба этих параметра.
      Vx, Vy, Vz, P : Real; // гидродинамические условия на стенке
      bpressure, bsymmetry : Boolean; // выходная граница или граница симметрии
      iunion : Integer; // номер union`a которому принадлежит если 0 значит самый высокий уровень на уровне кабинета
      bvisible : Boolean; // видимость элемента
  end;

  // библиотека твёрдых материалов
  TLibMatSolid = record
     name : String; // название материала
     rho : Real; // плотность
     cp : Real; // удельная теплоёмкость при постоянном давлении
     lam : Real; // теплопроводность
  end;

  // библиотека твёрдых материалов
  TLibMatFluid = record
     // Осторожно реальные свойства газов
     // и жидкостей сильно зависят от температуры,
     // поэтому данные значения лишь опорные
     // верные при одной температуре.
     name : String; // название материала
     rho : Real; // плотность
     cp : Real; // удельная теплоёмкость при постоянном давлении
     lam : Real; // теплопроводность
     mu : Real;
     beta_t : Real;
  end;

  // Система уравнений гидродинамики:
  // В одной Fluid Domain (жидкой области).
  TmyFLUIDmodel = record
      // опорная точка в жидкости
      xc : Real;
      yc : Real;
      zc : Real;
      // считать ли поле течения
      iflow : Integer; // 0 - не считать, 1 - расчитать.
      iflowregime : Integer; // 0 - Ламинарный, 1 - Турбулентный.
      // 0 - Zero Equation Model (ZEM). (RANS)
      // 1 - Smagorinsky Model (LES) (в неё как опция включена динамическая модель Германо [1991])
      // 2 - RNG (LES)
      iturbmodel : Integer; // выбор модели турбулентности
      // Параметры модели Смагоринского.
      SmagConst : Real; // константа Смагоринского.
      // использовать ли для определения константы Смагоринского динамическую модель.
      iDynamicStressGermano : Integer; // 0 - не использовать, 1 - использовать.
      // использовать ли ограничения на константу Смагоринского сверху и снизу.
      iLimitersCs : Integer; // 0 - не использовать, 1 - использовать.
      minCs, maxCs : Real; // минимаксные ограничители константы Смагоринского.
      itypeFiltrGermano : Integer; // тип фильтра в модели Германо.
      roughness : Real; // шероховатость твёрдой стенки.
      ipowerroughness : Integer; // показатель степени в модели учёта шероховатости.
      bfdelta : Boolean; // поправочный коэффициент связанный с неравномерностью сетки
      bSmagorinsky_Lilly : Boolean; // активирует модель Смагоринского-Лиллу.
      bsurface_roughness : Boolean; // активирует учёт шероховатости стенки.
      bSwirlamendment : Boolean; // поправка для течений с кривизной линий тока.
      rRimult : Real; // домножающий коэффициент подправляющий число Ричардсона для течений с кривизной линий тока.
      // избирательная модель Смагоринского.
      // турбулентная вязкость добавляется только в те области
      // где угол между вихрем и осреднённым вихрем  больше 15 градусов.
      bSelectiveSmagorinsky : Boolean;
      rSelectiveAngle : Real; // пороговое значение угла отсева.
      itypefiltr : Integer; // тип фильтра который используется для осреднения.
  end;

  // система уравнений в глобальной расчётной области
  TmyEGD = record
     itemper : Integer; // 0 - не считать температуру, 1 - расчитать температуру.
     imaxflD : Integer; // максимальное число не пересекающихся по жидкости жидких зон.
     myflmod : array of TmyFLUIDmodel; // система уравнений в каждой жидкой зоне.
  end;

  TmyVariable = record
     svar : String;  // имя переменной
     sval : String;  // значение переменной
  end;

  TLaplas = class(TForm)
    MainPanel: TPanel;
    // окно визуализации
    MainPaintBox: TPaintBox;
    // дерево элементов
    MainTreeView: TTreeView;
    // окно консольных сообщений для диалога с пользователем
    MainMemo: TMemo;
    // увеличивает изображение
    Bzoomp: TSpeedButton;
    // уменьшает изображение
    Bzoomm: TSpeedButton;
    // добавляет блок
    SPBAddBlock: TSpeedButton;
    // Добавляет источник тепла:
    DaddSource: TSpeedButton;
    // список картинок для интерфейса пользователя
    MainImageList: TImageList;
    SpeedButtonplanexy: TSpeedButton;
    // меню пользователя:
    MainMenu1: TMainMenu;
    // меню File для опрации с файлами:
    File1: TMenuItem;
    // записывает данные в текстовый файл
    write1: TMenuItem;
    // считывает данные из текстового файла
    read1: TMenuItem;
    // Закрывает приложение
    Close1: TMenuItem;
    // для диалога открытия файла
    OpenDialog1: TOpenDialog;
    // показывает чертёж расчетной области в изометрии
    SpeedButtonisogeom: TSpeedButton;
    SBwall: TSpeedButton;
    Labellength: TLabel;
    ComboBoxlength: TComboBox;
    SpeedButtonDel: TSpeedButton;
    // операция копирования элементов
    SpeedButtonCopy: TSpeedButton;
    // возвращает вид геометрии в плоскости xz
    SpeedButtonplanexz: TSpeedButton;
    // возвращает вид геометрии в плоскости yz
    SpeedButtonplaneyz: TSpeedButton;
    SpeedButtonUnion: TSpeedButton;
    Grid1: TMenuItem;
    Define1: TMenuItem;
    Models1: TMenuItem;
    // задаёт силу тяжести
    Gravity1: TMenuItem;
    // задаёт параметры расчётной сетки
    Mesh1: TMenuItem;
    // форма задания параметризации модели
    Variables1: TMenuItem;
    // глобальное меню солвера
    Solve1: TMenuItem;
    // настройки решающего устройства
    Settings1: TMenuItem;
    // записывает файл premeshin.txt и вызывает солвер
    RunSolution1: TMenuItem;
    PowerTable1: TMenuItem;
    // Вызывается при создании формы
    procedure FormCreate(Sender: TObject);
    // событие OnPaint
    procedure MainPaintBoxPaint(Sender: TObject);
    // Движение мыши
    procedure MainPaintBoxMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
      // Нажатие кнопки мыши
    procedure MainPaintBoxMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    // отпускание кнопки мыши
    procedure MainPaintBoxMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
      // увеличение иображения
    procedure BzoompClick(Sender: TObject);
    // уменьшение изображения
    procedure BzoommClick(Sender: TObject);
    // по нажатию на кнопку добавляется блок
    procedure SPBAddBlockClick(Sender: TObject);
    // добавляет источник тепла
    procedure DaddSourceClick(Sender: TObject);
    // выравнивание картинки по плоскости XOY
    procedure SpeedButtonplanexyClick(Sender: TObject);
    // закрывает приложение
    procedure Close1Click(Sender: TObject);
    // записывает информацию в текстовый файл
    procedure write1Click(Sender: TObject);
    // считывает информацию из текстового файла
    procedure read1Click(Sender: TObject);
    // устанавливает изометрию для изображения
    procedure SpeedButtonisogeomClick(Sender: TObject);
    // колёсико движется вниз уменьшение изображения
    procedure FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
    // колёсико движется вверх увеличение изображения
    procedure FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
      MousePos: TPoint; var Handled: Boolean);
      // изменение размеров формы
    procedure FormResize(Sender: TObject);
    // создаёт новую стенку
    procedure SBwallClick(Sender: TObject);
    // выполнен двойной щелчёк мышью по элементу на дереве
    procedure MainTreeViewDblClick(Sender: TObject);
    // удаление объекта
    procedure SpeedButtonDelClick(Sender: TObject);
    // создаёт копии элементов
    procedure SpeedButtonCopyClick(Sender: TObject);
    // показывает плоскоость XZ
    procedure SpeedButtonplanexzClick(Sender: TObject);
    // показывает плоскость YZ
    procedure SpeedButtonplaneyzClick(Sender: TObject);
    // создаёт объединение
    procedure SpeedButtonUnionClick(Sender: TObject);
    // задаёт параметры расчётной сетки
    procedure Mesh1Click(Sender: TObject);
    // задаёт силу тяжести
    procedure Gravity1Click(Sender: TObject);
    // задаёт набор уравнений для решения
    procedure Models1Click(Sender: TObject);
    // задаёт или редактирует переменные проекта
    procedure Variables1Click(Sender: TObject);
    // запичывает файл premeshin.txt
    procedure RunSolution1Click(Sender: TObject);
    procedure PowerTable1Click(Sender: TObject);
    procedure MainTreeViewClick(Sender: TObject);

  private
    { Private declarations }
  public
    { Public declarations }
    lb, itek : Integer; // всего кубиков и текущий обрабатываемый кубик
    body : array of TBody; // список тел
    ls : Integer; // всего источников тепла
    source : array of TPlane; // список источников тепла
    lw : Integer; // всего стенок
    wall : array of TPlane; // список стенок
    drawing : Boolean;
    Alf,Bet : Real;  // углы поворота для визуализации
    m : Real; // масштабный коэффициент для визуализации
    mlength : Real; // для масштабирования реальных длин
    libsolid : array of TLibMatSolid;
    lmatsol : Integer;
    libfluid : array of TLibMatFluid;
    lmatfluid : Integer;
    workmat : array of TMYMat; // список рабочих материалов
    lmatmax : Integer; // количество рабочих материалов
    inum : Integer;   // число копий
    spdx, spdy, spdz : String; // параметризованное значение перемещения при копировании.
    bcontinuecopy : Boolean; // нужно ли осуществлять операцию копирования.
    Oxc, Oyc, Ozc : Real; // смещение начала системы координат в точку
    lu : Integer; // количество объединений
    myassembles : array of TMyAssembles; // список объединений
    ixo, iyo : Integer; // сдвигание картинки мышью
    inx, iny, inz : Integer; // количество узлов сетки по каждому из направлений
    gx, gy, gz : Real; // сила тяжести
    operatingtemperature : Real; // опорная температура
    egddata : TmyEGD; // информация об уравнениях которые придётся решать.
    ivar : Integer; // количество переменных
    parametric : array of TmyVariable;
    iltdp : Integer; // integer length temperature depend power (количество уникальных таблично заданных зависимостей)
    listtablename : array of string; // список имен файлов (по одному файлу на каждую таблицу).
    breadfinish : Boolean; // считывание файла закончено
    
    // Добавляет вершину.
    procedure addvertex(nbody, nvert : Integer; x0,y0,z0 : Real);
    // создаёт рёбра для
    // прямоугольного параллелепипеда
    procedure Edgecubcreate(nbody : Integer);
    // вращение
    procedure Rotate;
    // загрузка значений вершин
    procedure LoadVertexBrick(nbody : Integer);
    // инициализация формы редактирования блока
    procedure initializeaddblockform;
    // преобразование осей координат
    procedure axis(q : TVertex; var p : TVertex); // оси координат
    // создаёт рёбра для прямоугольника на плоскости
    procedure EdgePlaneCreate(var plane : TPlane);
    // загрузка значений вершин для источника
    procedure LoadVertexPlane(plane : TPlane);
    // вращение источника
    procedure RotateSource;
    // инициализация формы редактирования источника тепла
    procedure InitializeAddSourceForm;
    // считывает параметры материала
    procedure myreadmaterial(var workmat : TMYMat; s : string);
    // считывает параметры для блока
    procedure myreadbody(var body : TBody; s : string);
    // считывает параметры для источника тепла
    procedure myreadsource(var source :  TPlane; s : string);
    // читает координаты плоского элемента
    procedure myreadplane(var plane : TPlane; s : string);
    // вращение стенки
    procedure RotateWall;
    // инициализация формы редактированния стенки
    procedure Initializeaddwallform;
    // вращанет точки
    procedure RotatePoint(var plane : TPlane; imax : word);
    // считывает параметры твёрдой стенки
    procedure myReadWall(var wall : TPlane; s : string);
    // считывает информацию о жидкой зоне
    procedure myreadfluidzone(var myflmod : TmyFLUIDmodel; s : string);
    // проверка уникальности имени объекта
    function isduplicatenameobj(chidobj : Char; scandidate : string; iobjid : Integer): Boolean;
    // процедура корректировки имени объекта
    procedure correctobjname(chidobj : Char;var scandidate : string; iobjid : Integer);
  end;

var
  Laplas: TLaplas;

implementation
uses
      Math, CabinetUnit, addBlockUnit, AddSourceUnit, AddWallUnit, UnitCopy,
  UnitFormUnion, MeshUnit, UnitGravity, UnitEQGD, UnitVariables,
  UnitPowerList;
{$R *.dfm}

// преобразование осей координат
procedure TLaplas.axis(q : TVertex; var p : TVertex);// оси координат
begin
   p.x:=q.x*cos(Alf) - q.y*sin(Alf);
   p.y:=q.x*sin(Alf)*cos(Bet)+ q.y*cos(Alf)*cos(Bet)- q.z*sin(Bet);
   p.z:=q.x*sin(Alf)*sin(Bet)+ q.y*cos(Alf)*sin(Bet)+ q.z*cos(Bet);
end;

// Добавляет вершину.
procedure TLaplas.addvertex(nbody, nvert : Integer; x0,y0,z0 : Real);
begin
   with (body[nbody].Vertexs[nvert]) do
   begin
      x:=x0;
      y:=y0;
      z:=z0;
   end;
end;

// создаёт рёбра для
// прямоугольного параллелепипеда
procedure TLaplas.Edgecubcreate(nbody : Integer);
begin
   // рёбра
   with (body[nbody]) do
   begin
      SetLength(Edges,12);
      Edges[0].p1:=0;
      Edges[0].p2:=1;
      Edges[1].p1:=0;
      Edges[1].p2:=2;
      Edges[2].p1:=1;
      Edges[2].p2:=3;
      Edges[3].p1:=2;
      Edges[3].p2:=3;
      Edges[4].p1:=4;
      Edges[4].p2:=5;
      Edges[5].p1:=4;
      Edges[5].p2:=6;
      Edges[6].p1:=5;
      Edges[6].p2:=7;
      Edges[7].p1:=6;
      Edges[7].p2:=7;
      Edges[8].p1:=0;
      Edges[8].p2:=4;
      Edges[9].p1:=1;
      Edges[9].p2:=5;
      Edges[10].p1:=2;
      Edges[10].p2:=6;
      Edges[11].p1:=3;
      Edges[11].p2:=7;
   end;
end; // создаёт рёбра для прямоугольного параллелепипеда

// создаёт рёбра для прямоугольника на плоскости
procedure TLaplas.EdgePlaneCreate(var plane : TPlane);
begin
   // рёбра
   SetLength(plane.Edges,4);
   with (plane) do
   begin
      Edges[0].p1:=0;
      Edges[0].p2:=1;
      Edges[1].p1:=0;
      Edges[1].p2:=2;
      Edges[2].p1:=1;
      Edges[2].p2:=3;
      Edges[3].p1:=2;
      Edges[3].p2:=3;
   end;
end; // создаёт рёбра для источника тепла

// вращанет точки
procedure TLaplas.RotatePoint(var plane : TPlane; imax : word);
var
   i : Integer;
begin
   with plane do
   begin
      for i:=0 to imax do
         begin
            Vertext[i].x:=(Vertexs[i].x-Oxc)*cos(Alf) - (Vertexs[i].y-Oyc)*sin(Alf);
            Vertext[i].y:=(Vertexs[i].x-Oxc)*sin(Alf)*cos(Bet)+ (Vertexs[i].y-Oyc)*cos(Alf)*cos(Bet)- (Vertexs[i].z-Ozc)*sin(Bet);
            Vertext[i].z:=(Vertexs[i].x-Oxc)*sin(Alf)*sin(Bet)+ (Vertexs[i].y-Oyc)*cos(Alf)*sin(Bet)+ (Vertexs[i].z-Ozc)*cos(Bet);
         end;
   end;
end;

// вращение
procedure TLaplas.Rotate;
var
    i,j : Integer;
begin
   for j:=0 to (lb-1) do
   begin
      with body[j] do
      begin
          for i:=0 to 7 do
         begin
            Vertext[i].x:=(Vertexs[i].x-Oxc)*cos(Alf) - (Vertexs[i].y-Oyc)*sin(Alf);
            Vertext[i].y:=(Vertexs[i].x-Oxc)*sin(Alf)*cos(Bet)+ (Vertexs[i].y-Oyc)*cos(Alf)*cos(Bet)- (Vertexs[i].z-Ozc)*sin(Bet);
            Vertext[i].z:=(Vertexs[i].x-Oxc)*sin(Alf)*sin(Bet)+ (Vertexs[i].y-Oyc)*cos(Alf)*sin(Bet)+ (Vertexs[i].z-Ozc)*cos(Bet);
         end;
      end;
   end;
end;

// вращение стенки
procedure TLaplas.RotateWall;
var
    j : Integer;
begin
   for j:=0 to (lw-1) do
   begin
      RotatePoint(wall[j],3);
   end;
end;

// вращение источника
procedure TLaplas.RotateSource;
var
    j : Integer;
begin
   for j:=0 to (ls-1) do
   begin
      RotatePoint(source[j],3);
   end;
end;

// загрузка значений вершин для кирпича
procedure TLaplas.LoadVertexBrick(nbody : Integer);
begin
   // точки вершины
   addvertex(nbody,0,body[nbody].xS,body[nbody].yS,body[nbody].zS);
   addvertex(nbody,1,body[nbody].xE,body[nbody].yS,body[nbody].zS);
   addvertex(nbody,2,body[nbody].xS,body[nbody].yE,body[nbody].zS);
   addvertex(nbody,3,body[nbody].xE,body[nbody].yE,body[nbody].zS);
   addvertex(nbody,4,body[nbody].xS,body[nbody].yS,body[nbody].zE);
   addvertex(nbody,5,body[nbody].xE,body[nbody].yS,body[nbody].zE);
   addvertex(nbody,6,body[nbody].xS,body[nbody].yE,body[nbody].zE);
   addvertex(nbody,7,body[nbody].xE,body[nbody].yE,body[nbody].zE);
end;

// загрузка значений вершин для источника
procedure TLaplas.LoadVertexPlane(plane : TPlane);
begin
   with plane do
   begin
      case iPlane of
       1 : // XY
          begin
             Vertexs[0].x:=xS; Vertexs[0].y:=yS; Vertexs[0].z:=zS;
             Vertexs[1].x:=xE; Vertexs[1].y:=yS; Vertexs[1].z:=zS;
             Vertexs[2].x:=xS; Vertexs[2].y:=yE; Vertexs[2].z:=zS;
             Vertexs[3].x:=xE; Vertexs[3].y:=yE; Vertexs[3].z:=zS;
          end;
       2 : // XZ
          begin
             Vertexs[0].x:=xS; Vertexs[0].y:=yS; Vertexs[0].z:=zS;
             Vertexs[1].x:=xE; Vertexs[1].y:=yS; Vertexs[1].z:=zS;
             Vertexs[2].x:=xS; Vertexs[2].y:=yS; Vertexs[2].z:=zE;
             Vertexs[3].x:=xE; Vertexs[3].y:=yS; Vertexs[3].z:=zE;
          end;
       3 : // YZ
          begin
             Vertexs[0].x:=xS; Vertexs[0].y:=yS; Vertexs[0].z:=zS;
             Vertexs[1].x:=xS; Vertexs[1].y:=yE; Vertexs[1].z:=zS;
             Vertexs[2].x:=xS; Vertexs[2].y:=yS; Vertexs[2].z:=zE;
             Vertexs[3].x:=xS; Vertexs[3].y:=yE; Vertexs[3].z:=zE;
          end;
      end;
   end;
end;

// вызывается при создании формы
procedure TLaplas.FormCreate(Sender: TObject);
var
   NewNode : TTreeNode;

begin
   breadfinish:=false;
   mlength:=1.0; // метры
   drawing:=false;
   // добавляет кубик
   lb:=1;
   SetLength(body,lb);
   body[0].xS:=-0.5;  body[0].xE:=0.5;  // отображение параметризованной пользователем
   body[0].yS:=-0.5;  body[0].yE:=0.5;  // геометрии
   body[0].zS:=-0.5;  body[0].zE:=0.5;  // в реальные числа
   body[0].sxS:='-0.5';  body[0].sxE:='0.5';  // параметризованная
   body[0].syS:='-0.5';  body[0].syE:='0.5';  // пользователем
   body[0].szS:='-0.5';  body[0].szE:='0.5';  // геометрия
   SetLength(body[0].Vertexs,8); // куб
   LoadVertexBrick(0); // заполнение значений вершин
   // рёбра
   Edgecubcreate(0);
   Alf:=-1.29; Bet:=1.26; // углы поворота
   SetLength(body[0].Vertext,8);
   Rotate;
   body[0].name:='cabinet';
   body[0].imatid:=0; // номер рабочего материала
   lmatmax:=2; // только два рабочих материала air и AlDuralumin
   SetLength(workmat,lmatmax); // выделяем память под рабочие материалы
   workmat[0].rho:=1.1614; // плотность воздуха
   workmat[0].cp:=1005; // удельная теплоёмкость воздуха
   workmat[0].lambda:=0.0261; // теплопроводность воздуха
   workmat[0].mu:=1.7894e-5; // коэффициент динамической вязкости
   workmat[0].ilawmu:=0; // const value
   // ограничители динамической вязкости.
   workmat[0].mumin:=workmat[0].mu;
   workmat[0].mumax:=workmat[0].mu;
   workmat[0].Amu:=1.0; // константы модельных зависимостей
   workmat[0].Bmu:=1.0;
   workmat[0].Cmu:=1.0;
   workmat[0].degreennmu:=1.0; // показатель степени
   workmat[0].beta_t:=0.003331; // коэффициент линейного температурного расширения
   body[0].power:=0.0; // мощность тепловыделения блока
   body[0].spower:='0.0'; // параметризованная пользователем мощность тепловыделения
   body[0].itype:=3; // FLUID
   workmat[0].namemat:='air';
   workmat[0].bBoussinesq:=0; // приближение Обербека-Буссинеска выключено
   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[0].name);
   NewNode.ImageIndex:=0;
   ls:=0; // количество источников тепла
   lw:=0; // количество твёрдых стенок
   m:=100; // масштабный коэффициент для визуализации
   lu:=0; // количество union-ов
   SetLength(myassembles,0);
   body[0].iunion:=0;
   body[0].bvisible:=true;
   workmat[0].blibmat:=0; // это материал определённый пользователем
   workmat[0].ilibident:=0; // это материал определённый пользователем

   workmat[1].rho:=2800; // плотность дюр-аллюминия
   workmat[1].cp:=480; // удельная теплоёмкость дюр-аллюминия
   workmat[1].lambda:=164; // теплопроводность дюр-аллюминия
   // следующие 8 значений не используются
   workmat[1].mu:=1.7894e-5; // воздух
   workmat[1].ilawmu:=0; // const value
   // ограничители динамической вязкости.
   workmat[1].mumin:=workmat[1].mu;
   workmat[1].mumax:=workmat[1].mu;
   workmat[1].Amu:=1.0; // константы модельных зависимостей
   workmat[1].Bmu:=1.0;
   workmat[1].Cmu:=1.0;
   workmat[1].degreennmu:=1.0; // показатель степени
   workmat[1].beta_t:=0.003331; // воздух
   workmat[1].bBoussinesq:=0; // приближение Обербека-Буссинеска выключено.
   workmat[1].namemat:='Al-Duralumin';
   workmat[1].blibmat:=0; // материал определяемый пользователем.
   workmat[1].ilibident:=100; // в библиотеке материалов не значится.

   // центры двух систем координат совпадают
   Oxc:=0.0;
   Oyc:=0.0;
   Ozc:=0.0;

   // библиотека твёрдых материалов
   lmatsol:=8;
   SetLength(libsolid,lmatsol);
   libsolid[0].name:='Al-Duralumin'; libsolid[0].lam:=164; libsolid[0].cp:=480; libsolid[0].rho:=2800;
   libsolid[1].name:='GaN'; libsolid[1].lam:=130; libsolid[1].cp:=700; libsolid[1].rho:=4000;
   libsolid[2].name:='SiC-4H'; libsolid[2].lam:=370; libsolid[2].cp:=690; libsolid[2].rho:=3210;
   libsolid[3].name:='Au80Sn20'; libsolid[3].lam:=57; libsolid[3].cp:=15; libsolid[3].rho:=14510;
   libsolid[4].name:='Cu'; libsolid[4].lam:=390; libsolid[4].cp:=390; libsolid[4].rho:=8930;
   libsolid[5].name:='MD-40'; libsolid[5].lam:=177; libsolid[5].cp:=540; libsolid[5].rho:=8900;
   libsolid[6].name:='GaAs'; libsolid[6].lam:=47; libsolid[6].cp:=330; libsolid[6].rho:=5300;
   libsolid[7].name:='Au'; libsolid[7].lam:=293; libsolid[7].cp:=126; libsolid[7].rho:=19300;
   // библиотека жидких материалов
   lmatfluid:=5;
   SetLength(libfluid,lmatfluid);
   libfluid[0].name:='Dry_Air'; libfluid[0].rho:=1.1614; libfluid[0].cp:=1005; libfluid[0].lam:=0.0261; libfluid[0].mu:=1.7894e-5; libfluid[0].beta_t:=3.665e-3;  // сухой воздух
   libfluid[1].name:='Hydrogen_H2'; libfluid[1].rho:=0.09; libfluid[1].cp:=14.26e3; libfluid[1].lam:=0.1861; libfluid[1].mu:=9.0e-6; libfluid[1].beta_t:=3.664e-3;  // водород
   libfluid[2].name:='Helium_He'; libfluid[2].rho:=0.18; libfluid[2].cp:=5.29e3; libfluid[2].lam:=0.152; libfluid[2].mu:=20.0e-6; libfluid[2].beta_t:=3.66e-3;  // гелий
   libfluid[3].name:='Argon_Ar'; libfluid[3].rho:=1.78; libfluid[3].cp:=0.52e3; libfluid[3].lam:=0.0177; libfluid[3].mu:=22.9e-6; libfluid[3].beta_t:=3.676e-3;  // аргон
   libfluid[4].name:='Carbon_dioxide'; libfluid[4].rho:=1.98; libfluid[4].cp:=1.0e3; libfluid[4].lam:=0.0186; libfluid[4].mu:=15.0e-6; libfluid[4].beta_t:=3.726e-3;  // углекислый газ, двуокись углерода, диоксид углерода

   // Инициализация параметров
   // сеточного генератора.
   inx:=23;
   iny:=23;
   inz:=23;
   // Сила тяжести.
   gx:=0.0;
   gy:=0.0;
   gz:=0.0;
   operatingtemperature:=20; // опорная температура град. С.

   // Информация об уравнениях которые придётся решать:
   egddata.itemper:=1; // решаем уравнение теплопроводности
   egddata.imaxflD:=1; // одна жидкая зона
   SetLength(egddata.myflmod,egddata.imaxflD); // одна жидкая зона
   // координаты опорной точки
   // Эта точка всегда находится внутри данной жидкости.
   egddata.myflmod[0].xc:=0.0;
   egddata.myflmod[0].yc:=0.0;
   egddata.myflmod[0].zc:=0.0;
   egddata.myflmod[0].iflow:=1; // считаем течение в данной жидкой зоне.
   // устанавливаем режим течения: 0 - ламинарный, 1 - турбулентный
   egddata.myflmod[0].iflowregime:=0; // режим течения ламинарный
   // модель турбулентности турбулентного режима
   // 0 - алгебраическая RANS модель Zero Equation Model (RANS)
   // 1 - модель Смагоринского (LES). (в неё как опция включена динамическая модель Германо 1991.)
   // 2 - RNG (LES).
   egddata.myflmod[0].iturbmodel:=0; // ZEM
   // модель Смагоринского
   egddata.myflmod[0].SmagConst:=0.151; // при Ck==1.8   (Ck соответствующая константа Колмогорова).
   egddata.myflmod[0].iDynamicStressGermano:=0; // модель Германо не используется
   egddata.myflmod[0].iLimitersCs:=0; // ограничения на константу Смагоринского не используются.
   egddata.myflmod[0].minCs:=-1.0e20; // данное значение не является ограничением.
   egddata.myflmod[0].maxCs:=1.0e23; // данное значение не является ограничением.
   egddata.myflmod[0].itypeFiltrGermano:=2; // фильтр Симпсона.
   egddata.myflmod[0].bSmagorinsky_Lilly:=true; // модель Смагоринского-Лиллу.
   egddata.myflmod[0].bfdelta:=true; // учёт неравномерности сетки
   egddata.myflmod[0].bsurface_roughness:=false; // не учитывать шероховатость стенки.
   egddata.myflmod[0].ipowerroughness:=2; // показатель степени в модели.
   egddata.myflmod[0].roughness:=10.0; // micron (шероховатость стенки в мкм).
   egddata.myflmod[0].bSwirlamendment:=true; // поправка для течений с кривизной линий тока.
   egddata.myflmod[0].rRimult:=1.0; // на эту величину будет домножаться турбулентное число Ричардсона.
   egddata.myflmod[0].bSelectiveSmagorinsky:=true; // добавляем избирательности в модель Смагоринского.
   egddata.myflmod[0].rSelectiveAngle:=15.0; // значение угла равное 15 градусов подобрано из DNS моделирования.
   egddata.myflmod[0].itypefiltr:=2; // фильтр Симпсона.

   ivar:=0; // нету переменных.
   SetLength(parametric,0); // нет переменных

   iltdp:=0; // пока нет ни одной таблицы.
   SetLength(listtablename,0); // пустой список имён файлов

   MainMemo.Lines.Add('Load material library: ');
   MainMemo.Lines.Add('SOLID : Al-Duralumin, GaN, SiC4H, Au80Sn20, Cu, MD40, GaAs, Au');
   MainMemo.Lines.Add('Gas : Dry_Air, Hydrogen_H2, Helium_He, Argon_Ar, Carbon_dioxide');
   MainMemo.Lines.Add('Done');
   breadfinish:=true;
end;

// событие OnPaint
procedure TLaplas.MainPaintBoxPaint(Sender: TObject);
const
    ax = 100;
    epsilon = 1e-20;  // для определения вещественного нуля
var
    L, i,j : Integer;
    xs1,ys1,xe1,ye1 : Integer;
    p,q : TVertex; // прорисовка осей координат
    xc, yc : Integer; // центральная точка на холсте
    s : string; // имя редактируемого элемента
    ch : Char;  // характеризующий префикс элемента
    bcontinue, bsel : Boolean; // нужно ли продолжать поиск

begin

   xc:= MainPaintBox.Width div 2;
   yc:= MainPaintBox.Height div 2;

   // вызывается при создании формы
   with MainPaintBox.Canvas do
   begin
     Brush.Color:=clWhite;

     Rectangle(0,0,Width, Height);

     // оси координат
     Pen.Color:=clGray;
     Pen.Style:=psDot;

     q.x:=ax; q.y:=0; q.z:=0;
     axis(q,p); // вращение
     MoveTo(120,yc-120); LineTo(round(120+p.x),round(yc-120+p.y));
     TextOut(round(120+p.x),round(yc-120+p.y),'X');
     q.x:=0; q.y:=ax; q.z:=0;
     axis(q,p);
     MoveTo(120,yc-120); LineTo(round(120 + p.x),round(yc-120 + p.y));
     TextOut(round(120+p.x),round(yc-120+p.y),'Y');
     q.x:=0; q.y:=0; q.z:=ax;
     axis(q,p);
     MoveTo(120,yc-120); LineTo(round(120 + p.x),round(yc-120 + p.y));
     TextOut(round(120+p.x),round(yc-120+p.y),'Z');

     // Прорисовка источников тепла:
     Pen.Color:=clGreen; // источники нарисуются зелёным
     Pen.Style:=psSolid;
     RotateSource; // вращение
     for j:=0 to (ls-1) do
     begin // проход по всем источникам тепла
        with source[j] do
        begin
           if (source[j].bvisible) then
           begin
               for i:=0 to 3 do
               begin // проход по всем рёбрам
                  xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                  ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                  MoveTo(xs1,ys1);
                  xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                  ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                  LineTo(xe1,ye1);
               end;
           end;
        end;
     end;

     // Прорисовка блоков:
     Pen.Color:=clBlue;
     Rotate; // вращение

     with (body[0]) do
     begin
        if (body[0].bvisible) then
        begin
           L:=Length(Edges);
           for i:=0 to (L-1) do
           begin
              xs1:=round(xc+m*Vertext[Edges[i].p1].x);
              ys1:=round(yc+m*Vertext[Edges[i].p1].y);
              MoveTo(xs1,ys1);
              xe1:=round(xc+m*Vertext[Edges[i].p2].x);
              ye1:=round(yc+m*Vertext[Edges[i].p2].y);
              LineTo(xe1,ye1);
           end;
        end;
     end;
     Pen.Color:=clBlack;
     for j:=1 to lb-1 do
     begin
        with (body[j]) do
        begin
           if (body[j].bvisible) then
           begin
              L:=Length(Edges);
              for i:=0 to (L-1) do
              begin
                 xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                 ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                 MoveTo(xs1,ys1);
                 xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                 ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                 LineTo(xe1,ye1);
              end;
           end;
        end;
     end;

     // прорисовка стенок
     Pen.Color:=clGray; // стенки нарисуются серым
     RotateWall; // вращение
     for j:=0 to (lw-1) do
     begin // проход по всем твёрдым стенкам
        with wall[j] do
        begin
           if (wall[j].bvisible) then
           begin

              if (bsymmetry or bpressure) then Pen.Color:=clYellow;
              if ((abs(Vx)>epsilon) or (abs(Vy)>epsilon) or (abs(Vz)>epsilon)) then
                    Pen.Color:=clFuchsia; // Сиреневый
              for i:=0 to 3 do
              begin // проход по всем рёбрам
                 xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                 ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                 MoveTo(xs1,ys1);
                 xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                 ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                 LineTo(xe1,ye1);
              end;
           end;

        end;
     end;

   bsel:=false;
   for i:=0 to MainTreeView.Items.Count-1 do
   begin
      if (MainTreeView.Items.Item[i].Selected) then
      begin
         bsel:=true;  // по крайней мере один элемент в дереве выделен
      end;
   end;

   if ( breadfinish and bsel) then
   begin
      // Мы прорисовываем геометрию в любое время кроме времени
      // в течение которого осуществляется построение модели

     // Выделение цветом выделенного в дереве элемента
     s:=MainTreeView.Selected.Text;
   if (length(s)<>0) then
   begin
      // символ ch может принимать значения : c, b, s, w, u, e-exit
      ch:='e';
      bcontinue:=true;
      // по всем блокам
      for i:=0 to (lb-1) do
      begin
         if (bcontinue and (length(body[i].name) = length(s)) and (Pos(body[i].name,s)=1)) then
         begin
            // найден блок :
            bcontinue:=false;
            itek:=i;
            if (i=0) then
            begin
               ch:='c';
            end
             else
            begin
               ch:='b';
            end;
         end;
      end;
      if (ch='e') then
      begin
         // по всем источникам
         for i:=0 to (ls-1) do
         begin
            if (bcontinue and (length(source[i].name) = length(s)) and (Pos(source[i].name,s)=1)) then
            begin
               // найден источник
               bcontinue:=false;
               ch:='s';
               itek:=i;
            end;
         end;
      end;
      if (ch='e') then
      begin
        // по всем твёрдым стенкам
        for i:=0 to (lw-1) do
       begin
          if (bcontinue and (length(wall[i].name) = length(s)) and (Pos(wall[i].name,s)=1)) then
          begin
             // найдена твёрдая стенка.
             bcontinue:=false;
             itek:=i;
             ch:='w';
          end;
       end;
   end;
   if (ch='e') then
   begin
      // по всем объединениям
      for i:=0 to (lu-1) do
      begin
         if (bcontinue and (length(myassembles[i].name) = length(s)) and (Pos(myassembles[i].name,s)=1)) then
         begin
            bcontinue:=false;
            ch:='u'; // двойной щелчек по объединению
            itek:=myassembles[i].identifire; // идентификатор объединения
            // внимание : обязательно должна быть справедлива связь itek=identifire=i+1;
            // т.е. номер объединения в списке должен быть на единицу меньше его идентификатора.
         end;
      end;
   end;

   Pen.Color:=clRed; // выделенный элемент покажем красным.
   Pen.Width:=2; // в трое более толстое перо
   case ch of
   'b' : begin
            with (body[itek]) do
            begin
               L:=Length(Edges);
               for i:=0 to (L-1) do
               begin
                  xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                  ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                  MoveTo(xs1,ys1);
                  xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                  ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                  LineTo(xe1,ye1);
               end;
            end;
         end;
   's' : begin
            with source[itek] do
            begin
               for i:=0 to 3 do
               begin // проход по всем рёбрам
                  xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                  ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                  MoveTo(xs1,ys1);
                  xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                  ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                  LineTo(xe1,ye1);
               end;
            end;
         end;
   'w' : begin
            with wall[itek] do
            begin
               for i:=0 to 3 do
               begin // проход по всем рёбрам
                 xs1:=round(xc+m*Vertext[Edges[i].p1].x);
                 ys1:=round(yc+m*Vertext[Edges[i].p1].y);
                 MoveTo(xs1,ys1);
                 xe1:=round(xc+m*Vertext[Edges[i].p2].x);
                 ye1:=round(yc+m*Vertext[Edges[i].p2].y);
                 LineTo(xe1,ye1);
               end;
            end;
         end;
   end;
   end;
   end;

   Pen.Width:=1; // стандартная ширина пера
   Pen.Color:=clBlack; // возвращение чёрного цвета

   end;
end;

// движение мыши
procedure TLaplas.MainPaintBoxMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   //a,b : Real;
   iAlf, iBet : Integer; // углы в градусах
   idx, idy : Integer;
begin
   if drawing then
   begin
      (*
      // углы меняются от -90 до +90 градусов
      a:=X - Width div 2;
      b:=Y - Height div 2;
      Alf:=ArcTan2(b,a);
      iAlf:=Round((Alf/3.141)*180);
      if ((iAlf>90) or (iAlf<-90)) then iAlf:=iAlf mod 90;
      Alf:=(iAlf/180)*3.141;
      Bet:=Sqrt(Sqr(a/30)+Sqr(b/30));
      iBet:=Round((Bet/3.141)*180);
      if ((iBet>90) or (iBet<-90)) then iBet:=iBet mod 90;
      Bet:=(iBet/180)*3.141;
      MainPaintBoxPaint(Sender);
      *)

      idx:=X-ixo;
      idy:=Y-iyo;
      if (idx>0) then Alf:=Alf+3.141/180; // добавляем один градус
      if (idx<0) then Alf:=Alf-3.141/180; // вычитаем один градус
      iAlf:=Round((Alf/3.141)*180);
      if ((iAlf>90) or (iAlf<-90)) then iAlf:=iAlf mod 90;
      Alf:=(iAlf/180)*3.141;

      if (idy>0) then Bet:=Bet+3.141/180; // добавляем один градус
      if (idy<0) then Bet:=Bet-3.141/180; // вычитаем один градус
      iBet:=Round((Bet/3.141)*180);
      if ((iBet>90) or (iBet<-90)) then iBet:=iBet mod 90;
      Bet:=(iBet/180)*3.141;

      ixo:=X; iyo:=Y;
      MainPaintBoxPaint(Sender);

   end;
end;

// левая кнопка мыши нажата
procedure TLaplas.MainPaintBoxMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   if (Button = mbLeft) then
   begin
      drawing:=true;
      // запоминаем начальную позицию мыши
      ixo:=X;
      iyo:=Y;
   end
    else
   begin
       if (Button = mbRight) then
       begin
          // Нажата правая кнопка мыши
          // запоминаем начальную позицию мыши
          ixo:=X;
          iyo:=Y;
       end;
   end;
end;

// левая кнопка мыши отпущена
procedure TLaplas.MainPaintBoxMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
const
     epsilon = 0.01;
var
    dxz, dyz, dzz : Real;
begin
   if (Button = mbLeft) then
   begin
      drawing:=false;
   end
    else
   begin
      if (Button = mbRight) then
      begin
         dxz:=0.0;
         dyz:=0.0;
         dzz:=0.0;
         //  Нажата правая кнопка мыши
         if (abs(cos(Alf))>0.01) then
         begin
            //dxz:=(-(X-ixo)/m)/cos(Alf)-((-(X-ixo)/m)*sin(Alf)/cos(Alf)-(-(Y-iyo)/m))*sin(Alf);
            dxz:=(-(Y-iyo)/m)/cos(Alf)-((-(Y-iyo)/m)*sin(Alf)/cos(Alf)-((X-ixo)/m))*sin(Alf);
         end;
         if (abs(cos(Bet))>0.01) then
         begin
             //dyz:=((-(X-ixo)/m)*sin(Alf)-(-(Y-iyo)/m)*cos(Alf))/cos(Bet);
             dyz:=((-(Y-iyo)/m)*sin(Alf)-((X-ixo)/m)*cos(Alf))/cos(Bet);
            if (abs(sin(Bet))>0.01) then
            begin
               //dzz:=((-(X-ixo)/m)*sin(Alf)-(-(Y-iyo)/m)*cos(Alf))/sin(Bet);
               dzz:=((-(Y-iyo)/m)*sin(Alf)-((X-ixo)/m)*cos(Alf))/sin(Bet);
            end
             else
            begin
               // плоскость XY
               dzz:=0.0;
               dxz:=-(X-ixo)/m;
               dyz:=-(Y-iyo)/m;
            end;
         end
          else
         begin
            // Угол Bet равен плюс или минус 90 градусов

            if (abs(Alf)<0.001) then
            begin
               // Alf=0.0
               // Оси x совпадают.
               if (Bet>0.0) then
               begin
                  dxz:=-(X-ixo)/m;
                  dyz:=0.0;
                  dzz:=(Y-iyo)/m;
               end
                else
               begin
                  dxz:=-(X-ixo)/m;
                  dyz:=0.0;
                  dzz:=-(Y-iyo)/m;
               end;
            end
             else
            begin

               if (Bet > 0.0) then
               begin
                  if (abs(cos(Alf))<0.01) then
                  begin
                     if (Alf<0.0) then
                     begin
                        // Alf = -90 град С
                        dxz:=0.0;
                        dyz:=-(X-ixo)/m;;
                        dzz:=(Y-iyo)/m;
                     end
                      else
                     begin
                        dxz:=0.0;
                        dyz:=(X-ixo)/m;;
                        dzz:=(Y-iyo)/m;
                     end;
                  end;
               end
                else
               begin
                 if (Alf<0.0) then
                  begin
                     // Alf = -90 град С
                     dxz:=0.0;
                     dyz:=-(X-ixo)/m;;
                     dzz:=-(Y-iyo)/m;
                  end
                   else
                  begin
                     dxz:=0.0;
                     dyz:=(X-ixo)/m;;
                     dzz:=-(Y-iyo)/m;
                  end;
             end;
            end;

         end;

         Oxc:=Oxc+dxz;
         Oyc:=Oyc+dyz;
         Ozc:=Ozc+dzz;
         MainPaintBoxPaint(Sender);
      end;
   end;
end;

// Увеличение изображения в окошке
procedure TLaplas.BzoompClick(Sender: TObject);
begin
   // колёсико движется вверх
    if (m>11) then
    begin
        m:=m+10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m+0.1;
       end
       else
       begin
          if (m>0.011) then
          begin
             m:=m+0.01; // ZOOM
          end
           else
          begin
             m:=m+0.001;
          end;
       end;
    end;
   MainPaintBoxPaint(Sender);
end;

// Уменьшение изображения в окошке
procedure TLaplas.BzoommClick(Sender: TObject);
begin
   if (m>11) then
    begin
        m:=m-10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m-0.1;
       end
        else
       begin
          if (m>0.011) then
          begin
             m:=m-0.01;
          end
           else
          begin
             m:=m-0.001;
          end;
       end;
    end;
   MainPaintBoxPaint(Sender);
end;

// инициализация формы редактирования блока
procedure TLaplas.initializeaddblockform;
const
    epsilon = 1e-20;  // для определения вещественного нуля
begin
   with body[itek] do
   begin
      // координаты блока
      AddBlockForm.ExS.Text:=sxS;
      AddBlockForm.EyS.Text:=syS;
      AddBlockForm.EzS.Text:=szS;
      AddBlockForm.ExE.Text:=sxE;
      AddBlockForm.EyE.Text:=syE;
      AddBlockForm.EzE.Text:=szE;

      AddBlockForm.Ename.Text:=name;
      AddBlockForm.RadioGroupType.ItemIndex:=itype-1;
      AddBlockForm.CBselectAction.ItemIndex:=0; // Edit Current Material
      if (Laplas.workmat[imatid].blibmat=0) then
      begin
         AddBlockForm.RGSelect.ItemIndex:=1; // материал определяемый пользователем
      end
      else AddBlockForm.RGSelect.ItemIndex:=0; // библиотечный материал
      case itype of
        1 : begin
               // SOLID
               AddBlockForm.GroupBoxPropBl.Visible:=true; // Форма со свойствами видна
               AddBlockForm.LMN.Caption:=workmat[imatid].namemat;
               AddBlockForm.EditPower.Text:=spower; // мощность параметризованная пользователем
            end;
        2 : begin
              // HOLLOW
               AddBlockForm.GroupBoxPropBl.Visible:=false; // форма со свойствами невидна
            end;
        3 : begin
               // FLUID
               AddBlockForm.GroupBoxPropBl.Visible:=true; // Форма со свойствами видна
               AddBlockForm.LMN.Caption:=workmat[imatid].namemat;
               AddBlockForm.EditPower.Text:=spower; // мощность параметризованная пользователем
            end;
      end;

   end;
end;  // initializeaddblockform

// инициализация формы редактирования источника тепла
procedure TLaplas.Initializeaddsourceform;
const
    epsilon = 1e-20; // для определения вещественного нуля
var
  i : Integer; // счётчик.
begin
   with source[itek] do
   begin
      AddSourceForm.Epower.Text:=spower; // мощность параметризованная пользователем

      case itempdep of
         0 : begin
                // константа
                AddSourceForm.Ptempdefloc.Visible:=false;
                AddSourceForm.Label1.Caption:='power';
                AddSourceForm.LW.Caption:='W';
                AddSourceForm.RGpowertype.ItemIndex:=0; // const
             end;
         1 : begin
                // задана таблично.
                AddSourceForm.Ptempdefloc.Visible:=true;
                AddSourceForm.Label1.Caption:='mult power';
                AddSourceForm.LW.Caption:='';
                AddSourceForm.CBtableid.Clear;
                for i:=0 to iltdp-1 do
                begin
                     AddSourceForm.CBtableid.Items.Add(IntToStr(i));
                end;
                AddSourceForm.CBtableid.ItemIndex:=id_table;
                AddSourceForm.EOperoffsetdrain.Text:=soperatingoffsetdrain;
                AddSourceForm.RGpowertype.ItemIndex:=1; // temperature depend
             end;
      end;

      AddSourceForm.RadioGroupPlane.ItemIndex:=iPlane-1;
      AddSourceForm.Ename.Text:=name;

      // координаты источника тепла :
      AddSourceForm.ExS.Text:=sxS;
      AddSourceForm.EyS.Text:=syS;
      AddSourceForm.EzS.Text:=szS;
      AddSourceForm.ExE.Text:=sxE;
      AddSourceForm.EyE.Text:=syE;
      AddSourceForm.EzE.Text:=szE;
   end;
end;

// инициализация формы редактированния стенки
procedure TLaplas.Initializeaddwallform;
 const
    epsilon = 1e-20; // для определения вещественного нуля
begin
   with wall[itek] do
   begin
      AddWallForm.RadioGroupBonConTemp.ItemIndex:=family-1;
      if (family=1) then
      begin
         // условие Дирихле
         AddWallForm.PaneltemperatureBC.Visible:=true;
         AddWallForm.Etemp.Text:=FloatToStr(Tamb);
      end
      else
      begin
         // однородное условие Неймана
         AddWallForm.PaneltemperatureBC.Visible:=false;
      end;
      AddWallForm.RadioGroupPlane.ItemIndex:=iPlane-1;
      AddWallForm.Ename.Text:=name;

      // координаты твёрдой стенки.
      AddWallForm.ExS.Text:=sxS;
      AddWallForm.EyS.Text:=syS;
      AddWallForm.EzS.Text:=szS;
      AddWallForm.ExE.Text:=sxE;
      AddWallForm.EyE.Text:=syE;
      AddWallForm.EzE.Text:=szE;

      if (bpressure) then
      begin
         // задано давление
         AddWallForm.GroupBoxpressure.Visible:=true;
         AddWallForm.GroupBoxvelcomp.Visible:=false;
         AddWallForm.RadioGroupflowtype.ItemIndex:=1;
      end;
      if (bsymmetry) then
      begin
         // граница симметрии
         AddWallForm.GroupBoxpressure.Visible:=false;
         AddWallForm.GroupBoxvelcomp.Visible:=false;
         AddWallForm.RadioGroupflowtype.ItemIndex:=2;
      end;
      if (not(bpressure) and not(bsymmetry)) then
      begin
         // задана нормальная компонента скорости
         AddWallForm.GroupBoxpressure.Visible:=false;
         AddWallForm.GroupBoxvelcomp.Visible:=true;
         AddWallForm.RadioGroupflowtype.ItemIndex:=0;
      end;
      AddWallForm.EditVx.Text:=FloatToStr(Vx);
      AddWallForm.EditVy.Text:=FloatToStr(Vy);
      AddWallForm.EditVz.Text:=FloatToStr(Vz);
      AddWallForm.Editpress.Text:=FloatToStr(P);

   end;
end;


// добавляет блок
procedure TLaplas.SPBAddBlockClick(Sender: TObject);
var
   hx,hy,hz : real;
   NewNode : TTreeNode;
begin
   inc(lb); itek:=lb-1;
   SetLength(body,lb); // выделение памяти под дополнительный блок
   hx:=abs(body[0].xE-body[0].xS)/6.0;
   hy:=abs(body[0].yE-body[0].yS)/6.0;
   hz:=abs(body[0].zE-body[0].zS)/6.0;
   body[itek].xS:=body[0].xS+2*hx;  body[itek].xE:=body[0].xE-2*hx;  // числовые значения
   body[itek].yS:=body[0].yS+2*hy;  body[itek].yE:=body[0].yE-2*hy;  // координат
   body[itek].zS:=body[0].zS+2*hz;  body[itek].zE:=body[0].zE-2*hz;
   body[itek].sxS:=FloatToStr(body[0].xS+2*hx);  body[itek].sxE:=FloatToStr(body[0].xE-2*hx);  // параметризованные
   body[itek].syS:=FloatToStr(body[0].yS+2*hy);  body[itek].syE:=FloatToStr(body[0].yE-2*hy);  // значения
   body[itek].szS:=FloatToStr(body[0].zS+2*hz);  body[itek].szE:=FloatToStr(body[0].zE-2*hz);  // координат
   SetLength(body[itek].Vertexs,8); // куб
   LoadVertexBrick(itek); // заполнение значений вершин
   // рёбра
   Edgecubcreate(itek);
   SetLength(body[itek].Vertext,8);
   Rotate;
   body[itek].itype:=1; // SOLID
   body[itek].name:='block'+IntToStr(itek);
   body[itek].imatid:=1; // Дюраль Аллюминий.
   body[itek].power:=0.0; // нет тепловыделения
   body[itek].spower:='0.0'; // нет тепловыделения
   body[itek].iunion:=0;
   body[itek].bvisible:=true;
   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[itek].name);
   NewNode.ImageIndex:=1;  // номер картинки
   NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
   MainPaintBoxPaint(Sender);
   initializeaddblockform;
   AddBlockForm.ShowModal;
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=body[itek].name;
   MainPaintBoxPaint(Sender);
end;


// по нажатию на кнопку добавляется источник тепла
procedure TLaplas.DaddSourceClick(Sender: TObject);
var
   hx,hy : real;
   NewNode : TTreeNode;
begin
   inc(ls); itek:=ls-1;
   SetLength(source,ls); // выделение памяти под дополнительный источник
   hx:=abs(body[0].xE-body[0].xS)/6;
   hy:=abs(body[0].yE-body[0].yS)/6;
   source[itek].iPlane:=1;//XY
   source[itek].xS:=body[0].xS+2*hx;  source[itek].xE:=body[0].xE-2*hx; // числовые
   source[itek].yS:=body[0].yS+2*hy;  source[itek].yE:=body[0].yE-2*hy; // значения
   source[itek].zS:=0.5*(body[0].zS+body[0].zE); source[itek].zE:=0.5*(body[0].zS+body[0].zE);  // координат
   source[itek].sxS:=FloatToStr(body[0].xS+2*hx);  source[itek].sxE:=FloatToStr(body[0].xE-2*hx);  // параметризованные
   source[itek].syS:=FloatToStr(body[0].yS+2*hy);  source[itek].syE:=FloatToStr(body[0].yE-2*hy);  // значения
   source[itek].szS:=FloatToStr(0.5*(body[0].zS+body[0].zE)); source[itek].szE:=FloatToStr(0.5*(body[0].zS+body[0].zE)); // координат
   SetLength(source[itek].Vertexs,4); // источник
   LoadVertexPlane(source[itek]); // задаёт координаты вершин
   //Рёбра
   EdgePlaneCreate(source[itek]);
   SetLength(source[itek].Vertext,4);
   RotateSource;
   source[itek].name:='source'+IntToStr(ls); // задаёт уникальное имя объекта
   source[itek].itempdep:=0; // мощность константа
   source[itek].id_table:=0;
   source[itek].operatingoffsetdrain:=28.0; // Vg  напряжение на сьтоке в вольтах.
   source[itek].soperatingoffsetdrain:='28.0'; // Vg text
   source[itek].Power:=0.0; // тепло не выделяется
   source[itek].spower:='0.0'; // тепло не выделяется
   // в гидродинамическом плане это твёрдая стенка
   source[itek].Vx:=0.0;
   source[itek].Vy:=0.0;
   source[itek].Vz:=0.0;
   source[itek].P:=0.0;
   source[itek].bpressure:=false;
   source[itek].bsymmetry:=false;
   source[itek].iunion:=0;
   source[itek].bvisible:=true;
   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,source[itek].name);
   NewNode.ImageIndex:=2; // загружает картинку источника тепла
   NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
   MainPaintBoxPaint(Sender);
   Initializeaddsourceform; // инициализирует форму перед запуском
   AddSourceForm.ShowModal;
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=source[itek].name;
   MainPaintBoxPaint(Sender);
end;


// устанавливаем плоскость XY
procedure TLaplas.SpeedButtonplanexyClick(Sender: TObject);
begin
   Alf:=0.0;
   Bet:=0.0;
   MainPaintBoxPaint(Sender);
end;

// закрывает приложение
procedure TLaplas.Close1Click(Sender: TObject);
begin
   Close;
end;

// записывает геометрию в текстовый файл.
procedure TLaplas.write1Click(Sender: TObject);
var
   filename : string; // имя записываемого файла
   f : TStringList; // переменная типа объект TStringList
   s : String; // текущая рабочая строка
   i : Integer; // текущий номер блока или источника при записи

begin
   // записывает файл с геометрией задачи
   filename:='';
   if not InputQuery('Ввод имени', 'Введите имя записываемого файла',filename)
   then exit;

   f:=TStringList.Create();

   s:='m='+FloatToStr(m);
   s:=s+' :'+FloatToStr(gx)+' :'+FloatToStr(gy)+' :'+FloatToStr(gz)+' :';
   s:=s+IntToStr(inx)+' :'+IntToStr(iny)+' :'+IntToStr(inz)+' :';
   s:=s+FloatToStr(operatingtemperature)+' :';
   f.Add(s); // масштабирующий коэффициент
   // единицы длины:
   s:='length=';
   s:=s+IntToStr(ComboBoxlength.ItemIndex); // запоминаем выбранные единицы длины
   f.Add(s); // единицы длины

   // Список таблиц в которых прописана зависимость
   // рассеиваемой мощности  от максимальной температуры и смещения стока.
   s:='ltdp=';
   s:=s+IntToStr(iltdp); // количество различных таблиц
   f.Add(s);
   for i:=0 to iltdp-1 do
   begin
      f.Add(listtablename[i]); // имя файла с таблицей
   end;

   // параметры объединений :
   s:='lu='+IntToStr(lu);
   f.Add(s);
   for i:=0 to lu-1 do
   begin
       // имя объединения, идентификатор объединения.
       s:=myassembles[i].name+' :'+IntToStr(myassembles[i].identifire)+' :';
       f.Add(s);
   end;

   // количество рабочих переменных :
   s:='ivarmax='+IntToStr(ivar);
   f.Add(s);
   for i:=0 to (ivar-1) do
   begin
      // каждая переменная записывается в отдельной строке.
      s:=parametric[i].svar+' :'+parametric[i].sval+' :';
      f.Add(s);
   end;

   // количество рабочих материалов: (solid and fluid).
   s:='lmatmax='+IntToStr(lmatmax);
   f.Add(s);
   for i:=0 to (lmatmax-1) do
   begin
      s:=workmat[i].namemat+' :'; // имя материала
      // плотность, теплоёмкость и теплопроводность.
      s:=s+FloatToStr(workmat[i].rho)+ ' :'; // плотность
      s:=s+FloatToStr(workmat[i].cp)+ ' :'; // теплоёмкость
      s:=s+FloatToStr(workmat[i].lambda)+ ' :'; // теплопроводность
      s:=s+FloatToStr(workmat[i].mu)+ ' :'; // динамическая вязкость
      s:=s+FloatToStr(workmat[i].beta_t)+ ' :'; // коэффициент линейного температурного расширения
      s:=s+IntToStr(workmat[i].blibmat)+' :'; // является ли материал библиотечным ?
      s:=s+IntToStr(workmat[i].ilibident)+' :'; // идентификатор библиотечного материаала
      s:=s+IntToStr(workmat[i].bBoussinesq)+' :'; // использовать приближение Обербека-Буссинеска или нет.
      s:=s+IntToStr(workmat[i].ilawmu)+' :';  // номер закона для динамической вязкости
      s:=s+FloatToStr(workmat[i].mumin)+' :'; // ограничители
      s:=s+FloatToStr(workmat[i].mumax)+' :'; // динамической вязкости.
      s:=s+FloatToStr(workmat[i].Amu)+' :';   // параметры
      s:=s+FloatToStr(workmat[i].Bmu)+' :';   // модельных
      s:=s+FloatToStr(workmat[i].Cmu)+' :';   // зависимостей
      s:=s+FloatToStr(workmat[i].degreennmu)+' :'; // показатель степени
      f.Add(s);
   end;

   // запись размеров кабинета
   s:='cabinet=';
   with (body[0]) do
   begin
      s:=s+sxS+' :';  // записываются
      s:=s+syS+' :';  // параметризованные
      s:=s+szS+' :';  // пользователем значения
      s:=s+sxE+' :';
      s:=s+syE+' :';
      s:=s+szE+' :';
      s:=s+IntToStr(imatid)+' :'; // идентификатор рабочего материала.
      s:=s+spower+ ' :'; // параметризованная пользователем мощность тепловыделения блока
      s:=s+IntToStr(itype)+ ' :'; // тип блока : SOLID, HOLLOW, FLUID.
      s:=s+IntToStr(iunion)+ ' :'; // номер объединения
   end;
   f.Add(s);
   // количество блоков:
   s:='lb='+IntToStr(lb);
   f.Add(s);
   // цикл по всем блокам :
   for i:=1 to (lb-1) do
   begin
      with (body[i]) do
      begin
         s:=name+'=';
         s:=s+sxS+' :';  // записываются
         s:=s+syS+' :';  // параметризованные
         s:=s+szS+' :';  // пользователем значения
         s:=s+sxE+' :';
         s:=s+syE+' :';
         s:=s+szE+' :';
         s:=s+IntToStr(imatid)+' :'; // идентификатор рабочего материала.
         s:=s+spower+ ' :'; // параметризованная пользователем мощность тепловыделения блока
         s:=s+IntToStr(itype)+ ' :'; // тип блока : SOLID, HOLLOW, FLUID.
         s:=s+IntToStr(iunion)+ ' :'; // номер объединения
      end;
      f.Add(s);
   end;
   // количество источников тепла:
   s:='ls='+IntToStr(ls);
   f.Add(s);
   // цикл по всем источникам тепла:
   for i:=0 to (ls-1) do
   begin
      with (source[i]) do
      begin
         s:=name+'=';
         // мощность тепловыделения, плоскость и координаты:
         s:=s+spower+' :';  // параметризованная пользователем мощность
         s:=s+IntToStr(itempdep)+' :';
         s:=s+IntToStr(id_table)+' :'; // идентификатор таблицы задания мощностей
         s:=s+soperatingoffsetdrain+' :'; // смещение стока.
         
         s:=s+IntToStr(iPlane)+' :'; // плоскость в которой лежит источник тепла
         s:=s+sxS+' :';  // записываются
         s:=s+syS+' :';  // параметризованные
         s:=s+szS+' :';  // пользователем значения
         s:=s+sxE+' :';
         s:=s+syE+' :';
         s:=s+szE+' :';
         s:=s+IntToStr(iunion)+ ' :'; // номер объединения
      end;
      f.Add(s);
   end;
   // количество твёрдых стенок
   // твёрдая стенка может быть только границей кабинета.
   s:='lw='+IntToStr(lw);
   f.Add(s);
   // цикл по всем твёрдым стенкам:
   for i:=0 to (lw-1) do
   begin
      with (wall[i]) do
      begin
         s:=name+'='; // имя
         // тип краевого условия, температура и тепловой поток,
         //  плоскость и координаты:
         s:=s+IntToStr(family)+' :'; // тип краевого условия
         s:=s+FloatToStr(Tamb)+' :'; // температура на идеальном теплооотводе
         s:=s+FloatToStr(HF)+' :'; // для граничного условия 2 или 3 рода.
         if (bsymmetry) then s:=s+'1 :' else s:=s+'0 :';
         if (bpressure) then s:=s+'1 :' else s:=s+'0 :';
         s:=s+FloatToStr(Vx)+' :';
         s:=s+FloatToStr(Vy)+' :';
         s:=s+FloatToStr(Vz)+' :';
         s:=s+FloatToStr(P)+' :';
         s:=s+IntToStr(iPlane)+' :'; // плоскость в которой лежит источник тепла
         s:=s+sxS+' :';  // записываются
         s:=s+syS+' :';  // параметризованные
         s:=s+szS+' :';  // пользователем
         s:=s+sxE+' :';  // значения
         s:=s+syE+' :';
         s:=s+szE+' :';
         s:=s+IntToStr(iunion)+ ' :'; // номер объединения
      end;
      f.Add(s);
   end;

   // Запись информации о решаемых уравнениях.
   s:=IntToStr(egddata.itemper)+' :'+IntToStr(egddata.imaxflD)+' :';
   f.Add(s);
   for i:=0 to egddata.imaxflD-1 do
   begin
      s:=FloatToStr(egddata.myflmod[i].xc)+' :'+FloatToStr(egddata.myflmod[i].yc)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].zc)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iflow)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iflowregime)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iturbmodel)+' :';
      // параметры модели Смагоринского
      s:=s+FloatToStr(egddata.myflmod[i].SmagConst)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iDynamicStressGermano)+' :';
      s:=s+IntToStr(egddata.myflmod[i].iLimitersCs)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].minCs)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].maxCs)+' :';
      s:=s+IntToStr(egddata.myflmod[i].itypeFiltrGermano)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].roughness)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].rRimult)+' :';
      s:=s+FloatToStr(egddata.myflmod[i].rSelectiveAngle)+' :';
      s:=s+IntToStr(egddata.myflmod[i].ipowerroughness)+' :';
      s:=s+IntToStr(egddata.myflmod[i].itypefiltr)+' :';
      // учёт неравномерности сетки.
      if (egddata.myflmod[i].bfdelta) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // модель Смагоринского-Лиллу.
      if (egddata.myflmod[i].bSmagorinsky_Lilly) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // учёт шероховатости стенки.
      if (egddata.myflmod[i].bsurface_roughness) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // течения с кривизной линий тока
      if (egddata.myflmod[i].bSwirlamendment) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      // модель Selective Smagorinsky
      if (egddata.myflmod[i].bSelectiveSmagorinsky) then
      begin
         s:=s+'1 :';
      end
      else
      begin
         s:=s+'0 :';
      end;
      f.Add(s);
   end;

   f.SaveToFile(filename+'.txt'); // сохранение результата
   f.Free;
   MainMemo.Lines.Add('файл '+filename+'.txt  успешно записан.');
end;

// считывает информацию о жидкой зоне
procedure TLaplas.myreadfluidzone(var myflmod : TmyFLUIDmodel; s : string);
var
    sub : string;
    itest : Integer;
begin
   // xc
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.xc:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yc
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.yc:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zc
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.zc:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iflow
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iflow:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iflowregime
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iflowregime:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // iturbmodel
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iturbmodel:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // постоянная Смагоринского.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.SmagConst:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // включать ли модель Германо 1991 года.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iDynamicStressGermano:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли заданные пользователем ограничения на постоянную Смагоринского.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.iLimitersCs:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // ограничение на постоянную Смагоринского снизу.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.minCs:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // ограничение на постоянную Смагоринского сверху.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.maxCs:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // тип фильтра который используется в модели Германо.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.itypeFiltrGermano:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // roughness
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.roughness:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // множитель корректирующий турбулентное число Ричардсона
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.rRimult:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // пороговое значение угла в модели Selective Smagorinsky
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.rSelectiveAngle:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // показатель степени в модели учёта шероховатости стенки
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.ipowerroughness:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // тип фильтра
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   myflmod.itypefiltr:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли поправку на неравномерность сетки.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
       myflmod.bfdelta:=true;
   end
   else
   begin
      myflmod.bfdelta:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли модель Смагоринского-Лиллу
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
       myflmod.bSmagorinsky_Lilly:=true;
   end
   else
   begin
      myflmod.bSmagorinsky_Lilly:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли шероховатость на стенке
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
      myflmod.bsurface_roughness:=true;
   end
   else
   begin
      myflmod.bsurface_roughness:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли поправку для течений с кривизной линий тока
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
      myflmod.bSwirlamendment:=true;
   end
   else
   begin
      myflmod.bSwirlamendment:=false;
   end;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // учитывать ли избирательность в модели Смагоринского.
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   itest:=StrToInt(sub);
   if (itest=1) then
   begin
      myflmod.bSelectiveSmagorinsky:=true;
   end
   else
   begin
      myflmod.bSelectiveSmagorinsky:=false;
   end;
end;

// считывает параметры материала
procedure TLaplas.myreadmaterial(var workmat : TMYMat; s : string);
var
   sub : string;
begin
   // имя материала из которого состоит блок
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.namemat:=sub;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // плотность
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.rho:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // теплоёмкость
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.cp:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // теплопроводность
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.lambda:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // динамическая вязкость
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.mu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // коэффициент линейного температурного расширения
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   workmat.beta_t:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // материал пользователя или из библиотеки.
   workmat.blibmat:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // идентификатор библиотечного материала.
   workmat.ilibident:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // Приближение Обербека-Буссинеска
   workmat.bBoussinesq:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // закон изменения динамической вязкости.
   workmat.ilawmu:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // минимальное значение динамической вязкости.
   workmat.mumin:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // максимальное значение динамической вязкости.
   workmat.mumax:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // константа модели для вязкости.
   workmat.Amu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // константа модели для вязкости.
   workmat.Bmu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // константа модели для вязкости.
   workmat.Cmu:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   // показатель степени для неньютоновских жидкостей
   workmat.degreennmu:=StrToFloat(sub);
end;

// считывает параметры для блока
procedure TLaplas.myreadbody(var body : TBody; s : string);
var
   sub : string;
   bOk : Boolean;

begin
   bOk:=true; // инициализация
   body.name:=Copy(s,1,Pos('=',s)-1);
   s:=Copy(s,Pos('=',s)+1,length(s));
   // xS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sxS:=sub;
   if (bOk) then body.xS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.syS:=sub;
   if (bOk) then body.yS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.szS:=sub;
   if (bOk) then body.zS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.sxE:=sub;
   if (bOk) then body.xE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.syE:=sub;
   if (bOk) then body.yE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.szE:=sub;
   if (bOk) then body.zE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // imatid
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.imatid:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // мощность тепловыделения на блок
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.spower:=sub;
   if (bOk) then body.power:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // тип блока
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.itype:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // идентификатор объединения
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   body.iunion:=StrToInt(sub);
end;

// читает координаты плоского элемента
procedure TLaplas.myreadplane(var plane : TPlane; s : string);
var
   sub : string;
   bOk : Boolean;
begin
   bOk:=true; // признак корректности ввода.
   // iPlane
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.iPlane:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.sxS:=sub;
   if (bOk) then plane.xS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.syS:=sub;
   if (bOk) then plane.yS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zS
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.szS:=sub;
   if (bOk) then plane.zS:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // xE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.sxE:=sub;
   if (bOk) then plane.xE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // yE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.syE:=sub;
   if (bOk) then plane.yE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // zE
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.szE:=sub;
   if (bOk) then plane.zE:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // идентификатор объединения
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   plane.iunion:=StrToInt(sub);
end;

// считывает параметры для источника тепла
procedure TLaplas.myreadsource(var source :  TPlane; s : string);
var
   sub : string;
   bOk : Boolean;

begin
   source.name:=Copy(s,1,Pos('=',s)-1);
   s:=Copy(s,Pos('=',s)+1,length(s));
   // Power
   bOk:=true;
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.spower:=sub;
   if (bOk) then source.Power:=FormVariables.my_real_convert(sub,bOk);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.itempdep:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.id_table:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   source.soperatingoffsetdrain:=sub;
   bOk:=true;
   if (bOk) then source.operatingoffsetdrain:=FormVariables.my_real_convert(sub,bOk);

   s:=Copy(s,Pos(':',s)+1,length(s));
   myreadplane(source,s);
   // устанавливаем твёрдую стенку в гидродинамическом плане
   source.Vx:=0.0;
   source.Vy:=0.0;
   source.Vz:=0.0;
   source.P:=0.0;
   source.bpressure:=false;
   source.bsymmetry:=false;
end; // myreadsource

// считывает параметры твёрдой стенки
procedure TLaplas.myReadWall(var wall : TPlane; s : string);
var
    sub : string;
    ikey : Integer;
begin
   wall.name:=Copy(s,1,Pos('=',s)-1);
   s:=Copy(s,Pos('=',s)+1,length(s));
   // family
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.family:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Tamb
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Tamb:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Heat Flux
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.HF:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // bsymmetry
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ikey:=StrToInt(sub);
   if (ikey=1) then wall.bsymmetry:=true else wall.bsymmetry:=false;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // bpressure
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   ikey:=StrToInt(sub);
   if (ikey=1) then wall.bpressure:=true else wall.bpressure:=false;
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Vx
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Vx:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Vy
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Vy:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // Vz
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.Vz:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // P
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   wall.P:=StrToFloat(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   // остальные параметры по умолчанию:
   wall.spower:='0.0';
   wall.Power:=0.0;
   myreadplane(wall,s);
end;

// считываем входной файл :
procedure TLaplas.read1Click(Sender: TObject);
var
   f : TStringList; // переменная типа объект TStringList
   i,j, imlength : Integer; // счётчик
   s,sub : string; // анализируемая строка из файла
   NewNode, Nodeloc, Noddy : TTreeNode; // узел дерева элементов
   flagunion : array of Boolean; //  было ли создано объединение
   SearchTarget : String;
   Searching : Boolean;

begin

   breadfinish:=false;
   f:=TStringList.Create();
   // читает файл с геометрией и создаёт тепловую модель
   // считывает файл с компьютерной программой
   OpenDialog1.Filter := 'Текстовые файлы|*.txt';
   if OpenDialog1.Execute and FileExists(OpenDialog1.FileName) then
       // Результат успешный - пользователь выбрал файл.
       // Загружаем файл .
       f.LoadFromFile(OpenDialog1.FileName);
   i:=0; // маркер на начало файла
   // начинаем считывание файла
   s:=f.Strings[i]; inc(i);
   sub:=Copy(s,1,Pos(':',s)-1);
   m:=StrToFloat(Copy(sub,Pos('m=',sub)+2,length(sub)));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   gx:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   gy:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   gz:=StrToFloat(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   inx:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   iny:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   inz:=StrToInt(Trim(sub));
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Copy(s,1,Pos(':',s)-1);
   operatingtemperature:=StrToFloat(Trim(sub)); //  считывание Operating Temperature
   s:=f.Strings[i]; inc(i);
   imlength:=StrToInt(Copy(s,Pos('length=',s)+7,length(s)));
   ComboBoxlength.ItemIndex:=imlength; // выставляем считанные единицы длины
   case imlength of
    0 : begin
           // m
           mlength:=1.0;
        end;
    1 : begin
           // mm
           mlength:=1e-3;
        end;
    2 : begin
           // micron
           mlength:=1e-6;
        end;
   end;

   // считывание информации о таблично заданной мощности.
   s:=f.Strings[i]; inc(i);
   iltdp:=StrToInt(Copy(s,Pos('ltdp=',s)+5,length(s)));
   SetLength(listtablename,iltdp);
   for j:=0 to iltdp-1 do
   begin
      s:=f.Strings[i]; inc(i);
      listtablename[j]:=s; // имя файла с таблицей.
   end;


   // считывание информации об объединениях :
   s:=f.Strings[i]; inc(i);
   lu:=StrToInt(Copy(s,Pos('lu=',s)+3,length(s)));
   SetLength(myassembles,lu);
   for j:=0 to lu-1 do
   begin
      s:=f.Strings[i]; inc(i);
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].name:=sub;
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      myassembles[j].identifire:=StrToInt(sub);
   end;

   s:=f.Strings[i]; inc(i);
   ivar:=StrToInt(Copy(s,Pos('ivarmax=',s)+8,length(s)));
   SetLength(parametric,ivar); // выделение памяти под переменные
   for j:=0 to ivar-1 do
   begin
      // считываем переменные из входного файла :
      s:=f.Strings[i]; inc(i);
      sub:=Copy(s,1,Pos(':',s)-1);
      parametric[j].svar:=Trim(sub);  // имя переменной
      s:=Copy(s,Pos(':',s)+1,length(s));
      sub:=Copy(s,1,Pos(':',s)-1);
      parametric[j].sval:=Trim(sub); // значение переменной
   end;

   s:=f.Strings[i];
   lmatmax:=StrToInt(Copy(s,Pos('lmatmax=',s)+8,length(s)));
   SetLength(workmat,lmatmax); // выделение оперативной памяти
   // Считываем материалы:
   for j:=0 to (lmatmax-1) do
   begin
      inc(i); s:=f.Strings[i];
      myreadmaterial(workmat[j],s);
   end;
   inc(i); s:=f.Strings[i]; // cabinet
   SetLength(body,1); // выделение оперативной памяти
   myreadbody(body[0],s); // считывание из текстового файла
   SetLength(body[0].Vertexs,8); // куб
   LoadVertexBrick(0); // заполнение значений вершин
   // рёбра
   Edgecubcreate(0);
   SetLength(body[0].Vertext,8);
   Oxc:=0.5*(body[0].xS+body[0].xE);
   Oyc:=0.5*(body[0].yS+body[0].yE);
   Ozc:=0.5*(body[0].zS+body[0].zE);
   body[0].bvisible:=true;
   //Rotate;  // память для вершин должна быть выделена всем блокам
   // количество блоков:
   inc(i);
   s:=f.Strings[i];
   lb:=StrToInt(Copy(s,Pos('lb=',s)+3,length(s)));
   SetLength(body,lb); // выделение оперативной памяти
   // считываем остальные блоки:
   for j:=1 to (lb-1) do
   begin
      inc(i); s:=f.Strings[i];
      myreadbody(body[j],s);
      SetLength(body[j].Vertexs,8); // куб
      LoadVertexBrick(j); // заполнение значений вершин
      // рёбра
      Edgecubcreate(j);
      SetLength(body[j].Vertext,8);
      body[j].bvisible:=true;
      //Rotate; // память для вершин должна быть выделена всем блокам
   end;
   Rotate;
   // сообщение на консоль:
   MainMemo.Lines.Add('считывание текстового файла:...');
   for j:=0 to (lb-1) do
   begin
      MainMemo.Lines.Add(body[j].name+' ... ready');
   end;
   // количество источников тепла:
   inc(i); s:=f.Strings[i];
   ls:=StrToInt(Copy(s,Pos('ls=',s)+3,length(s)));
   SetLength(source,ls); // выделение оперативной памяти под источники тепла
   // цикл по всем источникам тепла:
   for j:=0 to (ls-1) do
   begin
      inc(i); s:=f.Strings[i]; // считывание очередной строки
      myreadsource(source[j],s);
      SetLength(source[j].Vertexs,4); // источник
      LoadVertexPlane(source[j]); // задаёт координаты вершин
      //Рёбра
      EdgePlaneCreate(source[j]);
      SetLength(source[j].Vertext,4);
      source[j].bvisible:=true;
   end;
   RotateSource;
   for j:=0 to (ls-1) do
   begin
      MainMemo.Lines.Add(source[j].name+' ... ready');
   end;
   // количество стенок:
   inc(i); s:=f.Strings[i];
   lw:=StrToInt(Copy(s,Pos('lw=',s)+3,length(s)));
   SetLength(wall,lw); // выделение оперативной памяти под источники тепла
   // цикл по всем источникам тепла:
   for j:=0 to (lw-1) do
   begin
      inc(i); s:=f.Strings[i]; // считывание очередной строки
      myreadwall(wall[j],s);
      SetLength(wall[j].Vertexs,4); // источник
      LoadVertexPlane(wall[j]); // задаёт координаты вершин
      //Рёбра
      EdgePlaneCreate(wall[j]);
      SetLength(wall[j].Vertext,4);
      wall[j].bvisible:=true; // видимость стенки
   end;
   RotateWall;
   for j:=0 to (lw-1) do
   begin
      MainMemo.Lines.Add(wall[j].name+' ... ready');
   end;

   // Считывание информации о решаемом наборе уравнений.
   inc(i); s:=f.Strings[i]; // считывание очередной строки
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   egddata.itemper:=StrToInt(sub);
   s:=Copy(s,Pos(':',s)+1,length(s));
   sub:=Trim(Copy(s,1,Pos(':',s)-1));
   egddata.imaxflD:=StrToInt(sub);
   for j:=0 to egddata.imaxflD-1 do
   begin
      inc(i); s:=f.Strings[i]; // считывание очередной строки
      // считывание информации о текущей FLUID зоне.
      myreadfluidzone(egddata.myflmod[j], s);
   end;

   // отображение дерева элементов:

   // количество объединений уже известно.
   // Всего lu объединений.
   SetLength(flagunion,lu+1);
   for j:=0 to lu do flagunion[j]:=false; // ни один union не был создан

   MainTreeView.Items.Clear; // очистка дерева
   for j:=0 to (lb-1) do
   begin

      if (j=0) then
      begin
         // кабинет
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[j].name);
         NewNode.ImageIndex:=0;  // номер картинки
         NewNode.SelectedIndex:=0; // номер картинки когда элемент выделен
      end
       else
      begin
         // другие блоки
         if (body[j].iunion=0) then
         begin
            NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[j].name);
            NewNode.ImageIndex:=1;  // номер картинки
            NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
         end
          else
         begin
            if (flagunion[body[j].iunion]=false) then
            begin
               NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[body[j].iunion-1].name);
               NewNode.ImageIndex:=4;  // номер картинки
               NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен

                SearchTarget:=myassembles[body[j].iunion-1].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      // найден
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
               Nodeloc:=MainTreeView.Selected;
               NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,body[j].name);
               NewNode.ImageIndex:=1;  // номер картинки
               NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
               MainTreeView.Selected:=Nodeloc;
               flagunion[body[j].iunion]:=true;
            end
             else
            begin
                SearchTarget:=myassembles[body[j].iunion-1].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
                 Nodeloc:=MainTreeView.Selected;
                 NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,body[j].name);
                 NewNode.ImageIndex:=1;  // номер картинки
                 NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
                 MainTreeView.Selected:=Nodeloc;
            end;
         end;
      end;
   end;
   for j:=0 to (ls-1) do
   begin
      // источники тепла
      if (source[j].iunion=0) then
      begin
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,source[j].name);
         NewNode.ImageIndex:=2;  // номер картинки
         NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
      end
       else
      begin
          if (flagunion[source[j].iunion]=false) then
            begin
               NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[source[j].iunion-1].name);
               NewNode.ImageIndex:=4;  // номер картинки
               NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен

               SearchTarget:=myassembles[source[j].iunion-1].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
               Nodeloc:=MainTreeView.Selected;
               NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,source[j].name);
               NewNode.ImageIndex:=2;  // номер картинки
               NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
               MainTreeView.Selected:=Nodeloc;
               flagunion[source[j].iunion]:=true;
            end
             else
            begin
                SearchTarget:=myassembles[source[j].iunion-1].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
                 Nodeloc:=MainTreeView.Selected;
                 NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,source[j].name);
                 NewNode.ImageIndex:=2;  // номер картинки
                 NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
                 MainTreeView.Selected:=Nodeloc;
            end;
      end;
   end;
   for j:=0 to (lw-1) do
   begin
      // твёрдые стенки
      if (wall[j].iunion=0) then
      begin
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,wall[j].name);
         NewNode.ImageIndex:=3;  // номер картинки
         NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
      end
       else
       begin
          if (flagunion[wall[j].iunion]=false) then
            begin
               NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,myassembles[wall[j].iunion-1].name);

               NewNode.ImageIndex:=4;  // номер картинки
               NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
               SearchTarget:=myassembles[wall[j].iunion-1].name;
               Noddy := MainTreeView.Items[0];
               Searching := true;
               while (Searching) and (Noddy <> nil) do
               begin
                  if Noddy.text = SearchTarget then
                  begin
                     Searching := False;
                     MainTreeView.Selected := Noddy;
                     MainTreeView.SetFocus;
                  end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
               end;
               Nodeloc:=MainTreeView.Selected;


               NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,wall[j].name);
               NewNode.ImageIndex:=3;  // номер картинки
               NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
               MainTreeView.Selected:=Nodeloc;
               flagunion[wall[j].iunion]:=true;
            end
             else
            begin
                SearchTarget:=myassembles[wall[j].iunion-1].name;
                Noddy := MainTreeView.Items[0];
                Searching := true;
                while (Searching) and (Noddy <> nil) do
                begin
                   if Noddy.text = SearchTarget then
                   begin
                      Searching := False;
                      MainTreeView.Selected := Noddy;
                      MainTreeView.SetFocus;
                   end
                 else
                   begin
                     Noddy := Noddy.GetNext
                   end;
                 end;
                 Nodeloc:=MainTreeView.Selected;
                 NewNode:=MainTreeView.Items.AddChild(MainTreeView.Selected,wall[j].name);
                 NewNode.ImageIndex:=3;  // номер картинки
                 NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
                 MainTreeView.Selected:=Nodeloc;
            end;
      end;
   end;

   MainMemo.Lines.Add('Done');
   f.Free;
   MainPaintBoxPaint(Sender); // прорисовка геометрии

   breadfinish:=true;
end;

// возвращение в изометрию
procedure TLaplas.SpeedButtonisogeomClick(Sender: TObject);
begin
   Alf:=-1.29;
   Bet:=1.26;
   MainPaintBoxPaint(Sender);
end;

// уменьшение изображения в окошке
procedure TLaplas.FormMouseWheelDown(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
    // колёсико движется вниз
    if (m>11) then
    begin
        m:=m-10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m-0.1;
       end
       else
       begin
          if (m>0.011) then
          begin
             m:=m-0.01;
          end
           else
          begin
             m:=m-0.001;
          end;
       end;
    end;

    MainPaintBoxPaint(Sender);
end;

// увеличение изображения в окошке
procedure TLaplas.FormMouseWheelUp(Sender: TObject; Shift: TShiftState;
  MousePos: TPoint; var Handled: Boolean);
begin
   // колёсико движется вверх
    if (m>11) then
    begin
        m:=m+10; // ZOOM
    end
    else
    begin
       if (m>0.11) then
       begin
          m:=m+0.1;
       end
       else
       begin
          if (m>0.011) then
          begin
             m:=m+0.01; // ZOOM
          end
           else
          begin
             m:=m+0.001;
          end;
       end;
    end;
    MainPaintBoxPaint(Sender);
end;

// изменение размеров формы
// которое приводит к изменению и друнгих размеров:
procedure TLaplas.FormResize(Sender: TObject);
begin
   // изменение размеров главной панели
   MainPanel.Width:=Width-26;
   MainPanel.Height:=Height-71;
   // изменение положения MainMemo
   MainMemo.Top:=Height-160;
   // изменение размеров PaintBox
   MainPaintBox.Width:=Width-266;
   MainPaintBox.Height:=Height-183;
   MainPaintBoxPaint(Sender);
end;

// создание новой стенки
procedure TLaplas.SBwallClick(Sender: TObject);
var
   hx,hy : real;
   NewNode : TTreeNode;
begin
   // создаёт элемент стенку
   inc(lw); itek:=lw-1;
   SetLength(wall,lw); // выделение памяти под дополниткельную стенку
   hx:=abs(body[0].xE-body[0].xS)/6.0;
   hy:=abs(body[0].yE-body[0].yS)/6.0;
   wall[itek].iPlane:=1;//XY
   wall[itek].xS:=body[0].xS+2*hx;  wall[itek].xE:=body[0].xE-2*hx; // числовые значения
   wall[itek].yS:=body[0].yS+2*hy;  wall[itek].yE:=body[0].yE-2*hy; // геометрических размеров
   wall[itek].zS:=0.5*(body[0].zS+body[0].zE);  wall[itek].zE:=0.5*(body[0].zS+body[0].zE);
   wall[itek].sxS:=FloatToStr(body[0].xS+2*hx);  wall[itek].sxE:=FloatToStr(body[0].xE-2*hx); // параметризованные значения
   wall[itek].syS:=FloatToStr(body[0].yS+2*hy);  wall[itek].syE:=FloatToStr(body[0].yE-2*hy); // геометрических размеров
   wall[itek].szS:=FloatToStr(0.5*(body[0].zS+body[0].zE));  wall[itek].szE:=FloatToStr(0.5*(body[0].zS+body[0].zE));

   SetLength(wall[itek].Vertexs,4); // число вершин
   LoadVertexPlane(wall[itek]); // задаёт координаты вершин
   //Рёбра
   EdgePlaneCreate(wall[itek]); // создаёт рёбра
   SetLength(wall[itek].Vertext,4);
   RotateWall;
   wall[itek].name:='wall'+IntToStr(lw); // задаёт уникальное имя объекта
   wall[itek].family:=1; // род краевого условия
   wall[itek].Tamb:=20.0; // градусов цельсия
   wall[itek].HF:=0.0;
   wall[itek].Power:=0.0; // не источник тепла
   wall[itek].spower:='0.0'; // не источник тепла
   // в гидродинамическом плане твёрдая стенка
   wall[itek].Vx:=0.0;
   wall[itek].Vy:=0.0;
   wall[itek].Vz:=0.0;
   wall[itek].P:=0.0;
   wall[itek].bpressure:=false;
   wall[itek].bsymmetry:=false;
   wall[itek].iunion:=0;
   wall[itek].bvisible:=true;
   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,wall[itek].name);
   NewNode.ImageIndex:=3; // загружает картинку твёрдой стенки
   NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
   MainPaintBoxPaint(Sender);
   Initializeaddwallform; // инициализирует форму перед запуском
   AddWallForm.ShowModal;
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=wall[itek].name;
   MainPaintBoxPaint(Sender);
end;

// двойной щелчек по дереву элементов
procedure TLaplas.MainTreeViewDblClick(Sender: TObject);
const
    epsilon = 1e-20;
var
   s : string; // имя редактируемого элемента
   i : Integer;
   ch : Char;
   bcontinue : Boolean; // нужно ли продолжать поиск

begin
   // двойной клик по дереву
   s:=MainTreeView.Selected.Text;
   // символ ch может принимать значения : c, b, s, w, u, e-exit
   ch:='e';
   bcontinue:=true;
   // по всем блокам
   for i:=0 to (lb-1) do
   begin
      if (bcontinue and (length(body[i].name) = length(s)) and (Pos(body[i].name,s)=1)) then
      begin
         // найден блок :
         bcontinue:=false;
         itek:=i;
         if (i=0) then
         begin
            ch:='c';
         end
          else
         begin
            ch:='b';
         end;
      end;
   end;
   if (ch='e') then
   begin
      // по всем источникам
      for i:=0 to (ls-1) do
      begin
         if (bcontinue and (length(source[i].name) = length(s)) and (Pos(source[i].name,s)=1)) then
         begin
            // найден источник
            bcontinue:=false;
            ch:='s';
            itek:=i;
         end;
      end;
   end;
   if (ch='e') then
   begin
       // по всем твёрдым стенкам
       for i:=0 to (lw-1) do
       begin
          if (bcontinue and (length(wall[i].name) = length(s)) and (Pos(wall[i].name,s)=1)) then
          begin
             // найдена твёрдая стенка.
             bcontinue:=false;
             itek:=i;
             ch:='w';
          end;
       end;
   end;
   if (ch='e') then
   begin
      // по всем объединениям
      for i:=0 to (lu-1) do
      begin
         if (bcontinue and (length(myassembles[i].name) = length(s)) and (Pos(myassembles[i].name,s)=1)) then
         begin
            bcontinue:=false;
            ch:='u'; // двойной щелчек по объединению
            itek:=myassembles[i].identifire; // идентификатор объединения
            // внимание : обязательно должна быть справедлива связь itek=identifire=i+1;
            // т.е. номер объединения в списке должен быть на единицу меньше его идентификатора.
         end;
      end;
   end;

   case ch of
   'c' : // cabinet
          begin
             // вызов редактирования свойств кабинета
             CabinetForm.ExS.Text:=body[0].sxS;   // параметризованные
             CabinetForm.EyS.Text:=body[0].syS;   // пользователем
             CabinetForm.EzS.Text:=body[0].szS;   // геометрические
             CabinetForm.ExE.Text:=body[0].sxE;   // размеры.
             CabinetForm.EyE.Text:=body[0].syE;
             CabinetForm.EzE.Text:=body[0].szE;

             if (abs(Alf)>epsilon) then CabinetForm.EAlf.Text:=FormatFloat('###.##',Alf)
             else CabinetForm.EAlf.Text:='0.0';
             if (abs(Bet)>epsilon) then CabinetForm.EBet.Text:=FormatFloat('###.##',Bet)
             else CabinetForm.EBet.Text:='0.0';
             // Центр подвижной системы координат
             CabinetForm.EditXo.Text:=FloatToStr(Oxc);
             CabinetForm.EditYo.Text:=FloatToStr(Oyc);
             CabinetForm.EditZo.Text:=FloatToStr(Ozc);
             if (workmat[body[0].imatid].blibmat=0) then
             begin
                // материал определённый пользователем
                CabinetForm.RGCabinetMaterial.ItemIndex:=1;
             end
             else
             begin
                // Библиотечный материал.
                CabinetForm.RGCabinetMaterial.ItemIndex:=0;
             end;
             CabinetForm.EOpTemp.Text:=FloatToStr(operatingtemperature);
             CabinetForm.ShowModal;
             MainPaintBoxPaint(Sender);
          end;
   'b' : // блок
          begin
             // по всем блокам
             initializeaddblockform;
             AddBlockForm.ShowModal;
             MainTreeView.Selected.Text:=body[itek].name;
             MainPaintBoxPaint(Sender);
          end;
   's' : // источник
          begin
             // по всем источникам
             InitializeAddSourceForm;
             AddSourceForm.ShowModal;
             MainTreeView.Selected.Text:=source[itek].name;
             MainPaintBoxPaint(Sender);
          end;
    'w' : // стенка
          begin
             // по всем твёрдым стенкам
             InitializeAddWallForm;
             AddWallForm.ShowModal;
             MainTreeView.Selected.Text:=wall[itek].name;
             MainPaintBoxPaint(Sender);
          end;
    'u' : // делает видимыми или невидимыми все элементы объединения
          // и более ничего.
          begin
             // параметр itek; передаётся внутрь формы:
             FormUnion.ShowModal;
             MainTreeView.Selected.Text:=myassembles[itek-1].name;
             MainPaintBoxPaint(Sender);
          end;
   end; // case
end;

// удаление выделенного в дереве элемента
// может быть удалено не более одного элемента.
procedure TLaplas.SpeedButtonDelClick(Sender: TObject);
var
   sdel : String;
   i,j, idel : Integer;
   body_copy : array of TBody;
   source_copy : array of TPlane;
   wall_copy : array of TPlane;
begin
   // Удаление выделенного в дереве элемента
   sdel:=MainTreeView.Selected.Text; // уникальное имя удаляемого объекта
   // по всем блокам
   idel:=-1;
   for i:=1 to (lb-1) do
   begin
      if ( (length(body[i].name) = length(sdel)) and (Pos(body[i].name,sdel)=1)) then
      begin
         idel:=i; // номер удаляемого блока
      end;
   end;
   if (idel >-1) then
   begin
      SetLength(body_copy,lb-1);
      j:=0;
      for i:=0 to (lb-1) do
      begin
         if (i<>idel) then
         begin
            body_copy[j]:=body[i];
            inc(j);
         end;
      end;
      dec(lb);
      SetLength(body,lb);
      for i:=0 to (lb-1) do
      begin
         body[i]:=body_copy[i];
      end;
      SetLength(body_copy,0); // освобождение памяти
      body_copy:=nil;
   end;
   // по всем источникам
   idel:=-1;
   for i:=0 to (ls-1) do
   begin
      if ( (length(source[i].name) = length(sdel)) and (Pos(source[i].name,sdel)=1)) then
      begin
         idel:=i; // номер удаляемого блока
      end;
   end;
   if (idel >-1) then
   begin
      SetLength(source_copy,ls-1);
      j:=0;
      for i:=0 to (ls-1) do
      begin
         if (i<>idel) then
         begin
            source_copy[j]:=source[i];
            inc(j);
         end;
      end;
      dec(ls);
      SetLength(source,ls);
      for i:=0 to (ls-1) do
      begin
         source[i]:=source_copy[i];
      end;
      SetLength(source_copy,0); // освобождение памяти
      source_copy:=nil;
   end;
   // по всем стенкам
   idel:=-1;
   for i:=0 to (lw-1) do
   begin
      if ( (length(wall[i].name) = length(sdel)) and (Pos(wall[i].name,sdel)=1)) then
      begin
         idel:=i; // номер удаляемого блока
      end;
   end;
   if (idel >-1) then
   begin
      SetLength(wall_copy,lw-1);
      j:=0;
      for i:=0 to (lw-1) do
      begin
         if (i<>idel) then
         begin
            wall_copy[j]:=wall[i];
            inc(j);
         end;
      end;
      dec(lw);
      SetLength(wall,lw);
      for i:=0 to (lw-1) do
      begin
         wall[i]:=wall_copy[i];
      end;
      SetLength(wall_copy,0); // освобождение памяти
      wall_copy:=nil;
   end;
   // удаление выделенного элемента из дерева
   if (MainTreeView.Selected.Text<>body[0].name) then
   begin
      MainTreeView.Items.Delete(MainTreeView.Selected);
   end;
   MainPaintBoxPaint(Sender); // прорисовка изменений
end;

// создание inum копий выделенного объекта.
procedure TLaplas.SpeedButtonCopyClick(Sender: TObject);
var
    scop : String;
    iob,i,j,lold : Integer;
    NewNode : TTreeNode;
    dx, dy, dz, dmbuf : Real;
    bdxchange, bdychange, bdzchange : Boolean;
    bdxconst, bdyconst, bdzconst : Boolean;
    code : Integer;
    bOk, bOk1 : Boolean;

begin
   bcontinuecopy:=true; // по умолчанию всё впорядке и нужно осуществить операцию копирования.

   // копирование элементов
   FormCopyObject.ShowModal;
   // копированию подвергается только один объект,
   // имя данного объекта выделено в дереве.
   scop:=MainTreeView.Selected.Text;

   if (bcontinuecopy) then
   begin

   // нужно ли осуществлять копирование
   // вдоль соответствующей координатной оси
   bdxchange:=true;  // по умолчанию надо везде.
   bdychange:=true;
   bdzchange:=true;
   // если bdxconst=true то величина перемещения
   // является непараметризованной константой. Иначе
   // величина перемещения является параметризованной величиной.
   bdxconst:=true;
   bdyconst:=true;
   bdzconst:=true;

   val(spdx,dx,code);
   if (code=0) then
   begin
      // константа
      bdxconst:=true;
      if abs(dx)<1e-10 then
      begin
         spdx:='';
         bdxchange:=false; //вдоль оси Ох передвигать ненужно.
      end
      else
      begin
         bdxchange:=true; // нужно сдвигать вдоль оси Ох
      end;
   end
   else
   begin
      bdxconst:=false; // параметризованное смещение по оси X
      bdxchange:=true; // нужно сдвигать вдоль оси Ох
   end;

   val(spdy,dy,code);
   if (code=0) then
   begin
      // константа
      bdyconst:=true;
      if abs(dy)<1e-10 then
      begin
         spdy:='';
         bdychange:=false; //вдоль оси Оy передвигать ненужно.
      end
      else
      begin
         bdychange:=true; // нужно сдвигать вдоль оси Оy
      end;
   end
   else
   begin
      bdyconst:=false; // параметризованное смещение по оси Y
      bdychange:=true; // нужно сдвигать вдоль оси Оy
   end;

   val(spdz,dz,code);
   if (code=0) then
   begin
      // константа
      bdzconst:=true;
      if abs(dz)<1e-10 then
      begin
         spdz:='';
         bdzchange:=false; //вдоль оси Оz передвигать ненужно.
      end
      else
      begin
         bdzchange:=true; // нужно сдвигать вдоль оси Оz
      end;
   end
   else
   begin
      bdzconst:=false; // параметризованное смещение по оси Z
      bdzchange:=true; // нужно сдвигать вдоль оси Оz
   end;



   // по всем блокам
   iob:=-1;
   for i:=1 to (lb-1) do
   begin
      if ( (length(body[i].name) = length(scop)) and (Pos(body[i].name,scop)=1)) then
      begin
         iob:=i; // номер копируемого блока
      end;
   end;
   if (iob>-1) then
   begin
      lold:=lb;
      // inum - глобальная переменная в данном модуле
      // отвечающая за число копий.
      lb:=lb+inum;
      SetLength(body,lb);

      j:=1; 
      for i:=lold to (lb-1) do
      begin

         if (bdxchange) then
         begin
            if (not bdxconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               body[i].sxS:=body[iob].sxS+'+'+IntToStr(j)+'*('+spdx+')';
               body[i].sxE:=body[iob].sxE+'+'+IntToStr(j)+'*('+spdx+')';
               if (bOk) then body[i].xS:=FormVariables.my_real_convert(body[i].sxS,bOk);
               if (bOk) then body[i].xE:=FormVariables.my_real_convert(body[i].sxE,bOk);
            end
             else
            begin
               // числовое значение
               val(body[iob].sxS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  body[i].xS:=body[iob].xS+j*dx;
                  body[i].sxS:=FloatToStr(body[i].xS);
               end
               else
               begin
                  dmbuf:=j*dx;
                  if (dmbuf>0.0) then
                  begin
                     body[i].sxS:=body[iob].sxS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     body[i].xS:=FormVariables.my_real_convert(body[i].sxS,bOk);
                  end
                  else
                  begin
                     body[i].sxS:=body[iob].sxS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     body[i].xS:=FormVariables.my_real_convert(body[i].sxS,bOk);
                  end;
               end;

               val(body[iob].sxE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  body[i].xE:=body[iob].xE+j*dx;
                  body[i].sxE:=FloatToStr(body[i].xE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dx;
                  if (dmbuf>0.0) then
                  begin
                     body[i].sxE:=body[iob].sxE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     body[i].xE:=FormVariables.my_real_convert(body[i].sxE,bOk);
                  end
                  else
                  begin
                     body[i].sxE:=body[iob].sxE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     body[i].xE:=FormVariables.my_real_convert(body[i].sxE,bOk);
                  end;
               end;
            end;
         end
        else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            body[i].sxS:=body[iob].sxS;
            body[i].sxE:=body[iob].sxE;
            body[i].xS:=body[iob].xS;
            body[i].xE:=body[iob].xE;
         end;

         if (bdychange) then
         begin
            if (not bdyconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               body[i].syS:=body[iob].syS+'+'+IntToStr(j)+'*('+spdy+')';
               body[i].syE:=body[iob].syE+'+'+IntToStr(j)+'*('+spdy+')';
               if (bOk) then body[i].yS:=FormVariables.my_real_convert(body[i].syS,bOk);
               if (bOk) then body[i].yE:=FormVariables.my_real_convert(body[i].syE,bOk);
            end
             else
            begin
               // числовое значение
               val(body[iob].syS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  body[i].yS:=body[iob].yS+j*dy;
                  body[i].syS:=FloatToStr(body[i].yS);
               end
               else
               begin
                  dmbuf:=j*dy;
                  if (dmbuf>0.0) then
                  begin
                     body[i].syS:=body[iob].syS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     body[i].yS:=FormVariables.my_real_convert(body[i].syS,bOk);
                  end
                  else
                  begin
                     body[i].syS:=body[iob].syS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     body[i].yS:=FormVariables.my_real_convert(body[i].syS,bOk);
                  end;
               end;

               val(body[iob].syE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  body[i].yE:=body[iob].yE+j*dy;
                  body[i].syE:=FloatToStr(body[i].yE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dy;
                  if (dmbuf>0.0) then
                  begin
                     body[i].syE:=body[iob].syE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     body[i].yE:=FormVariables.my_real_convert(body[i].syE,bOk);
                  end
                  else
                  begin
                     body[i].syE:=body[iob].syE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     body[i].yE:=FormVariables.my_real_convert(body[i].syE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            body[i].syS:=body[iob].syS;
            body[i].syE:=body[iob].syE;
            body[i].yS:=body[iob].yS;
            body[i].yE:=body[iob].yE;
         end;

         if (bdzchange) then
         begin
            if (not bdzconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               body[i].szS:=body[iob].szS+'+'+IntToStr(j)+'*('+spdz+')';
               body[i].szE:=body[iob].szE+'+'+IntToStr(j)+'*('+spdz+')';
               if (bOk) then body[i].zS:=FormVariables.my_real_convert(body[i].szS,bOk);
               if (bOk) then body[i].zE:=FormVariables.my_real_convert(body[i].szE,bOk);
            end
             else
            begin
               // числовое значение
               val(body[iob].szS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  body[i].zS:=body[iob].zS+j*dz;
                  body[i].szS:=FloatToStr(body[i].zS);
               end
               else
               begin
                  dmbuf:=j*dz;
                  if (dmbuf>0.0) then
                  begin
                     body[i].szS:=body[iob].szS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     body[i].zS:=FormVariables.my_real_convert(body[i].szS,bOk);
                  end
                  else
                  begin
                     body[i].szS:=body[iob].szS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     body[i].zS:=FormVariables.my_real_convert(body[i].szS,bOk);
                  end;
               end;

               val(body[iob].szE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  body[i].zE:=body[iob].zE+j*dz;
                  body[i].szE:=FloatToStr(body[i].zE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dz;
                  if (dmbuf>0.0) then
                  begin
                     body[i].szE:=body[iob].szE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     body[i].zE:=FormVariables.my_real_convert(body[i].szE,bOk);
                  end
                  else
                  begin
                     body[i].szE:=body[iob].szE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     body[i].zE:=FormVariables.my_real_convert(body[i].szE,bOk);
                  end;
               end;
            end;
         end
         else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            body[i].szS:=body[iob].szS;
            body[i].szE:=body[iob].szE;
            body[i].zS:=body[iob].zS;
            body[i].zE:=body[iob].zE;
         end;

         body[i].imatid:=body[iob].imatid; // привязка к свойствам материала
         body[i].itype:=body[iob].itype;
         body[i].power:=body[iob].power;
         body[i].spower:=body[iob].spower; // не забываем при копировании копировать символьную мощность тепловыделения в блоке
         body[i].iunion:=0; // по умолчанию на уровне кабинета
         body[i].bvisible:=true;

         SetLength(body[i].Vertexs,8); // куб
         LoadVertexBrick(i); // заполнение значений вершин
         // рёбра
         Edgecubcreate(i);
         SetLength(body[i].Vertext,8);
         body[i].name:='block'+IntToStr(i);
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,body[i].name);
         NewNode.ImageIndex:=1;  // номер картинки
         NewNode.SelectedIndex:=1; // номер картинки когда элемент выделен
         MainTreeView.Items[MainTreeView.Items.Count-1].Text:=body[i].name;
         inc(j);
      end;
      Rotate;
   end;

   // по всем источникам
   iob:=-1;
   for i:=0 to (ls-1) do
   begin
      if ( (length(source[i].name) = length(scop)) and (Pos(source[i].name,scop)=1)) then
      begin
         iob:=i; // номер копируемого блока
      end;
   end;
   if (iob>-1) then
   begin
      lold:=ls;
      ls:=ls+inum;
      SetLength(source,ls);

      j:=1;
      for i:=lold to (ls-1) do
      begin

         if (bdxchange) then
         begin
            if (not bdxconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               source[i].sxS:=source[iob].sxS+'+'+IntToStr(j)+'*('+spdx+')';
               source[i].sxE:=source[iob].sxE+'+'+IntToStr(j)+'*('+spdx+')';
               if (bOk) then source[i].xS:=FormVariables.my_real_convert(source[i].sxS,bOk);
               if (bOk) then source[i].xE:=FormVariables.my_real_convert(source[i].sxE,bOk);
            end
             else
            begin
               // числовое значение
               val(source[iob].sxS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i].xS:=source[iob].xS+j*dx;
                  source[i].sxS:=FloatToStr(source[i].xS);
               end
               else
               begin
                  dmbuf:=j*dx;
                  if (dmbuf>0.0) then
                  begin
                     source[i].sxS:=source[iob].sxS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i].xS:=FormVariables.my_real_convert(source[i].sxS,bOk);
                  end
                  else
                  begin
                     source[i].sxS:=source[iob].sxS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i].xS:=FormVariables.my_real_convert(source[i].sxS,bOk);
                  end;
               end;

               val(source[iob].sxE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i].xE:=source[iob].xE+j*dx;
                  source[i].sxE:=FloatToStr(source[i].xE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dx;
                  if (dmbuf>0.0) then
                  begin
                     source[i].sxE:=source[iob].sxE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i].xE:=FormVariables.my_real_convert(source[i].sxE,bOk);
                  end
                  else
                  begin
                     source[i].sxE:=source[iob].sxE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i].xE:=FormVariables.my_real_convert(source[i].sxE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            source[i].sxS:=source[iob].sxS;
            source[i].sxE:=source[iob].sxE;
            source[i].xS:=source[iob].xS;
            source[i].xE:=source[iob].xE;
         end;

         if (bdychange) then
         begin
            if (not bdyconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               source[i].syS:=source[iob].syS+'+'+IntToStr(j)+'*('+spdy+')';
               source[i].syE:=source[iob].syE+'+'+IntToStr(j)+'*('+spdy+')';
               if (bOk) then source[i].yS:=FormVariables.my_real_convert(source[i].syS,bOk);
               if (bOk) then source[i].yE:=FormVariables.my_real_convert(source[i].syE,bOk);
            end
             else
            begin
               // числовое значение
               val(source[iob].syS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i].yS:=source[iob].yS+j*dy;
                  source[i].syS:=FloatToStr(source[i].yS);
               end
               else
               begin
                  dmbuf:=j*dy;
                  if (dmbuf>0.0) then
                  begin
                     source[i].syS:=source[iob].syS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i].yS:=FormVariables.my_real_convert(source[i].syS,bOk);
                  end
                  else
                  begin
                     source[i].syS:=source[iob].syS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i].yS:=FormVariables.my_real_convert(source[i].syS,bOk);
                  end;
               end;

               val(source[iob].syE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i].yE:=source[iob].yE+j*dy;
                  source[i].syE:=FloatToStr(source[i].yE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dy;
                  if (dmbuf>0.0) then
                  begin
                     source[i].syE:=source[iob].syE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i].yE:=FormVariables.my_real_convert(source[i].syE,bOk);
                  end
                  else
                  begin
                     source[i].syE:=source[iob].syE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i].yE:=FormVariables.my_real_convert(source[i].syE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            source[i].syS:=source[iob].syS;
            source[i].syE:=source[iob].syE;
            source[i].yS:=source[iob].yS;
            source[i].yE:=source[iob].yE;
         end;

         if (bdzchange) then
         begin
            if (not bdzconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               source[i].szS:=source[iob].szS+'+'+IntToStr(j)+'*('+spdz+')';
               source[i].szE:=source[iob].szE+'+'+IntToStr(j)+'*('+spdz+')';
               if (bOk) then source[i].zS:=FormVariables.my_real_convert(source[i].szS,bOk);
               if (bOk) then source[i].zE:=FormVariables.my_real_convert(source[i].szE,bOk);
            end
             else
            begin
               // числовое значение
               val(source[iob].szS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i].zS:=source[iob].zS+j*dz;
                  source[i].szS:=FloatToStr(source[i].zS);
               end
               else
               begin
                  dmbuf:=j*dz;
                  if (dmbuf>0.0) then
                  begin
                     source[i].szS:=source[iob].szS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i].zS:=FormVariables.my_real_convert(source[i].szS,bOk);
                  end
                  else
                  begin
                     source[i].szS:=source[iob].szS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i].zS:=FormVariables.my_real_convert(source[i].szS,bOk);
                  end;
               end;

               val(source[iob].szE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  source[i].zE:=source[iob].zE+j*dz;
                  source[i].szE:=FloatToStr(source[i].zE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dz;
                  if (dmbuf>0.0) then
                  begin
                     source[i].szE:=source[iob].szE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     source[i].zE:=FormVariables.my_real_convert(source[i].szE,bOk);
                  end
                  else
                  begin
                     source[i].szE:=source[iob].szE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     source[i].zE:=FormVariables.my_real_convert(source[i].szE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            source[i].szS:=source[iob].szS;
            source[i].szE:=source[iob].szE;
            source[i].zS:=source[iob].zS;
            source[i].zE:=source[iob].zE;
         end;

         source[i].iPlane:=source[iob].iPlane;
         source[i].Power:=source[iob].Power;
         source[i].spower:=source[iob].spower;
         source[i].itempdep:=source[iob].itempdep;
         source[i].id_table:=source[iob].id_table;
         source[i].soperatingoffsetdrain:=source[iob].soperatingoffsetdrain;
         //source[i].operatingoffsetdrain:=source[iob].operatingoffsetdrain;
         bOk1:=true;
         if (bOk1) then source[i].operatingoffsetdrain:=FormVariables.my_real_convert(source[iob].soperatingoffsetdrain,bOk);
         source[i].family:=source[iob].family;
         source[i].Tamb:=source[iob].Tamb;
         source[i].HF:=source[iob].HF;
         source[i].Vx:=source[iob].Vx;
         source[i].Vy:=source[iob].Vy;
         source[i].Vz:=source[iob].Vz;
         source[i].P:=source[iob].P;
         source[i].bpressure:=source[iob].bpressure;
         source[i].bsymmetry:=source[iob].bsymmetry;
         source[i].iunion:=0; // по умолчанию на уровне кабинета
         source[i].bvisible:=true;


         SetLength(source[i].Vertexs,4); // источник
         LoadVertexPlane(source[i]); // задаёт координаты вершин
         //Рёбра
         EdgePlaneCreate(source[i]);
         SetLength(source[i].Vertext,4);


         source[i].name:='source'+IntToStr(i+1);
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,source[i].name);
         NewNode.ImageIndex:=2;  // номер картинки
         NewNode.SelectedIndex:=2; // номер картинки когда элемент выделен
         MainTreeView.Items[MainTreeView.Items.Count-1].Text:=source[i].name;
         inc(j);
      end;
      RotateSource;
   end;

   // по всем стенкам
   iob:=-1;
   for i:=0 to (lw-1) do
   begin
      if ( (length(wall[i].name) = length(scop)) and (Pos(wall[i].name,scop)=1)) then
      begin
         iob:=i; // номер копируемого блока
      end;
   end;
   if (iob>-1) then
   begin
      lold:=lw;
      lw:=lw+inum;
      SetLength(wall,lw);

      j:=1;
      for i:=lold to (lw-1) do
      begin

         if (bdxchange) then
         begin
            if (not bdxconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               wall[i].sxS:=wall[iob].sxS+'+'+IntToStr(j)+'*('+spdx+')';
               wall[i].sxE:=wall[iob].sxE+'+'+IntToStr(j)+'*('+spdx+')';
               if (bOk) then wall[i].xS:=FormVariables.my_real_convert(wall[i].sxS,bOk);
               if (bOk) then wall[i].xE:=FormVariables.my_real_convert(wall[i].sxE,bOk);
            end
             else
            begin
               // числовое значение
               val(wall[iob].sxS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i].xS:=wall[iob].xS+j*dx;
                  wall[i].sxS:=FloatToStr(wall[i].xS);
               end
               else
               begin
                  dmbuf:=j*dx;
                  if (dmbuf>0.0) then
                  begin
                     wall[i].sxS:=wall[iob].sxS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i].xS:=FormVariables.my_real_convert(wall[i].sxS,bOk);
                  end
                   else
                  begin
                     wall[i].sxS:=wall[iob].sxS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i].xS:=FormVariables.my_real_convert(wall[i].sxS,bOk);
                  end;
               end;

               val(wall[iob].sxE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i].xE:=wall[iob].xE+j*dx;
                  wall[i].sxE:=FloatToStr(wall[i].xE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dx;
                  if (dmbuf>0.0) then
                  begin
                     wall[i].sxE:=wall[iob].sxE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i].xE:=FormVariables.my_real_convert(wall[i].sxE,bOk);
                  end
                  else
                  begin
                     wall[i].sxE:=wall[iob].sxE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i].xE:=FormVariables.my_real_convert(wall[i].sxE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            wall[i].sxS:=wall[iob].sxS;
            wall[i].sxE:=wall[iob].sxE;
            wall[i].xS:=wall[iob].xS;
            wall[i].xE:=wall[iob].xE;
         end;

         if (bdychange) then
         begin
            if (not bdyconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               wall[i].syS:=wall[iob].syS+'+'+IntToStr(j)+'*('+spdy+')';
               wall[i].syE:=wall[iob].syE+'+'+IntToStr(j)+'*('+spdy+')';
               if (bOk) then wall[i].yS:=FormVariables.my_real_convert(wall[i].syS,bOk);
               if (bOk) then wall[i].yE:=FormVariables.my_real_convert(wall[i].syE,bOk);
            end
             else
            begin
               // числовое значение
               val(wall[iob].syS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i].yS:=wall[iob].yS+j*dy;
                  wall[i].syS:=FloatToStr(wall[i].yS);
               end
                else
               begin
                  dmbuf:=j*dy;
                  if (dmbuf>0.0) then
                  begin
                     wall[i].syS:=wall[iob].syS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i].yS:=FormVariables.my_real_convert(wall[i].syS,bOk);
                  end
                  else
                  begin
                     wall[i].syS:=wall[iob].syS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i].yS:=FormVariables.my_real_convert(wall[i].syS,bOk);
                  end;
               end;

               val(wall[iob].syE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i].yE:=wall[iob].yE+j*dy;
                  wall[i].syE:=FloatToStr(wall[i].yE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dy;
                  if (dmbuf>0.0) then
                  begin
                     wall[i].syE:=wall[iob].syE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i].yE:=FormVariables.my_real_convert(wall[i].syE,bOk);
                  end
                  else
                  begin
                     wall[i].syE:=wall[iob].syE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i].yE:=FormVariables.my_real_convert(wall[i].syE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            wall[i].syS:=wall[iob].syS;
            wall[i].syE:=wall[iob].syE;
            wall[i].yS:=wall[iob].yS;
            wall[i].yE:=wall[iob].yE;
         end;

         if (bdzchange) then
         begin
            if (not bdzconst) then
            begin
               // параметризованное пользователем значение
               bOk:=true;
               wall[i].szS:=wall[iob].szS+'+'+IntToStr(j)+'*('+spdz+')';
               wall[i].szE:=wall[iob].szE+'+'+IntToStr(j)+'*('+spdz+')';
               if (bOk) then wall[i].zS:=FormVariables.my_real_convert(wall[i].szS,bOk);
               if (bOk) then wall[i].zE:=FormVariables.my_real_convert(wall[i].szE,bOk);
            end
             else
            begin
               // числовое значение
               val(wall[iob].szS,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i].zS:=wall[iob].zS+j*dz;
                  wall[i].szS:=FloatToStr(wall[i].zS);
               end
               else
               begin
                  dmbuf:=j*dz;
                  if (dmbuf>0.0) then
                  begin
                     wall[i].szS:=wall[iob].szS+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i].zS:=FormVariables.my_real_convert(wall[i].szS,bOk);
                  end
                  else
                  begin
                     wall[i].szS:=wall[iob].szS+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i].zS:=FormVariables.my_real_convert(wall[i].szS,bOk);
                  end;
               end;

               val(wall[iob].szE,dmbuf,code);
               if (code=0) then
               begin
                  // обе константы
                  wall[i].zE:=wall[iob].zE+j*dz;
                  wall[i].szE:=FloatToStr(wall[i].zE);
               end
               else
               begin
                  // слева параметризованная величина а справа константа.
                  dmbuf:=j*dz;
                  if (dmbuf>0.0) then
                  begin
                     wall[i].szE:=wall[iob].szE+'+'+FloatToStr(dmbuf);
                     bOk:=true;
                     wall[i].zE:=FormVariables.my_real_convert(wall[i].szE,bOk);
                  end
                  else
                  begin
                     wall[i].szE:=wall[iob].szE+'-'+FloatToStr(abs(dmbuf));
                     bOk:=true;
                     wall[i].zE:=FormVariables.my_real_convert(wall[i].szE,bOk);
                  end;
               end;
            end;
         end
          else
         begin
            // по этой оси размеры копии остаются такими же как и размеры оригинала.
            wall[i].szS:=wall[iob].szS;
            wall[i].szE:=wall[iob].szE;
            wall[i].zS:=wall[iob].zS;
            wall[i].zE:=wall[iob].zE;
         end;

         wall[i].iPlane:=wall[iob].iPlane;
         wall[i].Power:=wall[iob].Power;
         wall[i].family:=wall[iob].family;
         wall[i].Tamb:=wall[iob].Tamb;
         wall[i].HF:=wall[iob].HF;
         wall[i].Vx:=wall[iob].Vx;
         wall[i].Vy:=wall[iob].Vy;
         wall[i].Vz:=wall[iob].Vz;
         wall[i].P:=wall[iob].P;
         wall[i].bpressure:=wall[iob].bpressure;
         wall[i].bsymmetry:=wall[iob].bsymmetry;
         wall[i].iunion:=0; // по умолчанию на уровне кабинета
         wall[i].bvisible:=true;


         SetLength(wall[i].Vertexs,4); // источник
         LoadVertexPlane(wall[i]); // задаёт координаты вершин
         //Рёбра
         EdgePlaneCreate(wall[i]);
         SetLength(wall[i].Vertext,4);

         source[i].name:='wall'+IntToStr(i+1);
         NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,wall[i].name);
         NewNode.ImageIndex:=3; // номер картинки
         NewNode.SelectedIndex:=3; // номер картинки когда элемент выделен
         MainTreeView.Items[MainTreeView.Items.Count-1].Text:=wall[i].name;
         inc(j);
      end;
      RotateWall;
   end;
   MainPaintBoxPaint(Sender); // прорисовка изменений

   end; // bcontinuecopy=true;
end;

// вид в плоскости XZ
procedure TLaplas.SpeedButtonplanexzClick(Sender: TObject);
begin
   // plane XZ
   Alf:=0.0;
   Bet:=1.57;
   MainPaintBoxPaint(Sender);
end;

// вид в плоскости YZ
procedure TLaplas.SpeedButtonplaneyzClick(Sender: TObject);
begin
   // plane YZ
   Alf:=-1.57;
   Bet:=1.57;
   MainPaintBoxPaint(Sender);
end;

// Создаёт обединение
procedure TLaplas.SpeedButtonUnionClick(Sender: TObject);
var
    NewNode : TTreeNode;
    sname : String;
begin
   // нумерация объединений начинается с 1.
   // этот номер служит идентификатором объединения.
   inc(lu);
   SetLength(myassembles,lu);
   sname:='union'+IntToStr(lu);
   myassembles[lu-1].name:=sname; // присваиваем имя объекту.
   // идентификаторы объединений присваиваются последовательно начиная с 1.
   myassembles[lu-1].identifire:=lu;
   NewNode:=MainTreeView.Items.Add(MainTreeView.Selected,sname);
   NewNode.ImageIndex:=4; // номер картинки
   NewNode.SelectedIndex:=4; // номер картинки когда элемент выделен
   MainTreeView.Items[MainTreeView.Items.Count-1].Text:=sname;
end;

// Задаёт сеточные параметры
procedure TLaplas.Mesh1Click(Sender: TObject);
begin
   // Задаёт параметры расчётной сетки
   // инициализация :
   MeshForm.Einx.Text:=IntToStr(Laplas.inx);
   MeshForm.Einy.Text:=IntToStr(Laplas.iny);
   MeshForm.Einz.Text:=IntToStr(Laplas.inz);
   // Вызов :
   MeshForm.ShowModal;
end;

// Задаёт силу тяжести
procedure TLaplas.Gravity1Click(Sender: TObject);
begin
   // Задаёт силу тяжести
   // инициализация :
   FormGravity.Egx.Text:=FloatToStr(Laplas.gx);
   FormGravity.Egy.Text:=FloatToStr(Laplas.gy);
   FormGravity.Egz.Text:=FloatToStr(Laplas.gz);
   // Вызов :
   FormGravity.ShowModal;
end;

// Задаёт набор уравнений для решения.
procedure TLaplas.Models1Click(Sender: TObject);
var
    i : Integer;
begin
   // Определяет набор уравнений для решения.

   // Инициализация вызываемой формы
   case egddata.itemper of
     0 : begin
            EGDForm.CheckBoxTemperature.Checked:=false;
         end;
     1 : begin
            EGDForm.CheckBoxTemperature.Checked:=true;
         end;
   end;
   EGDForm.CBMaxFluidDomain.ItemIndex:=egddata.imaxflD;
   if (EGDForm.CBMaxFluidDomain.ItemIndex=0) then
   begin
      EGDForm.GBCFlZ.Visible:=false;
   end
   else
   begin
      EGDForm.GBCFlZ.Visible:=true;

      EGDForm.CBIdCurFLzone.Clear;
      for i:=0 to egddata.imaxflD-1 do
      begin
         EGDForm.CBIdCurFLzone.Items.Append(IntToStr(i+1));
      end;
      EGDForm.CBIdCurFLzone.ItemIndex:=0; // устанавливаем первую FLUID зону

      EGDForm.EditXC.Text:=FloatToStr(egddata.myflmod[0].xc);
      EGDForm.EditYC.Text:=FloatToStr(egddata.myflmod[0].yc);
      EGDForm.EditZC.Text:=FloatToStr(egddata.myflmod[0].zc);

      if (egddata.myflmod[0].iflow=1) then
      begin
         EGDForm.CBFlow.Checked:=true;
      end
       else
      begin
         EGDForm.CBFlow.Checked:=false;
      end;

      EGDForm.RadioGroupFlowRegime.ItemIndex:=egddata.myflmod[0].iflowregime;

      if (egddata.myflmod[0].iflow=1) then
      begin

         EGDForm.RadioGroupFlowRegime.Visible:=true;

         // показ окошка выбора модели турбулентности
         if (egddata.myflmod[0].iflowregime=0) then
         begin
            EGDForm.GroupBoxTurbulentModel.Visible:=false;
         end
          else
         begin
            EGDForm.GroupBoxTurbulentModel.Visible:=true;
            EGDForm.ComboBoxturbulentmodel.ItemIndex:=egddata.myflmod[0].iturbmodel;
            case egddata.myflmod[0].iturbmodel of
             0 :  begin
                     // ZEM
                     EGDForm.BEditTurb.Visible:=false;
                  end;
             1 :  begin
                     // Smagorinsky
                     EGDForm.BEditTurb.Visible:=true;
                  end;
             2 : begin
                    // RNG (LES)
                    EGDForm.BEditTurb.Visible:=false;
                 end;
            end;
         end;
      end
       else
      begin
         EGDForm.RadioGroupFlowRegime.Visible:=false;
         EGDForm.GroupBoxTurbulentModel.Visible:=false;
      end;
   end;

   EGDForm.ShowModal;  // вызов формы для редактирования свойств
end;

procedure TLaplas.Variables1Click(Sender: TObject);
var
    i : Integer;
begin
    // Вызываем форму задания и редактирования переменных.
    for i:=1 to FormVariables.StringGridVariables.RowCount-1 do
    begin
       if (i-1>=ivar) then
       begin
          FormVariables.StringGridVariables.Cells[1,i]:='';
          FormVariables.StringGridVariables.Cells[2,i]:='';
       end
       else
       begin
          FormVariables.StringGridVariables.Cells[1,i]:=parametric[i-1].svar;
          FormVariables.StringGridVariables.Cells[2,i]:=parametric[i-1].sval;
       end;
    end;
    //FormVariables.ShowModal;
    FormVariables.Show;
end;

// записывает файл premeshin.txt
procedure TLaplas.RunSolution1Click(Sender: TObject);
var
    f : TStringList; // переменная типа объект TStringList
    s : String; // текущая рабочая строка
    i : Integer; // текущий номер блока или источника при записи
    Sc : Real; // мощность тепловыделения на единицу объёма

begin
   f:=TStringList.Create();

   case ComboBoxlength.ItemIndex of
     0 : begin
            // m
            mlength:=1.0;
         end;
     1 : begin
            // mm
            mlength:=1e-3;
         end;
     2 : begin
            // micron
            mlength:=1e-6;
         end;
   end;

   s:=FloatToStr(mlength)+' '+IntToStr(lmatmax)+' '+IntToStr(lb)+' '+IntToStr(ls)+' '+IntToStr(lw)+' '+IntToStr(iltdp);
   s:=s+' '+FloatToStr(gx)+' '+FloatToStr(gy)+' '+FloatToStr(gz)+' ';
   s:=s+IntToStr(inx)+' '+IntToStr(iny)+' '+IntToStr(inz)+' '+FloatToStr(operatingtemperature);
   f.Add(s);

   // имена файлов в которых хранятся таблицы мощностей
   // зависящие от температуры и смещения стока.
   for i:=0 to (iltdp-1) do
   begin
      f.Add(listtablename[i]);
   end;

   for i:=0 to (lmatmax-1) do
   begin
      //s:=workmat[i].namemat+' '; // имя материала не требуется
      // плотность, теплоёмкость и теплопроводность.
      s:=FloatToStr(workmat[i].rho)+ ' '; // плотность
      s:=s+FloatToStr(workmat[i].cp)+ ' '; // теплоёмкость
      s:=s+FloatToStr(workmat[i].lambda)+ ' '; // теплопроводность
      s:=s+FloatToStr(workmat[i].mu)+ ' '; // динамическая вязкость
      s:=s+FloatToStr(workmat[i].beta_t)+ ' '; // коэффициент линейного температурного расширения
      s:=s+IntToStr(workmat[i].blibmat)+' '; // является ли материал библиотечным ?
      s:=s+IntToStr(workmat[i].ilibident)+' '; // идентификатор библиотечного материаала
      s:=s+IntToStr(workmat[i].bBoussinesq)+' '; // использовать приближение Обербека-Буссинеска или нет.
      s:=s+IntToStr(workmat[i].ilawmu)+' ';  // номер закона для динамической вязкости
      s:=s+FloatToStr(workmat[i].mumin)+' '; // ограничители
      s:=s+FloatToStr(workmat[i].mumax)+' '; // динамической вязкости.
      s:=s+FloatToStr(workmat[i].Amu)+' ';   // параметры
      s:=s+FloatToStr(workmat[i].Bmu)+' ';   // модельных
      s:=s+FloatToStr(workmat[i].Cmu)+' ';   // зависимостей
      s:=s+FloatToStr(workmat[i].degreennmu)+' '; // показатель степени
      f.Add(s);
   end;

   for i:=0 to (lb-1) do
   begin
      with (body[i]) do
      begin
         s:=FloatToStr(xS)+' ';
         s:=s+FloatToStr(yS)+' ';
         s:=s+FloatToStr(zS)+' ';
         s:=s+FloatToStr(xE)+' ';
         s:=s+FloatToStr(yE)+' ';
         s:=s+FloatToStr(zE)+' ';
         s:=s+IntToStr(imatid)+' ';
         Sc:=power/((xE-xS)*(yE-yS)*(zE-zS)*mlength*mlength*mlength);
         s:=s+FloatToStr(Sc)+' '; // мощность тепловыделения блока на единицу объёма
         s:=s+IntToStr(itype)+' '; // тип блока : SOLID, HOLLOW, FLUID.
      end;
      f.Add(s);
   end;
   // цикл по всем источникам тепла:
   for i:=0 to (ls-1) do
   begin
      with (source[i]) do
      begin
         // мощность тепловыделения, плоскость и координаты:
         s:=FloatToStr(Power)+' ';  // мощность
         s:=s+IntToStr(itempdep)+' '; // зависит ли мощность от температуры
         s:=s+IntToStr(id_table)+' '; // уникальный идентификатор таблицы.
         s:=s+FloatToStr(operatingoffsetdrain)+' '; // смещение стока
         s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
         s:=s+FloatToStr(xS)+' ';
         s:=s+FloatToStr(yS)+' ';
         s:=s+FloatToStr(zS)+' ';
         s:=s+FloatToStr(xE)+' ';
         s:=s+FloatToStr(yE)+' ';
         s:=s+FloatToStr(zE);
      end;
      f.Add(s);
   end;
   // цикл по всем твёрдым стенкам:
   for i:=0 to (lw-1) do
   begin
      with (wall[i]) do
      begin
         // тип краевого условия, температура и тепловой поток,
         //  плоскость и координаты:
         s:=IntToStr(family)+' '; // тип краевого условия
         s:=s+FloatToStr(Tamb)+' '; // температура на идеальном теплооотводе
         s:=s+FloatToStr(HF)+' '; // для граничного условия 2 или 3 рода.
         if (bsymmetry) then s:=s+'1 ' else s:=s+'0 ';
         if (bpressure) then s:=s+'1 ' else s:=s+'0 ';
         s:=s+FloatToStr(Vx)+' ';
         s:=s+FloatToStr(Vy)+' ';
         s:=s+FloatToStr(Vz)+' ';
         s:=s+FloatToStr(P)+' ';
         s:=s+IntToStr(iPlane)+' '; // плоскость в которой лежит источник тепла
         s:=s+FloatToStr(xS)+' ';
         s:=s+FloatToStr(yS)+' ';
         s:=s+FloatToStr(zS)+' ';
         s:=s+FloatToStr(xE)+' ';
         s:=s+FloatToStr(yE)+' ';
         s:=s+FloatToStr(zE);
      end;
      f.Add(s);
   end;

   // Запись информации о решаемых уравнениях.
   s:=IntToStr(egddata.itemper)+' '+IntToStr(egddata.imaxflD)+' ';
   f.Add(s);
   for i:=0 to egddata.imaxflD-1 do
   begin
      s:=FloatToStr(egddata.myflmod[i].xc)+' '+FloatToStr(egddata.myflmod[i].yc)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].zc)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iflow)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iflowregime)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iturbmodel)+' ';
      // параметры модели Смагоринского
      s:=s+FloatToStr(egddata.myflmod[i].SmagConst)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iDynamicStressGermano)+' ';
      s:=s+IntToStr(egddata.myflmod[i].iLimitersCs)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].minCs)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].maxCs)+' ';
      s:=s+IntToStr(egddata.myflmod[i].itypeFiltrGermano)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].roughness)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].rRimult)+' ';
      s:=s+FloatToStr(egddata.myflmod[i].rSelectiveAngle)+' ';
      s:=s+IntToStr(egddata.myflmod[i].ipowerroughness)+' ';
      s:=s+IntToStr(egddata.myflmod[i].itypefiltr)+' ';
      // учёт неравномерности сетки.
      if (egddata.myflmod[i].bfdelta) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // модель Смагоринского-Лиллу.
      if (egddata.myflmod[i].bSmagorinsky_Lilly) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // учёт шероховатости стенки.
      if (egddata.myflmod[i].bsurface_roughness) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // учёт течений с кривизной линий тока.
      if (egddata.myflmod[i].bSwirlamendment) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      // учёт избирательности в модели Смагоринского.
      if (egddata.myflmod[i].bSelectiveSmagorinsky) then
      begin
         s:=s+'1 ';
      end
      else
      begin
         s:=s+'0 ';
      end;
      f.Add(s);
   end;

   f.SaveToFile('premeshin.txt'); // сохранение результата
   f.Free;
   MainMemo.Lines.Add('файл  premeshin.txt  успешно записан.');
end;

// проверка уникальности имени объекта
function TLaplas.isduplicatenameobj(chidobj : Char; scandidate : string; iobjid : Integer) : Boolean;
var
   i : Integer;
   bOk : Boolean;
begin
   bOk:=true;
   // проверка всех блоков :
   for i:=0 to lb-1 do
   begin
      if (((length(body[i].name)=length(scandidate)) and (pos(scandidate,body[i].name)=1))) then
      begin
         if (not((chidobj='b')and(iobjid=i))) then
         begin
            bOk:=false;
         end;
      end;
   end;

   if (bOk) then
   begin
      // проверка всех стенок :
      for i:=0 to lw-1 do
      begin
         if (((length(wall[i].name)=length(scandidate)) and (pos(scandidate,wall[i].name)=1))) then
         begin
            if (not((chidobj='w')and(iobjid=i))) then
            begin
               bOk:=false;
            end;
         end;
      end;
   end;

   if (bOk) then
   begin
      // проверка всех источников тепла :
      for i:=0 to ls-1 do
      begin
         if (((length(source[i].name)=length(scandidate)) and (pos(scandidate,source[i].name)=1))) then
         begin
            if (not((chidobj='s')and(iobjid=i))) then
            begin
               bOk:=false;
            end;
         end;
      end;
   end;

   if (bOk) then
   begin
      // проверка всех объединений :
      for i:=0 to lu-1 do
      begin
         if (((length(myassembles[i].name)=length(scandidate)) and (pos(scandidate,myassembles[i].name)=1))) then
         begin
            if (not((chidobj='u')and(iobjid=i))) then
            begin
               bOk:=false;
            end;
         end;
      end;
   end;

   Result:=bOk;
end;

// процедура корректировки имени объекта
procedure TLaplas.correctobjname(chidobj : Char;var scandidate : string; iobjid : Integer);
var
   bOk : Boolean;
   i : integer;
   snamebuf : String;
begin
   bOk:=false;
   i:=0;
   snamebuf:=scandidate;
   while (not(bOk)) do
   begin
      bOk:=isduplicatenameobj(chidobj, snamebuf, iobjid);
      if (not(bOk)) then
      begin
         inc(i);
         snamebuf:=scandidate+'_'+IntToStr(i);
      end;
   end;
   scandidate:=snamebuf;
end;

procedure TLaplas.PowerTable1Click(Sender: TObject);
var
   i : Integer;
begin
   // формирование списка таблиц.
   FormPowerList.Eltdp.Text:=IntToStr(iltdp);
   FormPowerList.CBidtable.Clear;
   for i:=0 to iltdp-1 do
   begin
      FormPowerList.CBidtable.AddItem(IntToStr(i),Sender);
   end;
   if (iltdp=0) then
   begin
       FormPowerList.GBtableparam.Visible:=false;
       FormPowerList.Efilename.Text:=''; // пустая строека.
   end
   else
   begin
      FormPowerList.GBtableparam.Visible:=true;
      FormPowerList.CBidtable.ItemIndex:=0;
      FormPowerList.Efilename.Text:=listtablename[0];
   end;
   FormPowerList.ShowModal;
end;

procedure TLaplas.MainTreeViewClick(Sender: TObject);
begin
   // нужно вызвать прорисовку геометрии.
   Laplas.MainPaintBoxPaint(Sender); // прорисовка геометрии
end;

end.
